{"title":"Django框架笔记","slug":"Django框架笔记","date":"2020-05-04T07:11:26.000Z","updated":"2020-05-05T06:40:39.532Z","comments":true,"path":"api/articles/Django框架笔记.json","excerpt":null,"covers":["/image/MVC.png"],"content":"<!-- build time:Tue May 05 2020 14:41:16 GMT+0800 (GMT+08:00) --><h1 id=\"django-mtv与mvc的区别\"><a class=\"markdownIt-Anchor\" href=\"#django-mtv与mvc的区别\"></a> Django MTV与MVC的区别</h1><p>MVC是Model-View-Controller的缩写，其中每个单词都有其不同的含义：</p><ul><li>Modle 代表数据存储层，是对数据表的定义和数据的增删改查；</li><li>View 代表视图层，是系统前端显示部分，它负责显示什么和如何进行显示；</li><li>Controller 代表控制层，负责根据从 View 层输入的指令来检索 Model 层的数据，并在该层编写代码产生结果并输出。</li></ul><div align=\"center\"><img src=\"/image/MVC.png\" width=\"400\"></div><center>图1 MVC设计模式</center><p>MVC 设计模式的请求与响应过程描述如下：</p><ul><li>用户通过浏览器向服务器发起request请求，Controller层接受请求后，同时向Model层和View发送指令；</li><li>Mole 层根据指令与数据库交互并选择相应业务数据，然后将数据发送给 Controller 层；</li><li>View 层接收到 Controller 的指令后，加载用户请求的页面，并将此页面发送给 Controller 层；</li><li>Controller 层接收到 Model 层和 View 层的数据后，将它们组织成响应格式发送给浏览器，浏览器通过解析后把页面展示出来。</li></ul><p>MVC的3层之间紧密相连，但又相互独立，每一层的修改都不会影响其它层，每一层都提供了各自独立的接口供其它层调用，MVC的设计模式降低了代码之间的耦合性（即关联性），增加了模块的可重用性，这就是MVC的设计模式。</p><p>Django借鉴了经典的MVC模式，它也将交互的过程分为了3个层次，也就是MTV设计模式；</p><ul><li>Model：数据存储层，处理所有数据相关的业务，和数据库进行交互，并提供数据的增删改查；</li><li>Template：模板层（也叫表现层）具体来处理页面的显示；</li><li>View：业务逻辑层，处理具体的业务逻辑，它的作用是连通Model 层和 Template 。</li></ul><div align=\"center\"><img src=\"/image/MTV.png\" width=\"400\"></div><center>图2 MTV设计模式</center><p>对MTV设计模式的请求与响应过程进行描述：</p><ul><li>用户通过浏览器对服务器发起 request 请求，服务器接收请求后，通过 View 的业务逻辑层进行分析，同时向 Model 层和 Template 层发送指令；</li><li>Mole层与数据库进行交互，将数据返回给 View 层；</li><li>Template层接收到指令后，调用相应的模板，并返回给 View 层；</li><li>View层接收到模板与数据后，首先对模板进行渲染（即将相应的数据赋值给模板），然后组织成响应格式返回给浏览器，浏览器进行解析后并最终呈现给用户。</li></ul><p>通过以上两种设计模式的比较， 我们可以得出MTV是MVC的一种细化，将原来MVC中的 V层拿出来进行分离，视图的显示与如何显示交给Template层，而View层更专注于实现业务逻辑。</p><h1 id=\"orm模块\"><a class=\"markdownIt-Anchor\" href=\"#orm模块\"></a> ORM模块</h1><p>ORM（Object Realtional Mapping）即对象关系映射，它是一种基于关系型数据库的程序技术。ORM允许你使用类和对象对数据库进行操作，这大大提高了对数据库的控制，避免了直接使用SQL语句对数据库进行操作。如图3是ORM与数据库的映射关系，ORM 把类映射成数据库中的表，把类的一个实例对象映射成数据库中的数据行，把类的属性映射成表中的字段，通过对象的操作对应到数据库表的操作，实现了对象到 SQL、SQL 到对象转换过程。</p><div align=\"center\"><img src=\"/image/ORM与DB.png\" width=\"400\"></div><center>图3 ORM与DB映射关系</center><p>针对数据库中的字段类型，对应的&quot;xxxField&quot;表述如下表：</p><table><tr><td>字段</td><td>说明</td><td>字段属性</td></tr><tr><td>AutoFiled</td><td>默然自增主键（Primary_key=Ture），Django 默认建立id字段为主键。</td><td></td></tr><tr><td>CharFiled</td><td>字符类型</td><td>Max_length=32，字符长度需要明确</td></tr><tr><td>InterFiled</td><td>整型 int</td><td></td></tr><tr><td>DateFiled</td><td>年月日时间类型</td><td>auto_now=True，数据被更新就会更新时间 ；auto_now_add=True，数据第一次参数时产生。</td></tr><tr><td>DateTimeFiled</td><td>年月日小时分钟秒时间类型</td><td>auto_now=True，数据被更新就会更新时间； auto_now_add=True，数据第一次参数时产生。</td></tr><tr><td>DecimalFiled</td><td>混合精度的小数类型</td><td>max_digits=3，限定数字的最大位数(包含小数位)；decimal_places=2，限制小数的最大位数。</td></tr><td>BooleanFiled</td><td>布尔字段，对应数据库 tinyint 类型数据长度只有1位。</td><td>值为True或False</td><tr><td>TextFiled</td><td>用于大文件</td><td></td></tr></table><h1 id=\"视图函数\"><a class=\"markdownIt-Anchor\" href=\"#视图函数\"></a> 视图函数</h1><p>视图函数是一个 Python 函数或者类，开发者主要通过编写视图函数来实现业务逻辑。视图函数首先接受来自浏览器或者客户端的请求，并最终返回响应，视图函数返回的响应可以是HTML文件，也可以是HTTP协议中的303重定向，如下：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponse</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Hello_my_django</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponse(<span class=\"string\">'&lt;html&gt;&lt;body&gt;Hello my Django&lt;/body&gt;&lt;/html&gt;'</span>)</span><br></pre></td></tr></table></figure><p><strong>1.HttpResponse视图响应类型</strong></p><p>django.http 模块中导入 HttpResponse，从它简单的名字我们可以得知，它是一种视图的响应类型。</p><p><strong>2.视图函数参数request</strong></p><p>视图函数至少有一个参数，第一个参数必须是 request，request是HttpRequest请求类型的对象，它携带了浏览器的请求信息，所以视图函数的第一个参数必须为request。</p><p><strong>3.return视图响应</strong></p><p>视图函数要返回响应内容，这里的响应内容是我们用HTML标签编写的，把它作为HttpResponse的对象返回给浏览器。</p><h1 id=\"模板系统及应用\"><a class=\"markdownIt-Anchor\" href=\"#模板系统及应用\"></a> 模板系统及应用</h1><p>“模板”称之为Template，它的存在使得HTML和 View视图层实现了解耦，在 templates 文件中新建一个 HTML 文件，并且将此文件命名为 hello.html，然后在此文件中书写我们的 HTML 代码，如下所示：</p><p>写HTM代码：</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>&#123;&#123;vaule&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写视图函数：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.shortcuts <span class=\"keyword\">import</span> render      </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello_my_django</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render(request,<span class=\"string\">\"hello.html\"</span>,&#123;<span class=\"string\">\"vaule\"</span>:<span class=\"string\">\"hello my Django\"</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>1.模板传参</strong></p><p>hello.html 文件中的 是一个模板的变量，视图函数必须把数据形成字典的形式才可以传递给模板，这就是“模板传参”。</p><p><strong>2.render方法</strong></p><p>render 是 View 层加载模板的一种方式，它封装在 django.shortcuts 模块中，render 方法使用起来非常方便，它首先加载模板，然后将加载完成的模板响应给浏览器。</p><h1 id=\"路由系统\"><a class=\"markdownIt-Anchor\" href=\"#路由系统\"></a> 路由系统</h1><p>Django 中利用 ROOT_URLCONF 构建了 URL 与视图函数的映射关系。在 django.conf.urls 中封装了路由模块，新建的Django项目中提供了urls.py路由配置文件，urls.py文件中定义了一个 urlpatterns的列表，它是由url( )实例对象组成的列表，Django中url的定义就是在这个列表完成的。后台Admin管理系统的路由就定义在了列表第一个位置，下面我们对路由的语法格进行简单说明：</p><blockquote><p>url(regex,view,name=None)</p></blockquote><p>参数解析如下：</p><ul><li>regex，匹配请求路径，用正则表达式表示；</li><li>view，指定 regex 匹配路径所对应的视图函数的名称；</li><li>name，是给 url 地址起个别名，在模板反向解析的时候使用</li></ul><h2 id=\"配置url实现页面访问\"><a class=\"markdownIt-Anchor\" href=\"#配置url实现页面访问\"></a> 配置URL实现页面访问</h2><p>在 <a href=\"http://urls.py\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\">urls.py</a> 的同级目录下，新建 <a href=\"http://views.py\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\">views.py</a> 文件，把它作为编写视图函数的 View 层，然后在 <a href=\"http://views.py\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\">views.py</a> 中编写如下代码：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponse</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">page_view</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    html=<span class=\"string\">'&lt;h1&gt;欢迎来到，C语言中文网，网址是http://c.biancheng.net&lt;/h&gt;'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponse(html)</span><br></pre></td></tr></table></figure><p>目的是把 URL 与视图层进行绑定，然后在urls.py的 urlpatterns 中编写如下代码：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.conf.urls <span class=\"keyword\">import</span> url</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.contrib <span class=\"keyword\">import</span> admin</span><br><span class=\"line\"><span class=\"keyword\">from</span> myject <span class=\"keyword\">import</span> views</span><br><span class=\"line\">urlpatterns = [</span><br><span class=\"line\">    url(<span class=\"string\">r'admin/'</span>, admin.site.urls),</span><br><span class=\"line\">    url(<span class=\"string\">r'^page$/'</span>,views.page_view),]</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","more":"<!-- build time:Tue May 05 2020 14:41:16 GMT+0800 (GMT+08:00) --><h1 id=\"django-mtv与mvc的区别\"><a class=\"markdownIt-Anchor\" href=\"#django-mtv与mvc的区别\"></a> Django MTV与MVC的区别</h1><p>MVC是Model-View-Controller的缩写，其中每个单词都有其不同的含义：</p><ul><li>Modle 代表数据存储层，是对数据表的定义和数据的增删改查；</li><li>View 代表视图层，是系统前端显示部分，它负责显示什么和如何进行显示；</li><li>Controller 代表控制层，负责根据从 View 层输入的指令来检索 Model 层的数据，并在该层编写代码产生结果并输出。</li></ul><div align=\"center\"><img src=\"/image/MVC.png\" width=\"400\"></div><center>图1 MVC设计模式</center><p>MVC 设计模式的请求与响应过程描述如下：</p><ul><li>用户通过浏览器向服务器发起request请求，Controller层接受请求后，同时向Model层和View发送指令；</li><li>Mole 层根据指令与数据库交互并选择相应业务数据，然后将数据发送给 Controller 层；</li><li>View 层接收到 Controller 的指令后，加载用户请求的页面，并将此页面发送给 Controller 层；</li><li>Controller 层接收到 Model 层和 View 层的数据后，将它们组织成响应格式发送给浏览器，浏览器通过解析后把页面展示出来。</li></ul><p>MVC的3层之间紧密相连，但又相互独立，每一层的修改都不会影响其它层，每一层都提供了各自独立的接口供其它层调用，MVC的设计模式降低了代码之间的耦合性（即关联性），增加了模块的可重用性，这就是MVC的设计模式。</p><p>Django借鉴了经典的MVC模式，它也将交互的过程分为了3个层次，也就是MTV设计模式；</p><ul><li>Model：数据存储层，处理所有数据相关的业务，和数据库进行交互，并提供数据的增删改查；</li><li>Template：模板层（也叫表现层）具体来处理页面的显示；</li><li>View：业务逻辑层，处理具体的业务逻辑，它的作用是连通Model 层和 Template 。</li></ul><div align=\"center\"><img src=\"/image/MTV.png\" width=\"400\"></div><center>图2 MTV设计模式</center><p>对MTV设计模式的请求与响应过程进行描述：</p><ul><li>用户通过浏览器对服务器发起 request 请求，服务器接收请求后，通过 View 的业务逻辑层进行分析，同时向 Model 层和 Template 层发送指令；</li><li>Mole层与数据库进行交互，将数据返回给 View 层；</li><li>Template层接收到指令后，调用相应的模板，并返回给 View 层；</li><li>View层接收到模板与数据后，首先对模板进行渲染（即将相应的数据赋值给模板），然后组织成响应格式返回给浏览器，浏览器进行解析后并最终呈现给用户。</li></ul><p>通过以上两种设计模式的比较， 我们可以得出MTV是MVC的一种细化，将原来MVC中的 V层拿出来进行分离，视图的显示与如何显示交给Template层，而View层更专注于实现业务逻辑。</p><h1 id=\"orm模块\"><a class=\"markdownIt-Anchor\" href=\"#orm模块\"></a> ORM模块</h1><p>ORM（Object Realtional Mapping）即对象关系映射，它是一种基于关系型数据库的程序技术。ORM允许你使用类和对象对数据库进行操作，这大大提高了对数据库的控制，避免了直接使用SQL语句对数据库进行操作。如图3是ORM与数据库的映射关系，ORM 把类映射成数据库中的表，把类的一个实例对象映射成数据库中的数据行，把类的属性映射成表中的字段，通过对象的操作对应到数据库表的操作，实现了对象到 SQL、SQL 到对象转换过程。</p><div align=\"center\"><img src=\"/image/ORM与DB.png\" width=\"400\"></div><center>图3 ORM与DB映射关系</center><p>针对数据库中的字段类型，对应的&quot;xxxField&quot;表述如下表：</p><table><tr><td>字段</td><td>说明</td><td>字段属性</td></tr><tr><td>AutoFiled</td><td>默然自增主键（Primary_key=Ture），Django 默认建立id字段为主键。</td><td></td></tr><tr><td>CharFiled</td><td>字符类型</td><td>Max_length=32，字符长度需要明确</td></tr><tr><td>InterFiled</td><td>整型 int</td><td></td></tr><tr><td>DateFiled</td><td>年月日时间类型</td><td>auto_now=True，数据被更新就会更新时间 ；auto_now_add=True，数据第一次参数时产生。</td></tr><tr><td>DateTimeFiled</td><td>年月日小时分钟秒时间类型</td><td>auto_now=True，数据被更新就会更新时间； auto_now_add=True，数据第一次参数时产生。</td></tr><tr><td>DecimalFiled</td><td>混合精度的小数类型</td><td>max_digits=3，限定数字的最大位数(包含小数位)；decimal_places=2，限制小数的最大位数。</td></tr><td>BooleanFiled</td><td>布尔字段，对应数据库 tinyint 类型数据长度只有1位。</td><td>值为True或False</td><tr><td>TextFiled</td><td>用于大文件</td><td></td></tr></table><h1 id=\"视图函数\"><a class=\"markdownIt-Anchor\" href=\"#视图函数\"></a> 视图函数</h1><p>视图函数是一个 Python 函数或者类，开发者主要通过编写视图函数来实现业务逻辑。视图函数首先接受来自浏览器或者客户端的请求，并最终返回响应，视图函数返回的响应可以是HTML文件，也可以是HTTP协议中的303重定向，如下：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponse</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Hello_my_django</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponse(<span class=\"string\">'&lt;html&gt;&lt;body&gt;Hello my Django&lt;/body&gt;&lt;/html&gt;'</span>)</span><br></pre></td></tr></table></figure><p><strong>1.HttpResponse视图响应类型</strong></p><p>django.http 模块中导入 HttpResponse，从它简单的名字我们可以得知，它是一种视图的响应类型。</p><p><strong>2.视图函数参数request</strong></p><p>视图函数至少有一个参数，第一个参数必须是 request，request是HttpRequest请求类型的对象，它携带了浏览器的请求信息，所以视图函数的第一个参数必须为request。</p><p><strong>3.return视图响应</strong></p><p>视图函数要返回响应内容，这里的响应内容是我们用HTML标签编写的，把它作为HttpResponse的对象返回给浏览器。</p><h1 id=\"模板系统及应用\"><a class=\"markdownIt-Anchor\" href=\"#模板系统及应用\"></a> 模板系统及应用</h1><p>“模板”称之为Template，它的存在使得HTML和 View视图层实现了解耦，在 templates 文件中新建一个 HTML 文件，并且将此文件命名为 hello.html，然后在此文件中书写我们的 HTML 代码，如下所示：</p><p>写HTM代码：</p><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>&#123;&#123;vaule&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>写视图函数：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.shortcuts <span class=\"keyword\">import</span> render      </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello_my_django</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> render(request,<span class=\"string\">\"hello.html\"</span>,&#123;<span class=\"string\">\"vaule\"</span>:<span class=\"string\">\"hello my Django\"</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>1.模板传参</strong></p><p>hello.html 文件中的 是一个模板的变量，视图函数必须把数据形成字典的形式才可以传递给模板，这就是“模板传参”。</p><p><strong>2.render方法</strong></p><p>render 是 View 层加载模板的一种方式，它封装在 django.shortcuts 模块中，render 方法使用起来非常方便，它首先加载模板，然后将加载完成的模板响应给浏览器。</p><h1 id=\"路由系统\"><a class=\"markdownIt-Anchor\" href=\"#路由系统\"></a> 路由系统</h1><p>Django 中利用 ROOT_URLCONF 构建了 URL 与视图函数的映射关系。在 django.conf.urls 中封装了路由模块，新建的Django项目中提供了urls.py路由配置文件，urls.py文件中定义了一个 urlpatterns的列表，它是由url( )实例对象组成的列表，Django中url的定义就是在这个列表完成的。后台Admin管理系统的路由就定义在了列表第一个位置，下面我们对路由的语法格进行简单说明：</p><blockquote><p>url(regex,view,name=None)</p></blockquote><p>参数解析如下：</p><ul><li>regex，匹配请求路径，用正则表达式表示；</li><li>view，指定 regex 匹配路径所对应的视图函数的名称；</li><li>name，是给 url 地址起个别名，在模板反向解析的时候使用</li></ul><h2 id=\"配置url实现页面访问\"><a class=\"markdownIt-Anchor\" href=\"#配置url实现页面访问\"></a> 配置URL实现页面访问</h2><p>在 <a href=\"http://urls.py\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\">urls.py</a> 的同级目录下，新建 <a href=\"http://views.py\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\">views.py</a> 文件，把它作为编写视图函数的 View 层，然后在 <a href=\"http://views.py\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\">views.py</a> 中编写如下代码：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.http <span class=\"keyword\">import</span> HttpResponse</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">page_view</span><span class=\"params\">(request)</span>:</span></span><br><span class=\"line\">    html=<span class=\"string\">'&lt;h1&gt;欢迎来到，C语言中文网，网址是http://c.biancheng.net&lt;/h&gt;'</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> HttpResponse(html)</span><br></pre></td></tr></table></figure><p>目的是把 URL 与视图层进行绑定，然后在urls.py的 urlpatterns 中编写如下代码：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> django.conf.urls <span class=\"keyword\">import</span> url</span><br><span class=\"line\"><span class=\"keyword\">from</span> django.contrib <span class=\"keyword\">import</span> admin</span><br><span class=\"line\"><span class=\"keyword\">from</span> myject <span class=\"keyword\">import</span> views</span><br><span class=\"line\">urlpatterns = [</span><br><span class=\"line\">    url(<span class=\"string\">r'admin/'</span>, admin.site.urls),</span><br><span class=\"line\">    url(<span class=\"string\">r'^page$/'</span>,views.page_view),]</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","categories":[{"name":"计算机基础","path":"api/categories/计算机基础.json"},{"name":"Python","path":"api/categories/Python.json"}],"tags":[{"name":"Python","path":"api/tags/Python.json"},{"name":"Web框架","path":"api/tags/Web框架.json"}]}