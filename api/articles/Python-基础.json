{"title":"Python-基础","slug":"Python-基础","date":"2020-04-24T08:50:45.000Z","updated":"2020-04-24T12:20:25.520Z","comments":true,"path":"api/articles/Python-基础.json","excerpt":null,"covers":null,"content":"<!-- build time:Thu Apr 30 2020 10:09:51 GMT+0800 (GMT+08:00) --><h1 id=\"python注释\"><a class=\"markdownIt-Anchor\" href=\"#python注释\"></a> Python注释</h1><p>Python 支持两种类型的注释，分别是单行注释和多行注释。</p><h2 id=\"python单行注释\"><a class=\"markdownIt-Anchor\" href=\"#python单行注释\"></a> Python单行注释</h2><p>Python使用井号#作为单行注释的符号，语法格式为：</p><blockquote><p>#注释内容</p></blockquote><p>从井号#开始，直到这行结束为止的所有内容都是注释。Python 解释器遇到#时，会忽略它后面的整行内容。</p><h2 id=\"python多行注释\"><a class=\"markdownIt-Anchor\" href=\"#python多行注释\"></a> Python多行注释</h2><p>多行注释指的是一次性注释程序中多行的内容（包含一行）。Python 使用三个连续的单引号’’'或者三个连续的双引号&quot;&quot;&quot;注释多行内容，具体格式如下：</p><blockquote><p>‘’’<br>使用 3 个单引号分别作为注释的开头和结尾<br>可以一次性注释多行内容<br>这里面的内容全部是注释内容<br>‘’’</p></blockquote><h1 id=\"python缩进规则包含快捷键\"><a class=\"markdownIt-Anchor\" href=\"#python缩进规则包含快捷键\"></a> Python缩进规则(包含快捷键)</h1><p>在 Python 中，对于类定义、函数定义、流程控制语句、异常处理语句等，行尾的冒号和下一行的缩进，表示下一个代码块的开始，而缩进的结束则表示此代码块的结束。</p><p>注意，Python 中实现对代码的缩进，可以使用空格或者 Tab 键实现。但无论是手动敲空格，还是使用 Tab 键，通常情况下都是采用 4 个空格长度作为一个缩进量（默认情况下，一个 Tab 键就表示 4 个空格）。</p><h1 id=\"python编码规范pep-8\"><a class=\"markdownIt-Anchor\" href=\"#python编码规范pep-8\"></a> Python编码规范（PEP 8）</h1><p>Python 采用 PEP 8 作为编码规范，其中 PEP 是 Python Enhancement Proposal（Python 增强建议书）的缩写，8 代表的是 Python 代码的样式指南。</p><ul><li>每个 import 语句只导入一个模块，尽量避免一次导入多个模块</li><li>不要在行尾添加分号，也不要用分号将两条命令放在同一行</li><li>建议每行不超过80个字符，如果超过，建议使用小括号将多行内容隐式的连接起来，而不推荐使用反斜杠\\进行连接。</li><li>使用必要的空行可以增加代码的可读性，通常在顶级定义（如函数或类的定义）之间空两行，而方法定义之间空一行，另外在用于分隔某些功能的位置也可以空一行。</li><li>通常情况下，在运算符两侧、函数参数之间以及逗号两侧，都建议使用空格进行分隔。</li></ul><h1 id=\"python标识符命名规范\"><a class=\"markdownIt-Anchor\" href=\"#python标识符命名规范\"></a> Python标识符命名规范</h1><p>Python 中标识符的命名不是随意的，而是要遵守一定的命令规则，比如说：</p><ul><li>标识符是由字符（A~Z 和 a~z）、下划线和数字组成，但第一个字符不能是数字。</li><li>标识符不能和 Python 中的保留字相同。有关保留字，后续章节会详细介绍。</li><li>Python中的标识符中，不能包含空格、@、% 以及 $ 等特殊字符。</li><li>在 Python 中，标识符中的字母是严格区分大小写的，也就是说，两个同样的单词，如果大小格式不一样，多代表的意义也是完全不同的。</li><li>Python 语言中，以下划线开头的标识符有特殊含义，例如：以单下划线开头的标识符（如 _width），表示不能直接访问的类属性，其无法通过 from…import* 的方式导入；以双下划线开头的标识符（如__add）表示类的私有成员；以双下划线作为开头和结尾的标识符（如 <strong>init</strong>），是专用标识符。</li><li>标识符的命名，除了要遵守以上这几条规则外，不同场景中的标识符，其名称也有一定的规范可循，例如：当标识符用作模块名时，应尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母，例如 game_mian、game_register等。当标识符用作包的名称时，应尽量短小，也全部使用小写字母，不推荐使用下划线，例如 <a href=\"http://com.mr\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\">com.mr</a>、com.mr.book 等。当标识符用作类名时，应采用单词首字母大写的形式。例如，定义一个图书类，可以命名为 Book。模块内部的类名，可以采用 “下划线+首字母大写” 的形式，如 _Book;函数名、类中的属性名和方法名，应全部使用小写字母，多个单词之间可以用下划线分割；常量命名应全部使用大写字母，单词之间可以用下划线分割；</li></ul><h1 id=\"python关键字保留字\"><a class=\"markdownIt-Anchor\" href=\"#python关键字保留字\"></a> Python关键字(保留字)</h1><p>保留字是 Python 语言中一些已经被赋予特定意义的单词，这就要求开发者在开发程序时，不能用这些保留字作为标识符给变量、函数、类、模板以及其他对象命名。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> keyword</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class=\"line\">[<span class=\"string\">'False'</span>, <span class=\"string\">'None'</span>, <span class=\"string\">'True'</span>, <span class=\"string\">'and'</span>, <span class=\"string\">'as'</span>, <span class=\"string\">'assert'</span>, <span class=\"string\">'break'</span>, <span class=\"string\">'class'</span>, <span class=\"string\">'continue'</span>, <span class=\"string\">'def'</span>, <span class=\"string\">'del'</span>, <span class=\"string\">'elif'</span>, <span class=\"string\">'else'</span>, <span class=\"string\">'except'</span>, <span class=\"string\">'finally'</span>, <span class=\"string\">'for'</span>, <span class=\"string\">'from'</span>, <span class=\"string\">'global'</span>, <span class=\"string\">'if'</span>, <span class=\"string\">'import'</span>, <span class=\"string\">'in'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'lambda'</span>, <span class=\"string\">'nonlocal'</span>, <span class=\"string\">'not'</span>, <span class=\"string\">'or'</span>, <span class=\"string\">'pass'</span>, <span class=\"string\">'raise'</span>, <span class=\"string\">'return'</span>, <span class=\"string\">'try'</span>, <span class=\"string\">'while'</span>, <span class=\"string\">'with'</span>, <span class=\"string\">'yield'</span>]</span><br></pre></td></tr></table></figure><h1 id=\"python内置函数\"><a class=\"markdownIt-Anchor\" href=\"#python内置函数\"></a> Python内置函数</h1><h2 id=\"absx\"><a class=\"markdownIt-Anchor\" href=\"#absx\"></a> abs(x)</h2><p>返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。</p><h2 id=\"alliterable\"><a class=\"markdownIt-Anchor\" href=\"#alliterable\"></a> all(iterable)</h2><p>如果 iterable 的所有元素为真（或迭代器为空），返回 True 。等价于:</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">all</span><span class=\"params\">(iterable)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> iterable:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> element:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure><h2 id=\"anyiterable\"><a class=\"markdownIt-Anchor\" href=\"#anyiterable\"></a> any(iterable)</h2><p>如果 iterable 的任一元素为真则返回 True。 如果迭代器为空，返回 False。 等价于:</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">any</span><span class=\"params\">(iterable)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> iterable:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> element:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure><h2 id=\"asciiobject\"><a class=\"markdownIt-Anchor\" href=\"#asciiobject\"></a> ascii(object)</h2><p>像函数repr()，返回一个对象可打印的字符串，但是repr()返回的字符串中非ASCII编码的字符，会使用 \\x、\\u 和 \\U 来转义。生成的字符串和Python2的repr()返回的结果相似。</p><h2 id=\"binx\"><a class=\"markdownIt-Anchor\" href=\"#binx\"></a> bin(x)</h2><p>将一个整数转变为一个前缀为“0b”的二进制字符串。结果是一个合法的 Python 表达式。如果x不是 Python的int对象，那它需要定义 <strong>index</strong>()方法返回一个整数。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>bin(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"string\">'0b11'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>bin(<span class=\"number\">-10</span>)</span><br><span class=\"line\"><span class=\"string\">'-0b1010'</span></span><br></pre></td></tr></table></figure><h2 id=\"class-boolx\"><a class=\"markdownIt-Anchor\" href=\"#class-boolx\"></a> class bool([x])</h2><p>返回一个布尔值，True 或者 False。 x使用标准的 真值测试过程 来转换。如果x是假的或者被省略，返回 False；其他情况返回True。bool类是int的子类（参见 数字类型 — int, float, complex）。其他类不能继承自它。它只有False和True两个实例。</p><h2 id=\"breakpointargs-kws\"><a class=\"markdownIt-Anchor\" href=\"#breakpointargs-kws\"></a> breakpoint(*args, **kws)</h2><p>此函数会在调用时将你陷入调试器中。具体来说，它调用sys.breakpointhook() ，直接传递args和kws 。默认情况下， sys.breakpointhook()调用 pdb.set_trace()且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 pdb 且键入尽可能少的代码即可进入调试器。但是，sys.breakpointhook() 可以设置为其他一些函数并被breakpoint()自动调用，以允许进入你想用的调试器。</p><h2 id=\"class-bytearraysource-encoding-errors\"><a class=\"markdownIt-Anchor\" href=\"#class-bytearraysource-encoding-errors\"></a> class bytearray([source[, encoding[, errors]]])</h2><p>返回一个新的bytes数组。 bytearray类是一个可变序列，包含范围为0 &lt;= x &lt; 256的整数。它有可变序列大部分常见的方法，见 可变序列类型的描述；同时有 bytes类型的大部分方法，参见 bytes和bytearray操作。</p><h2 id=\"enumerateiterable-start0\"><a class=\"markdownIt-Anchor\" href=\"#enumerateiterable-start0\"></a> enumerate(iterable, start=0)</h2><p>返回一个枚举对象。iterable 必须是一个序列，或 iterator，或其他支持迭代的对象。 enumerate() 返回的迭代器的 <strong>next</strong>() 方法返回一个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代 iterable 获得的值。<br>##　divmod(a, b)<br>它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和 (a // b, a % b) 一致。对于浮点数，结果是(q, a % b) ，q通常是 math.floor(a / b) 但可能会比 1 小。在任何情况下， q * b + a % b和a基本相等；如果a % b非零，它的符号和 b 一样，并且 0 &lt;= abs(a % b) &lt; abs(b)。</p><h2 id=\"evalexpression-globals-locals\"><a class=\"markdownIt-Anchor\" href=\"#evalexpression-globals-locals\"></a> eval(expression[, globals[, locals]])</h2><p>实参是一个字符串，以及可选的 globals 和 locals。globals 实参必须是一个字典。locals 可以是任何映射对象。</p><p>expression参数会作为一个 Python表达式（从技术上说是一个条件列表）被解析并求值，使用 globals 和 locals 字典作为全局和局部命名空间。如果 globals 字典存在且不包含以 __builtins__为键的值，则会在解析expression之前插入以此为键的对内置模块builtins的字典的引用。这意味着expression通常具有对标准builtins模块的完全访问权限且受限的环境会被传播。如果省略locals字典则其默认值为 globals字典。如果两个字典同时省略，表达式会在eval()被调用的环境中执行。返回值为表达式求值的结果。语法错误将作为异常被报告。</p><h2 id=\"getattrobject-name-default\"><a class=\"markdownIt-Anchor\" href=\"#getattrobject-name-default\"></a> getattr(object, name[, default])</h2><p>返回对象命名属性的值。name必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， getattr(x, ‘foobar’) 等同于 x.foobar。如果指定的属性不存在，且提供了default值，则返回它，否则触发 AttributeError。</p><h2 id=\"globals\"><a class=\"markdownIt-Anchor\" href=\"#globals\"></a> globals()</h2><p>返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。</p><h2 id=\"hasattrobject-name\"><a class=\"markdownIt-Anchor\" href=\"#hasattrobject-name\"></a> hasattr(object, name)</h2><p>该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回True，否则返回False。（此功能是通过调用getattr(object, name) 看是否有 AttributeError异常来实现的）。</p><h2 id=\"hashobject\"><a class=\"markdownIt-Anchor\" href=\"#hashobject\"></a> hash(object)</h2><p>返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。</p><h2 id=\"reprobject\"><a class=\"markdownIt-Anchor\" href=\"#reprobject\"></a> repr(object)</h2><p>返回包含一个对象的可打印表示形式的字符串。 对于许多类型来说，该函数会尝试返回的字符串将会与该对象被传递给 eval() 时所生成的对象具有相同的值，在其他情况下表示形式会是一个括在尖括号中的字符串，其中包含对象类型的名称与通常包括对象名称和地址的附加信息。 类可以通过定义 <strong>repr</strong>() 方法来控制此函数为它的实例所返回的内容。</p><!-- rebuild by neat -->","more":"<!-- build time:Thu Apr 30 2020 10:09:51 GMT+0800 (GMT+08:00) --><h1 id=\"python注释\"><a class=\"markdownIt-Anchor\" href=\"#python注释\"></a> Python注释</h1><p>Python 支持两种类型的注释，分别是单行注释和多行注释。</p><h2 id=\"python单行注释\"><a class=\"markdownIt-Anchor\" href=\"#python单行注释\"></a> Python单行注释</h2><p>Python使用井号#作为单行注释的符号，语法格式为：</p><blockquote><p>#注释内容</p></blockquote><p>从井号#开始，直到这行结束为止的所有内容都是注释。Python 解释器遇到#时，会忽略它后面的整行内容。</p><h2 id=\"python多行注释\"><a class=\"markdownIt-Anchor\" href=\"#python多行注释\"></a> Python多行注释</h2><p>多行注释指的是一次性注释程序中多行的内容（包含一行）。Python 使用三个连续的单引号’’'或者三个连续的双引号&quot;&quot;&quot;注释多行内容，具体格式如下：</p><blockquote><p>‘’’<br>使用 3 个单引号分别作为注释的开头和结尾<br>可以一次性注释多行内容<br>这里面的内容全部是注释内容<br>‘’’</p></blockquote><h1 id=\"python缩进规则包含快捷键\"><a class=\"markdownIt-Anchor\" href=\"#python缩进规则包含快捷键\"></a> Python缩进规则(包含快捷键)</h1><p>在 Python 中，对于类定义、函数定义、流程控制语句、异常处理语句等，行尾的冒号和下一行的缩进，表示下一个代码块的开始，而缩进的结束则表示此代码块的结束。</p><p>注意，Python 中实现对代码的缩进，可以使用空格或者 Tab 键实现。但无论是手动敲空格，还是使用 Tab 键，通常情况下都是采用 4 个空格长度作为一个缩进量（默认情况下，一个 Tab 键就表示 4 个空格）。</p><h1 id=\"python编码规范pep-8\"><a class=\"markdownIt-Anchor\" href=\"#python编码规范pep-8\"></a> Python编码规范（PEP 8）</h1><p>Python 采用 PEP 8 作为编码规范，其中 PEP 是 Python Enhancement Proposal（Python 增强建议书）的缩写，8 代表的是 Python 代码的样式指南。</p><ul><li>每个 import 语句只导入一个模块，尽量避免一次导入多个模块</li><li>不要在行尾添加分号，也不要用分号将两条命令放在同一行</li><li>建议每行不超过80个字符，如果超过，建议使用小括号将多行内容隐式的连接起来，而不推荐使用反斜杠\\进行连接。</li><li>使用必要的空行可以增加代码的可读性，通常在顶级定义（如函数或类的定义）之间空两行，而方法定义之间空一行，另外在用于分隔某些功能的位置也可以空一行。</li><li>通常情况下，在运算符两侧、函数参数之间以及逗号两侧，都建议使用空格进行分隔。</li></ul><h1 id=\"python标识符命名规范\"><a class=\"markdownIt-Anchor\" href=\"#python标识符命名规范\"></a> Python标识符命名规范</h1><p>Python 中标识符的命名不是随意的，而是要遵守一定的命令规则，比如说：</p><ul><li>标识符是由字符（A~Z 和 a~z）、下划线和数字组成，但第一个字符不能是数字。</li><li>标识符不能和 Python 中的保留字相同。有关保留字，后续章节会详细介绍。</li><li>Python中的标识符中，不能包含空格、@、% 以及 $ 等特殊字符。</li><li>在 Python 中，标识符中的字母是严格区分大小写的，也就是说，两个同样的单词，如果大小格式不一样，多代表的意义也是完全不同的。</li><li>Python 语言中，以下划线开头的标识符有特殊含义，例如：以单下划线开头的标识符（如 _width），表示不能直接访问的类属性，其无法通过 from…import* 的方式导入；以双下划线开头的标识符（如__add）表示类的私有成员；以双下划线作为开头和结尾的标识符（如 <strong>init</strong>），是专用标识符。</li><li>标识符的命名，除了要遵守以上这几条规则外，不同场景中的标识符，其名称也有一定的规范可循，例如：当标识符用作模块名时，应尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母，例如 game_mian、game_register等。当标识符用作包的名称时，应尽量短小，也全部使用小写字母，不推荐使用下划线，例如 <a href=\"http://com.mr\" target=\"_blank\" rel=\"external nofollow noopener noreferrer\">com.mr</a>、com.mr.book 等。当标识符用作类名时，应采用单词首字母大写的形式。例如，定义一个图书类，可以命名为 Book。模块内部的类名，可以采用 “下划线+首字母大写” 的形式，如 _Book;函数名、类中的属性名和方法名，应全部使用小写字母，多个单词之间可以用下划线分割；常量命名应全部使用大写字母，单词之间可以用下划线分割；</li></ul><h1 id=\"python关键字保留字\"><a class=\"markdownIt-Anchor\" href=\"#python关键字保留字\"></a> Python关键字(保留字)</h1><p>保留字是 Python 语言中一些已经被赋予特定意义的单词，这就要求开发者在开发程序时，不能用这些保留字作为标识符给变量、函数、类、模板以及其他对象命名。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">import</span> keyword</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>keyword.kwlist</span><br><span class=\"line\">[<span class=\"string\">'False'</span>, <span class=\"string\">'None'</span>, <span class=\"string\">'True'</span>, <span class=\"string\">'and'</span>, <span class=\"string\">'as'</span>, <span class=\"string\">'assert'</span>, <span class=\"string\">'break'</span>, <span class=\"string\">'class'</span>, <span class=\"string\">'continue'</span>, <span class=\"string\">'def'</span>, <span class=\"string\">'del'</span>, <span class=\"string\">'elif'</span>, <span class=\"string\">'else'</span>, <span class=\"string\">'except'</span>, <span class=\"string\">'finally'</span>, <span class=\"string\">'for'</span>, <span class=\"string\">'from'</span>, <span class=\"string\">'global'</span>, <span class=\"string\">'if'</span>, <span class=\"string\">'import'</span>, <span class=\"string\">'in'</span>, <span class=\"string\">'is'</span>, <span class=\"string\">'lambda'</span>, <span class=\"string\">'nonlocal'</span>, <span class=\"string\">'not'</span>, <span class=\"string\">'or'</span>, <span class=\"string\">'pass'</span>, <span class=\"string\">'raise'</span>, <span class=\"string\">'return'</span>, <span class=\"string\">'try'</span>, <span class=\"string\">'while'</span>, <span class=\"string\">'with'</span>, <span class=\"string\">'yield'</span>]</span><br></pre></td></tr></table></figure><h1 id=\"python内置函数\"><a class=\"markdownIt-Anchor\" href=\"#python内置函数\"></a> Python内置函数</h1><h2 id=\"absx\"><a class=\"markdownIt-Anchor\" href=\"#absx\"></a> abs(x)</h2><p>返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。</p><h2 id=\"alliterable\"><a class=\"markdownIt-Anchor\" href=\"#alliterable\"></a> all(iterable)</h2><p>如果 iterable 的所有元素为真（或迭代器为空），返回 True 。等价于:</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">all</span><span class=\"params\">(iterable)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> iterable:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> element:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure><h2 id=\"anyiterable\"><a class=\"markdownIt-Anchor\" href=\"#anyiterable\"></a> any(iterable)</h2><p>如果 iterable 的任一元素为真则返回 True。 如果迭代器为空，返回 False。 等价于:</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">any</span><span class=\"params\">(iterable)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> element <span class=\"keyword\">in</span> iterable:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> element:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure><h2 id=\"asciiobject\"><a class=\"markdownIt-Anchor\" href=\"#asciiobject\"></a> ascii(object)</h2><p>像函数repr()，返回一个对象可打印的字符串，但是repr()返回的字符串中非ASCII编码的字符，会使用 \\x、\\u 和 \\U 来转义。生成的字符串和Python2的repr()返回的结果相似。</p><h2 id=\"binx\"><a class=\"markdownIt-Anchor\" href=\"#binx\"></a> bin(x)</h2><p>将一个整数转变为一个前缀为“0b”的二进制字符串。结果是一个合法的 Python 表达式。如果x不是 Python的int对象，那它需要定义 <strong>index</strong>()方法返回一个整数。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>bin(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"string\">'0b11'</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>bin(<span class=\"number\">-10</span>)</span><br><span class=\"line\"><span class=\"string\">'-0b1010'</span></span><br></pre></td></tr></table></figure><h2 id=\"class-boolx\"><a class=\"markdownIt-Anchor\" href=\"#class-boolx\"></a> class bool([x])</h2><p>返回一个布尔值，True 或者 False。 x使用标准的 真值测试过程 来转换。如果x是假的或者被省略，返回 False；其他情况返回True。bool类是int的子类（参见 数字类型 — int, float, complex）。其他类不能继承自它。它只有False和True两个实例。</p><h2 id=\"breakpointargs-kws\"><a class=\"markdownIt-Anchor\" href=\"#breakpointargs-kws\"></a> breakpoint(*args, **kws)</h2><p>此函数会在调用时将你陷入调试器中。具体来说，它调用sys.breakpointhook() ，直接传递args和kws 。默认情况下， sys.breakpointhook()调用 pdb.set_trace()且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 pdb 且键入尽可能少的代码即可进入调试器。但是，sys.breakpointhook() 可以设置为其他一些函数并被breakpoint()自动调用，以允许进入你想用的调试器。</p><h2 id=\"class-bytearraysource-encoding-errors\"><a class=\"markdownIt-Anchor\" href=\"#class-bytearraysource-encoding-errors\"></a> class bytearray([source[, encoding[, errors]]])</h2><p>返回一个新的bytes数组。 bytearray类是一个可变序列，包含范围为0 &lt;= x &lt; 256的整数。它有可变序列大部分常见的方法，见 可变序列类型的描述；同时有 bytes类型的大部分方法，参见 bytes和bytearray操作。</p><h2 id=\"enumerateiterable-start0\"><a class=\"markdownIt-Anchor\" href=\"#enumerateiterable-start0\"></a> enumerate(iterable, start=0)</h2><p>返回一个枚举对象。iterable 必须是一个序列，或 iterator，或其他支持迭代的对象。 enumerate() 返回的迭代器的 <strong>next</strong>() 方法返回一个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代 iterable 获得的值。<br>##　divmod(a, b)<br>它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和 (a // b, a % b) 一致。对于浮点数，结果是(q, a % b) ，q通常是 math.floor(a / b) 但可能会比 1 小。在任何情况下， q * b + a % b和a基本相等；如果a % b非零，它的符号和 b 一样，并且 0 &lt;= abs(a % b) &lt; abs(b)。</p><h2 id=\"evalexpression-globals-locals\"><a class=\"markdownIt-Anchor\" href=\"#evalexpression-globals-locals\"></a> eval(expression[, globals[, locals]])</h2><p>实参是一个字符串，以及可选的 globals 和 locals。globals 实参必须是一个字典。locals 可以是任何映射对象。</p><p>expression参数会作为一个 Python表达式（从技术上说是一个条件列表）被解析并求值，使用 globals 和 locals 字典作为全局和局部命名空间。如果 globals 字典存在且不包含以 __builtins__为键的值，则会在解析expression之前插入以此为键的对内置模块builtins的字典的引用。这意味着expression通常具有对标准builtins模块的完全访问权限且受限的环境会被传播。如果省略locals字典则其默认值为 globals字典。如果两个字典同时省略，表达式会在eval()被调用的环境中执行。返回值为表达式求值的结果。语法错误将作为异常被报告。</p><h2 id=\"getattrobject-name-default\"><a class=\"markdownIt-Anchor\" href=\"#getattrobject-name-default\"></a> getattr(object, name[, default])</h2><p>返回对象命名属性的值。name必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， getattr(x, ‘foobar’) 等同于 x.foobar。如果指定的属性不存在，且提供了default值，则返回它，否则触发 AttributeError。</p><h2 id=\"globals\"><a class=\"markdownIt-Anchor\" href=\"#globals\"></a> globals()</h2><p>返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。</p><h2 id=\"hasattrobject-name\"><a class=\"markdownIt-Anchor\" href=\"#hasattrobject-name\"></a> hasattr(object, name)</h2><p>该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回True，否则返回False。（此功能是通过调用getattr(object, name) 看是否有 AttributeError异常来实现的）。</p><h2 id=\"hashobject\"><a class=\"markdownIt-Anchor\" href=\"#hashobject\"></a> hash(object)</h2><p>返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。</p><h2 id=\"reprobject\"><a class=\"markdownIt-Anchor\" href=\"#reprobject\"></a> repr(object)</h2><p>返回包含一个对象的可打印表示形式的字符串。 对于许多类型来说，该函数会尝试返回的字符串将会与该对象被传递给 eval() 时所生成的对象具有相同的值，在其他情况下表示形式会是一个括在尖括号中的字符串，其中包含对象类型的名称与通常包括对象名称和地址的附加信息。 类可以通过定义 <strong>repr</strong>() 方法来控制此函数为它的实例所返回的内容。</p><!-- rebuild by neat -->","categories":[{"name":"计算机基础","path":"api/categories/计算机基础.json"},{"name":"Python","path":"api/categories/Python.json"}],"tags":[{"name":"Python","path":"api/tags/Python.json"}]}