{"title":"Python-类特殊成员","slug":"Python-类特殊成员","date":"2020-04-28T15:27:44.000Z","updated":"2020-04-29T04:17:42.880Z","comments":true,"path":"api/articles/Python-类特殊成员.json","excerpt":null,"covers":null,"content":"<!-- build time:Thu Apr 30 2020 10:09:51 GMT+0800 (GMT+08:00) --><h1 id=\"new方法\"><a class=\"markdownIt-Anchor\" href=\"#new方法\"></a> <strong>new</strong>()方法</h1><p><strong>new</strong>() 是一种负责创建类实例的静态方法，它无需使用 staticmethod 装饰器修饰，且该方法会优先__init__() 初始化方法被调用。一般情况下，覆写__new__()的实现将会使用合适的参数调用其超类的 super().<strong>new</strong>()，并在返回之前修改实例。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demoClass</span>:</span></span><br><span class=\"line\">    instances_created = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls,*args,**kwargs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"__new__():\"</span>,cls,args,kwargs)</span><br><span class=\"line\">        instance = super().__new__(cls)</span><br><span class=\"line\">        instance.number = cls.instances_created</span><br><span class=\"line\">        cls.instances_created += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,attribute)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"__init__():\"</span>,self,attribute)</span><br><span class=\"line\">        self.attribute = attribute</span><br><span class=\"line\">test1 = demoClass(<span class=\"string\">\"abc\"</span>)</span><br><span class=\"line\">test2 = demoClass(<span class=\"string\">\"xyz\"</span>)</span><br><span class=\"line\">print(test1.number,test1.instances_created)</span><br><span class=\"line\">print(test2.number,test2.instances_created)</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"comment\">#__new__(): &lt;class '__main__.demoClass'&gt; ('abc',) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">#__init__(): &lt;__main__.demoClass object at 0x0000026FC0DF8080&gt; abc</span></span><br><span class=\"line\"><span class=\"comment\">#__new__(): &lt;class '__main__.demoClass'&gt; ('xyz',) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">#__init__(): &lt;__main__.demoClass object at 0x0000026FC0DED358&gt; xyz</span></span><br><span class=\"line\"><span class=\"comment\">#0 2</span></span><br><span class=\"line\"><span class=\"comment\">#1 2</span></span><br></pre></td></tr></table></figure><h1 id=\"repr方法显示属性\"><a class=\"markdownIt-Anchor\" href=\"#repr方法显示属性\"></a> <strong>repr</strong>()方法：显示属性</h1><p><strong>repr</strong>() 会返回和调用者有关的 “类名+object at+内存地址”信息。当然，我们还可以通过在类中重写这个方法，从而实现当输出实例化对象时，输出我们想要的信息。实例：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CLanguage</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.name = <span class=\"string\">\"C语言中文网\"</span></span><br><span class=\"line\">        self.add = <span class=\"string\">\"http://c.biancheng.net\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"CLanguage[name=\"</span>+ self.name +<span class=\"string\">\",add=\"</span> + self.add +<span class=\"string\">\"]\"</span></span><br><span class=\"line\">clangs = CLanguage()</span><br><span class=\"line\">print(clangs)</span><br><span class=\"line\"><span class=\"comment\"># CLanguage[name=C语言中文网,add=http://c.biancheng.net]</span></span><br></pre></td></tr></table></figure><p><strong>repr</strong>() 方法是类的实例化对象用来做“自我介绍”的方法，默认情况下，它会返回当前对象的“类名+object at+内存地址”，而如果对该方法进行重写，可以为其制作自定义的自我描述信息。</p><h1 id=\"dir用法\"><a class=\"markdownIt-Anchor\" href=\"#dir用法\"></a> <strong>dir</strong>()用法</h1><p>提到了dir() 函数，通过此函数可以某个对象拥有的所有的属性名和方法名，该函数会返回一个包含有所有属性名和方法名的有序列表。</p><h1 id=\"__dict__属性查看对象内部所有属性名和属性值组成的字典\"><a class=\"markdownIt-Anchor\" href=\"#__dict__属性查看对象内部所有属性名和属性值组成的字典\"></a> __dict__属性：查看对象内部所有属性名和属性值组成的字典</h1><p>便用户查看类中包含哪些属性，Python 类提供了__dict__属性。需要注意的一点是，该属性可以用类名或者类的实例对象来调用，用类名直接调用 <strong>dict</strong>，会输出该由类中所有类属性组成的字典；而使用类的实例对象调用 <strong>dict</strong>，会输出由类中所有实例属性组成的字典。对于具有继承关系的父类和子类来说，父类有自己的__dict__，同样子类也有自己的__dict__，它不会包含父类的__dict__</p><h1 id=\"setattr-getattr-hasattr函数用法\"><a class=\"markdownIt-Anchor\" href=\"#setattr-getattr-hasattr函数用法\"></a> setattr()、getattr()、hasattr()函数用法</h1><h2 id=\"hasattr函数\"><a class=\"markdownIt-Anchor\" href=\"#hasattr函数\"></a> hasattr()函数</h2><p>hasattr() 函数用来判断某个类实例对象是否包含指定名称的属性或方法。该函数的语法格式如下：</p><blockquote><p>hasattr(obj, name)</p></blockquote><p>无论是属性名还是方法名，都在 hasattr() 函数的匹配范围内。因此，我们只能通过该函数判断实例对象是否包含该名称的属性或方法，但不能精确判断，该名称代表的是属性还是方法。</p><h2 id=\"getattr函数\"><a class=\"markdownIt-Anchor\" href=\"#getattr函数\"></a> getattr()函数</h2><p>getattr() 函数获取某个类实例对象中指定属性的值，该函数只会从类对象包含的所有属性中进行查找。<br>getattr() 函数的语法格式如下：</p><blockquote><p>getattr(obj, name[, default])</p></blockquote><p>其中，obj 表示指定的类实例对象，name 表示指定的属性名，而 default 是可选参数，用于设定该函数的默认返回值，即当函数查找失败时，如果不指定 default 参数，则程序将直接报 AttributeError 错误，反之该函数将返回 default 指定的值。</p><h2 id=\"setattr函数\"><a class=\"markdownIt-Anchor\" href=\"#setattr函数\"></a> setattr()函数</h2><p>setattr() 函数的功能相对比较复杂，它最基础的功能是修改类实例对象中的属性值。其次，它还可以实现为实例对象动态添加属性或者方法。setattr() 函数的语法格式如下：</p><blockquote><p>setattr(obj, name, value)</p></blockquote><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">say</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"我正在学Python\"</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CLanguage</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span> <span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.name = <span class=\"string\">\"C语言中文网\"</span></span><br><span class=\"line\">        self.add = <span class=\"string\">\"http://c.biancheng.net\"</span></span><br><span class=\"line\">clangs = CLanguage()</span><br><span class=\"line\">print(clangs.name)</span><br><span class=\"line\">print(clangs.add)</span><br><span class=\"line\">setattr(clangs,<span class=\"string\">\"name\"</span>,say)</span><br><span class=\"line\">clangs.name(clangs)</span><br><span class=\"line\"><span class=\"comment\">#程序运行结果为：</span></span><br><span class=\"line\"><span class=\"comment\">#C语言中文网</span></span><br><span class=\"line\"><span class=\"comment\">#http://c.biancheng.net</span></span><br><span class=\"line\"><span class=\"comment\">#我正在学Python</span></span><br></pre></td></tr></table></figure><h1 id=\"issubclass和isinstance函数检查类型\"><a class=\"markdownIt-Anchor\" href=\"#issubclass和isinstance函数检查类型\"></a> issubclass和isinstance函数：检查类型</h1><p>Python 提供了如下两个函数来检查类型：</p><ul><li>issubclass(cls, class_or_tuple)：检查 cls 是否为后一个类或元组包含的多个类中任意类的子类。</li><li>isinstance(obj, class_or_tuple)：检查 obj 是否为后一个类或元组包含的多个类中任意类的对象。</li></ul><p>区别只是 issubclass() 的第一个参数是类名，而 isinstance() 的第一个参数是变量，这也与两个函数的意义对应：issubclass 用于判断是否为子类，而 isinstance() 用于判断是否为该类或子类的实例。</p><p>Python为所有类都提供了一个 <strong>bases</strong> 属性，通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组。</p><h1 id=\"call方法\"><a class=\"markdownIt-Anchor\" href=\"#call方法\"></a> <strong>call</strong>()方法</h1><p>功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。</p><blockquote><p>Python 中，凡是可以将 () 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。</p></blockquote><p>hasattr()的功能是查找类的实例对象中是否包含指定名称的属性或者方法，但该函数有一个缺陷，即它无法判断该指定的名称，到底是类属性还是类方法。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CLanguage</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span> <span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.name = <span class=\"string\">\"C语言中文网\"</span></span><br><span class=\"line\">        self.add = <span class=\"string\">\"http://c.biancheng.net\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">say</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"我正在学Python\"</span>)</span><br><span class=\"line\">clangs = CLanguage()</span><br><span class=\"line\"><span class=\"keyword\">if</span> hasattr(clangs,<span class=\"string\">\"name\"</span>):</span><br><span class=\"line\">    print(hasattr(clangs.name,<span class=\"string\">\"__call__\"</span>))</span><br><span class=\"line\">print(<span class=\"string\">\"**********\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> hasattr(clangs,<span class=\"string\">\"say\"</span>):</span><br><span class=\"line\">    print(hasattr(clangs.say,<span class=\"string\">\"__call__\"</span>))</span><br><span class=\"line\">执行结果：</span><br><span class=\"line\">    <span class=\"literal\">False</span>  </span><br><span class=\"line\">    *********</span><br><span class=\"line\">    <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"comment\"># 由于name是类属性，它没有以__call__为名的__call__()方法；而 say是类方法，它是可调用对象，因此它有__call__()方法。</span></span><br></pre></td></tr></table></figure><h1 id=\"运算符重载\"><a class=\"markdownIt-Anchor\" href=\"#运算符重载\"></a> 运算符重载</h1><p>Python 类支持对哪些方法进行重载呢？，列出了 Python 中常用的可重载的运算符，以及各自的含义。</p><table><thead><tr><th>重载运算符</th><th>含义</th></tr></thead><tbody><tr><td><strong>new</strong></td><td>创建类，在 <strong>init</strong> 之前创建对象</td></tr><tr><td><strong>init</strong></td><td>类的构造函数，其功能是创建类对象时做初始化工作。</td></tr><tr><td><strong>del</strong></td><td>析构函数，其功能是销毁对象时进行回收资源的操作</td></tr><tr><td><strong>add</strong></td><td>加法运算符 +，当类对象 X 做例如 X+Y 或者 X+=Y 等操作，内部会调用此方法。但如果类中对 <strong>iadd</strong> 方法进行了重载，则类对象 X 在做 X+=Y 类似操作时，会优先选择调用 <strong>iadd</strong> 方法。</td></tr><tr><td><strong>radd</strong></td><td>当类对象 X 做类似 Y+X 的运算时，会调用此方法。</td></tr><tr><td><strong>iadd</strong></td><td>重载 += 运算符，也就是说，当类对象 X 做类似 X+=Y 的操作时，会调用此方法。</td></tr><tr><td><strong>or</strong></td><td>“或”运算符</td></tr><tr><td><strong>repr</strong>，<strong>str</strong></td><td>格式转换方法，分别对应函数 repr(X)、str(X)</td></tr><tr><td><strong>call</strong></td><td>函数调用，类似于 X(*args, **kwargs) 语句</td></tr><tr><td><strong>getattr</strong></td><td>点号运算，用来获取类属性</td></tr><tr><td><strong>setattr</strong></td><td>属性赋值语句，类似于 X.any=value</td></tr><tr><td><strong>delattr</strong></td><td>删除属性，类似于 del X.any</td></tr><tr><td><strong>getattribute</strong></td><td>获取属性，类似于 X.any</td></tr><tr><td><strong>getitem</strong></td><td>索引运算，类似于 X[key]，X[i:j]</td></tr><tr><td><strong>setitem</strong></td><td>索引赋值语句，类似于 X[key], X[i:j]=sequence</td></tr><tr><td><strong>delitem</strong></td><td>索引和分片删除</td></tr><tr><td><strong>get</strong>, <strong>set</strong>, <strong>delete</strong></td><td>描述符属性，类似于 X.attr，X.attr=value，del X.attr</td></tr><tr><td><strong>len</strong></td><td>计算长度，类似于 len(X)</td></tr><tr><td><strong>lt</strong>，<strong>gt</strong>，<strong>le</strong>，<strong>ge</strong>，<strong>eq</strong>，<strong>ne</strong></td><td>比较，分别对应于 &lt;、&gt;、&lt;=、&gt;=、=、!= 运算符。</td></tr><tr><td><strong>iter</strong>，<strong>next</strong></td><td>迭代环境下，生成迭代器与取下一条，类似于 I=iter(X) 和 next()</td></tr><tr><td><strong>contains</strong></td><td>成员关系测试，类似于 item in X</td></tr><tr><td><strong>index</strong></td><td>整数值，类似于 hex(X)，bin(X)，oct(X)</td></tr><tr><td><strong>enter</strong>，<strong>exit</strong></td><td>在对类对象执行类似 with obj as var 的操作之前，会先调用 <strong>enter</strong> 方法，其结果会传给 var；在最终结束该操作之前，会调用</td></tr></tbody></table><h1 id=\"python迭代器\"><a class=\"markdownIt-Anchor\" href=\"#python迭代器\"></a> Python迭代器</h1><p>迭代器指的就是支持迭代的容器，更确切的说，是支持迭代的容器类对象，这里的容器可以是列表、元组等这些 Python 提供的基础容器，也可以是自定义的容器类对象，只要该容器支持迭代即可。自定义实现一个迭代器，则类中必须实现如下2个方法：</p><ul><li><strong>next</strong>(self)：返回容器的下一个元素。</li><li><strong>iter</strong>(self)：该方法返回一个迭代器（iterator）。</li></ul><p>Python 内置的 iter() 函数也会返回一个迭代器，该函数的语法格式如下：</p><blockquote><p>iter(obj[, sentinel])</p></blockquote><p>其中，obj 必须是一个可迭代的容器对象，而 sentinel 作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象。</p><blockquote><p>可调用对象，指的是该类的实例对象可以像函数那样，直接以“对象名()”的形式被使用。通过在类中添加 <strong>call</strong>() 方法，就可以将该类的实例对象编程可调用对象。</p></blockquote><p>1个参数的 iter()函数，通过传入一个可迭代的容器对象，我们可以获得一个迭代器，通过调用该迭代器中的__next__()方法即可实现迭代，使用next()内置函数来迭代，即next(myIter)，和__next__()方法是完全一样的。</p><p>iter()函数第2个参数的作用，如果使用该参数，则要求第一个obj参数必须传入可调用对象（可以不支持迭代），这样当使用返回的迭代器调用__next__()方法时，它会通过执行obj()调用 <strong>call</strong>()方法，如果该方法的返回值和第 2 个参数值相同，则输出 StopInteration 异常；反之，则输出 <strong>call</strong>() 方法的返回值。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 迭代器实现字符串逆序</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Reverse</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, string)</span>:</span></span><br><span class=\"line\">        self.__string = string</span><br><span class=\"line\">        self.__index = len(string)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__iter__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__next__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.__index == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span>(StopIteration)</span><br><span class=\"line\">        self.__index -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.__string[self.__index]</span><br><span class=\"line\">revstr = Reverse(<span class=\"string\">'Python'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> revstr:</span><br><span class=\"line\">    print(c,end=<span class=\"string\">\" \"</span>)</span><br></pre></td></tr></table></figure><h1 id=\"生成器\"><a class=\"markdownIt-Anchor\" href=\"#生成器\"></a> 生成器</h1><p>生成器的创建方式也比迭代器简单很多，大体分为以下 2 步：</p><ul><li>定义一个以 yield 关键字标识返回值的函数；</li><li>调用刚刚创建的函数，即可创建一个生成器。</li></ul><p>和return相比，yield 除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。不仅如此，即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。</p><blockquote><p>相比迭代器，生成器最明显的优势就是节省内存空间，即它不会一次性生成所有的数据，而是什么时候需要，什么时候生成。</p></blockquote><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intNum</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"开始执行\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i</span><br><span class=\"line\">        print(<span class=\"string\">\"继续执行\"</span>)</span><br><span class=\"line\">num = intNum()</span><br></pre></td></tr></table></figure><p>即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。想要生成器函数执行，或者想使执行完 yield 语句立即暂停的程序得以继续执行，可以通过：</p><ul><li>通过生成器调用next()内置函数或者__next__()方法</li><li>通过for循环遍历生成器</li></ul><h2 id=\"生成器send方法\"><a class=\"markdownIt-Anchor\" href=\"#生成器send方法\"></a> 生成器send()方法</h2><p>通过 send() 方法，还可以向生成器中传值。</p><p>值得一提的是，send()方法可带一个参数，也可以不带任何参数（用 None 表示）。其中，当使用不带参数的send()方法时，它和next()函数的功能完全相同。例如：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ddef foo():</span><br><span class=\"line\">    bar_a = <span class=\"keyword\">yield</span> <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">    bar_b = <span class=\"keyword\">yield</span> bar_a</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> bar_b</span><br><span class=\"line\">f = foo()</span><br><span class=\"line\">print(f.send(<span class=\"literal\">None</span>))</span><br><span class=\"line\">print(f.send(<span class=\"string\">\"C语言中文网\"</span>))</span><br><span class=\"line\">print(f.send(<span class=\"string\">\"http://c.biancheng.net\"</span>))</span><br><span class=\"line\"><span class=\"comment\">#hello</span></span><br><span class=\"line\"><span class=\"comment\">#C语言中文网</span></span><br><span class=\"line\"><span class=\"comment\">#http://c.biancheng.net</span></span><br></pre></td></tr></table></figure><h2 id=\"close方法\"><a class=\"markdownIt-Anchor\" href=\"#close方法\"></a> close()方法</h2><p>生成器函数中遇到yield语句暂停运行时，此时如果调用 close()方法，会阻止生成器函数继续执行，该函数会在程序停止运行的位置抛出 GeneratorExit 异常。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> GeneratorExit:</span><br><span class=\"line\">        print(<span class=\"string\">'捕获到 GeneratorExit'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"number\">2</span> <span class=\"comment\">#抛出 RuntimeError 异常</span></span><br><span class=\"line\">f = foo()</span><br><span class=\"line\">print(next(f))</span><br><span class=\"line\">f.close()</span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">1</span></span><br><span class=\"line\"><span class=\"string\">捕获到 GeneratorExit Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"string\">  File \"D:\\python3.6\\1.py\", line 10, in &lt;module&gt;</span></span><br><span class=\"line\"><span class=\"string\">    f.close()</span></span><br><span class=\"line\"><span class=\"string\">RuntimeError: generator ignored GeneratorExit</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure><h2 id=\"生成器throw方法\"><a class=\"markdownIt-Anchor\" href=\"#生成器throw方法\"></a> 生成器throw()方法</h2><p>生成器 throw() 方法的功能是，在生成器函数执行暂停处，抛出一个指定的异常，之后程序会继续执行生成器函数中后续的代码，直到遇到下一个yield语句。需要注意的是，如果到剩余代码执行完毕没有遇到下一个yield语句，则程序会抛出 StopIteration异常。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> ValueError:</span><br><span class=\"line\">        print(<span class=\"string\">'捕获到 ValueError'</span>)</span><br><span class=\"line\">f = foo()</span><br><span class=\"line\">print(next(f))</span><br><span class=\"line\">f.throw(ValueError)</span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">运行结果：1</span></span><br><span class=\"line\"><span class=\"string\">捕获到 ValueError</span></span><br><span class=\"line\"><span class=\"string\">Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"string\">  File \"D:\\python3.6\\1.py\", line 9, in &lt;module&gt;</span></span><br><span class=\"line\"><span class=\"string\">    f.throw(ValueError)</span></span><br><span class=\"line\"><span class=\"string\">StopIteration</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure><p>一开始生成器函数在yield 1处暂停执行，当执行throw()方法时，它会先抛出 ValueError异常，然后继续执行后续代码找到下一个 yield语句，该程序中由于后续不再有yield语句，因此程序执行到最后，会抛出一个 StopIteration异常。</p><h1 id=\"函数装饰器及用法\"><a class=\"markdownIt-Anchor\" href=\"#函数装饰器及用法\"></a> 函数装饰器及用法</h1><p>Python 内置的 3 种函数装饰器，分别是 ＠staticmethod、＠classmethod 和 @property，其中 staticmethod()、classmethod()和 property()都是Python的内置函数。<br>使用函数装饰器A()去装饰另一个函数B()，其底层执行了如下2步操作：</p><ul><li>将B作为参数传给A()函数；</li><li>将A()函数执行完成的返回值反馈回B。</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">funA</span><span class=\"params\">(fn)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"C语言中文网\"</span>)</span><br><span class=\"line\">    fn() <span class=\"comment\"># 执行传入的fn参数</span></span><br><span class=\"line\">    print(<span class=\"string\">\"http://c.biancheng.net\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"装饰器函数的返回值\"</span></span><br><span class=\"line\"><span class=\"meta\">@funA</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">funB</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"学习 Python\"</span>)</span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">C语言中文网</span></span><br><span class=\"line\"><span class=\"string\">学习 Python</span></span><br><span class=\"line\"><span class=\"string\">http://c.biancheng.net</span></span><br><span class=\"line\"><span class=\"string\">在此基础上，如果在程序末尾添加如下语句：</span></span><br><span class=\"line\"><span class=\"string\">print(funB)</span></span><br><span class=\"line\"><span class=\"string\">其输出结果为：</span></span><br><span class=\"line\"><span class=\"string\">装饰器函数的返回值</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure><p>如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名；同样，如果装饰器返回的是一个函数的名称，怎么被修饰的函数名依然表示一个函数。</p><blockquote><p>函数装饰器，就是通过装饰器函数，在不修改原函数的前提下，来对函数的功能进行合理的扩充。</p></blockquote><h2 id=\"带参数的函数装饰器\"><a class=\"markdownIt-Anchor\" href=\"#带参数的函数装饰器\"></a> 带参数的函数装饰器</h2><p>函数装饰器中嵌套一个函数，该函数带有的参数个数和被装饰器修饰的函数相同。例如：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">funA</span><span class=\"params\">(fn)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义一个嵌套函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">say</span><span class=\"params\">(arc)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Python教程:\"</span>,arc)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> say</span><br><span class=\"line\"><span class=\"meta\">@funA</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">funB</span><span class=\"params\">(arc)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"funB():\"</span>, a)</span><br><span class=\"line\">funB(<span class=\"string\">\"http://c.biancheng.net/python\"</span>)</span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">程序执行结果为：</span></span><br><span class=\"line\"><span class=\"string\">Python教程: http://c.biancheng.net/python</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure><h2 id=\"函数装饰器嵌套\"><a class=\"markdownIt-Anchor\" href=\"#函数装饰器嵌套\"></a> 函数装饰器嵌套</h2><p>上面程序的执行顺序是里到外，所以它等效于下面这行代码：</p><blockquote><p>fun = funA( funB ( funC (fun) ) )</p></blockquote><h1 id=\"装饰器的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#装饰器的应用场景\"></a> 装饰器的应用场景</h1><h2 id=\"身份认证\"><a class=\"markdownIt-Anchor\" href=\"#身份认证\"></a> 身份认证</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">authenticate</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        request = args[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"comment\"># 如果用户处于登录状态</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> check_user_logged_in(request):</span><br><span class=\"line\">            <span class=\"comment\"># 执行函数 post_comment()</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kwargs)  </span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> Exception(<span class=\"string\">'Authentication failed'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">@authenticate</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post_comment</span><span class=\"params\">(request, ...)</span></span></span><br><span class=\"line\"><span class=\"function\">    ...</span></span><br></pre></td></tr></table></figure><p>定义了装饰器 authenticate，函数 post_comment() 则表示发表用户对某篇文章的评论，每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。</p><h2 id=\"日志记录\"><a class=\"markdownIt-Anchor\" href=\"#日志记录\"></a> 日志记录</h2><p>日志记录同样是很常见的一个案例。在实际工作中，如果你怀疑某些函数的耗时过长，导致整个系统的延迟增加，想在线上测试某些函数的执行时间，那么，装饰器就是一种很常用的手段。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log_execution_time</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        start = time.perf_counter()</span><br><span class=\"line\">        res = func(*args, **kwargs)</span><br><span class=\"line\">        print(<span class=\"string\">'&#123;&#125; took &#123;&#125; ms'</span>.format(func.__name__, (end - start) * <span class=\"number\">1000</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">@log_execution_time</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calculate_similarity</span><span class=\"params\">(items)</span>:</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure><p>装饰器 log_execution_time 记录某个函数的运行时间，并返回其执行结果。如果你想计算任何函数的执行时间，在这个函数上方加上@log_execution_time即可。</p><h2 id=\"装饰器用于输入合理性检查\"><a class=\"markdownIt-Anchor\" href=\"#装饰器用于输入合理性检查\"></a> 装饰器用于输入合理性检查</h2><p>在大型公司的机器学习框架中，调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检查。这样就可以大大避免输入不正确对机器造成的巨大开销。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validation_check</span><span class=\"params\">(input)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"><span class=\"meta\">@validation_check</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">neural_network_training</span><span class=\"params\">(param1, param2,...)</span></span></span><br></pre></td></tr></table></figure><p>很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现。</p><h2 id=\"缓存装饰器\"><a class=\"markdownIt-Anchor\" href=\"#缓存装饰器\"></a> 缓存装饰器</h2><p>ython 中的表示形式是 @lru_cache。@lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除最近最久未使用的数据。正确使用缓存装饰器，往往能极大地提高程序运行效率。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@lru_cache</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(param1, param2, ...)</span>  # 检查用户设备类型、版本号</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","more":"<!-- build time:Thu Apr 30 2020 10:09:51 GMT+0800 (GMT+08:00) --><h1 id=\"new方法\"><a class=\"markdownIt-Anchor\" href=\"#new方法\"></a> <strong>new</strong>()方法</h1><p><strong>new</strong>() 是一种负责创建类实例的静态方法，它无需使用 staticmethod 装饰器修饰，且该方法会优先__init__() 初始化方法被调用。一般情况下，覆写__new__()的实现将会使用合适的参数调用其超类的 super().<strong>new</strong>()，并在返回之前修改实例。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">demoClass</span>:</span></span><br><span class=\"line\">    instances_created = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls,*args,**kwargs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"__new__():\"</span>,cls,args,kwargs)</span><br><span class=\"line\">        instance = super().__new__(cls)</span><br><span class=\"line\">        instance.number = cls.instances_created</span><br><span class=\"line\">        cls.instances_created += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,attribute)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"__init__():\"</span>,self,attribute)</span><br><span class=\"line\">        self.attribute = attribute</span><br><span class=\"line\">test1 = demoClass(<span class=\"string\">\"abc\"</span>)</span><br><span class=\"line\">test2 = demoClass(<span class=\"string\">\"xyz\"</span>)</span><br><span class=\"line\">print(test1.number,test1.instances_created)</span><br><span class=\"line\">print(test2.number,test2.instances_created)</span><br><span class=\"line\"><span class=\"comment\"># 输出结果</span></span><br><span class=\"line\"><span class=\"comment\">#__new__(): &lt;class '__main__.demoClass'&gt; ('abc',) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">#__init__(): &lt;__main__.demoClass object at 0x0000026FC0DF8080&gt; abc</span></span><br><span class=\"line\"><span class=\"comment\">#__new__(): &lt;class '__main__.demoClass'&gt; ('xyz',) &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">#__init__(): &lt;__main__.demoClass object at 0x0000026FC0DED358&gt; xyz</span></span><br><span class=\"line\"><span class=\"comment\">#0 2</span></span><br><span class=\"line\"><span class=\"comment\">#1 2</span></span><br></pre></td></tr></table></figure><h1 id=\"repr方法显示属性\"><a class=\"markdownIt-Anchor\" href=\"#repr方法显示属性\"></a> <strong>repr</strong>()方法：显示属性</h1><p><strong>repr</strong>() 会返回和调用者有关的 “类名+object at+内存地址”信息。当然，我们还可以通过在类中重写这个方法，从而实现当输出实例化对象时，输出我们想要的信息。实例：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CLanguage</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.name = <span class=\"string\">\"C语言中文网\"</span></span><br><span class=\"line\">        self.add = <span class=\"string\">\"http://c.biancheng.net\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"CLanguage[name=\"</span>+ self.name +<span class=\"string\">\",add=\"</span> + self.add +<span class=\"string\">\"]\"</span></span><br><span class=\"line\">clangs = CLanguage()</span><br><span class=\"line\">print(clangs)</span><br><span class=\"line\"><span class=\"comment\"># CLanguage[name=C语言中文网,add=http://c.biancheng.net]</span></span><br></pre></td></tr></table></figure><p><strong>repr</strong>() 方法是类的实例化对象用来做“自我介绍”的方法，默认情况下，它会返回当前对象的“类名+object at+内存地址”，而如果对该方法进行重写，可以为其制作自定义的自我描述信息。</p><h1 id=\"dir用法\"><a class=\"markdownIt-Anchor\" href=\"#dir用法\"></a> <strong>dir</strong>()用法</h1><p>提到了dir() 函数，通过此函数可以某个对象拥有的所有的属性名和方法名，该函数会返回一个包含有所有属性名和方法名的有序列表。</p><h1 id=\"__dict__属性查看对象内部所有属性名和属性值组成的字典\"><a class=\"markdownIt-Anchor\" href=\"#__dict__属性查看对象内部所有属性名和属性值组成的字典\"></a> __dict__属性：查看对象内部所有属性名和属性值组成的字典</h1><p>便用户查看类中包含哪些属性，Python 类提供了__dict__属性。需要注意的一点是，该属性可以用类名或者类的实例对象来调用，用类名直接调用 <strong>dict</strong>，会输出该由类中所有类属性组成的字典；而使用类的实例对象调用 <strong>dict</strong>，会输出由类中所有实例属性组成的字典。对于具有继承关系的父类和子类来说，父类有自己的__dict__，同样子类也有自己的__dict__，它不会包含父类的__dict__</p><h1 id=\"setattr-getattr-hasattr函数用法\"><a class=\"markdownIt-Anchor\" href=\"#setattr-getattr-hasattr函数用法\"></a> setattr()、getattr()、hasattr()函数用法</h1><h2 id=\"hasattr函数\"><a class=\"markdownIt-Anchor\" href=\"#hasattr函数\"></a> hasattr()函数</h2><p>hasattr() 函数用来判断某个类实例对象是否包含指定名称的属性或方法。该函数的语法格式如下：</p><blockquote><p>hasattr(obj, name)</p></blockquote><p>无论是属性名还是方法名，都在 hasattr() 函数的匹配范围内。因此，我们只能通过该函数判断实例对象是否包含该名称的属性或方法，但不能精确判断，该名称代表的是属性还是方法。</p><h2 id=\"getattr函数\"><a class=\"markdownIt-Anchor\" href=\"#getattr函数\"></a> getattr()函数</h2><p>getattr() 函数获取某个类实例对象中指定属性的值，该函数只会从类对象包含的所有属性中进行查找。<br>getattr() 函数的语法格式如下：</p><blockquote><p>getattr(obj, name[, default])</p></blockquote><p>其中，obj 表示指定的类实例对象，name 表示指定的属性名，而 default 是可选参数，用于设定该函数的默认返回值，即当函数查找失败时，如果不指定 default 参数，则程序将直接报 AttributeError 错误，反之该函数将返回 default 指定的值。</p><h2 id=\"setattr函数\"><a class=\"markdownIt-Anchor\" href=\"#setattr函数\"></a> setattr()函数</h2><p>setattr() 函数的功能相对比较复杂，它最基础的功能是修改类实例对象中的属性值。其次，它还可以实现为实例对象动态添加属性或者方法。setattr() 函数的语法格式如下：</p><blockquote><p>setattr(obj, name, value)</p></blockquote><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">say</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"我正在学Python\"</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CLanguage</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span> <span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.name = <span class=\"string\">\"C语言中文网\"</span></span><br><span class=\"line\">        self.add = <span class=\"string\">\"http://c.biancheng.net\"</span></span><br><span class=\"line\">clangs = CLanguage()</span><br><span class=\"line\">print(clangs.name)</span><br><span class=\"line\">print(clangs.add)</span><br><span class=\"line\">setattr(clangs,<span class=\"string\">\"name\"</span>,say)</span><br><span class=\"line\">clangs.name(clangs)</span><br><span class=\"line\"><span class=\"comment\">#程序运行结果为：</span></span><br><span class=\"line\"><span class=\"comment\">#C语言中文网</span></span><br><span class=\"line\"><span class=\"comment\">#http://c.biancheng.net</span></span><br><span class=\"line\"><span class=\"comment\">#我正在学Python</span></span><br></pre></td></tr></table></figure><h1 id=\"issubclass和isinstance函数检查类型\"><a class=\"markdownIt-Anchor\" href=\"#issubclass和isinstance函数检查类型\"></a> issubclass和isinstance函数：检查类型</h1><p>Python 提供了如下两个函数来检查类型：</p><ul><li>issubclass(cls, class_or_tuple)：检查 cls 是否为后一个类或元组包含的多个类中任意类的子类。</li><li>isinstance(obj, class_or_tuple)：检查 obj 是否为后一个类或元组包含的多个类中任意类的对象。</li></ul><p>区别只是 issubclass() 的第一个参数是类名，而 isinstance() 的第一个参数是变量，这也与两个函数的意义对应：issubclass 用于判断是否为子类，而 isinstance() 用于判断是否为该类或子类的实例。</p><p>Python为所有类都提供了一个 <strong>bases</strong> 属性，通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组。</p><h1 id=\"call方法\"><a class=\"markdownIt-Anchor\" href=\"#call方法\"></a> <strong>call</strong>()方法</h1><p>功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。</p><blockquote><p>Python 中，凡是可以将 () 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。</p></blockquote><p>hasattr()的功能是查找类的实例对象中是否包含指定名称的属性或者方法，但该函数有一个缺陷，即它无法判断该指定的名称，到底是类属性还是类方法。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CLanguage</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span> <span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.name = <span class=\"string\">\"C语言中文网\"</span></span><br><span class=\"line\">        self.add = <span class=\"string\">\"http://c.biancheng.net\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">say</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"我正在学Python\"</span>)</span><br><span class=\"line\">clangs = CLanguage()</span><br><span class=\"line\"><span class=\"keyword\">if</span> hasattr(clangs,<span class=\"string\">\"name\"</span>):</span><br><span class=\"line\">    print(hasattr(clangs.name,<span class=\"string\">\"__call__\"</span>))</span><br><span class=\"line\">print(<span class=\"string\">\"**********\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> hasattr(clangs,<span class=\"string\">\"say\"</span>):</span><br><span class=\"line\">    print(hasattr(clangs.say,<span class=\"string\">\"__call__\"</span>))</span><br><span class=\"line\">执行结果：</span><br><span class=\"line\">    <span class=\"literal\">False</span>  </span><br><span class=\"line\">    *********</span><br><span class=\"line\">    <span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"comment\"># 由于name是类属性，它没有以__call__为名的__call__()方法；而 say是类方法，它是可调用对象，因此它有__call__()方法。</span></span><br></pre></td></tr></table></figure><h1 id=\"运算符重载\"><a class=\"markdownIt-Anchor\" href=\"#运算符重载\"></a> 运算符重载</h1><p>Python 类支持对哪些方法进行重载呢？，列出了 Python 中常用的可重载的运算符，以及各自的含义。</p><table><thead><tr><th>重载运算符</th><th>含义</th></tr></thead><tbody><tr><td><strong>new</strong></td><td>创建类，在 <strong>init</strong> 之前创建对象</td></tr><tr><td><strong>init</strong></td><td>类的构造函数，其功能是创建类对象时做初始化工作。</td></tr><tr><td><strong>del</strong></td><td>析构函数，其功能是销毁对象时进行回收资源的操作</td></tr><tr><td><strong>add</strong></td><td>加法运算符 +，当类对象 X 做例如 X+Y 或者 X+=Y 等操作，内部会调用此方法。但如果类中对 <strong>iadd</strong> 方法进行了重载，则类对象 X 在做 X+=Y 类似操作时，会优先选择调用 <strong>iadd</strong> 方法。</td></tr><tr><td><strong>radd</strong></td><td>当类对象 X 做类似 Y+X 的运算时，会调用此方法。</td></tr><tr><td><strong>iadd</strong></td><td>重载 += 运算符，也就是说，当类对象 X 做类似 X+=Y 的操作时，会调用此方法。</td></tr><tr><td><strong>or</strong></td><td>“或”运算符</td></tr><tr><td><strong>repr</strong>，<strong>str</strong></td><td>格式转换方法，分别对应函数 repr(X)、str(X)</td></tr><tr><td><strong>call</strong></td><td>函数调用，类似于 X(*args, **kwargs) 语句</td></tr><tr><td><strong>getattr</strong></td><td>点号运算，用来获取类属性</td></tr><tr><td><strong>setattr</strong></td><td>属性赋值语句，类似于 X.any=value</td></tr><tr><td><strong>delattr</strong></td><td>删除属性，类似于 del X.any</td></tr><tr><td><strong>getattribute</strong></td><td>获取属性，类似于 X.any</td></tr><tr><td><strong>getitem</strong></td><td>索引运算，类似于 X[key]，X[i:j]</td></tr><tr><td><strong>setitem</strong></td><td>索引赋值语句，类似于 X[key], X[i:j]=sequence</td></tr><tr><td><strong>delitem</strong></td><td>索引和分片删除</td></tr><tr><td><strong>get</strong>, <strong>set</strong>, <strong>delete</strong></td><td>描述符属性，类似于 X.attr，X.attr=value，del X.attr</td></tr><tr><td><strong>len</strong></td><td>计算长度，类似于 len(X)</td></tr><tr><td><strong>lt</strong>，<strong>gt</strong>，<strong>le</strong>，<strong>ge</strong>，<strong>eq</strong>，<strong>ne</strong></td><td>比较，分别对应于 &lt;、&gt;、&lt;=、&gt;=、=、!= 运算符。</td></tr><tr><td><strong>iter</strong>，<strong>next</strong></td><td>迭代环境下，生成迭代器与取下一条，类似于 I=iter(X) 和 next()</td></tr><tr><td><strong>contains</strong></td><td>成员关系测试，类似于 item in X</td></tr><tr><td><strong>index</strong></td><td>整数值，类似于 hex(X)，bin(X)，oct(X)</td></tr><tr><td><strong>enter</strong>，<strong>exit</strong></td><td>在对类对象执行类似 with obj as var 的操作之前，会先调用 <strong>enter</strong> 方法，其结果会传给 var；在最终结束该操作之前，会调用</td></tr></tbody></table><h1 id=\"python迭代器\"><a class=\"markdownIt-Anchor\" href=\"#python迭代器\"></a> Python迭代器</h1><p>迭代器指的就是支持迭代的容器，更确切的说，是支持迭代的容器类对象，这里的容器可以是列表、元组等这些 Python 提供的基础容器，也可以是自定义的容器类对象，只要该容器支持迭代即可。自定义实现一个迭代器，则类中必须实现如下2个方法：</p><ul><li><strong>next</strong>(self)：返回容器的下一个元素。</li><li><strong>iter</strong>(self)：该方法返回一个迭代器（iterator）。</li></ul><p>Python 内置的 iter() 函数也会返回一个迭代器，该函数的语法格式如下：</p><blockquote><p>iter(obj[, sentinel])</p></blockquote><p>其中，obj 必须是一个可迭代的容器对象，而 sentinel 作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象。</p><blockquote><p>可调用对象，指的是该类的实例对象可以像函数那样，直接以“对象名()”的形式被使用。通过在类中添加 <strong>call</strong>() 方法，就可以将该类的实例对象编程可调用对象。</p></blockquote><p>1个参数的 iter()函数，通过传入一个可迭代的容器对象，我们可以获得一个迭代器，通过调用该迭代器中的__next__()方法即可实现迭代，使用next()内置函数来迭代，即next(myIter)，和__next__()方法是完全一样的。</p><p>iter()函数第2个参数的作用，如果使用该参数，则要求第一个obj参数必须传入可调用对象（可以不支持迭代），这样当使用返回的迭代器调用__next__()方法时，它会通过执行obj()调用 <strong>call</strong>()方法，如果该方法的返回值和第 2 个参数值相同，则输出 StopInteration 异常；反之，则输出 <strong>call</strong>() 方法的返回值。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 迭代器实现字符串逆序</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Reverse</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, string)</span>:</span></span><br><span class=\"line\">        self.__string = string</span><br><span class=\"line\">        self.__index = len(string)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__iter__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__next__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.__index == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span>(StopIteration)</span><br><span class=\"line\">        self.__index -= <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.__string[self.__index]</span><br><span class=\"line\">revstr = Reverse(<span class=\"string\">'Python'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> revstr:</span><br><span class=\"line\">    print(c,end=<span class=\"string\">\" \"</span>)</span><br></pre></td></tr></table></figure><h1 id=\"生成器\"><a class=\"markdownIt-Anchor\" href=\"#生成器\"></a> 生成器</h1><p>生成器的创建方式也比迭代器简单很多，大体分为以下 2 步：</p><ul><li>定义一个以 yield 关键字标识返回值的函数；</li><li>调用刚刚创建的函数，即可创建一个生成器。</li></ul><p>和return相比，yield 除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。不仅如此，即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。</p><blockquote><p>相比迭代器，生成器最明显的优势就是节省内存空间，即它不会一次性生成所有的数据，而是什么时候需要，什么时候生成。</p></blockquote><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">intNum</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"开始执行\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> i</span><br><span class=\"line\">        print(<span class=\"string\">\"继续执行\"</span>)</span><br><span class=\"line\">num = intNum()</span><br></pre></td></tr></table></figure><p>即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。想要生成器函数执行，或者想使执行完 yield 语句立即暂停的程序得以继续执行，可以通过：</p><ul><li>通过生成器调用next()内置函数或者__next__()方法</li><li>通过for循环遍历生成器</li></ul><h2 id=\"生成器send方法\"><a class=\"markdownIt-Anchor\" href=\"#生成器send方法\"></a> 生成器send()方法</h2><p>通过 send() 方法，还可以向生成器中传值。</p><p>值得一提的是，send()方法可带一个参数，也可以不带任何参数（用 None 表示）。其中，当使用不带参数的send()方法时，它和next()函数的功能完全相同。例如：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ddef foo():</span><br><span class=\"line\">    bar_a = <span class=\"keyword\">yield</span> <span class=\"string\">\"hello\"</span></span><br><span class=\"line\">    bar_b = <span class=\"keyword\">yield</span> bar_a</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> bar_b</span><br><span class=\"line\">f = foo()</span><br><span class=\"line\">print(f.send(<span class=\"literal\">None</span>))</span><br><span class=\"line\">print(f.send(<span class=\"string\">\"C语言中文网\"</span>))</span><br><span class=\"line\">print(f.send(<span class=\"string\">\"http://c.biancheng.net\"</span>))</span><br><span class=\"line\"><span class=\"comment\">#hello</span></span><br><span class=\"line\"><span class=\"comment\">#C语言中文网</span></span><br><span class=\"line\"><span class=\"comment\">#http://c.biancheng.net</span></span><br></pre></td></tr></table></figure><h2 id=\"close方法\"><a class=\"markdownIt-Anchor\" href=\"#close方法\"></a> close()方法</h2><p>生成器函数中遇到yield语句暂停运行时，此时如果调用 close()方法，会阻止生成器函数继续执行，该函数会在程序停止运行的位置抛出 GeneratorExit 异常。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> GeneratorExit:</span><br><span class=\"line\">        print(<span class=\"string\">'捕获到 GeneratorExit'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"number\">2</span> <span class=\"comment\">#抛出 RuntimeError 异常</span></span><br><span class=\"line\">f = foo()</span><br><span class=\"line\">print(next(f))</span><br><span class=\"line\">f.close()</span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">1</span></span><br><span class=\"line\"><span class=\"string\">捕获到 GeneratorExit Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"string\">  File \"D:\\python3.6\\1.py\", line 10, in &lt;module&gt;</span></span><br><span class=\"line\"><span class=\"string\">    f.close()</span></span><br><span class=\"line\"><span class=\"string\">RuntimeError: generator ignored GeneratorExit</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure><h2 id=\"生成器throw方法\"><a class=\"markdownIt-Anchor\" href=\"#生成器throw方法\"></a> 生成器throw()方法</h2><p>生成器 throw() 方法的功能是，在生成器函数执行暂停处，抛出一个指定的异常，之后程序会继续执行生成器函数中后续的代码，直到遇到下一个yield语句。需要注意的是，如果到剩余代码执行完毕没有遇到下一个yield语句，则程序会抛出 StopIteration异常。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">yield</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> ValueError:</span><br><span class=\"line\">        print(<span class=\"string\">'捕获到 ValueError'</span>)</span><br><span class=\"line\">f = foo()</span><br><span class=\"line\">print(next(f))</span><br><span class=\"line\">f.throw(ValueError)</span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">运行结果：1</span></span><br><span class=\"line\"><span class=\"string\">捕获到 ValueError</span></span><br><span class=\"line\"><span class=\"string\">Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"string\">  File \"D:\\python3.6\\1.py\", line 9, in &lt;module&gt;</span></span><br><span class=\"line\"><span class=\"string\">    f.throw(ValueError)</span></span><br><span class=\"line\"><span class=\"string\">StopIteration</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure><p>一开始生成器函数在yield 1处暂停执行，当执行throw()方法时，它会先抛出 ValueError异常，然后继续执行后续代码找到下一个 yield语句，该程序中由于后续不再有yield语句，因此程序执行到最后，会抛出一个 StopIteration异常。</p><h1 id=\"函数装饰器及用法\"><a class=\"markdownIt-Anchor\" href=\"#函数装饰器及用法\"></a> 函数装饰器及用法</h1><p>Python 内置的 3 种函数装饰器，分别是 ＠staticmethod、＠classmethod 和 @property，其中 staticmethod()、classmethod()和 property()都是Python的内置函数。<br>使用函数装饰器A()去装饰另一个函数B()，其底层执行了如下2步操作：</p><ul><li>将B作为参数传给A()函数；</li><li>将A()函数执行完成的返回值反馈回B。</li></ul><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">funA</span><span class=\"params\">(fn)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"C语言中文网\"</span>)</span><br><span class=\"line\">    fn() <span class=\"comment\"># 执行传入的fn参数</span></span><br><span class=\"line\">    print(<span class=\"string\">\"http://c.biancheng.net\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"装饰器函数的返回值\"</span></span><br><span class=\"line\"><span class=\"meta\">@funA</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">funB</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"学习 Python\"</span>)</span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">C语言中文网</span></span><br><span class=\"line\"><span class=\"string\">学习 Python</span></span><br><span class=\"line\"><span class=\"string\">http://c.biancheng.net</span></span><br><span class=\"line\"><span class=\"string\">在此基础上，如果在程序末尾添加如下语句：</span></span><br><span class=\"line\"><span class=\"string\">print(funB)</span></span><br><span class=\"line\"><span class=\"string\">其输出结果为：</span></span><br><span class=\"line\"><span class=\"string\">装饰器函数的返回值</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure><p>如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名；同样，如果装饰器返回的是一个函数的名称，怎么被修饰的函数名依然表示一个函数。</p><blockquote><p>函数装饰器，就是通过装饰器函数，在不修改原函数的前提下，来对函数的功能进行合理的扩充。</p></blockquote><h2 id=\"带参数的函数装饰器\"><a class=\"markdownIt-Anchor\" href=\"#带参数的函数装饰器\"></a> 带参数的函数装饰器</h2><p>函数装饰器中嵌套一个函数，该函数带有的参数个数和被装饰器修饰的函数相同。例如：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">funA</span><span class=\"params\">(fn)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义一个嵌套函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">say</span><span class=\"params\">(arc)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">\"Python教程:\"</span>,arc)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> say</span><br><span class=\"line\"><span class=\"meta\">@funA</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">funB</span><span class=\"params\">(arc)</span>:</span></span><br><span class=\"line\">    print(<span class=\"string\">\"funB():\"</span>, a)</span><br><span class=\"line\">funB(<span class=\"string\">\"http://c.biancheng.net/python\"</span>)</span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">程序执行结果为：</span></span><br><span class=\"line\"><span class=\"string\">Python教程: http://c.biancheng.net/python</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br></pre></td></tr></table></figure><h2 id=\"函数装饰器嵌套\"><a class=\"markdownIt-Anchor\" href=\"#函数装饰器嵌套\"></a> 函数装饰器嵌套</h2><p>上面程序的执行顺序是里到外，所以它等效于下面这行代码：</p><blockquote><p>fun = funA( funB ( funC (fun) ) )</p></blockquote><h1 id=\"装饰器的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#装饰器的应用场景\"></a> 装饰器的应用场景</h1><h2 id=\"身份认证\"><a class=\"markdownIt-Anchor\" href=\"#身份认证\"></a> 身份认证</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">authenticate</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        request = args[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"comment\"># 如果用户处于登录状态</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> check_user_logged_in(request):</span><br><span class=\"line\">            <span class=\"comment\"># 执行函数 post_comment()</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kwargs)  </span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> Exception(<span class=\"string\">'Authentication failed'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">@authenticate</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">post_comment</span><span class=\"params\">(request, ...)</span></span></span><br><span class=\"line\"><span class=\"function\">    ...</span></span><br></pre></td></tr></table></figure><p>定义了装饰器 authenticate，函数 post_comment() 则表示发表用户对某篇文章的评论，每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。</p><h2 id=\"日志记录\"><a class=\"markdownIt-Anchor\" href=\"#日志记录\"></a> 日志记录</h2><p>日志记录同样是很常见的一个案例。在实际工作中，如果你怀疑某些函数的耗时过长，导致整个系统的延迟增加，想在线上测试某些函数的执行时间，那么，装饰器就是一种很常用的手段。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log_execution_time</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        start = time.perf_counter()</span><br><span class=\"line\">        res = func(*args, **kwargs)</span><br><span class=\"line\">        print(<span class=\"string\">'&#123;&#125; took &#123;&#125; ms'</span>.format(func.__name__, (end - start) * <span class=\"number\">1000</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"meta\">@log_execution_time</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calculate_similarity</span><span class=\"params\">(items)</span>:</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure><p>装饰器 log_execution_time 记录某个函数的运行时间，并返回其执行结果。如果你想计算任何函数的执行时间，在这个函数上方加上@log_execution_time即可。</p><h2 id=\"装饰器用于输入合理性检查\"><a class=\"markdownIt-Anchor\" href=\"#装饰器用于输入合理性检查\"></a> 装饰器用于输入合理性检查</h2><p>在大型公司的机器学习框架中，调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检查。这样就可以大大避免输入不正确对机器造成的巨大开销。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">validation_check</span><span class=\"params\">(input)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        ...</span><br><span class=\"line\"><span class=\"meta\">@validation_check</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">neural_network_training</span><span class=\"params\">(param1, param2,...)</span></span></span><br></pre></td></tr></table></figure><p>很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现。</p><h2 id=\"缓存装饰器\"><a class=\"markdownIt-Anchor\" href=\"#缓存装饰器\"></a> 缓存装饰器</h2><p>ython 中的表示形式是 @lru_cache。@lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除最近最久未使用的数据。正确使用缓存装饰器，往往能极大地提高程序运行效率。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@lru_cache</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">check</span><span class=\"params\">(param1, param2, ...)</span>  # 检查用户设备类型、版本号</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->","categories":[{"name":"计算机基础","path":"api/categories/计算机基础.json"},{"name":"Python","path":"api/categories/Python.json"}],"tags":[{"name":"Python","path":"api/tags/Python.json"}]}