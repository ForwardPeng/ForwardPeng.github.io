{"title":"单例模式","slug":"单例模式","date":"2020-05-10T08:55:42.000Z","updated":"2020-05-11T04:05:23.783Z","comments":true,"path":"api/articles/单例模式.json","excerpt":null,"covers":["/image/Singleton.png"],"content":"<!-- build time:Mon May 11 2020 23:59:11 GMT+0800 (GMT+08:00) --><h1 id=\"单例模式的定义与特点\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的定义与特点\"></a> 单例模式的定义与特点</h1><p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p><p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。单例模式有 3 个特点：</p><ul><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点；</li></ul><h1 id=\"单例模式的结构和实现\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的结构和实现\"></a> 单例模式的结构和实现</h1><p>单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p><h2 id=\"单例模式的结构\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的结构\"></a> 单例模式的结构</h2><ul><li>单例类：包含一个实例且能自行创建这个实例的类</li><li>访问类：使用单例的类</li></ul><p>结构如图所示：</p><div align=\"center\"><img src=\"/image/Singleton.png\" width=\"400\"></div><center>图1 单例模式的结构图</center><h2 id=\"单例模式的实现\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的实现\"></a> 单例模式的实现</h2><p><strong>1.懒汉式单例</strong></p><p>该模式的特点是类加载时没有生成单例，只有当一次调用get_instance方法时才创建这个单例，代码实现如下：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    __instance = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.__instance:</span><br><span class=\"line\">            print(<span class=\"string\">\"调用__init__, 实例未创建\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">\"调用__init__，实例已经创建：\"</span>, __instance)</span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_instance</span><span class=\"params\">(cls)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cls.__instance:</span><br><span class=\"line\">            cls.__instance = Singleton()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls.__instance</span><br></pre></td></tr></table></figure><blockquote><p>优点：资源利用合理，不调用get_instance方法不创建单例对象。缺点：线程不安全，多线程时可能会获取到不同单例对象的情况。解决办法是加互斥锁，但会降低效率<br>线程安全的单例</p></blockquote><p><strong>2.饿汉式单例</strong></p><p>该模式的特点是类一旦加载就创建一个单例，保证在调用getinstance方法之前单例已经存在了，实现代码如下：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> hasattr(cls, <span class=\"string\">'instance'</span>):</span><br><span class=\"line\">            cls.instance = super(Singleton, cls).__new__(cls)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls.instance</span><br></pre></td></tr></table></figure><blockquote><p>优点：线程安全；在类实例化前创建好一个静态对象，调用时反应速度快；直接执行其他方法和静态方法，单例实例不会初始化。缺点：不管使用与否，实例化前就初始化静态对象，资源浪费</p></blockquote><p><strong>3.线程安全的单例</strong></p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">synchronized</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    func.__lock__ = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lock_func</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> func.__lock__:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lock_func</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    instance = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @synchronized</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, *args, **kwargs)</span>:</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> cls.instance <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">           cls.instance = super().__new__(cls)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls.instance</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        self.a = num + <span class=\"number\">5</span></span><br></pre></td></tr></table></figure><h1 id=\"单例模式的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的应用场景\"></a> 单例模式的应用场景</h1><p>前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。</p><ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li><li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul><!-- rebuild by neat -->","more":"<!-- build time:Mon May 11 2020 23:59:11 GMT+0800 (GMT+08:00) --><h1 id=\"单例模式的定义与特点\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的定义与特点\"></a> 单例模式的定义与特点</h1><p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p><p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。单例模式有 3 个特点：</p><ul><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点；</li></ul><h1 id=\"单例模式的结构和实现\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的结构和实现\"></a> 单例模式的结构和实现</h1><p>单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p><h2 id=\"单例模式的结构\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的结构\"></a> 单例模式的结构</h2><ul><li>单例类：包含一个实例且能自行创建这个实例的类</li><li>访问类：使用单例的类</li></ul><p>结构如图所示：</p><div align=\"center\"><img src=\"/image/Singleton.png\" width=\"400\"></div><center>图1 单例模式的结构图</center><h2 id=\"单例模式的实现\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的实现\"></a> 单例模式的实现</h2><p><strong>1.懒汉式单例</strong></p><p>该模式的特点是类加载时没有生成单例，只有当一次调用get_instance方法时才创建这个单例，代码实现如下：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    __instance = <span class=\"literal\">None</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.__instance:</span><br><span class=\"line\">            print(<span class=\"string\">\"调用__init__, 实例未创建\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            print(<span class=\"string\">\"调用__init__，实例已经创建：\"</span>, __instance)</span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_instance</span><span class=\"params\">(cls)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> cls.__instance:</span><br><span class=\"line\">            cls.__instance = Singleton()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls.__instance</span><br></pre></td></tr></table></figure><blockquote><p>优点：资源利用合理，不调用get_instance方法不创建单例对象。缺点：线程不安全，多线程时可能会获取到不同单例对象的情况。解决办法是加互斥锁，但会降低效率<br>线程安全的单例</p></blockquote><p><strong>2.饿汉式单例</strong></p><p>该模式的特点是类一旦加载就创建一个单例，保证在调用getinstance方法之前单例已经存在了，实现代码如下：</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> hasattr(cls, <span class=\"string\">'instance'</span>):</span><br><span class=\"line\">            cls.instance = super(Singleton, cls).__new__(cls)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls.instance</span><br></pre></td></tr></table></figure><blockquote><p>优点：线程安全；在类实例化前创建好一个静态对象，调用时反应速度快；直接执行其他方法和静态方法，单例实例不会初始化。缺点：不管使用与否，实例化前就初始化静态对象，资源浪费</p></blockquote><p><strong>3.线程安全的单例</strong></p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">synchronized</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">    func.__lock__ = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lock_func</span><span class=\"params\">(*args, **kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">with</span> func.__lock__:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lock_func</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    instance = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @synchronized</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, *args, **kwargs)</span>:</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> cls.instance <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">           cls.instance = super().__new__(cls)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls.instance</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, num)</span>:</span></span><br><span class=\"line\">        self.a = num + <span class=\"number\">5</span></span><br></pre></td></tr></table></figure><h1 id=\"单例模式的应用场景\"><a class=\"markdownIt-Anchor\" href=\"#单例模式的应用场景\"></a> 单例模式的应用场景</h1><p>前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。</p><ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li><li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul><!-- rebuild by neat -->","categories":[{"name":"设计模式","path":"api/categories/设计模式.json"}],"tags":[{"name":"设计模式","path":"api/tags/设计模式.json"}]}