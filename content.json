{"meta":{"title":"Hello World","subtitle":"","description":"","author":"John Doe","url":"http://forwardpeng.github.io","root":"/"},"pages":[{"title":"书单","date":"2020-04-15T07:51:11.956Z","updated":"2020-04-15T07:51:11.956Z","comments":false,"path":"books/index.html","permalink":"http://forwardpeng.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-15T13:50:22.000Z","updated":"2020-04-16T01:51:00.843Z","comments":true,"path":"categories/index.html","permalink":"http://forwardpeng.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-15T07:51:41.545Z","updated":"2020-04-15T07:51:41.545Z","comments":true,"path":"links/index.html","permalink":"http://forwardpeng.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-04-15T07:50:12.856Z","updated":"2020-04-15T07:50:12.856Z","comments":false,"path":"repository/index.html","permalink":"http://forwardpeng.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-15T14:11:14.000Z","updated":"2020-04-16T01:53:51.407Z","comments":true,"path":"tags/index.html","permalink":"http://forwardpeng.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"动态内存管理","slug":"动态内存管理","date":"2020-04-23T08:08:46.000Z","updated":"2020-04-24T07:56:30.459Z","comments":true,"path":"2020/04/23/动态内存管理/","link":"","permalink":"http://forwardpeng.github.io/2020/04/23/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"动态内存管理机制 占用块和空闲块对于计算机中的内存来说，称已经分配给用户的的内存区统称为“占用块”；还未分配出去的内存区统称为“空闲块”或者“可利用空间块”。 系统的内存管理对于初始状态下的内存来说，整个空间都是一个空闲块（在编译程序中称为“堆”）。但是随着不同的用户不断地提出存储请求，系统依次分配。整个内存区就会分割成两个大部分：低地址区域会产生很多占用块；高地址区域还是空闲块。图1 动态分配过程中的内存状态当某些用户运行结束，所占用的内存区域就变成了空闲块，如图2：图2 动态分配过程中的内存变化时，就形成了占用块和空闲块犬牙交错的状态。当后续用户请求分配内存时，系统有两种分配方式：系统继续利用高地址区域的连续空闲块分配给用户，不去理会之前分配给用户的内存区域的状态。直到分配无法进行，也就是高地址的空闲块不能满足用户的需求时，系统才会去回收之前的空闲块，重新组织继续分配；当用户运行一结束，系统马上将其所占空间进行回收。当有新的用户请求分配内存时，系统遍历所有的空闲块，从中找出一个合适的空闲块分配给用户。 可利用空间表系统需要建立一张记录所有空闲块信息的表。表的形式有两种：目录表和链表。各自的结构如图3所示：图3 目录表和链表目录表：表中每一行代表一个空闲块，由三部分组成：初始地址：记录每个空闲块的起始地址。空闲块大小：记录每个空闲块的内存大小。使用情况：记录每个空闲块是否存储被占用的状态。链表：表中每个结点代表一个空闲块，每个结点中需要记录空闲块的使用情况、大小和连接下一个空闲块的指针域。由于链表中有指针的存在，所以结点中不需要记录各内存块的起始地址。存储空闲块的可利用空间表有以下不同的结构：如果每次用户请求的存储空间大小相同，对于此类系统中的内存来说，在用户运行初期就将整个内存存储块按照所需大小进行分割，然后通过链表链接。当用户申请空间时，从链表中摘除一个结点归其使用；用完后再链接到可利用空间表上。每次如果用户申请的都是若干种大小规格的存储空间，针对这种情况可以建立若干个可利用空间表，每一个链表中的结点大小相同。当用户申请某一规格大小的存储空间时，就从对应的链表中摘除一个结点供其使用；用完后链接到相同规格大小的链表中。用户申请的内存的大小不固定，所以造成系统分配的内存块的大小也不确定，回收时，链接到可利用空间表中每个结点的大小也各不一样。第 2 种情况下容易面临的问题是：如果同用户申请空间大小相同的链表中没有结点时，就需要找结点更大的链表，从中取出一个结点，一部分给用户使用，剩余部分插入到相应大小的链表中；回收时，将释放的空闲块插入到大小相同的链表中去。如果没有比用户申请的内存空间相等甚至更大的结点时，就需要系统重新组织一些小的连续空间，然后给用户使用。 分配存储空间的方式通常情况下系统中的可利用空间表是第 3 种情况。如图 3© 所示。由于链表中各结点的大小不一，在用户申请内存空间时，就需要从可利用空间表中找出一个合适的结点，有三种查找的方法：首次拟合法：在可利用空间表中从头开始依次遍历，将找到的第一个内存不小于用户申请空间的结点分配给用户，剩余空间仍留在链表中；回收时只要将释放的空闲块插入在链表的表头即可。最佳拟合法：和首次拟合法不同，最佳拟合法是选择一块内存空间不小于用户申请空间，但是却最接近的一个结点分配给用户。为了实现这个方法，首先要将链表中的各个结点按照存储空间的大小进行从小到大排序，由此，在遍历的过程中只需要找到第一块大于用户申请空间的结点即可进行分配；用户运行完成后，需要将空闲块根据其自身的大小插入到链表的相应位置。最差拟合法：和最佳拟合法正好相反，该方法是在不小于用户申请空间的所有结点中，筛选出存储空间最大的结点，从该结点的内存空间中提取出相应的空间给用户使用。为了实现这一方法，可以在开始前先将可利用空间表中的结点按照存储空间大小从大到小进行排序，第一个结点自然就是最大的结点。回收空间时，同样将释放的空闲块插入到相应的位置上。以上三种方法各有所长：最佳拟合法由于每次分配相差不大的结点给用户使用，所以会生成很多存储空间特别小的结点，以至于根本无法使用，使用过程中，链表中的结点存储大小发生两极分化，大的很大，小的很小。该方法适用于申请内存大小范围较广的系统最差拟合法，由于每次都是从存储空间最大的结点中分配给用户空间，所以链表中的结点大小不会起伏太大。依次适用于申请分配内存空间较窄的系统。首次拟合法每次都是随机分配。在不清楚用户申请空间大小的情况下，使用该方法分配空间。 边界标识法管理动态内存使用边界标识法的系统管理内存时，可利用空间表中的结点的构成如图 4：图4 结构构成每个结点中包含3个区域，head域、foot域和space域：space域表示为该内存块的大小，它的大小通过head域中的size值表示。head域中包含有4部分：llink 和rlink分别表示指向当前内存块结点的直接前驱和直接后继。tag值用于标记当前内存块的状态，是占用块（用 1 表示）还是空闲块（用 0 表示）。size用于记录该内存块的存储大小。foot域中包含有2部分：uplink 是指针域，用于指向内存块本身，通过uplink就可以获取该内存块所在内存的首地址。tag同head域中的tag相同，都是记录内存块状态的。注意：head域和foot域在本节中都假设只占用当前存储块的1个存储单位的空间，对于该结点整个存储空间来说，可以忽略不计。也就是说，在可利用空间表中，知道下一个结点的首地址，该值减1就可以找到当前结点的foot域。边界标识法管理的内存块结点代码：12345678910typedef struct WORD&#123; union&#123; struct WORD *llink;//指向直接前驱 struct WORD *uplink;//指向结点本身 &#125;; int tag;//标记域,0表示为空闲块；1表示为占用块 int size;//记录内存块的存储大小 struct WORD *rlink;//指向直接后继 OtherType other;//内存块可能包含的其它的部分&#125;WORD,head,foot,*Space; 分配算法3 种分配方法分别为：首部拟合法、最佳拟合法和最差拟合法。选定一个常量e，每次分配空间时，判断当前内存块向用户分配空间后，如果剩余部分的容量比e小，则将整个内存块全部分配给用户。采用头部拟合法进行分配时，如果每次都从pav指向的结点开始遍历，在若干次后，会出现存储量小的结点密集地分布在pav结点附近的情况，严重影响遍历的时间。解决办法就是：在每次分配空间后，让pav指针指向该分配空间结点的后继结点，然后从新的pav指向的结点开始下一次的分配。首部拟合法具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Space AllocBoundTag(Space *pav, int n)&#123; Space p, f; int e = 10; //设定常亮 e 的值 //如果在遍历过程，当前空闲块的在存储容量比用户申请空间 n 值小，在该空闲块有右孩子的情况下直接跳过 for (p = (*pav); p &amp;&amp; p-&gt;size &lt; n &amp;&amp; p-&gt;rlink != (*pav); p = p-&gt;rlink) ; //跳出循环，首先排除p为空和p指向的空闲块容量小于 n 的情况 if (!p || p-&gt;size &lt; n) &#123; return NULL; &#125; else &#123; //指针f指向p空闲块的foot域 f = FootLoc(p); //调整pav指针的位置，为下次分配做准备 (*pav) = p-&gt;rlink; //如果该空闲块的存储大小比 n 大，比 n+e 小，负责第一种情况，将 p 指向的空闲块全部分配给用户 if (p-&gt;size - n &lt;= e) &#123; if ((*pav) == p) &#123; pav = NULL; &#125; else &#123; //全部分配用户，即从可利用空间表中删除 p 空闲块 (*pav)-&gt;llink = p-&gt;llink; p-&gt;llink-&gt;rlink = (*pav); &#125; //同时调整head域和foot域中的tag值 p-&gt;tag = f-&gt;tag = 1; &#125; //否则，从p空闲块中拿出 大小为 n 的连续空间分配给用户，同时更新p剩余存储块中的信息。 else &#123; //更改分配块foot域的信息 f-&gt;tag = 1; p-&gt;size -= n; //f指针指向剩余空闲块 p 的底部 f = FootLoc(p); f-&gt;tag = 0; f-&gt;uplink = p; p = f + 1; //p指向的是分配给用户的块的head域，也就是该块的首地址 p-&gt;tag = 1; p-&gt;size = n; &#125; return p; &#125;&#125; 回收算法系统需要立即回收被用户占用的存储空间，以备新的用户使用。回收算法中需要解决的问题是：在若干次分配操作后，可利用空间块中会产生很多存储空间很小以致无法使用的空闲块。但是经过回收用户释放的空间后，可利用空间表中可能含有地址相邻的空闲块，回收算法需要将这些地址相邻的空闲块合并为大的空闲块供新的用户使用。合并空闲块有3种情况：该空闲块的左边有相邻的空闲块可以进行合并；该空闲块的右边用相邻的空闲块可以进行合并；该空闲块的左右两侧都有相邻的空闲块可以进行合并；判断当前空闲块左右两侧是否为空闲块的方法是：对于当前空闲块p ，p-1 就是相邻的低地址处的空闲块的foot域，如果foot域中的tag值为0 ，表明其为空闲块； p+p-&gt;size 表示的是高地址处的块的head域，如果head域中的tag值为 0，表明其为空闲块。如果当前空闲块的左右两侧都不是空闲块，而是占用块，此种情况下只需要将新的空闲块按照相应的规则（头部拟合法随意插入，其它两种方法在对应位置插入）插入到可利用空间表中即可。实现代码为：1234567891011121314151617//设定p指针指向的为用户释放的空闲块p-&gt;tag=0;//f指针指向p空闲块的foot域Space f=FootLoc(p);f-&gt;uplink=p;f-&gt;tag=0;//如果pav指针不存在，证明可利用空间表为空，此时设置p为头指针，并重新建立双向循环链表if (!pav) &#123; pav=p-&gt;llink=p-&gt;rlink=p;&#125;else&#123; //否则，在p空闲块插入到pav指向的空闲块的左侧 Space q=pav-&gt;llink; p-&gt;rlink=pav; p-&gt;llink=q; q-&gt;rlink=pav-&gt;llink=p; pav=p;&#125;该空闲块的左侧相邻的块为空闲块，右侧为占用块，处理的方法是：只需要更改左侧空闲块中的size的大小，并重新设置左侧空闲块的foot 域即可（如图2）。图5 空闲块合并（当前块，左侧内存块）实现代码：1234567//常量 n 表示当前空闲块的存储大小int n=p-&gt;size;Space s=(p-1)-&gt;uplink;//p-1 为当前块的左侧块的foot域，foot域中的uplink指向的就是左侧块的首地址，s指针代表的是当前块的左侧存储块s-&gt;size+=n;//设置左侧存储块的存储容量Space f=p+n-1;//f指针指向的是空闲块 p 的foot域f-&gt;uplink=s;//这是foot域的uplink指针重新指向合并后的存储空间的首地址f-&gt;tag=0;//设置foot域的tag标记为空闲块如果当前用户释放掉的空闲块，物理位置上相邻的左右两侧的内存块全部为空闲块，需要将 3 个空闲块合并为一个更大的块，操作的过程为：更新左侧空闲块的 size 的值，同时在可利用空间表中摘除右侧空闲块，最后更新合并后的大的空闲块的 foot域123456789101112 int n=p-&gt;size;Space s=(p-1)-&gt;uplink;//找到释放内存块物理位置相邻的低地址的空闲块Space t=p+p-&gt;size;//找到物理位置相邻的高地址处的空闲块s-&gt;size+=n+t-&gt;size;//更新左侧空闲块的size的值//从可利用空间表中摘除右侧空闲块Space q=t-&gt;llink;Space q1=t-&gt;rlink;q-&gt;rlink=q1;q1-&gt;llink=q;//更新合并后的空闲块的uplink指针的指向Space f=FootLoc(t);f-&gt;uplink=s; 伙伴系统管理动态内存伙伴系统本身是一种动态管理内存的方法，和边界标识法的区别是：使用伙伴系统管理的存储空间，无论是空闲块还是占用块，大小都是 2 的 n 次幂（n 为正整数）。例如，系统中整个存储空间为 2m 个字。那么在进行若干次分配与回收后，可利用空间表中只可能包含空间大小为：20、21、22、…、2m 的空闲块。字是一种计量单位，由若干个字节构成，不同位数的机器，字所包含的字节数不同。例如，8 位机中一个字由 1 个字节组成；16 位机器一个字由 2 个字节组成。 可利用空间表中结点构成图6 结点构成header 域表示为头部结点，由 4 部分构成：llink 和 rlink 为结点类型的指针域，分别用于指向直接前驱和直接后继结点。tag 值：用于标记内存块的状态，是占用块（用 1 表示）还是空闲块（用 0 表示）kval：记录该存储块的容量。由于系统中各存储块都是2的m幂次方，所以kval记录m的值。12345678typedef struct WORD_b&#123; struct WORD_b *llink;//指向直接前驱 int tag;//记录该块是占用块还是空闲块 int kval;//记录该存储块容量大小为2的多少次幂 struct WORD_b *rlink;//指向直接后继 OtherType other;//记录结点的其它信息&#125;WORD_b,head;在伙伴系统中，由于系统会不断地接受用户的内存申请的请求，所以会产生很多大小不同但是都是容量为2m2^{m}2m的内存块，所以为了在分配的时候查找方便，系统采用将大小相同的各自建立一个链表。对于初始容量为 2m2^{m}2m的一整块存储空间来说，形成的链表就有可能有m+1个，为了更好的对这些链表进行管理，系统将这m+1个链表的表头存储在数组中，就类似于邻接表的结构，如图7。图7 伙伴系统的初始状态可利用空间表的代码表示为：12345#define m 16//设定m的初始值typedef struct HeadNode &#123; int nodesize;//记录该链表中存储的空闲块的大小 WORD_b * first;//相当于链表中的next指针的作用&#125;FreeList[m+1];//一维数组 分配算法伙伴系统的分配算法很简单。假设用户向系统申请大小为 n 的存储空间，若2k−1&lt;n&lt;=2k2^{k-1} &lt; n &lt;= 2^{k}2k−1&lt;n&lt;=2k，此时就需要查看可利用空间表中大小为2k2^{k}2k 的链表中有没有可利用的空间结点：如果该链表不为NULL，可以直接采用头插法从头部取出一个结点，提供给用户使用；如果大小为2k2^{k}2k的链表为 NULL，就需要依次查看比2k2^{k}2k大的链表，找到后从链表中删除，截取相应大小的空间给用户使用，剩余的空间，根据大小插入到相应的链表中。用户向系统申请一块大小为7个字的空间，而系统总的内存为242^{4}24个字,按照伙伴系统的分配算法得出：22&lt;7&lt;232^{2} &lt; 7 &lt; 2^{3}22&lt;7&lt;23，所以此时应查看可利用空间表中大小为 23 的链表中是否有空闲结点：如果有，则从该链表中摘除一个结点，直接分配给用户使用；如果没有，则需依次查看比232^{3}23大的各个链表中是否有空闲结点。假设，在大小242^{4}24的链表中有空闲块，则摘除该空闲块，分配给用户232^{3}23个字的空间，剩余232^{3}23个字，该剩余的空闲块添加到大小为232^{3}23的链表中。图8 伙伴系统分配过程 回收算法无论使用什么内存管理机制，在内存回收的问题上都会面临一个共同的问题：如何把回收的内存进行有效地整合，伙伴系统也不例外。当用户申请的内存块不再使用时，系统需要将这部分存储块回收，回收时需要判断是否可以和其它的空闲块进行合并。在寻找合并对象时，伙伴系统和边界标识法不同，在伙伴系统中每一个存储块都有各自的“伙伴”，当用户释放存储块时只需要判断该内存块的伙伴是否为空闲块，如果是则将其合并，然后合并的新的空闲块还需要同其伙伴进行判断整合。反之直接将存储块根据大小插入到可利用空间表中即可。判断一个存储块的伙伴的位置时，采用的方法为：如果该存储块的起始地址为 p，大小为2k2^{k}2k，则其伙伴所在的起始地址为：例如，当大小为282^{8}28 ，起始地址为512的伙伴块的起始地址的计算方式为：由于512 MOD 292^{9}29=0，所以，512+28=768512+2^{8}=768512+28=768，及如果该存储块回收时，只需要查看起始地址为 768 的存储块的状态，如果是空闲块则两者合并，反之直接将回收的释放块链接到大小为282^{8}28的链表中。 总结使用伙伴系统进行存储空间的管理过程中，在用户申请空间时，由于大小不同的空闲块处于不同的链表中，所以分配完成的速度会更快，算法相对简单。回收存储空间时，对于空闲块的合并，不是取决于该空闲块的相邻位置的块的状态；而是完全取决于其伙伴块。所以即使其相邻位置的存储块时空闲块，但是由于两者不是伙伴的关系，所以也不会合并。这也就是该系统的缺点之一：由于在合并时只考虑伙伴，所以容易产生存储的碎片。 垃圾回收机制当用户发出申请空间的请求后，系统向用户分配内存；用户运行结束释放存储空间后，系统回收内存。这两部操作都是在用户给出明确的指令后，系统对存储空间进行有效地分配和回收。但是在实际使用过程中，有时会因为用户申请了空间，但是在使用完成后没有向系统发出释放的指令，导致存储空间既没有被使用也没有被回收，变为了无用单元或者会产生悬挂访问的问题。什么是无用单元？简单来讲，无用单元是一块用户不再使用，但是系统无法回收的存储空间。例如在C语言中，用户可以通过 malloc 和 free 两个功能函数来动态申请和释放存储空间。当用户使用 malloc 申请的空间使用完成后，没有使用 free 函数进行释放，那么该空间就会成为无用单元。悬挂访问也很好理解：假设使用malloc申请了一块存储空间，有多个指针同时指向这块空间，当其中一个指针完成使命后，私自将该存储空间使用free释放掉，导致其他指针处于悬空状态，如果释放掉的空间被再分配后，再通过之前的指针访问，就会造成错误。数据结构中称这种访问为悬挂访问。解决存储空间可能成为无用单元或者产生悬挂访问的方法有两个：每个申请的存储空间设置一个计数域，这个计数域记录的是指向该存储空间的指针数目，只有当计数域的值为 0 时，该存储空间才会被释放。在程序运行时，所有的存储空间无论是处于使用还是空闲的状态，一律不回收，当系统中的可利用空间表为空时，将程序中断，对当前不在使用状态的存储空间一律回收，全部链接成一个新的可利用空间表后，程序继续执行。第二种方法中，在程序运行过程中很难找出此时哪些存储空间是空闲的。解决这个问题的办法是：找当前正在被占用的存储空间，只需要从当前正在工作的指针变量出发依次遍历，就可以找到当前正在被占用的存储空间，剩余的自然就是此时处于空闲状态的存储空间。使用第二种方式，可以分为两步进行：对所有当前正在使用的存储空间加上被占用的标记（对于广义表来说，可以在每个结点结构的基础上，添加一个 mark 的标志域。在初始状态下，所有的存储空间全部标志为 0，被占用时标记为 1）；依次遍历所有的存储空间，将所有标记为 0 的存储空间链接成一个新的可利用空间表。对正在被占用的存储空间进行标记的方法有三种：从当前正在工作的指针变量开始，采用递归算法依次将所有表中的存储结点中的标志域全部设置为 1；*第一种方法中使用递归算法实现的遍历。而递归底层使用的栈的存储结构，所以也可以直接使用栈的方式进行遍历；以上两种方法都是使用栈结构来记录遍历时指针所走的路径，便于在后期可以沿原路返回。所以第三种方式就是使用其他的方法代替栈的作用。 内存紧缩(内存碎片化处理)这些地址连续的未被占用的存储区在编译程序中称为堆。 分配内存空间在分配内存空间时，每次都从可利用空间中选择最低（或者最高）的地址进行分配。具体的实现办法为：设置一个指针（称为堆指针），每次用户申请存储空间时，都是堆的最低（或者最高）地址进行分配。假设当用户申请 N 个单位的存储空间时，堆指针向高地址（或者低地址）移动 N 个存储单位，这 N 个存储单位即为分配给用户使用的空闲块，空闲块的起始地址为堆指针移动之前所在的地址。例如，某一时间段有四个用户（A、B、C、D）分别申请 12 个单位、6 个单位、10 个单位和 8 个单位的存储空间，假设此时堆指针的初值为 0。则分配后存储空间的效果为：图9 内存空间分配 回收算法由于系统中的可利用空间始终都是一个连续的存储空间，所以回收时必须将用户释放的存储块合并到这个堆上才能够重新使用。存储紧缩有两种做法：其一是一旦用户释放所占空间就立即进行回收紧缩；另外一种是在程序执行过程中不立即回收用户释放的存储块，而是等到可利用空间不够分配或者堆指针指向了可利用存储区的最高地址时才进行存储紧缩。具体的实现过程是：计算占用块的新地址。设立两个指针随巡查向前移动，分别用于指示占用块在紧缩之前和之后的原地址和新地址。因此，在每个占用块的第一个存储单位中，除了存储该占用块的大小和标志域之外，还需要新增一个新地址域，用于存储占用块在紧缩后应有的新地址，即建立一张新、旧地址的对照表。修改用户的出事变量表，保证在进行存储紧缩后，用户还能找到自己的占用块。检查每个占用块中存储的数据。如果有指向其它存储块的指针，则需作相应修改。将所有占用块迁移到新地址去，即进行数据的传递。最后，还要将堆指针赋以新的值。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"计算机基础/数据结构","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法导论","slug":"算法导论","permalink":"http://forwardpeng.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}]},{"title":"algo-table","slug":"algo-table","date":"2020-04-22T04:21:14.000Z","updated":"2020-04-23T06:11:24.963Z","comments":true,"path":"2020/04/22/algo-table/","link":"","permalink":"http://forwardpeng.github.io/2020/04/22/algo-table/","excerpt":"","text":"线性表将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。 顺序存储结构和链式存储结构将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构(顺序表)数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构(链表) 前驱和后继数据结构中，一组数据中的每个个体被称为“数据元素”。某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；图1 前驱和后继 顺序表(顺序存储结构)及初始化顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。顺序表存储数据使用的是数组。 顺序表的初始化使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：顺序表申请的存储容量顺序表的长度，元素的个数正常状态下，顺序表申请的存储容量要大于顺序表的长度。自定义顺序表的结构体：C语言实现：123456typedef struct Table&#123; int* head; //动态数组 int length; //顺序表的长度 int size; //顺序表分配的存储容量&#125;table;建立顺序表需要做如下工作：给head动态数据申请足够大小的物理空间；给size和length赋初值；1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define Size 5typedef struct Table&#123; int * head; int length; int size;&#125;table;table initTable()&#123; table t; t.head=(int*)malloc(Size*sizeof(int)); //构造一个空的顺序表，动态申请存储空间 if (!t.head) //如果申请失败，作出提示并直接退出程序 &#123; printf(\"初始化失败\"); exit(0); &#125; t.length=0; //长度为0 t.size=Size; //存储空间为Size return t;&#125;//输出顺序表中元素的函数void displayTable(table t)&#123; for (int i=0;i&lt;t.length;i++) &#123; printf(\"%d \",t.head[i]); &#125; printf(\"\\n\");&#125;int main()&#123; table t=initTable(); //向顺序表中添加元素 for (int i=1; i&lt;=Size; i++) &#123; t.head[i-1]=i; t.length++; &#125; printf(\"顺序表中存储的元素分别是：\\n\"); displayTable(t); return 0;&#125; 顺序表插入元素虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：将要插入位置元素以及后续的元素整体向后移动一个位置；将元素放到腾出来的位置上；12345678910111213141516171819202122232425262728293031//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置table addTable(table t, int elem, int add)&#123; //判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出） if (add &gt; t.length + 1 || add &lt; 1) &#123; printf(\"插入位置有问题\\n\"); return t; &#125; //做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请 if (t.length == t.size) &#123; t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int)); if (!t.head) &#123; printf(\"存储分配失败\\n\"); return t; &#125; t.size += 1; &#125; //插入操作，需要将从插入位置开始的后续元素，逐个后移 for (int i = t.length - 1; i &gt;= add - 1; i--) &#123; t.head[i + 1] = t.head[i]; &#125; //后移完成后，直接将所需插入元素，添加到顺序表的相应位置 t.head[add - 1] = elem; //由于添加了元素，所以长度+1 t.length++; return t;&#125;注意，动态数组额外申请更多物理空间使用的是 realloc 函数。并且，在实现后续元素整体后移的过程，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。 顺序表删除元素从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。123456789101112table delTable(table t, int add)&#123; printf(\"被删除元素的位置有误\\n\"); return t; &#125; //删除操作 for (int i=add; i&lt;t.length; i++) &#123; t.head[i-1]=t.head[i]; &#125; t.length--; return t;&#125; 顺序表查找元素顺序表中查找目标元素，可以使用多种查找算法实现，比如说二分查找算法、顺序查找等123456789//顺序查找int selectTable(table t,int elem)&#123; for (int i=0; i&lt;t.length; i++) &#123; if (t.head[i]==elem) &#123; return i+1; &#125; &#125; return -1;//如果查找失败，返回-1&#125; 更改元素顺序表更改元素的实现过程是：找到目标元素；直接修改该元素的值；12345table amendTable(table t,int elem,int newElem)&#123; int add=selectTable(t, elem); t.head[add-1]=newElem;//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标 return t;&#125; 单链表与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。通过指针表示数据之间逻辑关系的存储结构就是链式存储结构。 链表的节点链表中每个数据的存储都由以下两部分组成：数据元素本身，其所在的区域称为数据域；指向直接后继元素的指针，所在的区域称为指针域；图2 节点结构链表中每个节点的结构体实现c代码：1234 typedef struct Link&#123; char elem; //代表数据域 struct Link * next; //代表指针域，指向直接后继元素&#125;link; //link为节点名，每个节点都是一个 link 结构体 头节点、头指针和首元节点一个完整的链表需要由以下几部分构成：头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；其他节点：链表中其他的节点；注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。 链表的创建(初始化)创建一个链表步骤如下：声明一个头指针（如果有必要，可以声明一个头节点）；创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；1234567891011121314//创建一个存储 &#123;1,2,3,4&#125; 且含头节点的链表link * initLink()&#123; link * p=(link*)malloc(sizeof(link));//创建一个头结点 link * temp=p;//声明一个指针指向头结点， //生成链表 for (int i=1; i&lt;5; i++) &#123; link *a=(link*)malloc(sizeof(link)); a-&gt;elem=i; a-&gt;next=NULL; temp-&gt;next=a; temp=temp-&gt;next; &#125; return p;&#125; 链表插入元素虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：将新结点的 next 指针指向插入位置后的结点；将插入位置前结点的 next 指针指向插入结点；注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，除非再添加一个指针，作为插入位置后续链表的头指针，否则会导致插入位置后的这部分链表丢失，无法再实现步骤 1。12345678910111213141516171819//p为原链表，elem表示新数据元素，add表示新元素要插入的位置link * insertElem(link * p, int elem, int add) &#123; link * temp = p;//创建临时结点temp //首先找到要插入位置的上一个结点 for (int i = 1; i &lt; add; i++) &#123; temp = temp-&gt;next; if (temp == NULL) &#123; printf(\"插入位置无效\\n\"); return p; &#125; &#125; //创建插入结点c link * c = (link*)malloc(sizeof(link)); c-&gt;elem = elem; //向链表中插入结点 c-&gt;next = temp-&gt;next; temp-&gt;next = c; return p;&#125; 链表删除元素从链表中删除数据元素需要进行以下 2步操作：将结点从链表中摘下来;手动释放掉结点，回收被结点占用的存储空间;temp-&gt;next=temp-&gt;next-&gt;next;执行效果如图3所示：图3 链表删除元素12345678910111213141516//p为原链表，add为要删除元素的值link * delElem(link * p, int add) &#123; link * temp = p; //遍历到被删除结点的上一个结点 for (int i = 1; i &lt; add; i++) &#123; temp = temp-&gt;next; if (temp-&gt;next == NULL) &#123; printf(\"没有该结点\\n\"); return p; &#125; &#125; link * del = temp-&gt;next;//单独设置一个指针指向被删除结点，以防丢失 temp-&gt;next = temp-&gt;next-&gt;next;//删除某个结点的方法就是更改前一个结点的指针域 free(del);//手动释放该结点，防止内存泄漏 return p;&#125; 链表查找元素从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的 NULL（比对失败的标志）。12345678910111213141516//p为原链表，elem表示被查找元素、int selectElem(link * p,int elem)&#123;//新建一个指针t，初始化为头指针 p link * t=p; int i=1; //由于头节点的存在，因此while中的判断为t-&gt;next while (t-&gt;next) &#123; t=t-&gt;next; if (t-&gt;elem==elem) &#123; return i; &#125; i++; &#125; //程序执行至此处，表示查找失败 return -1;&#125; 链表更新元素更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。1234567891011//更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值link *amendElem(link * p,int add,int newElem)&#123; link * temp=p; temp=temp-&gt;next;//在遍历之前，temp指向首元结点 //遍历到待更新结点 for (int i=1; i&lt;add; i++) &#123; temp=temp-&gt;next; &#125; temp-&gt;elem=newElem; return p;&#125; 顺序表和链表的优缺点(区别、特点)顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合，不留一丝空隙，如图4a)所示；链表的存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持，如图4b)所示； 开辟空间的方式顺序表存储数据实行的是 “一次开辟，永久使用”，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。因此，若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。 空间利用率空间利用率的角度上看，顺序表的空间利用率显然要比链表高。链表在存储数据时，每次只申请一个节点的空间，且空间的位置是随机的这种申请存储空间的方式会产生很多空间碎片，一定程序上造成了空间浪费。不仅如此，由于链表中每个数据元素都必须携带至少一个指针，因此，链表对所申请空间的利用率也没有顺序表高。空间碎片，指的是某些容量很小（1KB 甚至更小）以致无法得到有效利用的物理空间。 时间复杂度根据顺序表和链表在存储结构上的差异，问题类型主要分为以下 2 类：问题中主要涉及访问元素的操作，元素的插入、删除和移动操作极少；问题中主要涉及元素的插入、删除和移动，访问元素的需求很少；第 1 类问题适合使用顺序表。这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 O(1)；而在链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为 O(n);第 2 类问题则适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 O(1)；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为 O(n); 静态链表及其创建使用静态链表存储数据，数据全部存储在数组中（和顺序表一样），但存储位置是随机的，数据之间&quot;一对一&quot;的逻辑关系通过一个整形变量（称为&quot;游标&quot;，和指针功能类似）维持（和链表类似）。图4 静态链表存储数据静态链表会将第一个数据元素放到数组下标为 1 的位置（a[1]）中。从 a[1] 存储的数据元素 1 开始，通过存储的游标变量 3，就可以在 a[3] 中找到元素 1 的直接后继元素 2；同样，通过元素 a[3] 存储的游标变量 5，可以在 a[5] 中找到元素 2 的直接后继元素 3，这样的循环过程直到某元素的游标变量为 0 截止（因为 a[0] 默认不存储数据元素）。 静态链表中的节点静态链表存储数据元素也需要自定义数据类型，至少需要包含以下 2 部分信息：数据域：用于存储数据元素的值；游标：其实就是数组下标，表示直接后继元素所在数组中的位置静态链表中节点构成的C语言实现：1234typedef struct &#123; int data;//数据域 int cur;//游标&#125;component; 备用链表备用链表的作用是回收数组中未使用或之前使用过（目前未使用）的存储空间，留待后期使用。也就是说，静态链表使用数组申请的物理空间中，存有两个链表，一条连接数据，另一条连接数组中未使用的空间通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。 静态链表的创建在数据链表未初始化之前，数组中所有位置都处于空闲状态，都被链接到备用链表上。向静态链表添加数据时，需提前从备用链表中摘除节点，供新数据使用。备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样，向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表，耗费的时间复杂度为 O(1)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#define maxSize 6typedef struct&#123; /* data */ int data; int cur;&#125; component;//将结构体数组中所有分量链接到备用链表void reserveArr(component *array);//初始化静态链表int initArr(component *array);//输出函数void displayArr(component *array, int body);//从备用链表上摘下空闲节点int mallocArr(component *array);int main()&#123; component array[maxSize]; int body = initArr(array); printf(\"静态链表：\\n\"); displayArr(array, body); return 0;&#125;//创建备用链表void reserveArr(component *array)&#123; for (int i = 0; i &lt; maxSize; i++) &#123; array[i].cur = i + 1; //将每个数组分量链接到一起 array[i].data = -1; &#125; array[maxSize - 1].cur = 0; //链表最后一个节点的游标为0&#125;//提前分配空间int mallocArr(component *array)&#123; int i = array[0].cur; if (array[0].cur) &#123; array[0].cur = array[i].cur; &#125; return i;&#125;//初始化静态链表int initArr(component *array)&#123; reserveArr(array); int body = mallocArr(array); //声明一个变量，把它当指针使，指向链表的最后的一个结点，因为链表为空，所以和头结点重合 int tempBody = body; for (int i = 1; i &lt; 4; i++) &#123; int j = mallocArr(array); //从备用链表中拿出空闲的分量 array[tempBody].cur = j; //将申请的空闲分量链接在链表的最后一个结点后面 array[j].data = i; //给新申请的分量的数据域初始化 tempBody = j; //将指向链表最后一个结点的指针后移 &#125; array[tempBody].cur = 0; //新的链表最后一个结点的指针设置为0 return body;&#125;void displayArr(component *array, int body)&#123; int tempBody = body; //tempBody准备做遍历使用 while (array[tempBody].cur) &#123; printf(\"%d,%d \", array[tempBody].data, array[tempBody].cur); tempBody = array[tempBody].cur; &#125; printf(\"%d,%d\\n\", array[tempBody].data, array[tempBody].cur);&#125; 静态链表的基本操作 添加元素将元素4添加到静态链表中的第3个位置上，实现过程如下：从备用链表中摘除一个节点，用于存储元素 4；找到表中第 2 个节点（添加位置的前一个节点，这里是数据元素 2），将元素 2 的游标赋值给新元素 4；将元素 4 所在数组中的下标赋值给元素 2 的游标；1234567891011void insertArr(component * array,int body,int add,char a)&#123; int tempBody=body;//tempBody做遍历结构体数组使用 //找到要插入位置的上一个结点在数组中的位置 for (int i=1; i&lt;add; i++) &#123; tempBody=array[tempBody].cur; &#125; int insert=mallocArr(array);//申请空间，准备插入 array[insert].data=a; array[insert].cur=array[tempBody].cur;//新插入结点的游标等于其直接前驱结点的游标 array[tempBody].cur=insert;//直接前驱结点的游标等于新插入结点所在数组中的下标&#125; 删除元素静态链表中删除指定元素，只需实现以下 2 步操作：将存有目标元素的节点从数据链表中摘除；将摘除节点添加到备用链表，以便下次再用；1234567891011121314151617181920212223242526272829//备用链表回收空间的函数，其中array为存储数据的数组，k表示未使用节点所在数组的下标void freeArr(component * array,int k)&#123; array[k].cur=array[0].cur; array[0].cur=k;&#125;//删除结点函数，a 表示被删除结点中数据域存放的数据void deletArr(component * array,int body,char a)&#123; int tempBody=body; //找到被删除结点的位置 while (array[tempBody].data!=a) &#123; tempBody=array[tempBody].cur; //当tempBody为0时，表示链表遍历结束，说明链表中没有存储该数据的结点 if (tempBody==0) &#123; printf(\"链表中没有此数据\"); return; &#125; &#125; //运行到此，证明有该结点 int del=tempBody; tempBody=body; //找到该结点的上一个结点，做删除操作 while (array[tempBody].cur!=del) &#123; tempBody=array[tempBody].cur; &#125; //将被删除结点的游标直接给被删除结点的上一个结点 array[tempBody].cur=array[del].cur; //回收被摘除节点的空间 freeArr(array, del);&#125; 查找元素静态链表查找指定元素，由于我们只知道静态链表第一个元素所在数组中的位置，因此只能通过逐个遍历静态链表的方式，查找存有指定数据元素的节点。1234567891011int selectElem(component * array,int body,char elem)&#123; int tempBody=body; //当游标值为0时，表示链表结束 while (array[tempBody].cur!=0) &#123; if (array[tempBody].data==elem) &#123; return tempBody; &#125; tempBody=array[tempBody].cur; &#125; return -1;//返回-1，表示在链表中没有找到该元素&#125; 更改数据找到目标元素所在的节点，直接更改节点中的数据域即可。12345678void amendElem(component * array,int body,char oldElem,char newElem)&#123; int add=selectElem(array, body, oldElem); if (add==-1) &#123; printf(\"无更改元素\"); return; &#125; array[add].data=newElem;&#125; 静态链表和动态链表区别 静态链表使用静态链表存储数据，需要预先申请足够大的一整块内存空间，也就是说，静态链表存储数据元素的个数从其创建的那一刻就已经确定，后期无法更改。比如，如果创建静态链表时只申请存储10个数据元素的空间，那么在使用静态链表时，数据的存储个数就不能超过10个，否则程序就会发生错误。不仅如此，静态链表是在固定大小的存储空间内随机存储各个数据元素，这就造成了静态链表中需要使用另一条链表（通常称为&quot;备用链表&quot;）来记录空间存储空间的位置，以便后期分配给新添加元素使用，如图 2 所示。这意味着，如果你选择使用静态链表存储数据，你需要通过操控两条链表，一条是存储数据，另一条是记录空闲空间的位置。 动态链表使用动态链表存储数据，不需要预先申请内存空间，而是在需要的时候才向内存申请。也就是说，动态链表存储数据元素的个数是不限的，想存多少就存多少。同时，使用动态链表的整个过程，你也只需操控一条存储数据的链表。当表中添加或删除数据元素时，你只需要通过 malloc 或 free 函数来申请或释放空间即可，实现起来比较简单。 双向链表双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要双向链表中各节点包含以下3部分信息：指针域：用于指向当前节点的直接前驱节点；数据域：用于存储数据元素。指针域：用于指向当前节点的直接后继节点；双链表的节点结构的Ｃ语言实现：12345typedef struct line&#123; struct line * prior; //指向直接前趋 int data; struct line * next; //指向直接后继&#125;line; 双向链表的创建与单链表不同，双链表创建过程中，每创建一个新节点，都要与其前驱节点建立两次联系，分别是：将新节点的 prior 指针指向直接前驱节点；将直接前驱节点的 next 指针指向新节点；12345678910111213141516171819line* initLine(line * head)&#123; head=(line*)malloc(sizeof(line));//创建链表第一个结点（首元结点） head-&gt;prior=NULL; head-&gt;next=NULL; head-&gt;data=1; line * list=head; for (int i=2; i&lt;=3; i++) &#123; //创建并初始化一个新结点 line * body=(line*)malloc(sizeof(line)); body-&gt;prior=NULL; body-&gt;next=NULL; body-&gt;data=i; list-&gt;next=body;//直接前趋结点的next指针指向新结点 body-&gt;prior=list;//新结点指向直接前趋结点 list=list-&gt;next; &#125; return head;&#125; 添加节点123456789101112131415161718192021222324252627282930line * insertLine(line * head,int data,int add)&#123; //新建数据域为data的结点 line * temp=(line*)malloc(sizeof(line)); temp-&gt;data=data; temp-&gt;prior=NULL; temp-&gt;next=NULL; //插入到链表头，要特殊考虑 if (add==1) &#123; temp-&gt;next=head; head-&gt;prior=temp; head=temp; &#125;else&#123; line * body=head; //找到要插入位置的前一个结点 for (int i=1; i&lt;add-1; i++) &#123; body=body-&gt;next; &#125; //判断条件为真，说明插入位置为链表尾 if (body-&gt;next==NULL) &#123; body-&gt;next=temp; temp-&gt;prior=body; &#125;else&#123; body-&gt;next-&gt;prior=temp; temp-&gt;next=body-&gt;next; body-&gt;next=temp; temp-&gt;prior=body; &#125; &#125; return head;&#125; 删除节点1234567891011121314151617//删除结点的函数，data为要删除结点的数据域的值line * delLine(line * head,int data)&#123; line * temp=head; //遍历链表 while (temp) &#123; //判断当前结点中数据域和data是否相等，若相等，摘除该结点 if (temp-&gt;data==data) &#123; temp-&gt;prior-&gt;next=temp-&gt;next; temp-&gt;next-&gt;prior=temp-&gt;prior; free(temp); return head; &#125; temp=temp-&gt;next; &#125; printf(\"链表中无该数据元素\"); return head;&#125; 查找节点12345678910111213141516//双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。//head为原双链表，elem表示被查找元素int selectElem(line * head,int elem)&#123;//新建一个指针t，初始化为头指针 head line * t=head; int i=1; while (t) &#123; if (t-&gt;data==elem) &#123; return i; &#125; i++; t=t-&gt;next; &#125; //程序执行至此处，表示查找失败 return -1;&#125; 更改节点12345678910//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值line *amendElem(line * p,int add,int newElem)&#123; line * temp=p; //遍历到被删除结点 for (int i=1; i&lt;add; i++) &#123; temp=temp-&gt;next; &#125; temp-&gt;data=newElem; return p;&#125; 循环链表将表中最后一个结点的指针指向头结点，虽然循环链表成环状，但本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等。循环链表和普通链表相比，唯一的不同就是循环链表首尾相连，其他都完全一样。 约瑟夫环已知 n 个人（分别用编号 1，2，3，…，n 表示）围坐在一张圆桌周围，从编号为 k 的人开始顺时针报数，数到 m 的那个人出列；他的下一个人又从 1 开始，还是顺时针开始报数，数到 m 的那个人又出列；依次重复下去，直到圆桌上剩余一个人。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int number; struct node *next;&#125; person;person *initLink(int n)&#123; person *head = (person *)malloc(sizeof(person)); head-&gt;number = 1; head-&gt;next = NULL; person *cyclic = head; for (int i = 2; i &lt;= n; i++) &#123; person *body = (person *)malloc(sizeof(person)); body-&gt;number = i; body-&gt;next = NULL; cyclic-&gt;next = body; cyclic = cyclic-&gt;next; &#125; cyclic-&gt;next = head; //首尾相连 return head;&#125;void findAndKillK(person *head, int k, int m)&#123; person *tail = head; //找到链表第一个结点的上一个结点，为删除操作做准备 while (tail-&gt;next != head) &#123; tail = tail-&gt;next; &#125; person *p = head; //找到编号为k的人 while (p-&gt;number != k) &#123; tail = p; p = p-&gt;next; &#125; //从编号为k的人开始，只有符合p-&gt;next==p时，说明链表中除了p结点，所有编号都出列了， while (p-&gt;next != p) &#123; //找到从p报数1开始，报m的人，并且还要知道数m-1de人的位置tail，方便做删除操作。 for (int i = 1; i &lt; m; i++) &#123; tail = p; p = p-&gt;next; &#125; tail-&gt;next = p-&gt;next; //从链表上将p结点摘下来 printf(\"出列人的编号为:%d\\n\", p-&gt;number); free(p); p = tail-&gt;next; //继续使用p指针指向出列编号的下一个编号，游戏继续 &#125; printf(\"出列人的编号为:%d\\n\", p-&gt;number); free(p);&#125;int main()&#123; printf(\"输入圆桌上的人数n:\"); int n; scanf(\"%d\", &amp;n); person *head = initLink(n); printf(\"从第k人开始报数(k&gt;1且k&lt;%d)：\", n); int k; scanf(\"%d\", &amp;k); printf(\"数到m的人出列：\"); int m; scanf(\"%d\", &amp;m); findAndKillK(head, k, m); return 0;&#125;","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"计算机基础/数据结构","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法导论","slug":"算法导论","permalink":"http://forwardpeng.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"线性表","slug":"线性表","permalink":"http://forwardpeng.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"SQL-函数","slug":"sql-函数","date":"2020-04-21T13:03:54.000Z","updated":"2020-04-21T13:53:18.427Z","comments":true,"path":"2020/04/21/sql-函数/","link":"","permalink":"http://forwardpeng.github.io/2020/04/21/sql-%E5%87%BD%E6%95%B0/","excerpt":"","text":"内建函数 Aggregate函数SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。有用的 Aggregate 函数： AVG()函数用于返回数值列的平均值语法格式：SELECT AVG(column_name) FROM table_name COUNT()函数COUNT() 函数返回匹配指定条件的行数。 SQL COUNT(column_name) 语法COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）：SELECT COUNT(column_name) FROM table_name; SQL COUNT(*) 语法COUNT(*) 函数返回表中的记录数：SELECT COUNT(*) FROM table_name; SQL COUNT(DISTINCT column_name) 语法COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：SELECT COUNT(DISTINCT column_name) FROM table_name; MAX()函数MAX()函数返回指定列的最大值。SQL MAX() 语法SELECT MAX(column_name) FROM table_name; MIN()函数MIN() 函数返回指定列的最小值。SELECT MIN(column_name) FROM table_name; SUM()函数SUM() 函数返回数值列的总数。SELECT SUM(column_name) FROM table_name; Scalar函数SQL Scalar 函数基于输入值，返回一个单一的值。 UCASE() 函数UCASE() 函数把字段的值转换为大写。SELECT UCASE(column_name) FROM table_name; LCASE() 函数LCASE()函数把字段的值转换为小写。SELECT LCASE(column_name) FROM table_name; MID() 函数MID()函数用于从文本字段中提取字符。SELECT MID(column_name,start[,length]) FROM table_name; LENGTH() 函数LENGTH() 函数返回文本字段中值的长度。SELECT LENGTH(column_name) FROM table_name; ROUND()函数ROUND() 函数用于把数值字段舍入为指定的小数位数。SELECT ROUND(column_name,decimals) FROM table_name; NOW()函数NOW() 函数返回当前系统的日期和时间。SELECT NOW() FROM table_name; FORMAT()函数FORMAT() 函数用于对字段的显示进行格式化。SELECT FORMAT(column_name,format) FROM table_name; 自定义函数自定义函数是一种与存储过程十分相似的过程式数据库对象。它与存储过程一样，都是由SQL语句和过程式语句组成的代码片段，并且可以被应用程序和其他SQL语句调用。自定义函数与存储过程之间存在几点区别：自定义函数不能拥有输出参数，这是因为自定义函数自身就是输出参数；而存储过程可以拥有输出参数。自定义函数中必须包含一条RETURN语句，而这条特殊的SQL语句不允许包含于存储过程中。可以直接对自定义函数进行调用而不需要使用CALL语句，而对存储过程的调用需要使用CALL语句。 创建并使用自定义函数使用 CREATE FUNCTION 语句创建自定义函数，语法格式如下：CREATE FUNCTION &lt;函数名&gt; ( [ &lt;参数1&gt; &lt;类型1&gt; [ , &lt;参数2&gt; &lt;类型2&gt;] ] … )RETURNS &lt;类型&gt;&lt;函数主体&gt;语法说明如下：&lt;函数名&gt;：指定自定义函数的名称。注意，自定义函数不能与存储过程具有相同的名称。&lt;参数&gt;&lt;类型&gt;：用于指定自定义函数的参数。这里的参数只有名称和类型，不能指定关键字 IN、OUT 和 INOUT。RETURNS&lt;类型&gt;：用于声明自定义函数返回值的数据类型。其中，&lt;类型&gt;用于指定返回值的数据类型。&lt;函数主体&gt;：自定义函数的主体部分，也称函数体。所有在存储过程中使用的 SQL 语句在自定义函数中同样适用，包括前面所介绍的局部变量、SET 语句、流程控制语句、游标等。除此之外，自定义函数体还必须包含一个 RETURN&lt;值&gt; 语句，其中&lt;值&gt;用于指定自定义函数的返回值。若要查看数据库中存在哪些自定义函数，可以使用 SHOW FUNCTION STATUS 语句；若要查看数据库中某个具体的自定义函数，可以使用 SHOW CREATE FUNCTION&lt;函数名&gt; 语句，其中&lt;函数名&gt;用于指定该自定义函数的名称注意：当使用 DELIMITER 命令时，应该避免使用反斜杠“\\”字符，因为反斜杠是 MySQL 的转义字符。函数调用的语法格式如下：SELECT &lt;自定义函数名&gt; ([&lt;参数&gt; [,…]])实例1：创建存储函数，名称为 StuNameById，该函数返回 SELECT 语句的查询结果，数值类型为字符串类型12345678910111213mysql&gt; CREATE FUNCTION StuNameById() -&gt; RETURNS VARCHAR(45) -&gt; RETURN -&gt; (SELECT name FROM tb_students_info WHERE id=1);Query OK, 0 rows affected (0.00 sec)# 调佣自定义函数mysql&gt; SELECT StuNameById();+---------------+| StuNameById() |+---------------+| peng |+---------------+1 row in set (0.00 sec) 修改自定义函数可以使用 ALTER FUNCTION 语句来修改自定义函数的某些相关特征。若要修改自定义函数的内容，则需要先删除该自定义函数，然后重新创建。 删除自定义函数语法格式：DROP FUNCTION [ IF EXISTS ] &lt;自定义函数名&gt;语法说明：&lt;自定义函数名&gt;：指定要删除的自定义函数的名称。IF EXISTS：指定关键字，用于防止因误删除不存在的自定义函数而引发错误。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-触发器","slug":"sql-触发器","date":"2020-04-21T10:16:10.000Z","updated":"2020-04-21T13:53:07.079Z","comments":true,"path":"2020/04/21/sql-触发器/","link":"","permalink":"http://forwardpeng.github.io/2020/04/21/sql-%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"触发器简介数据库中触发器是一个特殊的存储过程，不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，只要一个预定义的事件发生就会被 MySQL自动调用。引发触发器执行的事件一般如下：增加一条学生记录时，会自动检查年龄是否符合范围要求。每当删除一条学生信息时，自动删除其成绩表上的对应记录。每当删除一条数据时，在数据库存档表中保留一个备份副本。触发程序的优点：触发程序的执行是自动的，当对触发程序相关表的数据做出相应的修改后立即执行。触发程序可以通过数据库中相关的表层叠修改另外的表。触发程序可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。1.INSERT触发器在 INSERT 语句执行之前或之后响应的触发器。使用 INSERT 触发器需要注意以下几点：在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。2.UPDATE触发器在UPDATE语句执行之前或之后响应的触发器。使用UPDATE触发器需要注意以下几点：在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。OLD中的值全部是只读的，不能被更新。注意：当触发器设计对触发表自身的更新操作时，只能使用 BEFORE 类型的触发器，AFTER 类型的触发器将不被允许。DELETE触发器DELETE 语句执行之前或之后响应的触发器。使用 DELETE 触发器需要注意以下几点:在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。OLD 中的值全部是只读的，不能被更新。总体来说，触发器使用的过程中，MySQL会按照以下方式来处理错误。若对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。若 BEFORE 触发程序失败，则MySQL将不执行相应行上的操作。若在BEFORE或AFTER触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。仅当BEFORE触发程序和行操作均已被成功执行，MySQL才会执行AFTER触发程序。 创建触发器(CREATE TRIGGER)触发器是与MySQL数据表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性。语法格式：CREATE &lt;触发器名&gt; &lt; BEFORE | AFTER &gt;&lt;INSERT | UPDATE | DELETE &gt;ON &lt;表名&gt; FOR EACH Row&lt;触发器主体&gt;语法说明如下：1.触发器名：触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。2.INSERT | UPDATE | DELETE：触发事件，用于指定激活触发器的语句的种类。注意：三种触发器的执行时间如下。INSERT：将新行插入表时激活触发器。例如，INSERT的BEFORE触发器不仅能被MySQL的INSERT语句激活，也能被LOAD DATA 语句激活。DELETE： 从表中删除某一行数据时激活触发器，例如DELETE和REPLACE语句。UPDATE：更改表中某一行数据时激活触发器，例如UPDATE语句。3.BEFORE | AFTER：BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。若希望验证新数据是否满足条件，则使用 BEFORE 选项；若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。4.表名：与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。在该表上触发事件发生时才会激活触发器。同一个表不能拥有两个具有相同触发时刻和事件的触发器。例如，对于一张数据表，不能同时有两个 BEFORE UPDATE 触发器，但可以有一个 BEFORE UPDATE 触发器和一个 BEFORE INSERT 触发器，或一个 BEFORE UPDATE 触发器和一个 AFTER UPDATE 触发器。5.触发器主体：触发器动作主体，包含触发器激活时将要执行的 MySQL 语句。如果要执行多个语句，可使用 BEGIN…END 复合语句结构。6.FOR EACH ROW：一般是指行级触发，对于受触发事件影响的每一行都要激活触发器的动作。例如，使用 INSERT 语句向某个表中插入多行数据时，触发器会对每一行数据的插入都执行相应的触发器动作。注意：每个表都支持 INSERT、UPDATE 和DELETE的BEFORE 与AFTER，因此每个表最多支持6个触发器。每个表的每个事件每次只允许有一个触发器。单一触发器不能与多个事件或多个表关联。 创建BEFORE类型触发器实例1：创建一个名为 SumOfSalary 的触发器，触发的条件是向数据表 tb_emp8 中插入数据之前，对新插入的 salary 字段值进行求和计算。123456789101112131415161718192021mysql&gt; CREATE TRIGGER SumOfSalary -&gt; BEFORE INSERT ON tb_emp8 -&gt; FOR EACH ROW -&gt; SET @sum=@sum+NEW.salary;Query OK, 0 rows affected (0.08 sec)mysql&gt; SET @sum=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; INSERT INTO tb_emp8 -&gt; VALUES(1,'A',1,1000),(2,'B',1,500);Query OK, 2 rows affected (0.04 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; SELECT @sum;+------+| @sum |+------+| 1500 |+------+1 row in set (0.00 sec) 创建AFTER类型触发器实例2：创建一个名为 double_salary 的触发器，触发的条件是向数据表 tb_emp6 中插入数据之后，再向数据表 tb_emp7 中插入相同的数据，并且 salary 为 tb_emp6 中新插入的 salary 字段值的 2 倍。输入的 SQL 语句和执行过程如下所示。123456789101112131415161718192021222324252627mysql&gt; CREATE TRIGGER double_salary -&gt; AFTER INSERT ON tb_emp6 -&gt; FOR EACH ROW -&gt; INSERT INTO tb_emp7 -&gt; VALUE (NEW.id, NEW.name, deptId, 2*NEW.salary);Query OK, 0 rows affected (0.09 sec)mysql&gt; insert into tb_emp6 values(1,'A',1,1000),(2,'B',1,500);Query OK, 2 rows affected (0.04 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM tb_emp6;+----+------+--------+--------+| id | name | deptId | salary |+----+------+--------+--------+| 1 | A | 1 | 1000 || 2 | B | 1 | 500 |+----+------+--------+--------+2 rows in set (0.00 sec)mysql&gt; SELECT * FROM tb_emp7;+----+------+--------+--------+| id | name | deptId | salary |+----+------+--------+--------+| 1 | A | NULL | 2000 || 2 | B | NULL | 1000 |+----+------+--------+--------+2 rows in set (0.00 sec) 修改和删除触发器(DROP TRIGGER)语法格式：DROP TRIGGER [ IF EXISTS ] [数据库名] &lt;触发器名&gt;语法说明：触发器名：要删除的触发器名称。数据库名：可选项。指定触发器所在的数据库的名称。若没有指定，则为当前默认的数据库。权限：执行 DROP TRIGGER 语句需要 SUPER 权限。IF EXISTS：避免在没有触发器的情况下删除触发器。注意：删除一个表的同时，也会自动删除该表上的触发器。另外，触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，再重新创建。 删除触发器实例：删除 double_salary 触发器。12345678910111213141516171819202122mysql&gt; INSERT INTO tb_emp6 -&gt; VALUES (3,'C', 1, 200);Query OK, 1 row affected (0.04 sec)mysql&gt; SELECT * FROm tb_emp6;+----+------+--------+--------+| id | name | deptId | salary |+----+------+--------+--------+| 1 | A | 1 | 1000 || 2 | B | 1 | 500 || 3 | C | 1 | 200 |+----+------+--------+--------+3 rows in set (0.01 sec)mysql&gt; SELECT * FROm tb_emp7;+----+------+--------+--------+| id | name | deptId | salary |+----+------+--------+--------+| 1 | A | NULL | 2000 || 2 | B | NULL | 1000 |+----+------+--------+--------+2 rows in set (0.00 sec)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-存储","slug":"sql-存储","date":"2020-04-21T09:11:25.000Z","updated":"2020-04-21T13:53:12.271Z","comments":true,"path":"2020/04/21/sql-存储/","link":"","permalink":"http://forwardpeng.github.io/2020/04/21/sql-%E5%AD%98%E5%82%A8/","excerpt":"","text":"存储引擎 什么是存储引擎数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。 MySQL 5.7 支持的存储引擎MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如下：12345678910111213141516mysql&gt; SHOW ENGINES;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MyISAM | YES | MyISAM storage engine | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO || ARCHIVE | YES | Archive storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)# Support 列的值表示某种引擎是否能使用，YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认的存储引擎 选择MySQL存储引擎不同的存储引擎都有各自的特点，以适应不同的需求。功能MyISAMMEMORYInnoDBArchive存储限制256TBRAM64TBNone支持事务NoNoYesNo支持全文索引YesNoNoNo支持树索引YesYesYesNo支持哈希索引NoYesNoNo支持数据缓存NoN/AYesNo支持外键NoNoYesNo选择MySQL存储引擎：如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎修改数据库临时的默认存储引擎:SET default_storage_engine=&lt; 存储引擎名 &gt; 存储过程简介存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成。优点如下：1.封装性存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。2.可增强 SQL 语句的功能和灵活性存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。3.可减少网络流量由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。4.高性能存储过程执行一次后，产生的二进制代码就驻留在缓冲区，在以后的调用中，只需要从缓冲区中执行二进制代码即可，从而提高了系统的效率和性能。5.提高数据库的安全性和数据完整性使用存储过程可以完成所有数据库操作，并且可以通过编程的方式控制数据库信息访问的权限。 创建存储过程(CREATE PROCEDURE)使用 CREATE PROCEDURE 语句创建存储过程，语法格式如下：CREATE PROCEDURE &lt;过程名&gt; ( [过程参数[,…] ] ) &lt;过程体&gt;[过程参数[,…] ] 格式[ IN | OUT | INOUT ] &lt;参数名&gt; &lt;类型&gt;语法说明如下：1.过程名存储过程的名称，默认在当前数据库中创建。若需要在特定数据库中创建存储过程，则要在名称前面加上数据库的名称，即 db_name.sp_name。需要注意的是，名称应当尽量避免选取与 MySQL 内置函数相同的名称，否则会发生错误。3.过程参数存储过程的参数列表。其中，&lt;参数名&gt;为参数名，&lt;类型&gt;为参数的类型（可以是任何有效的 MySQL 数据类型）。当有多个参数时，参数列表中彼此间用逗号分隔。存储过程可以没有参数（此时存储过程的名称后仍需加上一对括号），也可以有 1 个或多个参数。MySQL 存储过程支持三种类型的参数，即输入参数、输出参数和输入/输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中，输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输入/输出参数既可以充当输入参数也可以充当输出参数。需要注意的是，参数的取名不要与数据表的列名相同，否则尽管不会返回出错信息，但是存储过程的 SQL 语句会将参数名看作列名，从而引发不可预知的结果。3.过程体存储过程的主体部分，也称为存储过程体，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 BEGIN 开始，以关键字 END 结束。若存储过程体中只有一条SQL语句，则可以省略BEGIN-END标志。通常可使用 DELIMITER 命令将结束命令修改为其他字符。语法格式：DELIMITER $$语法说明：$$ 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个“?”或两个“￥”等。当使用 DELIMITER 命令时，应该避免使用反斜杠“\\”字符，因为它是MySQL的转义字符。DELIMITER 和分号“;”之间一定要有一个空格。在创建存储过程时，必须具有 CREATE ROUTINE 权限。可以使用 SHOW PROCEDURE STATUS 命令查看数据库中存在哪些存储过程，若要查看某个存储过程的具体信息，则可以使用 SHOW CREATE PROCEDURE &lt;存储过程名&gt;。 创建不带参数的存储过程实例1：创建名称为 ShowStuScore 的存储过程，存储过程的作用是从学生成绩信息表中查询学生的成绩信息123456789101112131415161718192021222324mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE ShowStuScore() -&gt; BEGIN -&gt; SELECT * FROM tb_students_score; -&gt; END //Query OK, 0 rows affected (0.05 sec)mysql&gt; DELIMITER ;mysql&gt; CALL ShowStuScore();+----+--------------+---------------+| id | student_name | student_score |+----+--------------+---------------+| 1 | Dany | 90 || 2 | Green | 99 || 3 | Henry | 95 || 4 | Jane | 98 || 5 | Jim | 88 || 6 | John | 94 || 7 | Lily | 100 || 8 | Susan | 96 || 9 | Thomas | 93 |+----+--------------+---------------+9 rows in set (0.00 sec)Query OK, 0 rows affected (0.00 sec) 创建带参数的存储过程实例2：创建名称为 GetScoreByStu 的存储过程，输入参数是学生姓名。存储过程的作用是通过输入的学生姓名从学生成绩信息表中查询指定学生的成绩信息。1234567891011121314151617mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE GetScoreByStu -&gt; (IN name VARCHAR(30)) -&gt; BEGIN -&gt; SELECT student_score FROM tb_students_score -&gt; WHERE student_name=name; -&gt; END //Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL GetScoreByStu('Lily');+---------------+| student_score |+---------------+| 100 |+---------------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec) 修改存储过程(ALTE PROCEDURE)通过 ALTER PROCEDURE 语句来修改存储过程，语法格式如下：ALTER PROCEDURE 存储过程名[特征…]特征指定存储过程的特征，可能取值有：CONTAINS SQL 表示子程序包含 SQL 语句，但不包含读或写数据的语句。NO SQL 表示子程序中不包含 SQL 语句。READS SQL DATA 表示子程序中包含读数据的语句。MODIFIES SQL DATA 表示子程序中包含写数据的语句。SQL SECURITY { DEFINER |INVOKER } 指明谁有权限来执行。DEFINER 表示只有定义者自己才能够执行。INVOKER 表示调用者可以执行。COMMENT ‘string’ 表示注释信息。实例1：修改存储过程 showstuscore 的定义，将读写权限改为 MODIFIES SQL DATA。123456789101112131415161718mysql&gt; ALTER PROCEDURE showstuscore MODIFIES SQL DATA SQL SECURITY INVOKER;Query OK, 0 rows affected (0.00 sec)mysql&gt; SHOW CREATE PROCEDURE showstuscore \\G*************************** 1. row *************************** Procedure: showstuscore sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `showstuscore`() MODIFIES SQL DATA SQL SECURITY INVOKERBEGINSELECT * FROM tb_students_score;ENDcharacter_set_client: utf8collation_connection: utf8_general_ci Database Collation: utf8_general_ci1 row in set (0.00 sec)# 访问数据的权限已经变成了 MODIFIES SQL DATA，安全类型也变成了 INVOKE。提示：ALTER PROCEDURE 语句用于修改存储过程的某些特征。如果要修改存储过程的内容，可以先删除原存储过程，再以相同的命名创建新的存储过程；如果要修改存储过程的名称，可以先删除原存储过程，再以不同的命名创建新的存储过程。 删除存储过程(DROP PROCEDURE)使用 DROP PROCEDURE 语句来删除数据库中已经存在的存储过程。语法格式如下：DROP {PROCEDURE | FUNCTION}[IF EXISTS] &lt;过程名&gt;语法说明如下：过程名：指定要删除的存储过程的名称。IF EXISTS：指定这个关键字，用于防止因删除不存在的存储过程而引发的错误。注意：存储过程名称后面没有参数列表，也没有括号，在删除之前，必须确认该存储过程没有任何依赖关系，否则会导致其他与之关联的存储过程无法运行。实例1：删除存储过程 showstuscore，删除后，可以通过查询 information_schema 数据库下的 routines 表来确认上面的删除是否成功。1234mysql&gt; DROP PROCEDURE showstuscore;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT * FROM information_schema.routines WHERE routine_name='showstuscore';Empty set (0.03 sec)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-主键及约束","slug":"sql-主键及约束","date":"2020-04-21T05:14:36.000Z","updated":"2020-04-21T13:53:33.060Z","comments":true,"path":"2020/04/21/sql-主键及约束/","link":"","permalink":"http://forwardpeng.github.io/2020/04/21/sql-%E4%B8%BB%E9%94%AE%E5%8F%8A%E7%BA%A6%E6%9D%9F/","excerpt":"","text":"主键(PRIMARY KEY)主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 选取设置主键约束的字段主键约束即在表中定义一个主键来唯一确定表中每一行数据的标识符。主键可以是表中的某一列或者多列的组合，其中由多列组合的主键称为复合主键。主键应该遵守下面的规则：每个表只能定义一个主键。主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在两行数据有相同的主键值。这是唯一性原则。一个列名只能在复合主键列表中出现一次。复合主键不能包含不必要的多余列。当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。这是最小化原则。 在创建表时设置主键约束在 CREATE TABLE 语句中，主键是通过 PRIMARY KEY 关键字来指定的。语法规则：&lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值]实例1：在 test_db 数据库中创建 tb_emp 3 数据表，其主键为 id1234567891011121314151617181920mysql&gt; CREATE TABLE tb_emp3 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; DESC tb_emp3 -&gt; ;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)指定主键的语法格式：[CONSTRAINT &lt;约束名&gt;] PRIMARY KEY [字段名]实例2：在 test_db 数据库中创建 tb_emp 4 数据表，其主键为 id1234567891011121314151617181920mysql&gt; CREATE TABLE tb_emp4 -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT, -&gt; PRIMARY KEY(id) -&gt; );Query OK, 0 rows affected (0.34 sec)mysql&gt; DESC tb_emp4;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 在创建表时设置复合主键主键由多个字段联合组成，语法规则如下：PRIMARY KEY [字段1，字段2，…,字段n]实例3：创建数据表 tb_emp5，假设表中没有主键 id，为了唯一确定一个员工，可以把 name、deptId 联合起来作为主键。123456789101112mysql&gt; CREATE TABLE tb_emp5 ( name VARCHAR(25), deptId INT(11), salary FLOAT, PRIMARY KEY(name, deptId) );Query OK, 0 rows affected (0.26 sec)mysql&gt; DESC tb_emp5;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| name | varchar(25) | NO | PRI | NULL | || deptId | int(11) | NO | PRI | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 在修改表时添加主键约束修改数据表时添加主键约束的语法规则为：ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;);实例4：修改数据表 tb_emp2，将字段 id 设置为主键。1234567891011121314mysql&gt; ALTER TABLE tb_emp3 ADD PRIMARY KEY(id);Query OK, 0 rows affected (0.41 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_emp3;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 外键约束(FOREIGN KEY)外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。 选取设置MySQL外键约束的字段定义一个外键时，需要遵守下列规则:父表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则父表与子表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。必须为父表定义主键。主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。在父表的表名后面指定列名或列名的组合。这个列或列的组合必须是父表的主键或候选键。外键中列的数目必须和父表的主键中列的数目相同。外键中列的数据类型必须和父表主键中对应列的数据类型相同。 在创建表时设置外键约束在数据表中创建外键使用 FOREIGN KEY 关键字，具体的语法规则如下：[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…]REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]其中：外键名为定义的外键约束的名称，一个表中不能有相同名称的外键；字段名表示子表需要添加外健约束的字段列；主表名即被子表外键所依赖的表的名称；主键列表示主表中定义的主键列或者列组合。实例1：在 test_db 数据库中创建一个部门表 tb_dept1,表结构如下：字段名称数据类型备注idINT(11)部门编号nameVARCHAR(22)部门名称locationVARCHAR(22)部门位置12345678910111213141516171819202122# 创建tb_dept1的SQL语句mysql&gt; CREATE TABLE tb_dept1 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22) NOT NULL, -&gt; location VARCHAR(50) -&gt; );Query OK, 0 rows affected (0.27 sec)# 创建数据表 tb_emp6，并在表 tb_emp6 上创建外键约束，让它的键 deptId 作为外键关联到表 tb_dept1 的主键 idmysql&gt; CREATE TABLE tb_emp6 ( id INT(11) PRIMARY KEY, name VARCHAR(25), deptId INT(11), salary FLOAT, CONSTRAINT fk_emp_dept1 FOREIGN KEY(deptId) REFERENCES tb_dept1(id) );Query OK, 0 rows affected (0.32 sec)mysql&gt; DESC tb_emp6;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | MUL | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.01 sec提示：关联指的是关系数据库中，相关表之间的联系。它是通过相同的属性或属性组来表示的。子表的外键必须关联父表的主键，且关联字段的数据类型必须匹配，如果类型不一样，则创建子表时会出现错误“ERROR 1005(HY000)：Can’t create table’database.tablename’(errno：150)” 在修改表时添加外键约束语法规则：ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;索引名&gt;FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);实例2：修改数据表 tb_emp2，将字段 deptId 设置为外键，与数据表 tb_dept1 的主键 id 进行关联123456mysql&gt; ALTER TABLE tb_emp3 ADD CONSTRAINT fk_tb_dept1 FOREIGN KEY(deptId) REFERENCES tb_dept1(id);Query OK, 0 rows affected (0.70 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; ALTER TABLE tb_emp3 ADD CONSTRAINT fk_tb_dept1 FOREIGN KEY(deptId) REFERENCES tb_dept1(id);Query OK, 0 rows affected (0.70 sec)Records: 0 Duplicates: 0 Warnings: 0 删除外键约束对于数据库中定义的外键，如果不再需要，可以将其删除。外键一旦删除，就会解除主表和从表间的关联关系，MySQL 中删除外键的语法格式如下：ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;实例3：删除数据表 tb_emp2 中的外键约束 fk_tb_dept1。1234567891011121314151617mysql&gt; ALTER TABLE tb_emp3 -&gt; DROP FOREIGN KEY fk_tb_dept1;Query OK, 0 rows affected (0.05 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; SHOW CREATE TABLE tb_emp3\\G*************************** 1. row *************************** Table: tb_emp3Create Table: CREATE TABLE `tb_emp3` ( `id` int(11) NOT NULL, `name` varchar(25) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_tb_dept1` (`deptId`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) 唯一约束(UNIQUE KEY)唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。 创建表时设置唯一约束定义完列之后直接使用 UNIQUE 关键字指定唯一约束，语法规则如下：&lt;字段名&gt; &lt;数据类型&gt; UNIQUE实例1：创建数据表 tb_dept2，指定部门的名称唯一。1234567891011121314151617mysql&gt; CREATE TABLE tb_dept2 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22) UNIQUE, -&gt; location VARCHAR(50) -&gt; );Query OK, 0 rows affected (0.42 sec)mysql&gt; DESC tb_dept2;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | YES | UNI | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)UNIQUE 和 PRIMARY KEY 的区别：一个表可以有多个字段声明为 UNIQUE，但只能有一个 PRIMARY KEY 声明；声明为 PRIMAY KEY 的列不允许有空值，但是声明为 UNIQUE 的字段允许空值的存在。 在修改表时添加唯一约束修改表添加唯一约束的语法格式为：ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;唯一约束名&gt; UNIQUE(&lt;列名&gt;);实例2：修改数据表 tb_dept1，指定部门的名称唯一1234567891011121314mysql&gt; ALTER TABLE tb_dept1 -&gt; ADD CONSTRAINT unique_name UNIQUE(name);Query OK, 0 rows affected (0.22 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept1;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | UNI | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 删除唯一约束语法格式：ALTER TABLE &lt;表名&gt; DROP INDEX &lt;唯一约束名&gt;;实例3：删除数据表 tb_dept1 中的唯一约束 unique_name。1234567891011121314mysql&gt; ALTER TABLE tb_dept1 -&gt; DROP INDEX unique_name;Query OK, 0 rows affected (0.50 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept1;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 检查约束(CHECK)检查约束（CHECK）可以通过CREATE TABLE或ALTER TABLE语句实现，根据用户实际的完整性要求来定义。它可以分别对列或表实施 CHECK 约束。 选取设置检查约束的字段检查约束使用 CHECK 关键字，具体的语法格式如下：CHECK &lt;表达式&gt;其中：&lt;表达式&gt;指的就是 SQL 表达式，用于指定需要检查的限定条件。若将 CHECK 约束子句置于表中某个列的定义之后，则这种约束也称为基于列的 CHECK 约束。在更新表数据的时候，系统会检查更新后的数据行是否满足 CHECK 约束中的限定条件。MySQL 可以使用简单的表达式来实现 CHECK 约束，也允许使用复杂的表达式作为限定条件，例如在限定条件中加入子查询。将 CHECK 约束子句置于所有列的定义以及主键约束和外键定义之后，则这种约束也称为基于表的 CHECK 约束。该约束可以同时对表中多个列设置限定条件。 创建表时设置检测约束语法规则：CHECK(&lt;检查约束&gt;)实例1：在 test_db 数据库中创建 tb_emp7 数据表，要求 salary 字段值大于 0 且小于 1000012345678mysql&gt; CREATE TABLE tb_emp7 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT, -&gt; CHECK(salary&gt;0 AND salary&lt;100),FOREIGN KEY(deptId) REFERENCES tb_dept1(id));Query OK, 0 rows affected (0.28 sec) 修改表时添加检查约束语法规则：ALTER TABLE tb_emp7 ADD CONSTRAINT &lt;检查约束名&gt; CHECK(&lt;检查约束&gt;)实例2：修改 tb_dept 数据表，要求 id 字段值大于 012345mysql&gt; ALTER TABLE tb_emp7 -&gt; ADD CONSTRAINT check_id -&gt; CHECK(id&gt;0);Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 删除检查约束语法规则：ALTER TABLE &lt;数据表名&gt; DROP CONSTRAINT &lt;检查约束名&gt;; 默认值约束(DEFAULT)默认值约束用来指定某列的默认值。 创建表时设置默认值约束创建表时可以使用 DEFAULT 关键字设置默认值约束，具体的语法规则如下：&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;实例1：创建数据表 tb_dept3，指定部门位置默认为 Beijing12345678910111213141516mysql&gt; CREATE TABLE tb_dept3 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22), -&gt; location VARCHAR(50) DEFAULT 'Beijing');Query OK, 0 rows affected (0.26 sec)mysql&gt; DESC tb_dept3;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | YES | | NULL | || location | varchar(50) | YES | | Beijing | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 修改表时添加默认值约束语法规则：ALTER TABLE&lt;数据表名&gt; CHANGE COLUMN&lt;字段名&gt;&lt;数据类型&gt;DEFAULT&lt;默认值&gt;实例2：修改数据表 tb_dept3，将部门位置的默认值修改为 Shanghai。123456789101112131415mysql&gt; ALTER TABLE tb_dept3 -&gt; CHANGE COLUMN location -&gt; location VARCHAR(50) DEFAULT 'Shanghai';Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept3;+----------+-------------+------+-----+----------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+----------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | YES | | NULL | || location | varchar(50) | YES | | Shanghai | |+----------+-------------+------+-----+----------+-------+3 rows in set (0.00 sec) 删除默认值约束修改表时删除默认值约束的语法规则如下：ALTER TABLE &lt;数据库名&gt;CHANGE COLUMN &lt;字段名&gt;&lt;字段名&gt;&lt;数据类型&gt; DEFAULT NULL;实例3：修改数据表 tb_dept3，将部门位置的默认值约束删除。123456789101112mysql&gt; ALTER TABLE tb_dept3 CHANGE COLUMN location location VARCHAR(50) DEFAULT NULL;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept3; +----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | YES | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 非空约束(NOT NULL)非空约束可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空。非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。 创建表时设置非空约束创建表时可以使用 NOT NULL 关键字设置非空约束，具体的语法规则如下：&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;实例1：创建数据表 tb_dept4，指定部门名称不能为空。123456789101112mysql&gt; CREATE TABLE tb_dept4 -&gt; (id INT(11) PRIMARY KEY, name VARCHAR(22) NOT NULL, location VARCHAR(50));Query OK, 0 rows affected (0.36 sec)mysql&gt; DESC tb_dept4;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 修改表时添加非空约束语法规则：ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt;&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;实例2：修改数据表 tb_dept4，指定部门位置不能为空。123456789101112131415mysql&gt; ALTER TABLE tb_dept4 -&gt; CHANGE COLUMN location -&gt; location VARCHAR(50) NOT NULL;Query OK, 0 rows affected (0.62 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept4;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | NO | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 删除非空约束语法规则：ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; NULL;实例3：修改数据表 tb_dept4，将部门位置的非空约束删除。123456789101112131415mysql&gt; ALTER TABLE tb_dept4 -&gt; CHANGE COLUMN location -&gt; location VARCHAR(50) NULL;Query OK, 0 rows affected (0.49 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept4;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 查看表中的约束语法格式：SHOW CREATE TABLE &lt;数据表名&gt;;12345678910mysql&gt; SHOW CREATE TABLe tb_dept4\\G*************************** 1. row *************************** Table: tb_dept4Create Table: CREATE TABLE `tb_dept4` ( `id` int(11) NOT NULL, `name` varchar(22) NOT NULL, `location` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-视图","slug":"sql-视图","date":"2020-04-21T02:40:40.000Z","updated":"2020-04-21T13:53:24.007Z","comments":true,"path":"2020/04/21/sql-视图/","link":"","permalink":"http://forwardpeng.github.io/2020/04/21/sql-%E8%A7%86%E5%9B%BE/","excerpt":"","text":"视图简介视图是一个虚拟表，其内容由查询定义。同真实表一样，视图包含一系列带有名称的列和行数据，但视图并不是数据库真实存储的数据表。视图是从一个、多个表或者视图中导出的表，包含一系列带有名称的数据列和若干条数据行。视图并不同于数据表，它们的区别在于以下几点：视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。视图的建立和删除只影响视图本身，不影响对应的基本表。视图与表在本质上虽然不相同，但视图经过定义以后，结构形式和表一样，可以进行查询、修改、更新和删除等操作。同时，视图具有如下优点：1.定制用户数据，聚焦特定的数据在实际的应用过程中，不同的用户可能对不同的数据有不同的要求。例如，当数据库同时存在时，如学生基本信息表、课程表和教师信息表等多种表同时存在时，可以根据需求让不同的用户使用各自的数据。学生查看修改自己基本信息的视图，安排课程人员查看修改课程表和教师信息的视图，教师查看学生信息和课程信息表的视图。2.简化数据操作在使用查询时，很多时候要使用聚合函数，同时还要显示其他字段的信息，可能还需要关联到其他表，语句可能会很长，如果这个动作频繁发生的话，可以创建视图来简化操作。3.提高基表数据的安全性视图是虚拟的，物理上是不存在的。可以只授予用户视图的权限，而不具体指定使用表的权限，来保护基础数据的安全。4.共享所需数据通过使用视图，每个用户不必都定义和存储自己所需的数据，可以共享数据库中的数据，同样的数据只需要存储一次。5.更改数据格式通过使用视图，可以重新格式化检索出的数据，并组织输出到其他应用程序中。6.重用SQL语句视图提供的是对查询操作的封装，本身不包含数据，所呈现的数据是根据视图定义从基础表中检索出来的，如果基础表的数据新增或删除，视图呈现的也是更新后的数据。视图定义后，编写完所需的查询，可以方便地重用该视图。注意：要区别视图和数据表的本质，即视图是基于真实表的一张虚拟的表，其数据来源均建立在真实表的基础上。创建视图需要足够的访问权限。创建视图的数目没有限制。视图可以嵌套，即从其他视图中检索数据的查询来创建视图。视图不能索引，也不能有关联的触发器、默认值或规则。视图可以和表一起使用。视图不包含数据，所以每次使用视图时，都必须执行查询中所需的任何一个检索操作。如果用多个连接和过滤条件创建了复杂的视图或嵌套了视图，可能会发现系统运行性能下降得十分严重。因此，在部署大量视图应用时，应该进行系统测试。 创建视图(CREATE VIEW)视图可以建立在一张表中，也可以建立在多张表中。 基本语法使用CREATE VIEW 语句来创建视图语法格式：CREATE VIEW&lt;视图名&gt;AS&lt;SELECT语句&gt;语法说明如下：&lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。&lt;SELECT语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。对于创建视图中的SELECT语句存在以下限制：用户除了拥有 CREATE VIEW 权限外，还具有操作中涉及的基础表和其他视图的相关权限。SELECT语句不能引用系统或用户变量。SELECT语句不能包含 FROM子句中的子查询。SELECT语句不能引用预处理语句参数。视图定义中引用的表或视图必须存在。但是，创建完视图后，可以删除定义引用的表或视图。可使用 CHECK TABLE 语句检查视图定义是否存在这类问题。视图定义中允许使用 ORDER BY 语句，但是若从特定视图进行选择，而该视图使用了自己的 ORDER BY 语句，则视图定义中的 ORDER BY 将被忽略。视图定义中不能引用TEMPORARY表（临时表），不能创建TEMPORARY视图。WITH CHECK OPTION 的意思是，修改视图时，检查插入的数据是否符合 WHERE 设置的条件。 创建基于单表的视图实例1：在单个数据表上创建视图。在 tb_students_info 表上创建一个名为 view_students_info 的视图123456789101112131415mysql&gt; CREATE VIEW view_students_info -&gt; AS SELECT * FROM tb_students_info;Query OK, 0 rows affected (0.04 sec)mysql&gt; SELECT * FROM view_students_info;+----+------+---------+------+------+--------+---------------------+| id | name | dept_id | age | sex | height | login_date |+----+------+---------+------+------+--------+---------------------+| 1 | peng | 2 | 25 | F | 222 | 1000-01-01 00:00:00 || 2 | jun | 2 | 12 | F | 222 | 1000-01-01 00:00:01 || 3 | Gui | 1 | 44 | M | 170 | 1000-01-01 00:00:01 || 4 | Feng | 2 | 32 | F | 175 | 1000-01-01 00:00:01 || 5 | Qi | 0 | 22 | M | 170 | 1000-01-01 00:00:01 |+----+------+---------+------+------+--------+---------------------+5 rows in set (0.00 sec)实例2：在 tb_students_info 表上创建一个名为 v_students_info 的视图。1234567891011121314mysql&gt; CREATE VIEW v_students_info (s_id, s_name, d_id, s_age, s_sex, s_height, s_date) AS SELECT id, name, dept_id, age, sex, height, login_date FROM tb_students_info;Query OK, 0 rows affected (0.03 sec)mysql&gt; SELECT * FROM v_students_info;+------+--------+------+-------+-------+----------+---------------------+| s_id | s_name | d_id | s_age | s_sex | s_height | s_date |+------+--------+------+-------+-------+----------+---------------------+| 1 | peng | 2 | 25 | F | 222 | 1000-01-01 00:00:00 || 2 | jun | 2 | 12 | F | 222 | 1000-01-01 00:00:01 || 3 | Gui | 1 | 44 | M | 170 | 1000-01-01 00:00:01 || 4 | Feng | 2 | 32 | F | 175 | 1000-01-01 00:00:01 || 5 | Qi | 0 | 22 | M | 170 | 1000-01-01 00:00:01 |+------+--------+------+-------+-------+----------+---------------------+5 rows in set (0.01 sec) 创建基于多表的视图可以在两个以上的表中创建视图，使用 CREATE VIEW 语句创建。 查询视图视图一经定义之后，就可以如同查询数据表一样，使用 SELECT 语句查询视图中的数据，语法和查询基础表的数据一样。主要应用在以下几个方面：使用视图重新格式化检索出的数据使用视图简化复杂的表连接使用视图过滤数据语法格式：DESCRIBE 视图名；实例3：DESCRIBE 语句查看视图 v_students_info 的定义12345678910111213mysql&gt; DESC v_students_info;+----------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+-------+| s_id | int(11) | NO | | NULL | || s_name | varchar(255) | YES | | NULL | || d_id | int(11) | YES | | NULL | || s_age | int(11) | YES | | NULL | || s_sex | char(10) | YES | | NULL | || s_height | int(11) | YES | | NULL | || s_date | datetime | YES | | NULL | |+----------+--------------+------+-----+---------+-------+7 rows in set (0.00 sec) 修改视图(ALTER VIEW)修改数据库中存在的视图，当基本表的某些字段发生变化时，可以通过修改视图来保持与基本表的一致性。语法格式：ALTER VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;语法说明：&lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。&lt;SELECT 语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。对于 ALTER VIEW 语句的使用，需要用户具有针对视图的 CREATE VIEW 和 DROP 权限，以及由 SELECT 语句选择的每一列上的某些权限。 修改视图内容视图是一个虚拟表，实际的数据来自于基本表，所以通过插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据。某些视图是可更新的。也就是说，可以使用 UPDATE、DELETE 或 INSERT 等语句更新基本表的内容。对于可更新的视图，视图中的行和基本表的行之间必须具有一对一的关系对视图的修改就是对基本表的修改，因此在修改时，要满足基本表的数据定义视图包含以下结构中的任何一种，它就是不可更新的：聚合函数 SUM()、MIN()、MAX()、COUNT() 等。DISTINCT 关键字。GROUP BY 子句。HAVING 子句。UNION 或 UNION ALL 运算符。位于选择列表中的子查询。FROM 子句中的不可更新视图或包含多个表。WHERE 子句中的子查询，引用 FROM 子句中的表。ALGORITHM 选项为 TEMPTABLE（使用临时表总会使视图成为不可更新的）的时候。实例1：使用 ALTER 语句修改视图 view_students_info。123456789101112131415mysql&gt; ALTER VIEW view_students_info -&gt; AS SELECT id,name,age -&gt; FROM tb_students_info;Query OK, 0 rows affected (0.03 sec)mysql&gt; DESC view_students_info;+-------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+-------+| id | int(11) | NO | | NULL | || name | varchar(255) | YES | | NULL | || age | int(11) | YES | | NULL | |+-------+--------------+------+-----+---------+-------+3 rows in set (0.01 sec)# 用户可以通过视图来插入、更新、删除表中的数据，因为视图是一个虚拟的表，没有数据。通过视图更新时转到基本表上进行更新，如果对视图增加或删除记录，实际上是对基本表增加或删除记录。实例2：使用 UPDATE 语句更新视图 view_students_info。12345678910111213141516mysql&gt; UPDATE view_students_info -&gt; SET age=25 WHERE id=1;Query OK, 0 rows affected (0.05 sec)Rows matched: 1 Changed: 0 Warnings: 0mysql&gt; SELECT * FROM view_students_info;+----+------+------+| id | name | age |+----+------+------+| 1 | peng | 25 || 2 | jun | 12 || 3 | Gui | 44 || 4 | Feng | 32 || 5 | Qi | 22 |+----+------+------+5 rows in set (0.00 sec)修改视图的名称可以先将视图删除，然后按照相同的定义语句进行视图的创建，并命名为新的视图名称。 删除视图(DROP VIEW)删除视图时，只能删除视图的定义，不会删除数据。语法格式：DROP VIEW &lt;视图名1&gt; [ , &lt;视图名2&gt; …]其中：&lt;视图名&gt;指定要删除的视图名。DROP VIEW 语句可以一次删除多个视图，但是必须在每个视图上拥有 DROP 权限。实例：删除 v_students_info 视图。123456mysql&gt; DROP VIEW IF EXISTS v_students_info;Query OK, 0 rows affected (0.00 sec)mysql&gt; SHOW CREATE VIEW v_students_info;ERROR 1146 (42S02): Table 'test.v_students_info' doesn't exist# v_students_info 视图已不存在，将其成功删除。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-数据类型","slug":"SQL-数据类型","date":"2020-04-20T07:33:48.000Z","updated":"2020-04-21T10:47:08.216Z","comments":true,"path":"2020/04/20/SQL-数据类型/","link":"","permalink":"http://forwardpeng.github.io/2020/04/20/SQL-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"数据类型简介数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。大概可以分为5种，分别是整数类型、浮点数类型和定点数类型、日期和时间类型、字符串类型、二进制类型等。 数值类型整数类型包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型包括 FLOAT 和 DOUBLE，定点数类型为 DECIMAL。 日期/时间类型包括YEAR、TIME、DATE、DATETIME和TIMESTAMP。 字符串类型包括CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET等。 二进制类型 整数类型(INT、TINYINT、SMALLINT、MEDIUMINT、BIGINT)整数类型其属性字段可添加AUTO-INCREMENT自增约束条件。类型名称说明存储需求TINYINT很小的整数(-128〜127)1个字节SMALLINT小的整数(-32768〜32767)2个字节MEDIUMINT中等大小的整数( -8388608〜8388607)3个字节INT(INTEGHR)普通大小的整数(-2147483648〜2147483647)4个字节BIGINT大整数(-9223372036854775808〜9223372036854775807)8个字节注意：不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。 小数类型使用浮点数和定点数来表示小数，浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数，取值范围M(1255)；D称为标度，表示小数的位数(130，&lt;= M - 2)。小数类型及其存储需求如下：类型名称说明存储需求有符号的取值范围无符号取值范围FLOAT单精度浮点数4个字节-3.402823466E+38～-1.175494351E-380 和 -1.175494351E-38～-3.402823466E+38。DOUBLE双精度浮点数8 个字节-1.7976931348623157E+308～-2.2250738585072014E-3080 和 -2.2250738585072014E-308～-1.7976931348623157E+308DECIMAL (M, D)，DEC压缩的“严格”定点数M+2 个字节NULLNULL定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。 日期和时间类型(DTAETIME、TIMESTAMP、DATE、TIME、YEAR)日期与时间类型：类型名称日期格式日期范围存储需求YEARYYYY1901-21551个字节TIMEHH:MM:SS-838:59:59 ~ 838:59:593 个字节DATEYYYY-MM-DD1000-01-01~9999-12-33 个字节DATETIMEYYYY-MM-DD HH:MM:SS1000-01-01 00:00:00 ~ 9999-12-31 23:59:598 个字节TIMESTAMPYYYY-MM-DD HH:MM:SS1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC4 个字节 YEAR类型YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示：以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 ‘1901’～’2155’。输入格式为 ‘YYYY’ 或者 YYYY，例如，输入 ‘2010’ 或 2010，插入数据库的值均为 2010。以 2 位字符串格式表示的 YEAR，范围为 ‘00’ 到 ‘99’。‘00’～’69’ 和 ‘70’～’99’ 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。‘0’ 与 ‘00’ 的作用相同。插入超过取值范围的值将被转换为 2000。以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里0值将被转换为0000，而不是2000两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 ‘0’ 或 ‘00’，才可以被正确解释为 3000 TIME类型TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH表示小时，MM表示分钟，SS表示秒。‘D HH：MM：SS’ 格式的字符串。还可以使用这些“非严格”的语法：‘HH：MM：SS’、‘HH：MM’、‘D HH’ 或 ‘SS’。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。‘HHMMSS’ 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，‘101112’ 被理解为’10：11：12’，但是 ‘106112’ 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。注意：如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。TIME值中如果使用冒号则肯定被看作当天的时间， DATE类型DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 ‘YYYY-MM-DD’，其中 YYYY 表示年，MM 表示月，DD 表示日。在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可以 ‘YYYY-MM-DD’ 或者 ‘YYYYMMDD’ 字符中格式表示的日期，取值范围为 ‘1000-01-01’～’9999-12-3’。例如，输入 ‘2015-12-31’ 或者 ‘20151231’，插入数据库的日期为2015-12-31以 ‘YY-MM-DD’ 或者 ‘YYMMDD’ 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：‘00～69’ 范围的年值转换为 ‘20002069’，'7099’ 范围的年值转换为 ‘1970～1999’。例如，输入 ‘15-12-31’，插入数据库的日期为 2015-12-31；输入 ‘991231’，插入数据库的日期为 1999-12-31。以 YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。 DATETIME类型DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 ‘YYYY-MM-DD HH：MM：SS’，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示:以 ‘YYYY-MM-DD HH：MM：SS’ 或者 ‘YYYYMMDDHHMMSS’ 字符串格式表示的日期，取值范围为 ‘1000-01-01 00：00：00’～’9999-12-3 23：59：59’。例如，输入 ‘2014-12-31 05：05：05’ 或者 '20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。以 ‘YY-MM-DD HH：MM：SS’ 或者 ‘YYMMDDHHMMSS’ 字符串格式表示的日期，在这里 YY 表示两位的年值。以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。 TIMESTAMP类型TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 '1970-01-01 00：00：01’UTC～’2038-01-19 03：14：07’UTC。在插入数据时，要保证在合法的取值范围内。DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。 字符串类型(CHAR、VARCHAR、TEXT、ENUM、SET)字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找类型名称说明存储需求CHAR(M)固定长度非二进制字符串M 字节，1&lt;=M&lt;=255VARCHAR(M)变长非二进制字符串L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255TINYTEXT非常小的非二进制字符串L+1字节，在此，L&lt;2^8TEXT小的非二进制字符串L+2字节，在此，L&lt;2^16MEDIUMTEXT中等大小的非二进制字符串L+3字节，在此，L&lt;2^24LONGTEXT大的非二进制字符串L+4字节，在此，L&lt;2^32ENUM枚举类型，只能有一个枚举字符串值1或2个字节，取决于枚举值的数目 (最大值为65535)SET一个设置，字符串对象可以有零个或 多个SET成员1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） CHAR 和 VARCHAR类型CHAR(M)为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255个字符。插入值CHAR(4)存储需求VARCHAR(4)存储需求‘’’ ’4字节‘’1字节‘ab’‘ab’4字节‘ab’3字节‘abc’‘abc’4字节‘abc’4字节‘abcd’‘abcd’4字节‘abcd’5字节‘abcdef’‘avcd’4字节‘abcd’5字节 TEXT类型TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。TINYTEXT 表示长度为255（28-1）字符的TEXT列。TEXT 表示长度为 65535（216-1）字符的TEXT列。MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。 ENUM类型ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：&lt;字段名&gt; ENUM( ‘值1’, ‘值1’, …, ‘值n’ )ENUM值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从1开始编号，MySQL存储的就是这个索引编号，枚举最多可以有65535 个元素。NUM值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL值排在其他所有枚举值前 SET类型SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：SET( ‘值1’, ‘值2’, …, ‘值n’ )SET值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET成员值的尾部空格将自动删除。但与ENUM类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而SET类型的列可从定义的列值中选择多个字符的联合。 二进制类型(BIT、BINARY、VARBINARY、BLOB)支持两类字符型数据：文本字符串和二进制字符串。MySQL中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。 BIT类型位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。BIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为1101，在这里需要位数至少为4位的BIT类型，即可以定义列类型为BIT(4)。大于二进制1111的数据是不能插入BIT(4)类型的字段中的 BINARY和VARBINARY类型BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下：列名称 BINARY(M) 或者 VARBINARY(M)BINARY类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充“\\0”补齐，以达到指定长度。例如，指定列数据类型为BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入ab时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值M。 BLOB类型BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB，它们可容纳值的最大长度不同，如下表所示数据类型存储范围TINYBLOB最大长度为255 (28−12^8-128−1)字节BLOB最大长度为65535 (216−12^{16}-1216−1)字节MEDIUMBLOB最大长度为16777215 (224−12^{24}-1224−1)字节LONGBLOB最大长度为4294967295或4GB (231−12^{31}-1231−1)字节BLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。BLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-查询(二)","slug":"SQL-查询(二)","date":"2020-04-19T14:14:35.000Z","updated":"2020-04-21T13:49:44.286Z","comments":true,"path":"2020/04/19/SQL-查询(二)/","link":"","permalink":"http://forwardpeng.github.io/2020/04/19/SQL-%E6%9F%A5%E8%AF%A2(%E4%BA%8C)/","excerpt":"","text":"子查询子查询指一个查询语句嵌套在另一个查询语句内部的查询，子查询结果作为外层另一个查询的过滤条件，查询可以基于一个表或者多个表。可以添加到 SELECT、UPDATE 和 DELETE 语句中，而且可以进行多层嵌套。子查询也可以使用比较运算符，如“&lt;”、“&lt;=”、“&gt;”、“&gt;=”、“！=”等。 子查询中常见的运算符1.IN子查询关键字 IN 所使用的子查询主要用于判断一个给定值是否存在于子查询的结果集中。其语法格式为：&lt;表达式&gt; [NOT] IN &lt;子查询&gt;语法说明：&lt;表达式&gt;：用于指定表达式。当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回的值正好相反。&lt;子查询&gt;：用于指定子查询。这里的子查询只能返回一列数据。对于比较复杂的查询要求，可以使用 SELECT 语句实现子查询的多层嵌套。2.比较运算符子查询比较运算符所使用的子查询主要用于对表达式的值和子查询返回的值进行比较运算，语法格式为：&lt;表达式&gt; {= | &lt; | &gt; | &gt;= | &lt;= | &lt;=&gt; | &lt; &gt; | != }{ ALL | SOME | ANY} &lt;子查询&gt;语法说明如下：&lt;子查询&gt;：用于指定子查询。&lt;表达式&gt;：用于指定要进行比较的表达式。ALL、SOME 和 ANY：可选项。用于指定对比较运算的限制。其中，关键字 ALL 用于指定表达式需要与子查询结果集中的每个值都进行比较，当表达式与每个值都满足比较关系时，会返回 TRUE，否则返回 FALSE；关键字 SOME 和 ANY 是同义词，表示表达式只要与子查询结果集中的某个值满足比较关系，就返回 TRUE，否则返回 FALSE。3.EXIST子查询关键字 EXIST 所使用的子查询主要用于判断子查询的结果集是否为空。其语法格式为：EXIST &lt;子查询&gt;若子查询的结果集不为空，则返回 TRUE；否则返回 FALSE。 子查询的应用实例1：先执行内层子查询，再执行外层查询，内层子查询的结果作为外部查询的比较条件。12345678910mysql&gt; select name from tb_students_info where dept_id in (select idept_id from tb_departments where dept_type='A');+------+| name |+------+| peng || jun || Gui || Feng |+------+4 rows in set (0.00 sec)。实例2：在 tb_departments 表中查询 dept_name 等于“Computer”的学院 id，然后在 tb_students_info 表中查询所有该学院的学生的姓名1234567891011mysql&gt; select name from tb_students_info -&gt; where dept_id= -&gt; (select idept_id -&gt; from tb_departments -&gt; where dept_name='Computer');+------+| name |+------+| Gui |+------+1 row in set (0.00 sec)实例3：查询的dept_name不等于’Computer’的学院id，然后查询学生姓名。1234567891011121314mysql&gt; select name from tb_students_info -&gt; where dept_id &lt;&gt; -&gt; (select idept_id -&gt; from tb_departments -&gt; where dept_name='Computer');+------+| name |+------+| peng || jun || Feng || Qi |+------+4 rows in set (0.00 sec) 分组查询(GROUP BY)使用 GROUP BY 子句，将结果集中的数据行根据选择列的值进行逻辑分组，以便能汇总表内容的子集，实现对每个组而不是对整个结果集进行整合。语法格式：GROUP BY { &lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt; } [ASC | DESC]语法说明：&lt;列名&gt;：指定用于分组的列。可以指定多个列，彼此间用逗号分隔。&lt;表达式&gt;：指定用于分组的表达式。通常与聚合函数一块使用，例如可将表达式 COUNT(*)AS’人数’ 作为 SELECT 选择列表清单的一项。&lt;位置&gt;：指定用于分组的选择列在 SELECT 语句结果集中的位置，通常是一个正整数。例如，GROUP BY 2 表示根据 SELECT 语句列清单上的第 2 列的值进行逻辑分组。ASC|DESC：关键字 ASC 表示按升序分组，关键字 DESC 表示按降序分组，其中 ASC 为默认值，注意这两个关键字必须位于对应的列名、表达式、列的位置之后。使用GROUP BY子句时注意：GROUP BY 子句可以包含任意数目的列，使其可以对分组进行嵌套，为数据分组提供更加细致的控制。GROUP BY 子句列出的每个列都必须是检索列或有效的表达式，但不能是聚合函数。若在 SELECT 语句中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。除聚合函数之外，SELECT 语句中的每个列都必须在 GROUP BY 子句中给出。若用于分组的列中包含有 NULL 值，则 NULL 将作为一个单独的分组返回；若该列中存在多个 NULL 值，则将这些 NULL 值所在的行分为一组。实例：据 dept_id 对 tb_students_info 表中的数据进行分组，将每个学院的学生姓名显示出来123456789mysql&gt; select dept_id,GROUP_CONCAT(name) AS names FROM tb_students_info group by dept_id;+---------+---------------+| dept_id | names |+---------+---------------+| 0 | Qi || 1 | Gui || 2 | peng,jun,Feng |+---------+---------------+3 rows in set (0.00 sec) 指定过滤条件(HAVING)使用 HAVING 子句过滤分组，在结果集中规定了包含哪些分组和排除哪些分组。语法格式：HAVING &lt;条件&gt;HAVING 子句和 WHERE 子句非常相似，HAVING 子句支持 WHERE 子句中所有的操作符和语法，存在的差异如下：WHERE 子句主要用于过滤数据行，而 HAVING 子句主要用于过滤分组，即 HAVING 子句基于分组的聚合值而不是特定行的值来过滤数据，主要用来过滤分组。WHERE 子句不可以包含聚合函数，HAVING 子句中的条件可以包含聚合函数。HAVING 子句是在数据分组后进行过滤，WHERE 子句会在数据分组前进行过滤。WHERE 子句排除的行不包含在分组中，可能会影响 HAVING 子句基于这些值过滤掉的分组。实例：根据 dept_id 对 tb_students_info 表中的数据进行分组，并显示学生人数大于1的分组信息，1234567mysql&gt; SELECT dept_id,group_concat(name) as names from tb_students_info group by dept_id having count(name)&gt;1;+---------+---------------+| dept_id | names |+---------+---------------+| 2 | peng,jun,Feng |+---------+---------------+1 row in set (0.00 sec) 正则表达式查询(REGEXP)正则表达式通常被用来检索或替换符合某个模式的文本内容，根据指定的匹配模式匹配文中符合要求的特殊字符串。选项说明例子匹配值实例^匹配文本的开始字符‘^b’ 匹配以字母 b 开头 的字符串book、big、banana、 bike$匹配文本的结果字符'st$’ 匹配以 st 结尾的字 符串中等文本test、resist、persist.匹配任何单个字符'b.t’ 匹配任何 b 和 t 之间有一个字符bit、bat、but、bite*匹配零个或多个在它前面的字符'f*n’ 匹配字符 n 前面有 任意个字符 ffn、fan、faan、abcn+匹配前面的字符 1 次或多次''ba+’ 匹配以 b 开头，后 面至少紧跟一个 aba、bay、bare、battle&lt;字符串&gt;匹配包含指定字符的文本'fa’fan、afa、faad[字符集合]匹配字符集合中的任何一个字 符'[xz]'匹配 x 或者 zdizzy、zebra、x-ray、 extra[^]匹配不在括号中的任何字符'[^abc]’ 匹配任何不包 含 a、b 或 c 的字符串desk、fox、f8ke字符串{n,}匹配前面的字符串至少 n 次b{2} 匹配 2 个或更多 的 bbbb、 bbbb、 bbbbbbb{n,m}匹配前面的字符串至少 n 次， 至多 m 次b{2,4} 匹配最少 2 个， 最多 4 个 bbbb、 bbbb实例1：字符“^”匹配以特定字符或者字符串开头的文本。查询 dept_name 字段以字母“C”开头的记录123456789mysql&gt; select * from tb_departments -&gt; where dept_name REGEXP '^C';+----------+-----------+-----------+| idept_id | dept_name | dept_type |+----------+-----------+-----------+| 1 | Computer | A || 2 | Chinese | A |+----------+-----------+-----------+2 rows in set (0.00 sec)实例2：用符号“.”代替字符串中的任意一个字符。查询 dept_name 字段值包含字母“o”与字母“y”，且两个字母之间只有一个字母的记录123456789mysql&gt; select * from tb_departments -&gt; where dept_name regexp 'o.y';+----------+-----------+-----------+| idept_id | dept_name | dept_type |+----------+-----------+-----------+| 4 | Economy | B || 5 | History | A |+----------+-----------+-----------+2 rows in set (0.00 sec)实例3：查询 dept_name 字段值包含字符串“in”或者“on”的记录123456789mysql&gt; SELECT * FROM tb_departments -&gt; WHERE dept_name REGEXP 'in|on';+---------+-----------+-----------+-----------+| dept_id | dept_name | dept_call | dept_type |+---------+-----------+-----------+-----------+| 3 | Chinese | 3 | B || 4 | Economy | 4 | B |+---------+-----------+-----------+-----------+2 rows in set (0.00 sec实例3：匹配指定字符串。查询 dept_name 字段值包含字符串“in”或者“on”的记录。123456789mysql&gt; SELECT * FROM tb_departments -&gt; WHERE dept_name REGEXP 'in|on';+---------+-----------+-----------+-----------+| dept_id | dept_name | dept_call | dept_type |+---------+-----------+-----------+-----------+| 3 | Chinese | 33333 | B || 4 | Economy | 44444 | B |+---------+-----------+-----------+-----------+2 rows in set (0.00 sec)实例4:匹配不在指定集合中的任何字符。查询 dept_name 字段值包含字母 a~t 以外的字符的记录。12345678910mysql&gt; SELECT * FROM tb_departments -&gt; WHERE dept_name REGEXP '[^a-t]';+---------+-----------+-----------+-----------+| dept_id | dept_name | dept_call | dept_type |+---------+-----------+-----------+-----------+| 1 | Computer | 11111 | A || 4 | Economy | 44444 | B || 5 | History | 55555 | B |+---------+-----------+-----------+-----------+3 rows in set (0.00 sec)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-查询(一)","slug":"SQL-查询(一)","date":"2020-04-18T09:49:11.000Z","updated":"2020-04-21T10:46:32.384Z","comments":true,"path":"2020/04/18/SQL-查询(一)/","link":"","permalink":"http://forwardpeng.github.io/2020/04/18/SQL-%E6%9F%A5%E8%AF%A2(%E4%B8%80)/","excerpt":"","text":"查询数据表SELECT 语句来查询数据。查询数据是指从数据库中根据需求，使用不同的查询方式来获取不同的数据，是使用频率最高、最重要的操作。语法格式如下：SELECT {* | &lt;字段列名&gt;} [ FROM &lt;表 1&gt;, &lt;表 2&gt;… [WHERE &lt;表达式&gt; [GROUP BY &lt;group by definition&gt; [HAVING &lt;expression&gt; [{&lt;operator&gt; &lt;expression&gt;}…]] [ORDER BY &lt;order by definition&gt;] [LIMIT[&lt;offset&gt;,] &lt;row count&gt;] ]其中，各条子句说明如下：{*|&lt;字段列名&gt;}包含星号通配符的字段列表，表示所要查询字段的名称。&lt;表1&gt;，&lt;表2&gt;…，表1和表2表示查询数据的来源，可以是单个或多个。WHERE&lt;表达式&gt;是可选项，如果选择该项，将限定查询数据必须满足该查询条件。GROUP BY&lt;字段&gt;，该子句告诉数据库如何显示查询出来的数据，并按照指定的字段分组。ORDER BY&lt; 字段 &gt;]，按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC），默认情况下是升序。[LIMIT[&lt;offset&gt;，]&lt;row count&gt;]，该子句告诉 MySQL 每次显示查询出来的数据条数。 查询表中所有字段1. 使用&quot;*&quot;查询表的所有字段语法格式如下：SELECT * FROM 表名;2. 列出表的所有字段SELECT关键字后面的字段名为需要查找的字段，可以使用 DESC 命令查看表的结构。 查询表中指定的字段查询表中的某一个字段的语法格式为：SELECT &lt; 列名 &gt; FROM &lt; 表名 &gt;;123456789mysql&gt; SELECT name FROM tb_students_info;+--------+| name |+--------+| Dany || Thomas || Tom |+--------+10 rows in set (0.00 sec) 去重(过滤重复数据)使用DISTINCT关键字指示 数据库消除重复的记录值。语法格式为：SELECT DISTINCT &lt;字段名&gt; FROM &lt;表名&gt;; 设置别名 为表指定别名当数据表名很长或者执行一些特殊查询的时候，为了方便操作，可以为表指定一个别名，语法格式为：&lt;表名&gt; [AS] &lt;别名&gt;使用示例如下：1234567mysql&gt; SELECT stu.name,stu.height FROM tb_students_info AS stu;+--------+--------+| name | height |+--------+--------+| Dany | 160 || Green | 158 |2 rows in set (0.04 sec) 为字段指定别名每个 SELECT 后面指定输出的字段。有时为了显示结果更加直观，可以为字段指定一个别名。基本语法格式：&lt;字段名&gt; [AS] &lt;别名&gt;使用示例如下：123456mysql&gt; SELECT name AS student_name, age AS student_age FROM tb_students_info;+--------------+-------------+| student_name | student_age |+--------------+-------------+| Dany | 25 || Green | 23 | 限制查询结果的记录条数SELECT语句时往往返回的是所有匹配的行，有些时候我们仅需要返回第一行或者前几行，这时候就需要用到数据库LIMT子句基本的语法格式：&lt;LIMIT&gt; [&lt;位置偏移量&gt;,] &lt;行数&gt;LIMIT接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。1234567mysql&gt; select * from tb_students_info limit 1, 2;+----+------+---------+------+------+--------+---------------------+| id | name | dept_id | age | sex | height | login_date |+----+------+---------+------+------+--------+---------------------+| 2 | jun | 2 | 12 | F | 222 | 1000-01-01 00:00:01 |+----+------+---------+------+------+--------+---------------------+1 row in set (0.00 sec) 对查询结果进行排序ORDER BY 子句主要用来将结果集中的数据按照一定的顺序进行排序。语法格式：ORDER BY {&lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt;} [ASC|DESC]语法说明如下：列名：指定用于排序的列。可以指定多个列，列名之间用逗号分隔。表达式：指定用于排序的表达式。位置：指定用于排序的列在SELECT语句结果集中的位置，通常是正整数。ASC|DESC：关键字 ASC 表示按升序分组，关键字 DESC 表示按降序分组，其中 ASC 为默认值。这两个关键字必须位于对应的列名、表达式、列的位置之后。使用示例如下：1234567891011121314mysql&gt; select * from tb_students_info ORDER by age;+----+------+---------+------+------+--------+---------------------+| id | name | dept_id | age | sex | height | login_date |+----+------+---------+------+------+--------+---------------------+| 2 | jun | 2 | 12 | F | 222 | 1000-01-01 00:00:01 || 1 | peng | 2 | 25 | F | 222 | 1000-01-01 00:00:00 |+----+------+---------+------+------+--------+---------------------+2 rows in set (0.00 sec)mysql&gt; SELECT name,height FROM tb_student_info ORDER BY height DESC,name ASC;+--------+--------+| name | height |+--------+--------+| Henry | 185 || Thomas | 178 |注意：DESC 关键字只对前面的列进行降序排列，在这里只对 height 排序，而并没有对 name 进行排序，因此，height 按降序排序，而 name 仍按升序排序，如果要对多列进行降序排序，必须要在每一列的后面加 DESC 关键字。 条件查询使用 WHERE 子句来指定查询条件，从 FROM 子句的中间结果中选取适当的数据行，达到数据过滤的效果。语法格式：WHERE &lt;查询条件&gt; {&lt;判定运算1&gt;，&lt;判定运算2&gt;，…}运算的语法分类如下：&lt;表达式1&gt;{=|&lt;|&lt;=|&gt;|&gt;=|&lt;=&gt;|&lt;&gt;|！=}&lt;表达式2&gt;&lt;表达式1&gt;[NOT]LIKE&lt;表达式2&gt;&lt;表达式1&gt;[NOT][REGEXP|RLIKE]&lt;表达式2&gt;&lt;表达式1&gt;[NOT]BETWEEN&lt;表达式2&gt;AND&lt;表达式3&gt;&lt;表达式1&gt;IS[NOT]NULL 单一条件的查询语句语句采用简单的相等过滤，使用示例如下：12345678910mysql&gt; select name, age -&gt; from tb_students_info -&gt; where age&lt;=25;+------+------+| name | age |+------+------+| peng | 25 || jun | 12 |+------+------+2 rows in set (0.00 sec) 多条件的查询语句SQL在WHERE子句中使用AND操作符限定只有满足所有查询条件的记录才会被返回。使用示例如下：12345678910mysql&gt; select * from tb_students_info -&gt; where age&lt;35 and height &gt;170;+----+------+---------+------+------+--------+---------------------+| id | name | dept_id | age | sex | height | login_date |+----+------+---------+------+------+--------+---------------------+| 1 | peng | 2 | 25 | F | 222 | 1000-01-01 00:00:00 || 2 | jun | 2 | 12 | F | 222 | 1000-01-01 00:00:01 || 4 | Feng | 2 | 32 | F | 175 | 1000-01-01 00:00:01 |+----+------+---------+------+------+--------+---------------------+3 rows in set (0.00 sec) 使用LIKE的模糊查询字符串匹配语法格式：&lt;表达式1&gt; [NOT] LIKE &lt;表达式2&gt;相互间进行匹配运算的对象可以是CHAR、VARCHAR、TEXT、DATETIME 等数据类型。运算返回的结果是 TRUE 或 FALSE。通配符如下：1.百分号(%)百分号可以表示任何字符串，并且该字符串可以出现任意次。使用示例如下：1234567891011mysql&gt; SELECT name FROM tb_students_info -&gt; WHERE name LIKE '%e%';+-------+| name |+-------+| Green || Henry || Jane |+-------+3 rows in set (0.00 sec)# 查找所有包含“e”字母的学生姓名sql默认不区分大小写，除非更换字符集的校对规则百分号不匹配空值百分号可以代表搜索模式中给定位置的 0 个、1 个或多个字符。尾空格可能会干扰通配符的匹配，一般可以在搜索模式的最后附加一个百分号。2.下划线(_)下画线只匹配单个字符，而不是多个字符，也不是 0 个字符。123456789mysql&gt; SELECT name FROM tb_students_info -&gt; WHERE name LIKE '____y';+-------+| name |+-------+| Henry |+-------+1 row in set (0.00 sec)# 查找所有以字母“y”结尾，且“y”前面只有 4 个字母 日期字段作为条件的查询语句以日期字段作为条件，可以使用比较运算符设置查询条件，也可以使用 BETWEEN AND 运算符查询某个范围内的值。使用示例如下：1234567mysql&gt; SELECT * FROM tb_students_info -&gt; WHERE login_date&lt;'2016-01-01';+----+-------+---------+------+------+--------+------------+| id | name | dept_id | age | sex | height | login_date |+----+-------+---------+------+------+--------+------------+| 1 | Dany | 1 | 25 | F | 160 | 2015-09-10 || 3 | Henry | 2 | 23 | M | 185 | 2015-05-31 | 内连接查询(INNER JOIN)利用条件表达式来消除交叉连接的某些数据行。关键字 INNER JOIN 连接两张表，并使用 ON 子句来设置连接条件。如果没有任何条件，INNER JOIN 和 CROSS JOIN 在语法上是等同的。语法格式：SELECT &lt;列名1，列名2 …&gt;FROM &lt;表名1&gt; INNER JOIN &lt;表名2&gt; [ ON子句]语法说明如下：&lt;列名1，列名2…&gt;：需要检索的列名。&lt;表名1&gt;&lt;表名2&gt;：进行内连接的两张表的表名。123456789mysql&gt; SELECT id,name,age,dept_name -&gt; FROM tb_students_info,tb_departments -&gt; WHERE tb_students_info.dept_id=tb_departments.dept_id;+----+--------+------+-----------+| id | name | age | dept_name |+----+--------+------+-----------+| 1 | Dany | 25 | Computer || 2 | Green | 23 | Chinese || 3 | Henry | 23 | MathSELECT后面指定的列分别属于两个不同的表，id、name、age在表tb_students_info中，dept_name在表tb_departments。12345678910mysql&gt; SELECT id,name,age,dept_name -&gt; FROM tb_students_info INNER JOIN tb_departments -&gt; WHERE tb_students_info.dept_id=tb_departments.dept_id;+----+--------+------+-----------+| id | name | age | dept_name |+----+--------+------+-----------+| 1 | Dany | 25 | Computer || 2 | Green | 23 | Chinese || 3 | Henry | 23 | Math |# 使用INNER JOIN语法进行内连接查询 外连接查询(LEFT/RIGHT JOIN)外连接更加注重两张表之间的关系。按照连接表的顺序，可以分为左外连接和右外连接。左外连接又称为左连接，在 FROM 子句中使用关键字 LEFT OUTER JOIN 或者 LEFT JOIN，用于接收该关键字左表（基表）的所有行，并用这些行与该关键字右表（参考表）中的行进行匹配，即匹配左表中的每一行及右表中符合条件的行。除了匹配的行之外，还包括左表中有但在右表中不匹配的行，对于这样的行，从右表中选择的列的值被设置为 NULL，即左外连接的结果集中的 NULL 值表示右表中没有找到与左表相符的记录。123456789101112131415mysql&gt; SELECT name,dept_name -&gt; FROM tb_students_info s -&gt; LEFT OUTER JOIN tb_departments d -&gt; ON s.dept_id=d.idept_id;+------+-----------+| name | dept_name |+------+-----------+| peng | Chinese || jun | Chinese || Gui | Computer || Feng | Chinese || Qi | NULL |+------+-----------+5 rows in set (0.00 sec)# 学生Qi在tb_departments表中取出的值为 NULL。右外连接又称为右连接，在 FROM 子句中使用 RIGHT OUTER JOIN 或者 RIGHT JOIN。与左外连接相反，右外连接以右表为基表，连接方法和左外连接相同。在右外连接的结果集中，除了匹配的行外，还包括右表中有但在左表中不匹配的行，对于这样的行，从左表中选择的值被设置为 NULL。1234567891011121314mysql&gt; Select name,dept_name from tb_students_info s right outer join tb_departments d on s.dept_id=d.idept_id;+------+-----------+| name | dept_name |+------+-----------+| peng | Chinese || jun | Chinese || Gui | Computer || Feng | Chinese || NULL | Math || NULL | Economy || NULL | History |+------+-----------+7 rows in set (0.00 sec)# 从 tb_students_info 表中取出的值为 NULL。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-索引","slug":"SQL-索引","date":"2020-04-16T12:02:11.000Z","updated":"2020-04-22T06:57:36.270Z","comments":true,"path":"2020/04/16/SQL-索引/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/SQL-%E7%B4%A2%E5%BC%95/","excerpt":"","text":"索引简介索引是 MySQL 中一种十分重要的数据库对象。它是数据库性能调优技术的基础，常用于实现数据的快速检索。索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表。1.顺序访问顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。这种方式实现比较简单，但是当表中有大量数据的时候，效率非常低下。例如，在几千万条数据中查找少量的数据时，使用顺序访问方式将会遍历所有的数据，花费大量的时间，显然会影响数据库的处理性能。2.索引访问索引访问是通过遍历索引来直接访问表中记录行的方式。使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。 索引的分类索引的类型和存储引擎有关，每种存储引擎所支持的索引类型不一定完全相同。根据存储方式的不同，MySQL中常用的索引在物理上分为以下两类。B-树索引B-树索引又称为 BTREE 索引，目前大部分的索引都是采用 B-树索引来存储的。B-树索引是一个典型的数据结构，其包含的组件主要有以下几个：叶子节点：包含的条目直接指向表里的数据行。叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。分支节点：包含的条目指向索引里其他的分支节点或者叶子节点。根节点：一个 B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。表中的每一行都会在索引上有一个对应值。因此，在表中进行数据查询时，可以根据索引值一步一步定位到数据所在的行。B-树索引可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行 ORDER BY排序。但B-树索引必须遵循左边前缀原则，要考虑以下几点约束：查询必须从索引的最左边的列开始。查询不能跳过某一索引列，必须按照从左到右的顺序进行匹配。存储引擎不能使用索引中范围条件右边的列。哈希索引哈希通过散列算法变换成固定长度的输出，该输出就是散列值。哈希索引也称为散列索引或 HASH 索引。MySQL目前仅有MEMORY存储引擎和HEAP存储引擎支持这类索引。其中，MEMORY存储引擎可以支持B-树索引和HASH索引，且将HASH当成默认索引。HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B- 树索引来说，建立哈希索引会耗费更多的时间。不能使用HASH索引排序HASH 索引只支持等值比较，如“=”“IN()”或“&lt;=&gt;”HASH索引不支持键的部分匹配，因为在计算HASH值的时候是通过整个索引值来计算的MySQL中的索引在逻辑上分为以下5 类：普通索引：普通索引是最基本的索引类型，唯一任务是加快对数据的访问速度，没有任何限制。创建普通索引时，通常使用的关键字是INDEX或 KEY。唯一性索引：唯一性索引是不允许索引列具有相同索引值的索引。如果能确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一性索引。创建唯一性索引的目的往往不是为了提高访问速度，而是为了避免数据出现重复。主键索引：主键索引是一种唯一性索引，即不允许值重复或者值为空，并且每个表只能有一个主键。主键可以在创建表的时候指定，也可以通过修改表的方式添加，必须指定关键字 PRIMARY KEY。每个表只能有一个主键空间索引：空间索引主要用于地理空间数据类型 GEOMETRY。全文索引：全文索引只能在 VARCHAR 或 TEXT 类型的列上创建，并且只能在 MyISAM 表中创建。索引在逻辑上分为以上 5 类，但在实际使用中，索引通常被创建成单列索引和组合索引。单列索引就是索引只包含原表的一个列；组合索引也称为复合索引或多列索引，相对于单列索引来说，组合索引是将原表的多个列共同组成一个索引。为了提高索引的应用性能，MySQL中的索引可以根据具体应用采用不同的索引策略。这些索引策略所对应的索引类型有聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引等 索引的使用原则和注意事项虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下弊端：创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。索引可以在一些情况下加速查询，但是在某些情况下，会降低效率。索引只是提高效率的一个因素，因此在建立索引的时候应该遵循以下原则：在经常需要搜索的列上建立索引，可以加快搜索的速度。在作为主键的列上创建索引，强制该列的唯一性，并组织表中数据的排列结构。在经常使用表连接的列上创建索引，这些列主要是一些外键，可以加快表连接的速度。在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，所以其指定的范围是连续的。在经常需要排序的列上创建索引，因为索引已经排序，所以查询时可以利用索引的排序，加快排序查询在经常使用WHERE子句的列上创建索引，加快条件的判断速度。在某些应用场合下建立索引不能提高 MySQL的工作效率，甚至降低了数据库的工作效率，一般来说不适合创建索引的环境如下：对于那些在查询中很少使用或参考的列不应该创建索引。因为这些列很少使用到，所以有索引或者无索引并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，并增大了空间要求。对于那些只有很少数据值的列也不应该创建索引。因为这些列的取值很少，例如人事表的性别列。查询结果集的数据行占了表中数据行的很大比例，增加索引并不能明显加快检索速度。对于那些定义为 TEXT、IMAGE 和 BIT 数据类型的列不应该创建索引。因为这些列的数据量要么相当大，要么取值很少。当修改性能远远大于检索性能时，不应该创建索引。因为修改性能和检索性能是互相矛盾的。当创建索引时，会提高检索性能，降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 创建索引(CREATE INDEX)索引的建立对于数据库的高效运行是很重要的，索引可以大大提升SQL的检索速度。 基本语法MySQL提供三种创建索引的方法：1.使用CREATE INDEX语句使用专门用于创建索引的 CREATE INDEX 语句在一个已有的表上创建索引，但该语句不能创建主键。语法格式：CREATE &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;长度&gt;] [ ASC | DESC])语法说明：&lt;索引名&gt;：指定索引名。一个表可以创建多个索引，但每个索引在该表中的名称是唯一的.&lt;表名&gt;：指定要创建索引的表名。&lt;列名&gt;：指定要创建索引的列名。通常可以考虑将查询语句中在 JOIN 子句和 WHERE 子句里经常出现的列作为索引列。&lt;列名&gt;：指定要创建索引的列名。通常可以考虑将查询语句中在 JOIN 子句和 WHERE 子句里经常出现的列作为索引列。ASC|DESC：可选项。ASC指定索引按照升序来排列，DESC指定索引按照降序来排列，默认为ASC.2.使用CREATE TABLE语句索引也可以在创建表（CREATE TABLE）的同时创建。在 CREATE TABLE 语句中添加以下语句。语法格式：CONSTRAINT PRIMARY KEY [索引类型] (&lt;列名&gt;,…)在CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的主键。语法格式1：KEY | INDEX [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)在 CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的索引。语法格式2：UNIQUE [ INDEX | KEY] [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)在 CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的唯一性索引。语法格式3：FOREIGN KEY &lt;索引名&gt; &lt;列名&gt;在 CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的外键。3.使用ALTER TABLE语句CREATE INDEX 语句可以在一个已有的表上创建索引，ALTER TABLE 语句也可以在一个已有的表上创建索引。在使用 ALTER TABLE 语句修改表的同时，可以向已有的表添加索引。具体的做法是在 ALTER TABLE 语句中添加以下语法成分的某一项或几项。语法格式1：ADD INDEX [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加索引。语法格式2：ADD PRIMARY KEY [&lt;索引类型&gt;] (&lt;列名&gt;,…)在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加主键。语法格式3：ADD UNIQUE [ INDEX | KEY] [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加唯一性索引。语法格式4：ADD FOREIGN KEY [&lt;索引名&gt;] (&lt;列名&gt;,…)在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加外键 创建一般索引实例1：创建一个表 tb_stu_info，在该表的 height 字段创建一般索引。输入的 SQL 语句和执行过程如下所示。1234567891011121314151617181920212223mysql&gt; create table tb_stu_info -&gt; ( -&gt; id INT NOT NULL, -&gt; nam CHAR(45) DEFAULT NULL, -&gt; dept_id INT DEFAULT NULL\\ -&gt; ,age INT DEFAULT NULL, -&gt; height INT DEFAULT NULL, -&gt; INDEX(height) -&gt; );Query OK, 0 rows affected (0.30 sec)mysql&gt; show create table tb_stu_info\\G*************************** 1. row *************************** Table: tb_stu_infoCreate Table: CREATE TABLE `tb_stu_info` ( `id` int(11) NOT NULL, `nam` char(45) DEFAULT NULL, `dept_id` int(11) DEFAULT NULL, `age` int(11) DEFAULT NULL, `height` int(11) DEFAULT NULL, KEY `height` (`height`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) 创建唯一索引实例2：创建一个表 tb_stu_info2，在该表的 id 字段上使用 UNIQUE 关键字创建唯一索引。1234567891011121314151617181920212223mysql&gt; CREATE TABLE tb_stu_info2 -&gt; ( -&gt; id INT NOT NULL, -&gt; name CHAR(45) DEFAULT NULL, -&gt; dept_id INT DEFAULT NULL, -&gt; age INT DEFAULT NULL, -&gt; height INT DEFAULT NULL, -&gt; UNIQUE INDEX(height) -&gt; );Query OK, 0 rows affected (0.29 sec)mysql&gt; SHOW CREATE TABLE tb_stu_info2\\G*************************** 1. row *************************** Table: tb_stu_info2Create Table: CREATE TABLE `tb_stu_info2` ( `id` int(11) NOT NULL, `name` char(45) DEFAULT NULL, `dept_id` int(11) DEFAULT NULL, `age` int(11) DEFAULT NULL, `height` int(11) DEFAULT NULL, UNIQUE KEY `height` (`height`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) 查看索引查看已创建的索引的情况，可以使用 SHOW INDEX 语句查看表中创建的索引。语法格式：SHOW INDEX FROM &lt;表名&gt; [ FROM &lt;数据库名&gt;]语法说明：&lt;表名&gt;：要显示索引的表。&lt;数据库名&gt;：要显示的表所在的数据库。12mysql&gt; SHOW INDEX FROM course FROM mytest;# 显示数据库mytest的表course的索引情况显示字段说明如下：Table：表的名称。Non_unique：用于显示该索引是否是唯一索引。若不是唯一索引，则该列的值显示为 1；若是唯一索引，则该列的值显示为 0。Key_name：索引的名称。Seq_in_index：索引中的列序列号，从 1 开始计数。Column_name：列名称。Collation：显示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。Cardinality：显示索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。Sub_part：若列只是被部分编入索引，则为被编入索引的字符的数目。若整列被编入索引，则为 NULL。Packed：指示关键字如何被压缩。若没有被压缩，则为 NULL。Null：用于显示索引列中是否包含 NULL。若列含有 NULL，则显示为 YES。若没有，则该列显示为 NO。Index_type：显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。Comment：显示评注。实例：使用 SHOW INDEX 语句查看表 tb_stu_info2 的索引信息12345678910111213141516mysql&gt; SHOW INDEX FROM tb_stu_info2\\G*************************** 1. row *************************** Table: tb_stu_info2 Non_unique: 0 Key_name: height Seq_in_index: 1 Column_name: height Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: YES Index_type: BTREE Comment: Index_comment: 1 row in set (0.00 sec) 修改和删除索引(DROP INDEX)当不再需要索引时，可以使用 DROP INDEX 语句或 ALTER TABLE 语句来对索引进行删除。1.使用DROP INDEX语句语法格式：DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;语法说明：&lt;索引名&gt;：要删除的索引名&lt;表名&gt;：指定该索引所在的表名2.使用ALTER TABLE语句根据 ALTER TABLE 语句的语法可知，该语句也可以用于删除索引。具体使用方法是将 ALTER TABLE 语句的语法中部分指定为以下子句中的某一项。DROP PRIMARY KEY：表示删除表中的主键。一个表只有一个主键，主键也是一个索引。DROP INDEX index_name：表示删除名称为 index_name 的索引。DROP FOREIGN KEY fk_symbol：表示删除外键。 删除索引实例：删除表tb_stu_info中的索引12345678910111213141516mysql&gt; DROP INDEX height -&gt; on tb_stu_info;Query OK, 0 rows affected (0.20 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; show create table tb_stu_info\\G*************************** 1. row *************************** Table: tb_stu_infoCreate Table: CREATE TABLE `tb_stu_info` ( `id` int(11) NOT NULL, `nam` char(45) DEFAULT NULL, `dept_id` int(11) DEFAULT NULL, `age` int(11) DEFAULT NULL, `height` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-数据操作语言(DML)","slug":"SQL-数据操作语言","date":"2020-04-16T10:05:27.000Z","updated":"2020-04-21T10:46:52.760Z","comments":true,"path":"2020/04/16/SQL-数据操作语言/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/SQL-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/","excerpt":"","text":"INSERT INTO-向数据库表中插入数据INSERT语句有两种语法形式，分别是INSERT…VALUES语句和INSERT…SET语句。1. INSERT…VALUES的语法格式为：INSERT INTO &lt;表名&gt; [ &lt;列名1&gt; [ , … &lt;列名n&gt;] ]VALUES (值1) [… , (值n) ];语法说明如下：&lt;表名&gt;：指定被操作的表名。&lt;列名&gt;：指定需要插入数据的列名。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用 INSERT&lt;表名&gt;VALUES(…) 即可。VALUES 或 VALUE 子句：该子句包含要插入的数据清单。数据清单中数据的顺序要和列的顺序相对应。2. INSERT…SET的语法格式为：INSERT INTO &lt;表名&gt;SET &lt;列名1&gt; = &lt;值1&gt;,&lt;列名2&gt; = &lt;值2&gt;,…此语句用于给表中的某些列指定对应的列值，即要插入的数据的列名在SET子句中指定，col_name为指定的列名，等号后面为指定的数据，而对于未指定的列，列值会指定为该列的默认值。INSERT语句的两种形式可是看出：使用 INSERT…VALUES 语句可以向表中插入一行数据，也可以插入多行数据；使用 INSERT…SET 语句可以指定插入行中每列的值，也可以指定部分列的值；INSERT…SELECT 语句向表中插入其他表的数据。采用 INSERT…SET 语句可以向表中插入部分列的值，这种方式更为灵活；NSERT…VALUES 语句可以一次插入多条数据。 向表中的全部字段添加值插入数据时，指定表的所有字段，为每一个字段插入新的值。123456789101112mysql&gt; INSERT INTO tb_courses -&gt; (course_id, course_name, course_grade, course_info) -&gt; values(1, 'Math', 3, 'Computer Math');Query OK, 1 row affected (0.04 sec)mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | Math | 3 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.00 sec)使用INSERT插入数据，允许列名称顺序与定义不同，必须保证值顺序与列字段顺序相同。允许列名称为空，插入顺序必须与数据表中定义的顺序相同。 表中指定字段添加值表的指定字段插入数据，是在 INSERT 语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值，示例如下：12345678910111213mysql&gt; insert into tb_courses -&gt; (course_name, course_grade, course_info) -&gt; values('System',3,'Operation System');Query OK, 1 row affected (0.04 sec)mysql&gt; select * from tb_courses;+-----------+-------------+--------------+------------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+------------------+| 1 | Math | 3 | Computer Math || 2 | System | 3 | Operation System |+-----------+-------------+--------------+------------------+2 rows in set (0.00 sec) INSERT INTO…FROM语句复制表数据SELECT子句返回的是一个查询到的结果集，INSERT语句将这个结果集插入指定表中，结果集中的每行数据的字段数、字段的数据类型都必须与被操作的表完全一致。使用示例如下：123456789101112131415mysql&gt; INSERT INTO tb_courses_new -&gt; (course_id, course_name, course_grade, course_info) -&gt; SELECT course_id, course_name, course_grade, course_info -&gt; FROM tb_courses;Query OK, 2 rows affected (0.05 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from tb_courses_new;+-----------+-------------+--------------+------------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+------------------+| 1 | Math | 3 | Computer Math || 2 | System | 3 | Operation System |+-----------+-------------+--------------+------------------+2 rows in set (0.00 sec) DELETE-从数据库表中删除数据SQL中使用DELETE语句来删除表的一行或者多行数据。 删除单个表中的数据DELETE语句从单个表中删除数据语法格式:DELETE FROM &lt;表名&gt; [WHERE 子句] [ORDER BY 子句] [LIMIT 子句]语法说明如下：&lt;表名&gt;：指定要删除数据的表名。ORDER BY 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。WHERE 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。LIMIT 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。使用示例如下：1234567891011mysql&gt; DELETE FROM tb_courses -&gt; WHERE course_id = 2;Query OK, 1 row affected (0.04 sec)mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | Math | 3 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.00 sec) UPDATE-更新数据库表中的数据UPDATE 语句修改单个表，语法格式为UPDATE &lt;表名&gt; SET 字段 1=值 1 [,字段 2=值 2… ] [WHERE 子句 ][ORDER BY 子句] [LIMIT 子句]语法说明如下：&lt;表名&gt;：用于指定要更新的表名称SET 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。WHERE 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。ORDER BY 子句：可选项。用于限定表中的行被修改的次序。LIMIT 子句：可选项。用于限定被修改的行数。 修改表中的数据使用示例如下：1234567891011mysql&gt; UPDATE tb_courses SET course_grade=4;Query OK, 1 row affected (0.05 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | Math | 4 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.00 sec) 根据条件修改表中的数据使用示例如下：12345678910111213mysql&gt; UPDATE tb_courses -&gt; SET course_name='DB', course_grade=3.5 -&gt; WHERE course_id=1;Query OK, 1 row affected (0.05 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | DB | 3.5 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.01 sec) SELECT-从数据库表中获取数据数据表查询见SQL-查询","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"interview-tree","slug":"interview-tree","date":"2020-04-16T02:24:14.000Z","updated":"2020-04-16T12:06:04.779Z","comments":true,"path":"2020/04/16/interview-tree/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/interview-tree/","excerpt":"","text":"树 二叉树L、D、R分别表示遍历左子树、访问根节点和遍历右子树先序遍历：DLR中序遍历：LDR后序遍历：LRD确定一个二叉树，必须有中序遍历 二叉树的性质性质1：在二叉树中第i层的结点数最多为2i−1（i≥1）2^{i - 1}（i \\geq 1）2i−1（i≥1）性质2：高度为k的二叉树节点其结点总数最多为2k−1（k≥1）2^{k} - 1（k \\geq 1）2k−1（k≥1）性质3：对任意的非空二叉树T，如果叶节点的个数为n0n_{0}n0​，而其度为2的结点数为n2n_{2}n2​，则：n0=n2+1n{0} = n_{2} + 1n0=n2​+1 满二叉树深度为k，且有2k−12^{k} - 12k−1个节点称为满二叉树；性质4：第i层上的结点数为2i−12^{i - 1}2i−1； 完全二叉树深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。性质5：对于具有n个结点的完全二叉树的高度为log2n+1log^{n}_{2} + 1log2n​+1二叉树的构造12345678910111213141516171819class TreeNode: def __init__(self, val=None): self.val = val self.left = None self.right = None self.parent = Noneclass Tree: def __init__(self, data: , n): # if n &gt;= len(data): return if data[n] == '#': return node = TreeNode() node.val = data[n] node.left = Tree(data, n + 1) node.right = Tree(data, n + 2) return node","categories":[{"name":"面试","slug":"面试","permalink":"http://forwardpeng.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"http://forwardpeng.github.io/tags/%E6%A0%91/"}]},{"title":"SQL-数据定义语言(DDL)","slug":"SQL-数据定义语言","date":"2020-04-16T02:21:26.000Z","updated":"2020-04-21T10:47:36.004Z","comments":true,"path":"2020/04/16/SQL-数据定义语言/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/SQL-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/","excerpt":"","text":"数据库 CREATE DATABASE-创建新数据库语法格式：CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;[[DEFAULT] CHARACTER SET &lt;字符集名&gt;][[DEFAULT] COLLATE &lt;校对规则名&gt;];[]中的内容是可选的。语法说明如下：&lt;数据库名&gt;：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。[DEFAULT] CHARACTER SET：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。[DEFAULT] COLLATE：指定字符集的默认校对规则。创建数据库的基本示例：1234mysql&gt; CREATE DATABASE IF NOT EXISTS test_db_char -&gt; DEFAULT CHARACTER SET utf8 -&gt; DEFAULT COLLATE utf8_unicode_ci;Query OK, 1 row affected (0.03 sec) ALTER DATABASE-修改数据库语法格式：ALTER DATABASE [数据库名] {[ DEFAULT ] CHARACTER SET &lt;字符集名&gt; |[ DEFAULT ] COLLATE &lt;校对规则名&gt;}语法说明如下：ALTER DATABASE 用于更改数据库的全局特性。使用 ALTER DATABASE 需要获得数据库 ALTER 权限。数据库名称可以忽略，此时语句对应于默认数据库。CHARACTER SET 子句用于更改默认的数据库字符集。修改数据库的示例如下：1234mysql&gt; ALTER CREATE test_db_char -&gt; DEFAULT CHARACTER SET utf8 -&gt; DEFAULT COLLATE utf8_general_ci;Query OK, 1 row affected (0.00 sec) SHOW DATABASE-查看数据库语法格式：SHOW DATABASES [LIKE ‘数据库名’];语法说明如下：LIKE 从句是可选项，用于匹配指定的数据库名称。LIKE 从句可以部分匹配，也可以完全匹配。数据库名使用单引号’ '。查看数据库示例如下：12345678mysql&gt; SHOW DATABSES LIKE '%test%';+-------------------+| Database (%test%) |+-------------------+| test || test_db_char |+-------------------+2 rows in set (0.00 sec) DROP DATABASE-删除数据库语法格式：DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt;语法说明如下：&lt;数据库名&gt;：指定要删除的数据库名。IF EXISTS：用于防止当数据库不存在时发生错误。DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。12mysql&gt; DROP DATABASE test;Query OK, 0 rows affected (0.19 sec) 数据表 CREATE TABLE-创建新数据库表语法格式：CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];语法说明如下：CREATE TABLE：用于创建给定名称的表，必须拥有表CREATE的权限。&lt;表名&gt;：指定要创建表的名称，在 CREATE TABLE 之后给出，必须符合标识符命名规则。表名称被指定为 db_name.tbl_name，以便在特定的数据库中创建表。无论是否有当前数据库，都可以通过这种方式创建。在当前数据库中创建表时，可以省略 db-name。如果使用加引号的识别名，则应对数据库和表名称分别加引号。例如，‘mydb’.‘mytbl’ 是合法的，但 ‘mydb.mytbl’ 不合法。&lt;表定义选项&gt;：表创建定义，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。默认的情况是，表被创建到当前的数据库中。若表已存在、没有当前数据库或者数据库不存在，则会出现错误。12345678mysql&gt; CREATE TABLE tb_test -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT -&gt;);Query OK, 0 rows affected（0.37 sec）DESCRIBE(DESC)&lt;表名&gt;; 用于查看表的字段信息12345678mysql&gt; DESCRIBE join_test1;+-------+-----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-----------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | char(255) | YES | | NULL | |+-------+-----------+------+-----+---------+-------+2 rows in set (0.06 sec)SHOW CREATE TABLE&lt;表名&gt;\\G;12345678mysql&gt; show create table join_test1\\G*************************** 1. row *************************** Table: join_test1Create Table: CREATE TABLE `join_test1` ( `id` int(11) DEFAULT NULL, `name` char(255) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) ALTER TABLE-修改数据库表语法格式：ALTER TABLE &lt;表名&gt; [修改选项]修改选项的语法格式如下：{ ADD COLUMN &lt;列名&gt; &lt;类型&gt;| CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;| ALTER COLUMN &lt;列名&gt; { SET DEFAULT &lt;默认值&gt; | DROP DEFAULT }| MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;| DROP COLUMN &lt;列名&gt;| RENAME TO &lt;新表名&gt; } 添加字段的语法格式如下：ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST|AFTER 已存在的字段名]; #FIRST|AFTER用于指定新字段在表中的位置。添加字段的使用示例：1234567891011121314mysql&gt; ALTER TABLE test ADD COLUMN col2 INT FIRST;Query OK, 0 rows affected (0.41 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| col2 | int(11) | YES | | NULL | || col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(25) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 修改字段的数据类型语法格式：ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;其中，表名指要修改数据类型的字段所在表的名称，字段名指需要修改的字段，数据类型指修改后字段的新数据类型。修改字段的使用示例：123456789101112131415mysql&gt; ALTER TABLE test -&gt; MODIFY name varchar(30);Query OK, 0 rows affected (0.07 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| col2 | int(11) | YES | | NULL | || col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 删除字段语法格式：ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;；删除字段的使用示例如下：123456789101112mysql&gt; ALTER TABLE test DROP col1;Query OK, 0 rows affected (0.45 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec) 修改字段名称ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;；其中，旧字段名指修改前的字段名；新字段名指修改后的字段名；新数据类型指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。修改字段名称的使用示例：1234567891011121314mysql&gt; ALTER TABLE test -&gt; CHANGE col1 col3 CHAR(50);Query OK, 0 rows affected (0.81 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| col3 | char(50) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec) 修改表名语法格式：ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;；修改表名使用示例：123456789101112mysql&gt; ALTER TABLE test -&gt; RENAME TO test_re;Query OK, 0 rows affected (0.13 sec)mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| join_test1 || test_re |+----------------+2 rows in set (0.00 sec) DROP TABLE-删除表基本语法：DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 …]语法格式的说明：表名1, 表名2, 表名3 …表示要被删除的数据表的名称。DROP TABLE 可以同时删除多个表，只要将表名依次写在后面，相互之间用逗号隔开即可。IF EXISTS 用于在删除数据表之前判断该表是否存在。如果不加 IF EXISTS，当数据表不存在时 MySQL 将提示错误，中断 SQL 语句的执行；加上 IF EXISTS 后，当数据表不存在时 SQL 语句可以顺利执行，但是会发出警告（warning）。用户必须拥有执行DROP的权限，否则无法删除。表删除后，用户在该表上的权限不会自动删除删除表的使用示例：12mysql&gt; DROP TABLE test_re;Query OK, 0 rows affected (0.15 sec)CREATE INDEX-创建索引、DROP INDEX-删除索引。见SQL-索引","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"算法导论-基本的数据结构","slug":"algo-tree","date":"2020-04-15T15:46:44.000Z","updated":"2020-04-22T07:13:20.900Z","comments":true,"path":"2020/04/15/algo-tree/","link":"","permalink":"http://forwardpeng.github.io/2020/04/15/algo-tree/","excerpt":"","text":"介绍几种基本的结构：栈、队列、链表和有根树。同时介绍由数组构造对象和指针的方法。（参考算法导论第三版P129 - P160） 栈和队列栈与队列属于动态集合，在其进行DELETE操作所移除的元素是预先设定的。栈被删除的是最近插入的元素：栈的实现的是一种后进后出（LIFO）策略 链表 指针和对象的实现 有根树的表示 课后习题","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"计算机基础/数据结构","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法导论","slug":"算法导论","permalink":"http://forwardpeng.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}]},{"title":"STL标准模板库","slug":"STL标准模板库","date":"2020-04-15T05:47:40.000Z","updated":"2020-04-16T12:05:17.720Z","comments":true,"path":"2020/04/15/STL标准模板库/","link":"","permalink":"http://forwardpeng.github.io/2020/04/15/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/","excerpt":"","text":"STL 网站github . huihut/note/STL.mdcplusplus . stlcppreference . C++ 参考手册CSDN专栏：STL学习笔记 组成容器（containers）算法（algorithms）迭代器（iterators）仿函数（functors）配接器（adapters）空间配置器（allocator） 容器（containers）序列式容器（sequence containers）：元素都是可序（ordered），但未必是有序（sorted）关联式容器（associattive containers） arrayarray是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。1template &lt; class T, size_t N &gt; class array; array::begin返回指向数组容器中第一个元素的迭代器。12 iterator begin() noexcept;const_iterator begin() const noexcept;Example12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 5&gt; myarray = &#123;2, 16, 77,34, 50&#125;; std::cout &lt;&lt; \"myarray contains:\"; for(auto it = myarray.begin(); it != myarray.end(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 2 16 77 34 50 array::end返回指向数组容器中最后一个元素之后的理论元素的迭代器。12 iterator end() noexcept;const_iterator end() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 5, 19, 77, 34, 99 &#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.begin(); it != myarray.end(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 5 19 77 34 99 array::rbegin返回指向数组容器中最后一个元素的反向迭代器。12 reverse_iterator rbegin（）noexcept;const_reverse_iterator rbegin（）const noexcept;Example12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125; ; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 14 80 26 4 array::rend返回一个反向迭代器，指向数组中第一个元素之前的理论元素（这被认为是它的反向结束）。12 reverse_iterator rend() noexcept;const_reverse_iterator rend() const noexcept;Example1234567891011121314#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125;; std::cout &lt;&lt; \"myarray contains\"; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 14 80 26 4 array::cbegin返回指向数组容器中第一个元素的常量迭代器（const_iterator）；这个迭代器可以增加和减少，但是不能用来修改它指向的内容。1const_iterator cbegin（）const noexcept;Example12345678910111213141516#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123;2, 16, 77, 34, 50&#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 2 16 77 34 50 array::cend返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）。这个迭代器可以增加和减少，但是不能用来修改它指向的内容。1const_iterator cend() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 15, 720, 801, 1002, 3502 &#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 2 16 77 34 50 array::crbegin返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）1const_reverse_iterator crbegin（）const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; \"myarray backwards:\"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray backwards: 60 50 40 30 20 10 array::crend返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator），它被认为是其反向结束。1const_reverse_iterator crend() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; \"myarray backwards:\"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray backwards: 60 50 40 30 20 10 array::size返回数组容器中元素的数量。1constexpr size_type size（）noexcept;Example1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myints; std::cout &lt;&lt; \"size of myints:\" &lt;&lt; myints.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"sizeof(myints):\" &lt;&lt; sizeof(myints) &lt;&lt; std::endl; return 0;&#125;Possible Output12size of myints: 5sizeof(myints): 20 array::max_size返回数组容器可容纳的最大元素数。数组对象的max_size与其size一样，始终等于用于实例化数组模板类的第二个模板参数。1constexpr size_type max_size() noexcept;Example1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myints; std::cout &lt;&lt; \"size of myints: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; std::cout &lt;&lt; \"max_size of myints: \" &lt;&lt; myints.max_size() &lt;&lt; '\\n'; return 0;&#125;Output12size of myints: 10max_size of myints: 10 array::empty返回一个布尔值，指示数组容器是否为空，即它的size()是否为0。1constexpr bool empty() noexcept;Example1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,0&gt; first; std::array&lt;int,5&gt; second; std::cout &lt;&lt; \"first \" &lt;&lt; (first.empty() ? \"is empty\" : \"is not empty\") &lt;&lt; '\\n'; std::cout &lt;&lt; \"second \" &lt;&lt; (second.empty() ? \"is empty\" : \"is not empty\") &lt;&lt; '\\n'; return 0;&#125;Output:12first is emptysecond is not empt array::operator[]返回数组中第n个位置的元素的引用。与array::at相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。12 reference operator[] (size_type n);const_reference operator[] (size_type n) const;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myarray; unsigned int i; // assign some values: for(i=0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; \"myarray contains:\"; for(i=0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::at返回数组中第n个位置的元素的引用。与array::operator[]相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。12 reference at ( size_type n );const_reference at ( size_type n ) const;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 10&gt; myarray; unsigned int i; // assign some values: for (i = 0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; \"myarray contains:\"; for (i = 0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray.at(i); std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::front返回对数组容器中第一个元素的引用。array::begin返回的是迭代器，array::front返回的是直接引用。在空容器上调用此函数会导致未定义的行为。12 reference front();const_reference front() const;Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;2, 16, 77&#125;; std::cout &lt;&lt; \"front is: \" &lt;&lt; myarray.front() &lt;&lt; std::endl; // 2 std::cout &lt;&lt; \"back is: \" &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.front() = 100; std::cout &lt;&lt; \"myarray now contains:\"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output123front is: 2back is: 77myarray now contains: 100 16 77 array::back返回对数组容器中最后一个元素的引用。array::end返回的是迭代器，array::back返回的是直接引用。在空容器上调用此函数会导致未定义的行为。12 reference back();const_reference back() const;Example123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;5, 19, 77&#125;; std::cout &lt;&lt; \"front is: \" &lt;&lt; myarray.front() &lt;&lt; std::endl; // 5 std::cout &lt;&lt; \"back is: \" &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.back() = 50; std::cout &lt;&lt; \"myarray now contains:\"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output123front is: 5back is: 77myarray now contains: 5 19 50 array::data返回指向数组对象中第一个元素的指针。由于数组中的元素存储在连续的存储位置，所以检索到的指针可以偏移以访问数组中的任何元素。12 value_type* data() noexcept;const value_type* data() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;array&gt;int main ()&#123; const char* cstr = \"Test string\"; std::array&lt;char,12&gt; charray; std::memcpy (charray.data(),cstr,12); std::cout &lt;&lt; charray.data() &lt;&lt; '\\n'; return 0;&#125;Output1Test string array::fill用val填充数组所有元素，将val设置为数组对象中所有元素的值。1void fill (const value_type&amp; val);Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main () &#123; std::array&lt;int,6&gt; myarray; myarray.fill(5); std::cout &lt;&lt; \"myarray contains:\"; for ( int&amp; x : myarray) &#123; std::cout &lt;&lt; ' ' &lt;&lt; x; &#125; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 5 5 5 5 5 5 array::swap通过x的内容交换数组的内容，这是另一个相同类型的数组对象（包括相同的大小）。与其他容器的交换成员函数不同，此成员函数通过在各个元素之间执行与其大小相同的单独交换操作，以线性时间运行。1void swap (array&amp; x) noexcept(noexcept(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;())));Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; first = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; second = &#123;11, 22, 33, 44, 55&#125;; first.swap (second); std::cout &lt;&lt; \"first:\"; for (int&amp; x : first) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"second:\"; for (int&amp; x : second) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output12first: 11 22 33 44 55second: 10 20 30 40 50 get（array）形如：std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用。123template &lt;size_t I，class T，size_t N&gt; T＆get（array &lt;T，N&gt;＆arr）noexcept; template &lt;size_t I，class T，size_t N&gt; T &amp;&amp; get（array &lt;T，N&gt; &amp;&amp; arr）noexcept; template &lt;size_t I，class T，size_t N&gt; const T＆get（const array &lt;T，N&gt;＆arr）noexcept;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;tuple&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;10, 20, 30&#125;; std::tuple&lt;int,int,int&gt; mytuple (10, 20, 30); std::tuple_element&lt;0,decltype(myarray)&gt;::type myelement; // int myelement myelement = std::get&lt;2&gt;(myarray); std::get&lt;2&gt;(myarray) = std::get&lt;0&gt;(myarray); std::get&lt;0&gt;(myarray) = myelement; std::cout &lt;&lt; \"first element in myarray: \" &lt;&lt; std::get&lt;0&gt;(myarray) &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"first element in mytuple: \" &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; \"\\n\"; return 0;&#125;Output12first element in myarray: 30first element in mytuple: 10 relational operators (array)形如：arrayA != arrayB、arrayA &gt; arrayB；依此比较数组每个元素的大小关系。123456789101112131415161718（1） template &lt;class T，size_T N&gt; bool operator ==（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（2） template &lt;class T，size_T N&gt; bool operator！=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（3） template &lt;class T，size_T N&gt; bool operator &lt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（4） template &lt;class T，size_T N&gt; bool operator &lt;=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（5） template &lt;class T，size_T N&gt; bool operator&gt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（6） template &lt;class T，size_T N&gt; bool operator&gt; =（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;Example123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; a = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; b = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; c = &#123;50, 40, 30, 20, 10&#125;; if (a==b) std::cout &lt;&lt; \"a and b are equal\\n\"; if (b!=c) std::cout &lt;&lt; \"b and c are not equal\\n\"; if (b&lt;c) std::cout &lt;&lt; \"b is less than c\\n\"; if (c&gt;b) std::cout &lt;&lt; \"c is greater than b\\n\"; if (a&lt;=b) std::cout &lt;&lt; \"a is less than or equal to b\\n\"; if (a&gt;=b) std::cout &lt;&lt; \"a is greater than or equal to b\\n\"; return 0;&#125;Output123456a and b are equalb and c are not equalb is less than cc is greater than ba is less than or equal to ba is greater than or equal to b vectorvector是表示可以改变大小的数组的序列容器。就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。针对 vector 的各种常见操作的复杂度（效率）如下：随机访问 - 常数 O(1)在尾部增删元素 - 平摊（amortized）常数 O(1)}}增删元素 - 至 vector 尾部的线性距离 O(n)}}1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; vector::vector（1）empty容器构造函数（默认构造函数）构造一个空的容器，没有元素。（2）fill构造函数用n个元素构造一个容器。每个元素都是val的副本（如果提供）。（3）范围（range）构造器使用与[ range，first，last]范围内的元素相同的顺序构造一个容器，其中的每个元素都是emplace -从该范围内相应的元素构造而成。（4）复制（copy）构造函数（并用分配器复制）按照相同的顺序构造一个包含x中每个元素的副本的容器。（5）移动（move）构造函数（和分配器移动）构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。（6）初始化列表构造函数构造一个容器中的每个元件中的一个拷贝的IL，以相同的顺序。12345678910111213141516171819default (1) explicit vector (const allocator_type&amp; alloc = allocator_type());fill (2) explicit vector (size_type n); vector (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; vector (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) vector (const vector&amp; x);vector (const vector&amp; x, const allocator_type&amp; alloc);move (5) vector (vector&amp;&amp; x);vector (vector&amp;&amp; x, const allocator_type&amp; alloc);initializer list (6) vector (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type());Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; // constructors used in the same order as described above: std::vector&lt;int&gt; first; // empty vector of ints std::vector&lt;int&gt; second(4, 100); // four ints with value 100 std::vector&lt;int&gt; third(second.begin(), second.end());// iterating through second std::vector&lt;int&gt; fourth(third); // a copy of third // the iterator constructor can also be used to construct from arrays: int myints[] = &#123;16,2,77,29&#125;; std::vector&lt;int&gt; fifth(myints, myints + sizeof(myints) / sizeof(int)); std::cout &lt;&lt; \"The contents of fifth are:\"; for(std::vector&lt;int&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1The contents of fifth are: 16 2 77 29 vector::~vector销毁容器对象。这将在每个包含的元素上调用allocator_traits::destroy，并使用其分配器释放由矢量分配的所有存储容量。1~vector(); vector::operator=将新内容分配给容器，替换其当前内容，并相应地修改其大小。123456copy (1) vector&amp; operator= (const vector&amp; x);move (2) vector&amp; operator= (vector&amp;&amp; x);initializer list (3) vector&amp; operator= (initializer_list&lt;value_type&gt; il);Example123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,0); std::vector&lt;int&gt; bar (5,0); bar &#x3D; foo; foo &#x3D; std::vector&lt;int&gt;(); std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &#39;\\n&#39;; return 0;&#125;Output12Size of foo: 0Size of bar: 3 vector::begin vector::end vector::rbegin vector::rend vector::cbegin vector::cend vector::rcbegin vector::rcend vector::size返回vector中元素的数量。这是vector中保存的实际对象的数量，不一定等于其存储容量。1size_type size() const noexcept;Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myints; std::cout &lt;&lt; \"0. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; for (int i=0; i&lt;10; i++) myints.push_back(i); std::cout &lt;&lt; \"1. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; myints.insert (myints.end(),10,100); std::cout &lt;&lt; \"2. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; myints.pop_back(); std::cout &lt;&lt; \"3. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; return 0;&#125;Output12340. size: 01. size: 102. size: 203. size: 19 vector::max_size返回该vector可容纳的元素的最大数量。由于已知的系统或库实现限制，这是容器可以达到的最大潜在大小，但容器无法保证能够达到该大小：在达到该大小之前的任何时间，仍然无法分配存储。1size_type max_size() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; \"size: \" &lt;&lt; myvector.size() &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"capacity: \" &lt;&lt; myvector.capacity() &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"max_size: \" &lt;&lt; myvector.max_size() &lt;&lt; \"\\n\"; return 0;&#125;A possible output for this program could be:123size: 100capacity: 128max_size: 1073741823 vector::resize调整容器的大小，使其包含n个元素。如果n小于当前的容器size，内容将被缩小到前n个元素，将其删除（并销毁它们）。如果n大于当前容器size，则通过在末尾插入尽可能多的元素以达到大小n来扩展内容。如果指定了val，则新元素将初始化为val的副本，否则将进行值初始化。如果n也大于当前的容器的capacity（容量），分配的存储空间将自动重新分配。注意这个函数通过插入或者删除元素的内容来改变容器的实际内容。12void resize (size_type n);void resize (size_type n, const value_type&amp; val);Example123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some initial content: for (int i=1;i&lt;10;i++) myvector.push_back(i); myvector.resize(5); myvector.resize(8,100); myvector.resize(12); std::cout &lt;&lt; \"myvector contains:\"; for (int i=0;i&lt;myvector.size();i++) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0 vector::capacity返回当前为vector分配的存储空间的大小，用元素表示。这个capacity(容量)不一定等于vector的size。它可以相等或更大，额外的空间允许适应增长，而不需要重新分配每个插入。1size_type capacity() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; \"size: \" &lt;&lt; (int) myvector.size() &lt;&lt; '\\n'; std::cout &lt;&lt; \"capacity: \" &lt;&lt; (int) myvector.capacity() &lt;&lt; '\\n'; std::cout &lt;&lt; \"max_size: \" &lt;&lt; (int) myvector.max_size() &lt;&lt; '\\n'; return 0;&#125;A possible output for this program could be:123size: 100capacity: 128max_size: 1073741823 vector::empty返回vector是否为空（即，它的size是否为0）1bool empty() const noexcept;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); for (int i=1;i&lt;=10;i++) myvector.push_back(i); while (!myvector.empty()) &#123; sum += myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; \"total: \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125;Output1total: 55 vector::reserve请求vector容量至少足以包含n个元素。如果n大于当前vector容量，则该函数使容器重新分配其存储容量，从而将其容量增加到n（或更大）。在所有其他情况下，函数调用不会导致重新分配，并且vector容量不受影响。这个函数对vector大小没有影响，也不能改变它的元素。1void reserve (size_type n);Example12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt;::size_type sz; std::vector&lt;int&gt; foo; sz = foo.capacity(); std::cout &lt;&lt; \"making foo grow:\\n\"; for (int i=0; i&lt;100; ++i) &#123; foo.push_back(i); if (sz!=foo.capacity()) &#123; sz = foo.capacity(); std::cout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n'; &#125; &#125; std::vector&lt;int&gt; bar; sz = bar.capacity(); bar.reserve(100); // this is the only difference with foo above std::cout &lt;&lt; \"making bar grow:\\n\"; for (int i=0; i&lt;100; ++i) &#123; bar.push_back(i); if (sz!=bar.capacity()) &#123; sz = bar.capacity(); std::cout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n'; &#125; &#125; return 0;&#125;Possible output1234567891011making foo grow:capacity changed: 1capacity changed: 2capacity changed: 4capacity changed: 8capacity changed: 16capacity changed: 32capacity changed: 64capacity changed: 128making bar grow:capacity changed: 100 vector::shrink_to_fit要求容器减小其capacity(容量)以适应其尺寸。该请求是非绑定的，并且容器实现可以自由地进行优化，并且保持capacity大于其size的vector。 这可能导致重新分配，但对矢量大小没有影响，并且不能改变其元素。1void shrink_to_fit();Example12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (100); std::cout &lt;&lt; \"1. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; myvector.resize(10); std::cout &lt;&lt; \"2. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; myvector.shrink_to_fit(); std::cout &lt;&lt; \"3. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; return 0;&#125;Possible output1231. capacity of myvector: 1002. capacity of myvector: 1003. capacity of myvector: 10 vector::operator[] vector::at vector::front vector::back vector::data vector::assign将新内容分配给vector，替换其当前内容，并相应地修改其大小。在范围版本（1）中，新内容是从第一个和最后一个范围内的每个元素按相同顺序构造的元素。在填充版本（2）中，新内容是n个元素，每个元素都被初始化为一个val的副本。在初始化列表版本（3）中，新内容是以相同顺序作为初始化列表传递的值的副本。所述内部分配器被用于（通过其性状），以分配和解除分配存储器如果重新分配发生。它也习惯于摧毁所有现有的元素，并构建新的元素。1234567range (1) template &lt;class InputIterator&gt; void assign (InputIterator first, InputIterator last);fill (2) void assign (size_type n, const value_type&amp; val);initializer list (3) void assign (initializer_list&lt;value_type&gt; il);Example123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; first; std::vector&lt;int&gt; second; std::vector&lt;int&gt; third; first.assign (7,100); // 7 ints with a value of 100 std::vector&lt;int&gt;::iterator it; it=first.begin()+1; second.assign (it,first.end()-1); // the 5 central values of first int myints[] = &#123;1776,7,4&#125;; third.assign (myints,myints+3); // assigning from array. std::cout &lt;&lt; \"Size of first: \" &lt;&lt; int (first.size()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"Size of second: \" &lt;&lt; int (second.size()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"Size of third: \" &lt;&lt; int (third.size()) &lt;&lt; '\\n'; return 0;&#125;Output123Size of first: 7Size of second: 5Size of third: 3补充：vector::assign 与 vector::operator= 的区别：vector::assign 实现源码12345678910111213141516void assign(size_type __n, const _Tp&amp; __val) &#123; _M_fill_assign(__n, __val); &#125;template &lt;class _Tp, class _Alloc&gt;void vector&lt;_Tp, _Alloc&gt;::_M_fill_assign(size_t __n, const value_type&amp; __val) &#123; if (__n &gt; capacity()) &#123; vector&lt;_Tp, _Alloc&gt; __tmp(__n, __val, get_allocator()); __tmp.swap(*this); &#125; else if (__n &gt; size()) &#123; fill(begin(), end(), __val); _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val); &#125; else erase(fill_n(begin(), __n, __val), end());&#125;vector::operator= 实现源码12345678910111213141516171819202122232425template &lt;class _Tp, class _Alloc&gt;vector&lt;_Tp,_Alloc&gt;&amp; vector&lt;_Tp,_Alloc&gt;::operator=(const vector&lt;_Tp, _Alloc&gt;&amp; __x)&#123; if (&amp;__x != this) &#123; const size_type __xlen = __x.size(); if (__xlen &gt; capacity()) &#123; iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end()); destroy(_M_start, _M_finish); _M_deallocate(_M_start, _M_end_of_storage - _M_start); _M_start = __tmp; _M_end_of_storage = _M_start + __xlen; &#125; else if (size() &gt;= __xlen) &#123; iterator __i = copy(__x.begin(), __x.end(), begin()); destroy(__i, _M_finish); &#125; else &#123; copy(__x.begin(), __x.begin() + size(), _M_start); uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish); &#125; _M_finish = _M_start + __xlen; &#125; return *this;&#125; vector::push_back在vector的最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新的元素。这有效地将容器size增加了一个，如果新的矢量size超过了当前vector的capacity，则导致所分配的存储空间自动重新分配。12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val);Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int myint; std::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\\n\"; do &#123; std::cin &gt;&gt; myint; myvector.push_back (myint); &#125; while (myint); std::cout &lt;&lt; \"myvector stores \" &lt;&lt; int(myvector.size()) &lt;&lt; \" numbers.\\n\"; return 0;&#125; vector::pop_back删除vector中的最后一个元素，有效地将容器size减少一个。这破坏了被删除的元素。1void pop_back();Example123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); myvector.push_back (100); myvector.push_back (200); myvector.push_back (300); while (!myvector.empty()) &#123; sum+=myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; \"The elements of myvector add up to \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125;Output1The elements of myvector add up to 600 vector::insert通过在指定位置的元素之前插入新元素来扩展该vector，通过插入元素的数量有效地增加容器大小。 这会导致分配的存储空间自动重新分配，只有在新的vector的size超过当前的vector的capacity的情况下。由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。1234567891011single element (1) iterator insert (const_iterator position, const value_type&amp; val);fill (2) iterator insert (const_iterator position, size_type n, const value_type&amp; val);range (3) template &lt;class InputIterator&gt;iterator insert (const_iterator position, InputIterator first, InputIterator last);move (4) iterator insert (const_iterator position, value_type&amp;&amp; val);initializer list (5) iterator insert (const_iterator position, initializer_list&lt;value_type&gt; il);Example1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (3,100); std::vector&lt;int&gt;::iterator it; it = myvector.begin(); it = myvector.insert ( it , 200 ); myvector.insert (it,2,300); // \"it\" no longer valid, get a new one: it = myvector.begin(); std::vector&lt;int&gt; anothervector (2,400); myvector.insert (it+2,anothervector.begin(),anothervector.end()); int myarray [] = &#123; 501,502,503 &#125;; myvector.insert (myvector.begin(), myarray, myarray+3); std::cout &lt;&lt; \"myvector contains:\"; for (it=myvector.begin(); it&lt;myvector.end(); it++) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 501 502 503 300 300 400 400 200 100 100 100补充：insert 迭代器野指针错误：123456789101112131415int main()&#123; std::vector&lt;int&gt; v(5, 0); std::vector&lt;int&gt;::iterator vi; // 获取vector第一个元素的迭代器 vi = v.begin(); // push_back 插入元素之后可能会因为 push_back 的骚操作（创建一个新vector把旧vector的值复制到新vector），导致vector迭代器iterator的指针变成野指针，而导致insert出错 v.push_back(10); v.insert(vi, 2, 300); return 0;&#125;改正：应该把vi = v.begin();放到v.push_back(10);后面 vector::erase从vector中删除单个元素（position）或一系列元素（[first，last））。这有效地减少了被去除的元素的数量，从而破坏了容器的大小。由于vector使用一个数组作为其底层存储，所以删除除vector结束位置之后，或vector的begin之前的元素外，将导致容器将段被擦除后的所有元素重新定位到新的位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。12iterator erase (const_iterator position);iterator erase (const_iterator first, const_iterator last);Example1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some values (from 1 to 10) for (int i=1; i&lt;=10; i++) myvector.push_back(i); // erase the 6th element myvector.erase (myvector.begin()+5); // erase the first 3 elements: myvector.erase (myvector.begin(),myvector.begin()+3); std::cout &lt;&lt; \"myvector contains:\"; for (unsigned i=0; i&lt;myvector.size(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 4 5 7 8 9 10 vector::swap通过x的内容交换容器的内容，x是另一个相同类型的vector对象。尺寸可能不同。在调用这个成员函数之后，这个容器中的元素是那些在调用之前在x中的元素，而x的元素是在这个元素中的元素。所有迭代器，引用和指针对交换对象保持有效。请注意，非成员函数存在具有相同名称的交换，并使用与此成员函数相似的优化来重载该算法。1void swap (vector&amp; x);Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,100); // three ints with a value of 100 std::vector&lt;int&gt; bar (5,200); // five ints with a value of 200 foo.swap(bar); std::cout &lt;&lt; \"foo contains:\"; for (unsigned i=0; i&lt;foo.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; foo[i]; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"bar contains:\"; for (unsigned i=0; i&lt;bar.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; bar[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output12foo contains: 200 200 200 200 200 bar contains: 100 100 100 vector::clear从vector中删除所有的元素（被销毁），留下size为0的容器。不保证重新分配，并且由于调用此函数， vector的capacity不保证发生变化。强制重新分配的典型替代方法是使用swap：vector&lt;T&gt;().swap(x); // clear x reallocating1void clear() noexcept;Example1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;void printVector(const std::vector&lt;int&gt; &amp;v)&#123; for (auto it = v.begin(); it != v.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; ' '; &#125; std::cout &lt;&lt; std::endl;&#125;int main()&#123; std::vector&lt;int&gt; v1(5, 50); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.clear(); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.push_back(11); v1.push_back(22); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; return 0;&#125;Output12345678950 50 50 50 50v1 size &#x3D; 5v1 capacity &#x3D; 5v1 size &#x3D; 0v1 capacity &#x3D; 511 22v1 size &#x3D; 2v1 capacity &#x3D; 5 vector::emplace通过在position位置处插入新元素args来扩展容器。这个新元素是用args作为构建的参数来构建的。这有效地增加了一个容器的大小。分配存储空间的自动重新分配发生在新的vector的size超过当前向量容量的情况下。由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。该元素是通过调用allocator_traits::construct来转换args来创建的。插入一个类似的成员函数，将现有对象复制或移动到容器中。12template &lt;class... Args&gt;iterator emplace (const_iterator position, Args&amp;&amp;... args);Example123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector = &#123;10,20,30&#125;; auto it = myvector.emplace ( myvector.begin()+1, 100 ); myvector.emplace ( it, 200 ); myvector.emplace ( myvector.end(), 300 ); std::cout &lt;&lt; \"myvector contains:\"; for (auto&amp; x: myvector) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 10 200 100 20 30 300 vector::emplace_back在vector的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新元素是用args作为构造函数的参数来构造的。这有效地将容器大小增加了一个，如果新的矢量大小超过了当前的vector容量，则导致所分配的存储空间自动重新分配。该元素是通过调用allocator_traits :: construct来转换args来创建的。与push_back相比，emplace_back可以避免额外的复制和移动操作。12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args);Example12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct President&#123; std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) &#123; std::cout &lt;&lt; \"I am being constructed.\\n\"; &#125; President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) &#123; std::cout &lt;&lt; \"I am being moved.\\n\"; &#125; President&amp; operator=(const President&amp; other) = default;&#125;; int main()&#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; \"emplace_back:\\n\"; elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; \"\\npush_back:\\n\"; reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936)); std::cout &lt;&lt; \"\\nContents:\\n\"; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was re-elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125;&#125;Output12345678910emplace_back:I am being constructed. push_back:I am being constructed.I am being moved. Contents:Nelson Mandela was elected president of South Africa in 1994.Franklin Delano Roosevelt was re-elected president of the USA in 1936. vector::get_allocator返回与vector关联的构造器对象的副本。1allocator_type get_allocator() const noexcept;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int * p; unsigned int i; // allocate an array with space for 5 elements using vector's allocator: p = myvector.get_allocator().allocate(5); // construct values in-place on the array: for (i=0; i&lt;5; i++) myvector.get_allocator().construct(&amp;p[i],i); std::cout &lt;&lt; \"The allocated array contains:\"; for (i=0; i&lt;5; i++) std::cout &lt;&lt; ' ' &lt;&lt; p[i]; std::cout &lt;&lt; '\\n'; // destroy and deallocate: for (i=0; i&lt;5; i++) myvector.get_allocator().destroy(&amp;p[i]); myvector.get_allocator().deallocate(p,5); return 0;&#125;Output1The allocated array contains: 0 1 2 3 4注意：deallocate和destory的关系：deallocate实现的源码：template &lt;class T&gt; inline void _deallocate(T* buffer) { ::operator delete(buffer); //为什么不用 delete [] ? ,operator delete 区别于 delete //operator delete 是一个底层操作符 } destory：template &lt;class T&gt; inline void _destory(T *ptr) { ptr-&gt;~T(); } destory负责调用类型的析构函数，销毁相应内存上的内容（但销毁后内存地址仍保留）deallocate负责释放内存（此时相应内存中的值在此之前应调用destory销毁，将内存地址返回给系统，代表这部分地址使用引用-1） relational operators (vector) swap (vector) vector dequedeque（['dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。deque上常见操作的复杂性（效率）如下：随机访问 - 常数O(1)在结尾或开头插入或移除元素 - 摊销不变O(1)插入或移除元素 - 线性O(n)1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque; deque::deque构造一个deque容器对象，根据所使用的构造函数版本初始化它的内容：Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; unsigned int i; // constructors used in the same order as described above: std::deque&lt;int&gt; first; // empty deque of ints std::deque&lt;int&gt; second (4,100); // four ints with value 100 std::deque&lt;int&gt; third (second.begin(),second.end()); // iterating through second std::deque&lt;int&gt; fourth (third); // a copy of third // the iterator constructor can be used to copy arrays: int myints[] = &#123;16,2,77,29&#125;; std::deque&lt;int&gt; fifth (myints, myints + sizeof(myints) / sizeof(int) ); std::cout &lt;&lt; \"The contents of fifth are:\"; for (std::deque&lt;int&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1The contents of fifth are: 16 2 77 29 deque::push_back在当前的最后一个元素之后 ，在deque容器的末尾添加一个新元素。val的内容被复制（或移动）到新的元素。这有效地增加了一个容器的大小。12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val);Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int myint; std::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\\n\"; do &#123; std::cin &gt;&gt; myint; mydeque.push_back (myint); &#125; while (myint); std::cout &lt;&lt; \"mydeque stores \" &lt;&lt; (int) mydeque.size() &lt;&lt; \" numbers.\\n\"; return 0;&#125; deque::push_front在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前。val的内容被复制（或移动）到插入的元素。这有效地增加了一个容器的大小。12void push_front (const value_type&amp; val);void push_front (value_type&amp;&amp; val);Example12345678910111213141516#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque (2,100); // two ints with a value of 100 mydeque.push_front (200); mydeque.push_front (300); std::cout &lt;&lt; \"mydeque contains:\"; for (std::deque&lt;int&gt;::iterator it = mydeque.begin(); it != mydeque.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1300 200 100 100 deque::pop_back删除deque容器中的最后一个元素，有效地将容器大小减少一个。这破坏了被删除的元素。1void pop_back();Example123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int sum (0); mydeque.push_back (10); mydeque.push_back (20); mydeque.push_back (30); while (!mydeque.empty()) &#123; sum+=mydeque.back(); mydeque.pop_back(); &#125; std::cout &lt;&lt; \"The elements of mydeque add up to \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125;Output1The elements of mydeque add up to 60 deque::pop_front删除deque容器中的第一个元素，有效地减小其大小。这破坏了被删除的元素。1void pop_front();Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; mydeque.push_back (100); mydeque.push_back (200); mydeque.push_back (300); std::cout &lt;&lt; \"Popping out the elements in mydeque:\"; while (!mydeque.empty()) &#123; std::cout &lt;&lt; ' ' &lt;&lt; mydeque.front(); mydeque.pop_front(); &#125; std::cout &lt;&lt; \"\\nThe final size of mydeque is \" &lt;&lt; int(mydeque.size()) &lt;&lt; '\\n'; return 0;&#125;Output12Popping out the elements in mydeque: 100 200 300The final size of mydeque is 0 deque::emplace_front在deque的开头插入一个新的元素，就在其当前的第一个元素之前。这个新的元素是用args作为构建的参数来构建的。这有效地增加了一个容器的大小。该元素是通过调用allocator_traits::construct来转换args来创建的。存在一个类似的成员函数push_front，它可以将现有对象复制或移动到容器中。12template &lt;class... Args&gt; void emplace_front (Args&amp;&amp;... args);Example1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_front (111); mydeque.emplace_front (222); std::cout &lt;&lt; \"mydeque contains:\"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mydeque contains: 222 111 10 20 30 deque::emplace_back在deque的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新的元素是用args作为构建的参数来构建的。这有效地增加了一个容器的大小。该元素是通过调用allocator_traits::construct来转换args来创建的。存在一个类似的成员函数push_back，它可以将现有对象复制或移动到容器中12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args);Example1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_back (100); mydeque.emplace_back (200); std::cout &lt;&lt; \"mydeque contains:\"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mydeque contains: 10 20 30 100 200 forward_listforward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。 forward_list::forward_list12345678910111213141516171819default (1) explicit forward_list (const allocator_type&amp; alloc = allocator_type());fill (2) explicit forward_list (size_type n);explicit forward_list (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; forward_list (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) forward_list (const forward_list&amp; fwdlst);forward_list (const forward_list&amp; fwdlst, const allocator_type&amp; alloc);move (5) forward_list (forward_list&amp;&amp; fwdlst);forward_list (forward_list&amp;&amp; fwdlst, const allocator_type&amp; alloc);initializer list (6) forward_list (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type());Example1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; // constructors used in the same order as described above: std::forward_list&lt;int&gt; first; // default: empty std::forward_list&lt;int&gt; second (3,77); // fill: 3 seventy-sevens std::forward_list&lt;int&gt; third (second.begin(), second.end()); // range initialization std::forward_list&lt;int&gt; fourth (third); // copy constructor std::forward_list&lt;int&gt; fifth (std::move(fourth)); // move ctor. (fourth wasted) std::forward_list&lt;int&gt; sixth = &#123;3, 52, 25, 90&#125;; // initializer_list constructor std::cout &lt;&lt; \"first:\" ; for (int&amp; x: first) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"second:\"; for (int&amp; x: second) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"third:\"; for (int&amp; x: third) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"fourth:\"; for (int&amp; x: fourth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"fifth:\"; for (int&amp; x: fifth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"sixth:\"; for (int&amp; x: sixth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Possible output1234567forward_list constructor examples:first:second: 77 77 77third: 77 77 77fourth:fifth: 77 77 77sixth: 3 52 25 90 forward_list::~forward_list forward_list::before_begin返回指向容器中第一个元素之前的位置的迭代器。返回的迭代器不应被解除引用：它是为了用作成员函数的参数emplace_after，insert_after，erase_after或splice_after，指定序列，其中执行该动作的位置的开始位置。12 iterator before_begin() noexcept;const_iterator before_begin() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;20, 30, 40, 50&#125;; mylist.insert_after ( mylist.before_begin(), 11 ); std::cout &lt;&lt; \"mylist contains:\"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mylist contains: 11 20 30 40 50 forward_list::cbefore_begin返回指向容器中第一个元素之前的位置的const_iterator。一个常量性是指向常量内容的迭代器。这个迭代器可以增加和减少（除非它本身也是const），就像forward_list::before_begin返回的迭代器一样，但不能用来修改它指向的内容。返回的价值不得解除引用。1const_iterator cbefore_begin() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;77, 2, 16&#125;; mylist.insert_after ( mylist.cbefore_begin(), 19 ); std::cout &lt;&lt; \"mylist contains:\"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mylist contains: 19 77 2 16 list stack queue priority_queue set multiset mapmap 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种：1typedef pair&lt;const Key, T&gt; value_type;在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施12345template &lt; class Key, // map::key_type class T, // map::mapped_type class Compare = less&lt;Key&gt;, // map::key_compare class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; // map::allocator_type &gt; class map; map::map构造一个映射容器对象，根据所使用的构造器版本初始化其内容：（1）空容器构造函数（默认构造函数）构造一个空的容器，没有元素。（2）范围构造函数构造具有一样多的元素的范围内的容器[第一，最后一个），其中每个元件布设构造的从在该范围内它的相应的元件。（3）复制构造函数（并用分配器复制）使用x中的每个元素的副本构造一个容器。（4）移动构造函数（并与分配器一起移动）构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。（5）初始化列表构造函数用il中的每个元素的副本构造一个容器。12345678910111213141516171819empty (1) explicit map (const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());explicit map (const allocator_type&amp; alloc);range (2) template &lt;class InputIterator&gt; map (InputIterator first, InputIterator last, const key_compare&amp; comp = key_compare(), const allocator_type&amp; = allocator_type());copy (3) map (const map&amp; x);map (const map&amp; x, const allocator_type&amp; alloc);move (4) map (map&amp;&amp; x);map (map&amp;&amp; x, const allocator_type&amp; alloc);initializer list (5) map (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());Example123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;map&gt;bool fncomp (char lhs, char rhs) &#123;return lhs&lt;rhs;&#125;struct classcomp &#123; bool operator() (const char&amp; lhs, const char&amp; rhs) const &#123;return lhs&lt;rhs;&#125;&#125;;int main ()&#123; std::map&lt;char,int&gt; first; first['a']=10; first['b']=30; first['c']=50; first['d']=70; std::map&lt;char,int&gt; second (first.begin(),first.end()); std::map&lt;char,int&gt; third (second); std::map&lt;char,int,classcomp&gt; fourth; // class as Compare bool(*fn_pt)(char,char) = fncomp; std::map&lt;char,int,bool(*)(char,char)&gt; fifth (fn_pt); // function pointer as Compare return 0;&#125; map::begin返回引用map容器中第一个元素的迭代器。由于map容器始终保持其元素的顺序，所以开始指向遵循容器排序标准的元素。如果容器是空的，则返回的迭代器值不应被解除引用。12 iterator begin() noexcept;const_iterator begin() const noexcept;Example1234567891011121314151617#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['b'] = 100; mymap['a'] = 200; mymap['c'] = 300; // show content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output123a &#x3D;&gt; 200b &#x3D;&gt; 100c &#x3D;&gt; 300 map::key_comp返回容器用于比较键的比较对象的副本。1key_compare key_comp() const;Example1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::key_compare mycomp = mymap.key_comp(); mymap['a']=100; mymap['b']=200; mymap['c']=300; std::cout &lt;&lt; \"mymap contains:\\n\"; char highest = mymap.rbegin()-&gt;first; // key value of last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; &#125; while ( mycomp((*it++).first, highest) ); std::cout &lt;&lt; '\\n'; return 0;&#125;Output1234mymap contains:a &#x3D;&gt; 100b &#x3D;&gt; 200c &#x3D;&gt; 300 map::value_comp返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前。1value_compare value_comp() const;Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['x']=1001; mymap['y']=2002; mymap['z']=3003; std::cout &lt;&lt; \"mymap contains:\\n\"; std::pair&lt;char,int&gt; highest = *mymap.rbegin(); // last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; &#125; while ( mymap.value_comp()(*it++, highest) ); return 0;&#125;Output1234mymap contains:x &#x3D;&gt; 1001y &#x3D;&gt; 2002z &#x3D;&gt; 3003 map::find在容器中搜索具有等于k的键的元素，如果找到则返回一个迭代器，否则返回map::end的迭代器。如果容器的比较对象自反地返回假（即，不管元素作为参数传递的顺序），则两个key被认为是等同的。另一个成员函数map::count可以用来检查一个特定的键是否存在。12 iterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator it; mymap['a']=50; mymap['b']=100; mymap['c']=150; mymap['d']=200; it = mymap.find('b'); if (it != mymap.end()) mymap.erase (it); // print content: std::cout &lt;&lt; \"elements in mymap:\" &lt;&lt; '\\n'; std::cout &lt;&lt; \"a =&gt; \" &lt;&lt; mymap.find('a')-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"c =&gt; \" &lt;&lt; mymap.find('c')-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"d =&gt; \" &lt;&lt; mymap.find('d')-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output1234elements in mymap:a &#x3D;&gt; 50c &#x3D;&gt; 150d &#x3D;&gt; 200 map::count在容器中搜索具有等于k的键的元素，并返回匹配的数量。由于地图容器中的所有元素都是唯一的，因此该函数只能返回1（如果找到该元素）或返回零（否则）。如果容器的比较对象自反地返回错误（即，不管按键作为参数传递的顺序），则两个键被认为是等同的。1size_type count (const key_type&amp; k) const;Example1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; char c; mymap ['a']=101; mymap ['c']=202; mymap ['f']=303; for (c='a'; c&lt;'h'; c++) &#123; std::cout &lt;&lt; c; if (mymap.count(c)&gt;0) std::cout &lt;&lt; \" is an element of mymap.\\n\"; else std::cout &lt;&lt; \" is not an element of mymap.\\n\"; &#125; return 0;&#125;Output1234567a is an element of mymap.b is not an element of mymap.c is an element of mymap.d is not an element of mymap.e is not an element of mymap.f is an element of mymap.g is not an element of mymap. map::lower_bound将迭代器返回到下限返回指向容器中第一个元素的迭代器，该元素的键不会在k之前出现（即，它是等价的或者在其后）。该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（element_key，k）将返回false的第一个元素。如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键不小于k。一个类似的成员函数upper_bound具有相同的行为lower_bound，除非映射包含一个key值等于k的元素：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。12 iterator lower_bound (const key_type&amp; k);const_iterator lower_bound (const key_type&amp; k) const;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output12a &#x3D;&gt; 20e &#x3D;&gt; 100 map::upper_bound将迭代器返回到上限返回一个指向容器中第一个元素的迭代器，它的关键字被认为是在k之后。该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（k，element_key）将返回true的第一个元素。如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键大于k。类似的成员函数lower_bound具有与upper_bound相同的行为，除了map包含一个元素，其键值等于k：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。12 iterator upper_bound (const key_type&amp; k);const_iterator upper_bound (const key_type&amp; k) const;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output12a &#x3D;&gt; 20e &#x3D;&gt; 100 map::equal_range获取相同元素的范围返回包含容器中所有具有与k等价的键的元素的范围边界。 由于地图容器中的元素具有唯一键，所以返回的范围最多只包含一个元素。如果没有找到匹配，则返回的范围具有零的长度，与两个迭代器指向具有考虑去后一个密钥对所述第一元件ķ根据容器的内部比较对象（key_comp）。如果容器的比较对象返回false，则两个键被认为是等价的。12pair&lt;const_iterator,const_iterator&gt; equal_range (const key_type&amp; k) const;pair&lt;iterator,iterator&gt; equal_range (const key_type&amp; k);Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['a']=10; mymap['b']=20; mymap['c']=30; std::pair&lt;std::map&lt;char,int&gt;::iterator,std::map&lt;char,int&gt;::iterator&gt; ret; ret = mymap.equal_range('b'); std::cout &lt;&lt; \"lower bound points to: \"; std::cout &lt;&lt; ret.first-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; ret.first-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"upper bound points to: \"; std::cout &lt;&lt; ret.second-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; ret.second-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output12lower bound points to: &#39;b&#39; &#x3D;&gt; 20upper bound points to: &#39;c&#39; &#x3D;&gt; 30 multimap 无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap包括：unordered_setunordered_multisetunordered_mapunordered_multimap都是以哈希表实现的。unordered_set、unodered_multiset结构：unordered_map、unodered_multimap结构： unordered_set unordered_multiset unordered_map unordered_multimap tuple元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。1template &lt;class... Types&gt; class tuple;Example1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;tuple&gt; // std::tuple, std::get, std::tie, std::ignoreint main ()&#123; std::tuple&lt;int,char&gt; foo (10,'x'); auto bar = std::make_tuple (\"test\", 3.1, 14, 'y'); std::get&lt;2&gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get&lt;3&gt;(bar); std::get&lt;0&gt;(foo) = std::get&lt;2&gt;(bar); std::get&lt;1&gt;(foo) = mychar; std::cout &lt;&lt; \"foo contains: \"; std::cout &lt;&lt; std::get&lt;0&gt;(foo) &lt;&lt; ' '; std::cout &lt;&lt; std::get&lt;1&gt;(foo) &lt;&lt; '\\n'; return 0;&#125;Output1foo contains: 100 y tuple::tuple构建一个 tuple（元组）对象。这涉及单独构建其元素，初始化取决于调用的构造函数形式：（1）默认的构造函数构建一个 元组对象的元素值初始化。（2）复制/移动构造函数该对象使用tpl的内容进行初始化 元组目的。tpl的相应元素被传递给每个元素的构造函数。（3）隐式转换构造函数同上。tpl中的所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。（4）初始化构造函数用elems中的相应元素初始化每个元素。elems的相应元素被传递给每个元素的构造函数。（5）对转换构造函数该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。（6）分配器版本和上面的版本一样，除了每个元素都是使用allocator alloc构造的。1234567891011121314151617181920212223242526272829303132333435363738default (1) constexpr tuple();copy / move (2) tuple (const tuple&amp; tpl) = default;tuple (tuple&amp;&amp; tpl) = default;implicit conversion (3) template &lt;class... UTypes&gt; tuple (const tuple&lt;UTypes...&gt;&amp; tpl);template &lt;class... UTypes&gt; tuple (tuple&lt;UTypes...&gt;&amp;&amp; tpl);initialization (4) explicit tuple (const Types&amp;... elems);template &lt;class... UTypes&gt; explicit tuple (UTypes&amp;&amp;... elems);conversion from pair (5) template &lt;class U1, class U2&gt; tuple (const pair&lt;U1,U2&gt;&amp; pr);template &lt;class U1, class U2&gt; tuple (pair&lt;U1,U2&gt;&amp;&amp; pr);allocator (6) template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&amp;&amp; tpl);template&lt;class Alloc,class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&lt;UTypes...&gt;&amp; tpl);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&lt;UTypes...&gt;&amp;&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const Types&amp;... elems);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, UTypes&amp;&amp;... elems);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const pair&lt;U1,U2&gt;&amp; pr);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, pair&lt;U1,U2&gt;&amp;&amp; pr);Example123456789101112131415161718#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::make_pair#include &lt;tuple&gt; // std::tuple, std::make_tuple, std::getint main ()&#123; std::tuple&lt;int,char&gt; first; // default std::tuple&lt;int,char&gt; second (first); // copy std::tuple&lt;int,char&gt; third (std::make_tuple(20,'b')); // move std::tuple&lt;long,char&gt; fourth (third); // implicit conversion std::tuple&lt;int,char&gt; fifth (10,'a'); // initialization std::tuple&lt;int,char&gt; sixth (std::make_pair(30,'c')); // from pair / move std::cout &lt;&lt; \"sixth contains: \" &lt;&lt; std::get&lt;0&gt;(sixth); std::cout &lt;&lt; \" and \" &lt;&lt; std::get&lt;1&gt;(sixth) &lt;&lt; '\\n'; return 0;&#125;Output1sixth contains: 30 and c pair这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。pair是tuple（元组）的一个特例。pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。应用：可以将两个类型数据组合成一个如map&lt;key, value&gt;当某个函数需要两个返回值时1template &lt;class T1, class T2&gt; struct pair; pair::pair构建一个pair对象。这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式：（1）默认的构造函数构建一个 对对象的元素值初始化。（2）复制/移动构造函数（和隐式转换）该对象被初始化为pr的内容 对目的。pr的相应成员被传递给每个成员的构造函数。（3）初始化构造函数会员 第一是由一个和成员构建的第二与b。（4）分段构造构造成员 first 和 second 到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。1234567891011121314default (1) constexpr pair();copy / move (2) template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);pair (const pair&amp; pr) = default;pair (pair&amp;&amp; pr) = default;initialization (3) pair (const first_type&amp; a, const second_type&amp; b);template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);piecewise (4) template &lt;class... Args1, class... Args2&gt; pair (piecewise_construct_t pwc, tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args);Example12345678910111213141516171819#include &lt;utility&gt; // std::pair, std::make_pair#include &lt;string&gt; // std::string#include &lt;iostream&gt; // std::coutint main () &#123; std::pair &lt;std::string,double&gt; product1; // default constructor std::pair &lt;std::string,double&gt; product2 (\"tomatoes\",2.30); // value init std::pair &lt;std::string,double&gt; product3 (product2); // copy constructor product1 = std::make_pair(std::string(\"lightbulbs\"),0.99); // using make_pair (move) product2.first = \"shoes\"; // the type of first is string product2.second = 39.90; // the type of second is double std::cout &lt;&lt; \"The price of \" &lt;&lt; product1.first &lt;&lt; \" is $\" &lt;&lt; product1.second &lt;&lt; '\\n'; std::cout &lt;&lt; \"The price of \" &lt;&lt; product2.first &lt;&lt; \" is $\" &lt;&lt; product2.second &lt;&lt; '\\n'; std::cout &lt;&lt; \"The price of \" &lt;&lt; product3.first &lt;&lt; \" is $\" &lt;&lt; product3.second &lt;&lt; '\\n'; return 0;&#125;Output123The price of lightbulbs is $0.99The price of shoes is $39.9The price of tomatoes is $2.3","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://forwardpeng.github.io/tags/C/"}]}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"计算机基础/数据结构","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"面试","slug":"面试","permalink":"http://forwardpeng.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法导论","slug":"算法导论","permalink":"http://forwardpeng.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"线性表","slug":"线性表","permalink":"http://forwardpeng.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"树","slug":"树","permalink":"http://forwardpeng.github.io/tags/%E6%A0%91/"},{"name":"C++","slug":"C","permalink":"http://forwardpeng.github.io/tags/C/"}]}