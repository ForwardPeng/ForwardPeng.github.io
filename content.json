{"meta":{"title":"Hello World","subtitle":"","description":"","author":"John Doe","url":"http://forwardpeng.github.io","root":"/"},"pages":[{"title":"书单","date":"2020-04-15T07:51:11.956Z","updated":"2020-04-15T07:51:11.956Z","comments":false,"path":"books/index.html","permalink":"http://forwardpeng.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-15T07:51:41.545Z","updated":"2020-04-15T07:51:41.545Z","comments":true,"path":"links/index.html","permalink":"http://forwardpeng.github.io/links/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-15T13:50:22.000Z","updated":"2020-04-16T01:51:00.843Z","comments":true,"path":"categories/index.html","permalink":"http://forwardpeng.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-04-15T07:50:12.856Z","updated":"2020-04-15T07:50:12.856Z","comments":false,"path":"repository/index.html","permalink":"http://forwardpeng.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-15T14:11:14.000Z","updated":"2020-04-16T01:53:51.407Z","comments":true,"path":"tags/index.html","permalink":"http://forwardpeng.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"SQL-查询","slug":"SQL-查询","date":"2020-04-18T09:49:11.000Z","updated":"2020-04-18T10:31:18.622Z","comments":true,"path":"2020/04/18/SQL-查询/","link":"","permalink":"http://forwardpeng.github.io/2020/04/18/SQL-%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"数据库表查询操作 查询数据表SELECT 语句来查询数据。查询数据是指从数据库中根据需求，使用不同的查询方式来获取不同的数据，是使用频率最高、最重要的操作。语法格式如下：SELECT {* | &lt;字段列名&gt;} [ FROM &lt;表 1&gt;, &lt;表 2&gt;… [WHERE &lt;表达式&gt; [GROUP BY &lt;group by definition&gt; [HAVING &lt;expression&gt; [{&lt;operator&gt; &lt;expression&gt;}…]] [ORDER BY &lt;order by definition&gt;] [LIMIT[&lt;offset&gt;,] &lt;row count&gt;] ]其中，各条子句说明如下：{*|&lt;字段列名&gt;}包含星号通配符的字段列表，表示所要查询字段的名称。&lt;表1&gt;，&lt;表2&gt;…，表1和表2表示查询数据的来源，可以是单个或多个。WHERE&lt;表达式&gt;是可选项，如果选择该项，将限定查询数据必须满足该查询条件。GROUP BY&lt;字段&gt;，该子句告诉数据库如何显示查询出来的数据，并按照指定的字段分组。ORDER BY&lt; 字段 &gt;]，按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC），默认情况下是升序。[LIMIT[&lt;offset&gt;，]&lt;row count&gt;]，该子句告诉 MySQL 每次显示查询出来的数据条数。 查询表中所有字段1. 使用&quot;*&quot;查询表的所有字段语法格式如下：SELECT * FROM 表名;2. 列出表的所有字段SELECT关键字后面的字段名为需要查找的字段，可以使用 DESC 命令查看表的结构。 查询表中指定的字段查询表中的某一个字段的语法格式为：SELECT &lt; 列名 &gt; FROM &lt; 表名 &gt;;123456789mysql&gt; SELECT name FROM tb_students_info;+--------+| name |+--------+| Dany || Thomas || Tom |+--------+10 rows in set (0.00 sec) 去重(过滤重复数据)使用DISTINCT关键字指示 数据库消除重复的记录值。语法格式为：SELECT DISTINCT &lt;字段名&gt; FROM &lt;表名&gt;; 设置别名当数据表名很长或者执行一些特殊查询的时候，为了方便操作，可以为表指定一个别名，语法格式为：&lt;表名&gt; [AS] &lt;别名&gt;使用示例如下：","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-索引","slug":"SQL-索引","date":"2020-04-16T12:02:11.000Z","updated":"2020-04-18T09:49:46.690Z","comments":true,"path":"2020/04/16/SQL-索引/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/SQL-%E7%B4%A2%E5%BC%95/","excerpt":"","text":"","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-数据操作语言","slug":"SQL-数据操作语言","date":"2020-04-16T10:05:27.000Z","updated":"2020-04-18T09:49:49.970Z","comments":true,"path":"2020/04/16/SQL-数据操作语言/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/SQL-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/","excerpt":"","text":"数据操作语言(DML) INSERT INTO-向数据库表中插入数据INSERT语句有两种语法形式，分别是INSERT…VALUES语句和INSERT…SET语句。1. INSERT…VALUES的语法格式为：INSERT INTO &lt;表名&gt; [ &lt;列名1&gt; [ , … &lt;列名n&gt;] ]VALUES (值1) [… , (值n) ];语法说明如下：&lt;表名&gt;：指定被操作的表名。&lt;列名&gt;：指定需要插入数据的列名。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用 INSERT&lt;表名&gt;VALUES(…) 即可。VALUES 或 VALUE 子句：该子句包含要插入的数据清单。数据清单中数据的顺序要和列的顺序相对应。2. INSERT…SET的语法格式为：INSERT INTO &lt;表名&gt;SET &lt;列名1&gt; = &lt;值1&gt;,&lt;列名2&gt; = &lt;值2&gt;,…此语句用于给表中的某些列指定对应的列值，即要插入的数据的列名在SET子句中指定，col_name为指定的列名，等号后面为指定的数据，而对于未指定的列，列值会指定为该列的默认值。INSERT语句的两种形式可是看出：使用 INSERT…VALUES 语句可以向表中插入一行数据，也可以插入多行数据；使用 INSERT…SET 语句可以指定插入行中每列的值，也可以指定部分列的值；INSERT…SELECT 语句向表中插入其他表的数据。采用 INSERT…SET 语句可以向表中插入部分列的值，这种方式更为灵活；NSERT…VALUES 语句可以一次插入多条数据。 向表中的全部字段添加值插入数据时，指定表的所有字段，为每一个字段插入新的值。123456789101112mysql&gt; INSERT INTO tb_courses -&gt; (course_id, course_name, course_grade, course_info) -&gt; values(1, 'Math', 3, 'Computer Math');Query OK, 1 row affected (0.04 sec)mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | Math | 3 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.00 sec)使用INSERT插入数据，允许列名称顺序与定义不同，必须保证值顺序与列字段顺序相同。允许列名称为空，插入顺序必须与数据表中定义的顺序相同。 表中指定字段添加值表的指定字段插入数据，是在 INSERT 语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值，示例如下：12345678910111213mysql&gt; insert into tb_courses -&gt; (course_name, course_grade, course_info) -&gt; values('System',3,'Operation System');Query OK, 1 row affected (0.04 sec)mysql&gt; select * from tb_courses;+-----------+-------------+--------------+------------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+------------------+| 1 | Math | 3 | Computer Math || 2 | System | 3 | Operation System |+-----------+-------------+--------------+------------------+2 rows in set (0.00 sec) INSERT INTO…FROM语句复制表数据SELECT子句返回的是一个查询到的结果集，INSERT语句将这个结果集插入指定表中，结果集中的每行数据的字段数、字段的数据类型都必须与被操作的表完全一致。使用示例如下：123456789101112131415mysql&gt; INSERT INTO tb_courses_new -&gt; (course_id, course_name, course_grade, course_info) -&gt; SELECT course_id, course_name, course_grade, course_info -&gt; FROM tb_courses;Query OK, 2 rows affected (0.05 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from tb_courses_new;+-----------+-------------+--------------+------------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+------------------+| 1 | Math | 3 | Computer Math || 2 | System | 3 | Operation System |+-----------+-------------+--------------+------------------+2 rows in set (0.00 sec) DELETE-从数据库表中删除数据SQL中使用DELETE语句来删除表的一行或者多行数据。 删除单个表中的数据DELETE语句从单个表中删除数据语法格式:DELETE FROM &lt;表名&gt; [WHERE 子句] [ORDER BY 子句] [LIMIT 子句]语法说明如下：&lt;表名&gt;：指定要删除数据的表名。ORDER BY 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。WHERE 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。LIMIT 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。使用示例如下：1234567891011mysql&gt; DELETE FROM tb_courses -&gt; WHERE course_id = 2;Query OK, 1 row affected (0.04 sec)mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | Math | 3 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.00 sec) UPDATE-更新数据库表中的数据UPDATE 语句修改单个表，语法格式为UPDATE &lt;表名&gt; SET 字段 1=值 1 [,字段 2=值 2… ] [WHERE 子句 ][ORDER BY 子句] [LIMIT 子句]语法说明如下：&lt;表名&gt;：用于指定要更新的表名称SET 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。WHERE 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。ORDER BY 子句：可选项。用于限定表中的行被修改的次序。LIMIT 子句：可选项。用于限定被修改的行数。 修改表中的数据使用示例如下：1234567891011mysql&gt; UPDATE tb_courses SET course_grade=4;Query OK, 1 row affected (0.05 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | Math | 4 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.00 sec) 根据条件修改表中的数据使用示例如下：12345678910111213mysql&gt; UPDATE tb_courses -&gt; SET course_name='DB', course_grade=3.5 -&gt; WHERE course_id=1;Query OK, 1 row affected (0.05 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | DB | 3.5 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.01 sec) SELECT-从数据库表中获取数据数据表查询见SQL-查询","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"interview-tree","slug":"interview-tree","date":"2020-04-16T02:24:14.000Z","updated":"2020-04-16T12:06:04.779Z","comments":true,"path":"2020/04/16/interview-tree/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/interview-tree/","excerpt":"","text":"树 二叉树L、D、R分别表示遍历左子树、访问根节点和遍历右子树先序遍历：DLR中序遍历：LDR后序遍历：LRD确定一个二叉树，必须有中序遍历 二叉树的性质性质1：在二叉树中第i层的结点数最多为2i−1（i≥1）2^{i - 1}（i \\geq 1）2i−1（i≥1）性质2：高度为k的二叉树节点其结点总数最多为2k−1（k≥1）2^{k} - 1（k \\geq 1）2k−1（k≥1）性质3：对任意的非空二叉树T，如果叶节点的个数为n0n_{0}n0​，而其度为2的结点数为n2n_{2}n2​，则：n0=n2+1n{0} = n_{2} + 1n0=n2​+1 满二叉树深度为k，且有2k−12^{k} - 12k−1个节点称为满二叉树；性质4：第i层上的结点数为2i−12^{i - 1}2i−1； 完全二叉树深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。性质5：对于具有n个结点的完全二叉树的高度为log2n+1log^{n}_{2} + 1log2n​+1二叉树的构造12345678910111213141516171819class TreeNode: def __init__(self, val=None): self.val = val self.left = None self.right = None self.parent = Noneclass Tree: def __init__(self, data: , n): # if n &gt;= len(data): return if data[n] == '#': return node = TreeNode() node.val = data[n] node.left = Tree(data, n + 1) node.right = Tree(data, n + 2) return node","categories":[{"name":"面试","slug":"面试","permalink":"http://forwardpeng.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"树","slug":"树","permalink":"http://forwardpeng.github.io/tags/%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"SQL-数据定义语言","slug":"SQL-数据定义语言","date":"2020-04-16T02:21:26.000Z","updated":"2020-04-18T09:50:18.222Z","comments":true,"path":"2020/04/16/SQL-数据定义语言/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/SQL-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/","excerpt":"","text":"数据定义语言(DDL) 数据库 CREATE DATABASE-创建新数据库语法格式：CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;[[DEFAULT] CHARACTER SET &lt;字符集名&gt;][[DEFAULT] COLLATE &lt;校对规则名&gt;];[]中的内容是可选的。语法说明如下：&lt;数据库名&gt;：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。[DEFAULT] CHARACTER SET：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。[DEFAULT] COLLATE：指定字符集的默认校对规则。创建数据库的基本示例：1234mysql&gt; CREATE DATABASE IF NOT EXISTS test_db_char -&gt; DEFAULT CHARACTER SET utf8 -&gt; DEFAULT COLLATE utf8_unicode_ci;Query OK, 1 row affected (0.03 sec) ALTER DATABASE-修改数据库语法格式：ALTER DATABASE [数据库名] {[ DEFAULT ] CHARACTER SET &lt;字符集名&gt; |[ DEFAULT ] COLLATE &lt;校对规则名&gt;}语法说明如下：ALTER DATABASE 用于更改数据库的全局特性。使用 ALTER DATABASE 需要获得数据库 ALTER 权限。数据库名称可以忽略，此时语句对应于默认数据库。CHARACTER SET 子句用于更改默认的数据库字符集。修改数据库的示例如下：1234mysql&gt; ALTER CREATE test_db_char -&gt; DEFAULT CHARACTER SET utf8 -&gt; DEFAULT COLLATE utf8_general_ci;Query OK, 1 row affected (0.00 sec) SHOW DATABASE-查看数据库语法格式：SHOW DATABASES [LIKE ‘数据库名’];语法说明如下：LIKE 从句是可选项，用于匹配指定的数据库名称。LIKE 从句可以部分匹配，也可以完全匹配。数据库名使用单引号’ '。查看数据库示例如下：12345678mysql&gt; SHOW DATABSES LIKE '%test%';+-------------------+| Database (%test%) |+-------------------+| test || test_db_char |+-------------------+2 rows in set (0.00 sec) DROP DATABASE-删除数据库语法格式：DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt;语法说明如下：&lt;数据库名&gt;：指定要删除的数据库名。IF EXISTS：用于防止当数据库不存在时发生错误。DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。12mysql&gt; DROP DATABASE test;Query OK, 0 rows affected (0.19 sec) 数据表 CREATE TABLE-创建新数据库表语法格式：CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];语法说明如下：CREATE TABLE：用于创建给定名称的表，必须拥有表CREATE的权限。&lt;表名&gt;：指定要创建表的名称，在 CREATE TABLE 之后给出，必须符合标识符命名规则。表名称被指定为 db_name.tbl_name，以便在特定的数据库中创建表。无论是否有当前数据库，都可以通过这种方式创建。在当前数据库中创建表时，可以省略 db-name。如果使用加引号的识别名，则应对数据库和表名称分别加引号。例如，‘mydb’.‘mytbl’ 是合法的，但 ‘mydb.mytbl’ 不合法。&lt;表定义选项&gt;：表创建定义，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。默认的情况是，表被创建到当前的数据库中。若表已存在、没有当前数据库或者数据库不存在，则会出现错误。12345678mysql&gt; CREATE TABLE tb_test -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT -&gt;);Query OK, 0 rows affected（0.37 sec）DESCRIBE(DESC)&lt;表名&gt;; 用于查看表的字段信息12345678mysql&gt; DESCRIBE join_test1;+-------+-----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-----------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | char(255) | YES | | NULL | |+-------+-----------+------+-----+---------+-------+2 rows in set (0.06 sec)SHOW CREATE TABLE&lt;表名&gt;\\G;12345678mysql&gt; show create table join_test1\\G*************************** 1. row *************************** Table: join_test1Create Table: CREATE TABLE `join_test1` ( `id` int(11) DEFAULT NULL, `name` char(255) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) ALTER TABLE-修改数据库表语法格式：ALTER TABLE &lt;表名&gt; [修改选项]修改选项的语法格式如下：{ ADD COLUMN &lt;列名&gt; &lt;类型&gt;| CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;| ALTER COLUMN &lt;列名&gt; { SET DEFAULT &lt;默认值&gt; | DROP DEFAULT }| MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;| DROP COLUMN &lt;列名&gt;| RENAME TO &lt;新表名&gt; } 添加字段的语法格式如下：ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST|AFTER 已存在的字段名]; #FIRST|AFTER用于指定新字段在表中的位置。添加字段的使用示例：1234567891011121314mysql&gt; ALTER TABLE test ADD COLUMN col2 INT FIRST;Query OK, 0 rows affected (0.41 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| col2 | int(11) | YES | | NULL | || col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(25) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 修改字段的数据类型语法格式：ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;其中，表名指要修改数据类型的字段所在表的名称，字段名指需要修改的字段，数据类型指修改后字段的新数据类型。修改字段的使用示例：123456789101112131415mysql&gt; ALTER TABLE test -&gt; MODIFY name varchar(30);Query OK, 0 rows affected (0.07 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| col2 | int(11) | YES | | NULL | || col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 删除字段语法格式：ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;；删除字段的使用示例如下：123456789101112mysql&gt; ALTER TABLE test DROP col1;Query OK, 0 rows affected (0.45 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec) 修改字段名称ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;；其中，旧字段名指修改前的字段名；新字段名指修改后的字段名；新数据类型指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。修改字段名称的使用示例：1234567891011121314mysql&gt; ALTER TABLE test -&gt; CHANGE col1 col3 CHAR(50);Query OK, 0 rows affected (0.81 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| col3 | char(50) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec) 修改表名语法格式：ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;；修改表名使用示例：123456789101112mysql&gt; ALTER TABLE test -&gt; RENAME TO test_re;Query OK, 0 rows affected (0.13 sec)mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| join_test1 || test_re |+----------------+2 rows in set (0.00 sec) DROP TABLE-删除表基本语法：DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 …]语法格式的说明：表名1, 表名2, 表名3 …表示要被删除的数据表的名称。DROP TABLE 可以同时删除多个表，只要将表名依次写在后面，相互之间用逗号隔开即可。IF EXISTS 用于在删除数据表之前判断该表是否存在。如果不加 IF EXISTS，当数据表不存在时 MySQL 将提示错误，中断 SQL 语句的执行；加上 IF EXISTS 后，当数据表不存在时 SQL 语句可以顺利执行，但是会发出警告（warning）。用户必须拥有执行DROP的权限，否则无法删除。表删除后，用户在该表上的权限不会自动删除删除表的使用示例：12mysql&gt; DROP TABLE test_re;Query OK, 0 rows affected (0.15 sec)CREATE INDEX-创建索引、DROP INDEX-删除索引。见SQL-索引","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"算法导论-基本的数据结构","slug":"algo-tree","date":"2020-04-15T15:46:44.000Z","updated":"2020-04-16T02:59:34.112Z","comments":true,"path":"2020/04/15/algo-tree/","link":"","permalink":"http://forwardpeng.github.io/2020/04/15/algo-tree/","excerpt":"","text":"基本数据结构介绍几种基本的结构：栈、队列、链表和有根树。同时介绍由数组构造对象和指针的方法。（参考算法导论第三版P129 - P160） 栈和队列栈与队列属于动态集合，在其进行DELETE操作所移除的元素是预先设定的。栈被删除的是最近插入的元素：栈的实现的是一种后进后出（LIFO）策略 链表 指针和对象的实现 有根树的表示 课后习题","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法导论","slug":"算法导论","permalink":"http://forwardpeng.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}]},{"title":"STL标准模板库","slug":"STL标准模板库","date":"2020-04-15T05:47:40.000Z","updated":"2020-04-16T12:05:17.720Z","comments":true,"path":"2020/04/15/STL标准模板库/","link":"","permalink":"http://forwardpeng.github.io/2020/04/15/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/","excerpt":"","text":"STL 网站github . huihut/note/STL.mdcplusplus . stlcppreference . C++ 参考手册CSDN专栏：STL学习笔记 组成容器（containers）算法（algorithms）迭代器（iterators）仿函数（functors）配接器（adapters）空间配置器（allocator） 容器（containers）序列式容器（sequence containers）：元素都是可序（ordered），但未必是有序（sorted）关联式容器（associattive containers） arrayarray是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。1template &lt; class T, size_t N &gt; class array; array::begin返回指向数组容器中第一个元素的迭代器。12 iterator begin() noexcept;const_iterator begin() const noexcept;Example12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 5&gt; myarray = &#123;2, 16, 77,34, 50&#125;; std::cout &lt;&lt; \"myarray contains:\"; for(auto it = myarray.begin(); it != myarray.end(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 2 16 77 34 50 array::end返回指向数组容器中最后一个元素之后的理论元素的迭代器。12 iterator end() noexcept;const_iterator end() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 5, 19, 77, 34, 99 &#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.begin(); it != myarray.end(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 5 19 77 34 99 array::rbegin返回指向数组容器中最后一个元素的反向迭代器。12 reverse_iterator rbegin（）noexcept;const_reverse_iterator rbegin（）const noexcept;Example12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125; ; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 14 80 26 4 array::rend返回一个反向迭代器，指向数组中第一个元素之前的理论元素（这被认为是它的反向结束）。12 reverse_iterator rend() noexcept;const_reverse_iterator rend() const noexcept;Example1234567891011121314#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125;; std::cout &lt;&lt; \"myarray contains\"; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 14 80 26 4 array::cbegin返回指向数组容器中第一个元素的常量迭代器（const_iterator）；这个迭代器可以增加和减少，但是不能用来修改它指向的内容。1const_iterator cbegin（）const noexcept;Example12345678910111213141516#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123;2, 16, 77, 34, 50&#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 2 16 77 34 50 array::cend返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）。这个迭代器可以增加和减少，但是不能用来修改它指向的内容。1const_iterator cend() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 15, 720, 801, 1002, 3502 &#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 2 16 77 34 50 array::crbegin返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）1const_reverse_iterator crbegin（）const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; \"myarray backwards:\"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray backwards: 60 50 40 30 20 10 array::crend返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator），它被认为是其反向结束。1const_reverse_iterator crend() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; \"myarray backwards:\"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray backwards: 60 50 40 30 20 10 array::size返回数组容器中元素的数量。1constexpr size_type size（）noexcept;Example1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myints; std::cout &lt;&lt; \"size of myints:\" &lt;&lt; myints.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"sizeof(myints):\" &lt;&lt; sizeof(myints) &lt;&lt; std::endl; return 0;&#125;Possible Output12size of myints: 5sizeof(myints): 20 array::max_size返回数组容器可容纳的最大元素数。数组对象的max_size与其size一样，始终等于用于实例化数组模板类的第二个模板参数。1constexpr size_type max_size() noexcept;Example1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myints; std::cout &lt;&lt; \"size of myints: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; std::cout &lt;&lt; \"max_size of myints: \" &lt;&lt; myints.max_size() &lt;&lt; '\\n'; return 0;&#125;Output12size of myints: 10max_size of myints: 10 array::empty返回一个布尔值，指示数组容器是否为空，即它的size()是否为0。1constexpr bool empty() noexcept;Example1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,0&gt; first; std::array&lt;int,5&gt; second; std::cout &lt;&lt; \"first \" &lt;&lt; (first.empty() ? \"is empty\" : \"is not empty\") &lt;&lt; '\\n'; std::cout &lt;&lt; \"second \" &lt;&lt; (second.empty() ? \"is empty\" : \"is not empty\") &lt;&lt; '\\n'; return 0;&#125;Output:12first is emptysecond is not empt array::operator[]返回数组中第n个位置的元素的引用。与array::at相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。12 reference operator[] (size_type n);const_reference operator[] (size_type n) const;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myarray; unsigned int i; // assign some values: for(i=0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; \"myarray contains:\"; for(i=0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::at返回数组中第n个位置的元素的引用。与array::operator[]相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。12 reference at ( size_type n );const_reference at ( size_type n ) const;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 10&gt; myarray; unsigned int i; // assign some values: for (i = 0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; \"myarray contains:\"; for (i = 0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray.at(i); std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::front返回对数组容器中第一个元素的引用。array::begin返回的是迭代器，array::front返回的是直接引用。在空容器上调用此函数会导致未定义的行为。12 reference front();const_reference front() const;Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;2, 16, 77&#125;; std::cout &lt;&lt; \"front is: \" &lt;&lt; myarray.front() &lt;&lt; std::endl; // 2 std::cout &lt;&lt; \"back is: \" &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.front() = 100; std::cout &lt;&lt; \"myarray now contains:\"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output123front is: 2back is: 77myarray now contains: 100 16 77 array::back返回对数组容器中最后一个元素的引用。array::end返回的是迭代器，array::back返回的是直接引用。在空容器上调用此函数会导致未定义的行为。12 reference back();const_reference back() const;Example123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;5, 19, 77&#125;; std::cout &lt;&lt; \"front is: \" &lt;&lt; myarray.front() &lt;&lt; std::endl; // 5 std::cout &lt;&lt; \"back is: \" &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.back() = 50; std::cout &lt;&lt; \"myarray now contains:\"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output123front is: 5back is: 77myarray now contains: 5 19 50 array::data返回指向数组对象中第一个元素的指针。由于数组中的元素存储在连续的存储位置，所以检索到的指针可以偏移以访问数组中的任何元素。12 value_type* data() noexcept;const value_type* data() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;array&gt;int main ()&#123; const char* cstr = \"Test string\"; std::array&lt;char,12&gt; charray; std::memcpy (charray.data(),cstr,12); std::cout &lt;&lt; charray.data() &lt;&lt; '\\n'; return 0;&#125;Output1Test string array::fill用val填充数组所有元素，将val设置为数组对象中所有元素的值。1void fill (const value_type&amp; val);Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main () &#123; std::array&lt;int,6&gt; myarray; myarray.fill(5); std::cout &lt;&lt; \"myarray contains:\"; for ( int&amp; x : myarray) &#123; std::cout &lt;&lt; ' ' &lt;&lt; x; &#125; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 5 5 5 5 5 5 array::swap通过x的内容交换数组的内容，这是另一个相同类型的数组对象（包括相同的大小）。与其他容器的交换成员函数不同，此成员函数通过在各个元素之间执行与其大小相同的单独交换操作，以线性时间运行。1void swap (array&amp; x) noexcept(noexcept(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;())));Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; first = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; second = &#123;11, 22, 33, 44, 55&#125;; first.swap (second); std::cout &lt;&lt; \"first:\"; for (int&amp; x : first) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"second:\"; for (int&amp; x : second) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output12first: 11 22 33 44 55second: 10 20 30 40 50 get（array）形如：std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用。123template &lt;size_t I，class T，size_t N&gt; T＆get（array &lt;T，N&gt;＆arr）noexcept; template &lt;size_t I，class T，size_t N&gt; T &amp;&amp; get（array &lt;T，N&gt; &amp;&amp; arr）noexcept; template &lt;size_t I，class T，size_t N&gt; const T＆get（const array &lt;T，N&gt;＆arr）noexcept;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;tuple&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;10, 20, 30&#125;; std::tuple&lt;int,int,int&gt; mytuple (10, 20, 30); std::tuple_element&lt;0,decltype(myarray)&gt;::type myelement; // int myelement myelement = std::get&lt;2&gt;(myarray); std::get&lt;2&gt;(myarray) = std::get&lt;0&gt;(myarray); std::get&lt;0&gt;(myarray) = myelement; std::cout &lt;&lt; \"first element in myarray: \" &lt;&lt; std::get&lt;0&gt;(myarray) &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"first element in mytuple: \" &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; \"\\n\"; return 0;&#125;Output12first element in myarray: 30first element in mytuple: 10 relational operators (array)形如：arrayA != arrayB、arrayA &gt; arrayB；依此比较数组每个元素的大小关系。123456789101112131415161718（1） template &lt;class T，size_T N&gt; bool operator ==（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（2） template &lt;class T，size_T N&gt; bool operator！=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（3） template &lt;class T，size_T N&gt; bool operator &lt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（4） template &lt;class T，size_T N&gt; bool operator &lt;=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（5） template &lt;class T，size_T N&gt; bool operator&gt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（6） template &lt;class T，size_T N&gt; bool operator&gt; =（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;Example123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; a = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; b = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; c = &#123;50, 40, 30, 20, 10&#125;; if (a==b) std::cout &lt;&lt; \"a and b are equal\\n\"; if (b!=c) std::cout &lt;&lt; \"b and c are not equal\\n\"; if (b&lt;c) std::cout &lt;&lt; \"b is less than c\\n\"; if (c&gt;b) std::cout &lt;&lt; \"c is greater than b\\n\"; if (a&lt;=b) std::cout &lt;&lt; \"a is less than or equal to b\\n\"; if (a&gt;=b) std::cout &lt;&lt; \"a is greater than or equal to b\\n\"; return 0;&#125;Output123456a and b are equalb and c are not equalb is less than cc is greater than ba is less than or equal to ba is greater than or equal to b vectorvector是表示可以改变大小的数组的序列容器。就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。针对 vector 的各种常见操作的复杂度（效率）如下：随机访问 - 常数 O(1)在尾部增删元素 - 平摊（amortized）常数 O(1)}}增删元素 - 至 vector 尾部的线性距离 O(n)}}1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; vector::vector（1）empty容器构造函数（默认构造函数）构造一个空的容器，没有元素。（2）fill构造函数用n个元素构造一个容器。每个元素都是val的副本（如果提供）。（3）范围（range）构造器使用与[ range，first，last]范围内的元素相同的顺序构造一个容器，其中的每个元素都是emplace -从该范围内相应的元素构造而成。（4）复制（copy）构造函数（并用分配器复制）按照相同的顺序构造一个包含x中每个元素的副本的容器。（5）移动（move）构造函数（和分配器移动）构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。（6）初始化列表构造函数构造一个容器中的每个元件中的一个拷贝的IL，以相同的顺序。12345678910111213141516171819default (1) explicit vector (const allocator_type&amp; alloc = allocator_type());fill (2) explicit vector (size_type n); vector (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; vector (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) vector (const vector&amp; x);vector (const vector&amp; x, const allocator_type&amp; alloc);move (5) vector (vector&amp;&amp; x);vector (vector&amp;&amp; x, const allocator_type&amp; alloc);initializer list (6) vector (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type());Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; // constructors used in the same order as described above: std::vector&lt;int&gt; first; // empty vector of ints std::vector&lt;int&gt; second(4, 100); // four ints with value 100 std::vector&lt;int&gt; third(second.begin(), second.end());// iterating through second std::vector&lt;int&gt; fourth(third); // a copy of third // the iterator constructor can also be used to construct from arrays: int myints[] = &#123;16,2,77,29&#125;; std::vector&lt;int&gt; fifth(myints, myints + sizeof(myints) / sizeof(int)); std::cout &lt;&lt; \"The contents of fifth are:\"; for(std::vector&lt;int&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1The contents of fifth are: 16 2 77 29 vector::~vector销毁容器对象。这将在每个包含的元素上调用allocator_traits::destroy，并使用其分配器释放由矢量分配的所有存储容量。1~vector(); vector::operator=将新内容分配给容器，替换其当前内容，并相应地修改其大小。123456copy (1) vector&amp; operator= (const vector&amp; x);move (2) vector&amp; operator= (vector&amp;&amp; x);initializer list (3) vector&amp; operator= (initializer_list&lt;value_type&gt; il);Example123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,0); std::vector&lt;int&gt; bar (5,0); bar &#x3D; foo; foo &#x3D; std::vector&lt;int&gt;(); std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &#39;\\n&#39;; return 0;&#125;Output12Size of foo: 0Size of bar: 3 vector::begin vector::end vector::rbegin vector::rend vector::cbegin vector::cend vector::rcbegin vector::rcend vector::size返回vector中元素的数量。这是vector中保存的实际对象的数量，不一定等于其存储容量。1size_type size() const noexcept;Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myints; std::cout &lt;&lt; \"0. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; for (int i=0; i&lt;10; i++) myints.push_back(i); std::cout &lt;&lt; \"1. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; myints.insert (myints.end(),10,100); std::cout &lt;&lt; \"2. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; myints.pop_back(); std::cout &lt;&lt; \"3. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; return 0;&#125;Output12340. size: 01. size: 102. size: 203. size: 19 vector::max_size返回该vector可容纳的元素的最大数量。由于已知的系统或库实现限制，这是容器可以达到的最大潜在大小，但容器无法保证能够达到该大小：在达到该大小之前的任何时间，仍然无法分配存储。1size_type max_size() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; \"size: \" &lt;&lt; myvector.size() &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"capacity: \" &lt;&lt; myvector.capacity() &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"max_size: \" &lt;&lt; myvector.max_size() &lt;&lt; \"\\n\"; return 0;&#125;A possible output for this program could be:123size: 100capacity: 128max_size: 1073741823 vector::resize调整容器的大小，使其包含n个元素。如果n小于当前的容器size，内容将被缩小到前n个元素，将其删除（并销毁它们）。如果n大于当前容器size，则通过在末尾插入尽可能多的元素以达到大小n来扩展内容。如果指定了val，则新元素将初始化为val的副本，否则将进行值初始化。如果n也大于当前的容器的capacity（容量），分配的存储空间将自动重新分配。注意这个函数通过插入或者删除元素的内容来改变容器的实际内容。12void resize (size_type n);void resize (size_type n, const value_type&amp; val);Example123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some initial content: for (int i=1;i&lt;10;i++) myvector.push_back(i); myvector.resize(5); myvector.resize(8,100); myvector.resize(12); std::cout &lt;&lt; \"myvector contains:\"; for (int i=0;i&lt;myvector.size();i++) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0 vector::capacity返回当前为vector分配的存储空间的大小，用元素表示。这个capacity(容量)不一定等于vector的size。它可以相等或更大，额外的空间允许适应增长，而不需要重新分配每个插入。1size_type capacity() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; \"size: \" &lt;&lt; (int) myvector.size() &lt;&lt; '\\n'; std::cout &lt;&lt; \"capacity: \" &lt;&lt; (int) myvector.capacity() &lt;&lt; '\\n'; std::cout &lt;&lt; \"max_size: \" &lt;&lt; (int) myvector.max_size() &lt;&lt; '\\n'; return 0;&#125;A possible output for this program could be:123size: 100capacity: 128max_size: 1073741823 vector::empty返回vector是否为空（即，它的size是否为0）1bool empty() const noexcept;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); for (int i=1;i&lt;=10;i++) myvector.push_back(i); while (!myvector.empty()) &#123; sum += myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; \"total: \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125;Output1total: 55 vector::reserve请求vector容量至少足以包含n个元素。如果n大于当前vector容量，则该函数使容器重新分配其存储容量，从而将其容量增加到n（或更大）。在所有其他情况下，函数调用不会导致重新分配，并且vector容量不受影响。这个函数对vector大小没有影响，也不能改变它的元素。1void reserve (size_type n);Example12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt;::size_type sz; std::vector&lt;int&gt; foo; sz = foo.capacity(); std::cout &lt;&lt; \"making foo grow:\\n\"; for (int i=0; i&lt;100; ++i) &#123; foo.push_back(i); if (sz!=foo.capacity()) &#123; sz = foo.capacity(); std::cout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n'; &#125; &#125; std::vector&lt;int&gt; bar; sz = bar.capacity(); bar.reserve(100); // this is the only difference with foo above std::cout &lt;&lt; \"making bar grow:\\n\"; for (int i=0; i&lt;100; ++i) &#123; bar.push_back(i); if (sz!=bar.capacity()) &#123; sz = bar.capacity(); std::cout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n'; &#125; &#125; return 0;&#125;Possible output1234567891011making foo grow:capacity changed: 1capacity changed: 2capacity changed: 4capacity changed: 8capacity changed: 16capacity changed: 32capacity changed: 64capacity changed: 128making bar grow:capacity changed: 100 vector::shrink_to_fit要求容器减小其capacity(容量)以适应其尺寸。该请求是非绑定的，并且容器实现可以自由地进行优化，并且保持capacity大于其size的vector。 这可能导致重新分配，但对矢量大小没有影响，并且不能改变其元素。1void shrink_to_fit();Example12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (100); std::cout &lt;&lt; \"1. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; myvector.resize(10); std::cout &lt;&lt; \"2. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; myvector.shrink_to_fit(); std::cout &lt;&lt; \"3. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; return 0;&#125;Possible output1231. capacity of myvector: 1002. capacity of myvector: 1003. capacity of myvector: 10 vector::operator[] vector::at vector::front vector::back vector::data vector::assign将新内容分配给vector，替换其当前内容，并相应地修改其大小。在范围版本（1）中，新内容是从第一个和最后一个范围内的每个元素按相同顺序构造的元素。在填充版本（2）中，新内容是n个元素，每个元素都被初始化为一个val的副本。在初始化列表版本（3）中，新内容是以相同顺序作为初始化列表传递的值的副本。所述内部分配器被用于（通过其性状），以分配和解除分配存储器如果重新分配发生。它也习惯于摧毁所有现有的元素，并构建新的元素。1234567range (1) template &lt;class InputIterator&gt; void assign (InputIterator first, InputIterator last);fill (2) void assign (size_type n, const value_type&amp; val);initializer list (3) void assign (initializer_list&lt;value_type&gt; il);Example123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; first; std::vector&lt;int&gt; second; std::vector&lt;int&gt; third; first.assign (7,100); // 7 ints with a value of 100 std::vector&lt;int&gt;::iterator it; it=first.begin()+1; second.assign (it,first.end()-1); // the 5 central values of first int myints[] = &#123;1776,7,4&#125;; third.assign (myints,myints+3); // assigning from array. std::cout &lt;&lt; \"Size of first: \" &lt;&lt; int (first.size()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"Size of second: \" &lt;&lt; int (second.size()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"Size of third: \" &lt;&lt; int (third.size()) &lt;&lt; '\\n'; return 0;&#125;Output123Size of first: 7Size of second: 5Size of third: 3补充：vector::assign 与 vector::operator= 的区别：vector::assign 实现源码12345678910111213141516void assign(size_type __n, const _Tp&amp; __val) &#123; _M_fill_assign(__n, __val); &#125;template &lt;class _Tp, class _Alloc&gt;void vector&lt;_Tp, _Alloc&gt;::_M_fill_assign(size_t __n, const value_type&amp; __val) &#123; if (__n &gt; capacity()) &#123; vector&lt;_Tp, _Alloc&gt; __tmp(__n, __val, get_allocator()); __tmp.swap(*this); &#125; else if (__n &gt; size()) &#123; fill(begin(), end(), __val); _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val); &#125; else erase(fill_n(begin(), __n, __val), end());&#125;vector::operator= 实现源码12345678910111213141516171819202122232425template &lt;class _Tp, class _Alloc&gt;vector&lt;_Tp,_Alloc&gt;&amp; vector&lt;_Tp,_Alloc&gt;::operator=(const vector&lt;_Tp, _Alloc&gt;&amp; __x)&#123; if (&amp;__x != this) &#123; const size_type __xlen = __x.size(); if (__xlen &gt; capacity()) &#123; iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end()); destroy(_M_start, _M_finish); _M_deallocate(_M_start, _M_end_of_storage - _M_start); _M_start = __tmp; _M_end_of_storage = _M_start + __xlen; &#125; else if (size() &gt;= __xlen) &#123; iterator __i = copy(__x.begin(), __x.end(), begin()); destroy(__i, _M_finish); &#125; else &#123; copy(__x.begin(), __x.begin() + size(), _M_start); uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish); &#125; _M_finish = _M_start + __xlen; &#125; return *this;&#125; vector::push_back在vector的最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新的元素。这有效地将容器size增加了一个，如果新的矢量size超过了当前vector的capacity，则导致所分配的存储空间自动重新分配。12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val);Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int myint; std::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\\n\"; do &#123; std::cin &gt;&gt; myint; myvector.push_back (myint); &#125; while (myint); std::cout &lt;&lt; \"myvector stores \" &lt;&lt; int(myvector.size()) &lt;&lt; \" numbers.\\n\"; return 0;&#125; vector::pop_back删除vector中的最后一个元素，有效地将容器size减少一个。这破坏了被删除的元素。1void pop_back();Example123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); myvector.push_back (100); myvector.push_back (200); myvector.push_back (300); while (!myvector.empty()) &#123; sum+=myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; \"The elements of myvector add up to \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125;Output1The elements of myvector add up to 600 vector::insert通过在指定位置的元素之前插入新元素来扩展该vector，通过插入元素的数量有效地增加容器大小。 这会导致分配的存储空间自动重新分配，只有在新的vector的size超过当前的vector的capacity的情况下。由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。1234567891011single element (1) iterator insert (const_iterator position, const value_type&amp; val);fill (2) iterator insert (const_iterator position, size_type n, const value_type&amp; val);range (3) template &lt;class InputIterator&gt;iterator insert (const_iterator position, InputIterator first, InputIterator last);move (4) iterator insert (const_iterator position, value_type&amp;&amp; val);initializer list (5) iterator insert (const_iterator position, initializer_list&lt;value_type&gt; il);Example1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (3,100); std::vector&lt;int&gt;::iterator it; it = myvector.begin(); it = myvector.insert ( it , 200 ); myvector.insert (it,2,300); // \"it\" no longer valid, get a new one: it = myvector.begin(); std::vector&lt;int&gt; anothervector (2,400); myvector.insert (it+2,anothervector.begin(),anothervector.end()); int myarray [] = &#123; 501,502,503 &#125;; myvector.insert (myvector.begin(), myarray, myarray+3); std::cout &lt;&lt; \"myvector contains:\"; for (it=myvector.begin(); it&lt;myvector.end(); it++) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 501 502 503 300 300 400 400 200 100 100 100补充：insert 迭代器野指针错误：123456789101112131415int main()&#123; std::vector&lt;int&gt; v(5, 0); std::vector&lt;int&gt;::iterator vi; // 获取vector第一个元素的迭代器 vi = v.begin(); // push_back 插入元素之后可能会因为 push_back 的骚操作（创建一个新vector把旧vector的值复制到新vector），导致vector迭代器iterator的指针变成野指针，而导致insert出错 v.push_back(10); v.insert(vi, 2, 300); return 0;&#125;改正：应该把vi = v.begin();放到v.push_back(10);后面 vector::erase从vector中删除单个元素（position）或一系列元素（[first，last））。这有效地减少了被去除的元素的数量，从而破坏了容器的大小。由于vector使用一个数组作为其底层存储，所以删除除vector结束位置之后，或vector的begin之前的元素外，将导致容器将段被擦除后的所有元素重新定位到新的位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。12iterator erase (const_iterator position);iterator erase (const_iterator first, const_iterator last);Example1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some values (from 1 to 10) for (int i=1; i&lt;=10; i++) myvector.push_back(i); // erase the 6th element myvector.erase (myvector.begin()+5); // erase the first 3 elements: myvector.erase (myvector.begin(),myvector.begin()+3); std::cout &lt;&lt; \"myvector contains:\"; for (unsigned i=0; i&lt;myvector.size(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 4 5 7 8 9 10 vector::swap通过x的内容交换容器的内容，x是另一个相同类型的vector对象。尺寸可能不同。在调用这个成员函数之后，这个容器中的元素是那些在调用之前在x中的元素，而x的元素是在这个元素中的元素。所有迭代器，引用和指针对交换对象保持有效。请注意，非成员函数存在具有相同名称的交换，并使用与此成员函数相似的优化来重载该算法。1void swap (vector&amp; x);Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,100); // three ints with a value of 100 std::vector&lt;int&gt; bar (5,200); // five ints with a value of 200 foo.swap(bar); std::cout &lt;&lt; \"foo contains:\"; for (unsigned i=0; i&lt;foo.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; foo[i]; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"bar contains:\"; for (unsigned i=0; i&lt;bar.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; bar[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output12foo contains: 200 200 200 200 200 bar contains: 100 100 100 vector::clear从vector中删除所有的元素（被销毁），留下size为0的容器。不保证重新分配，并且由于调用此函数， vector的capacity不保证发生变化。强制重新分配的典型替代方法是使用swap：vector&lt;T&gt;().swap(x); // clear x reallocating1void clear() noexcept;Example1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;void printVector(const std::vector&lt;int&gt; &amp;v)&#123; for (auto it = v.begin(); it != v.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; ' '; &#125; std::cout &lt;&lt; std::endl;&#125;int main()&#123; std::vector&lt;int&gt; v1(5, 50); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.clear(); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.push_back(11); v1.push_back(22); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; return 0;&#125;Output12345678950 50 50 50 50v1 size &#x3D; 5v1 capacity &#x3D; 5v1 size &#x3D; 0v1 capacity &#x3D; 511 22v1 size &#x3D; 2v1 capacity &#x3D; 5 vector::emplace通过在position位置处插入新元素args来扩展容器。这个新元素是用args作为构建的参数来构建的。这有效地增加了一个容器的大小。分配存储空间的自动重新分配发生在新的vector的size超过当前向量容量的情况下。由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。该元素是通过调用allocator_traits::construct来转换args来创建的。插入一个类似的成员函数，将现有对象复制或移动到容器中。12template &lt;class... Args&gt;iterator emplace (const_iterator position, Args&amp;&amp;... args);Example123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector = &#123;10,20,30&#125;; auto it = myvector.emplace ( myvector.begin()+1, 100 ); myvector.emplace ( it, 200 ); myvector.emplace ( myvector.end(), 300 ); std::cout &lt;&lt; \"myvector contains:\"; for (auto&amp; x: myvector) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 10 200 100 20 30 300 vector::emplace_back在vector的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新元素是用args作为构造函数的参数来构造的。这有效地将容器大小增加了一个，如果新的矢量大小超过了当前的vector容量，则导致所分配的存储空间自动重新分配。该元素是通过调用allocator_traits :: construct来转换args来创建的。与push_back相比，emplace_back可以避免额外的复制和移动操作。12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args);Example12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct President&#123; std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) &#123; std::cout &lt;&lt; \"I am being constructed.\\n\"; &#125; President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) &#123; std::cout &lt;&lt; \"I am being moved.\\n\"; &#125; President&amp; operator=(const President&amp; other) = default;&#125;; int main()&#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; \"emplace_back:\\n\"; elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; \"\\npush_back:\\n\"; reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936)); std::cout &lt;&lt; \"\\nContents:\\n\"; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was re-elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125;&#125;Output12345678910emplace_back:I am being constructed. push_back:I am being constructed.I am being moved. Contents:Nelson Mandela was elected president of South Africa in 1994.Franklin Delano Roosevelt was re-elected president of the USA in 1936. vector::get_allocator返回与vector关联的构造器对象的副本。1allocator_type get_allocator() const noexcept;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int * p; unsigned int i; // allocate an array with space for 5 elements using vector's allocator: p = myvector.get_allocator().allocate(5); // construct values in-place on the array: for (i=0; i&lt;5; i++) myvector.get_allocator().construct(&amp;p[i],i); std::cout &lt;&lt; \"The allocated array contains:\"; for (i=0; i&lt;5; i++) std::cout &lt;&lt; ' ' &lt;&lt; p[i]; std::cout &lt;&lt; '\\n'; // destroy and deallocate: for (i=0; i&lt;5; i++) myvector.get_allocator().destroy(&amp;p[i]); myvector.get_allocator().deallocate(p,5); return 0;&#125;Output1The allocated array contains: 0 1 2 3 4注意：deallocate和destory的关系：deallocate实现的源码：template &lt;class T&gt; inline void _deallocate(T* buffer) { ::operator delete(buffer); //为什么不用 delete [] ? ,operator delete 区别于 delete //operator delete 是一个底层操作符 } destory：template &lt;class T&gt; inline void _destory(T *ptr) { ptr-&gt;~T(); } destory负责调用类型的析构函数，销毁相应内存上的内容（但销毁后内存地址仍保留）deallocate负责释放内存（此时相应内存中的值在此之前应调用destory销毁，将内存地址返回给系统，代表这部分地址使用引用-1） relational operators (vector) swap (vector) vector dequedeque（['dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。deque上常见操作的复杂性（效率）如下：随机访问 - 常数O(1)在结尾或开头插入或移除元素 - 摊销不变O(1)插入或移除元素 - 线性O(n)1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque; deque::deque构造一个deque容器对象，根据所使用的构造函数版本初始化它的内容：Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; unsigned int i; // constructors used in the same order as described above: std::deque&lt;int&gt; first; // empty deque of ints std::deque&lt;int&gt; second (4,100); // four ints with value 100 std::deque&lt;int&gt; third (second.begin(),second.end()); // iterating through second std::deque&lt;int&gt; fourth (third); // a copy of third // the iterator constructor can be used to copy arrays: int myints[] = &#123;16,2,77,29&#125;; std::deque&lt;int&gt; fifth (myints, myints + sizeof(myints) / sizeof(int) ); std::cout &lt;&lt; \"The contents of fifth are:\"; for (std::deque&lt;int&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1The contents of fifth are: 16 2 77 29 deque::push_back在当前的最后一个元素之后 ，在deque容器的末尾添加一个新元素。val的内容被复制（或移动）到新的元素。这有效地增加了一个容器的大小。12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val);Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int myint; std::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\\n\"; do &#123; std::cin &gt;&gt; myint; mydeque.push_back (myint); &#125; while (myint); std::cout &lt;&lt; \"mydeque stores \" &lt;&lt; (int) mydeque.size() &lt;&lt; \" numbers.\\n\"; return 0;&#125; deque::push_front在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前。val的内容被复制（或移动）到插入的元素。这有效地增加了一个容器的大小。12void push_front (const value_type&amp; val);void push_front (value_type&amp;&amp; val);Example12345678910111213141516#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque (2,100); // two ints with a value of 100 mydeque.push_front (200); mydeque.push_front (300); std::cout &lt;&lt; \"mydeque contains:\"; for (std::deque&lt;int&gt;::iterator it = mydeque.begin(); it != mydeque.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1300 200 100 100 deque::pop_back删除deque容器中的最后一个元素，有效地将容器大小减少一个。这破坏了被删除的元素。1void pop_back();Example123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int sum (0); mydeque.push_back (10); mydeque.push_back (20); mydeque.push_back (30); while (!mydeque.empty()) &#123; sum+=mydeque.back(); mydeque.pop_back(); &#125; std::cout &lt;&lt; \"The elements of mydeque add up to \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125;Output1The elements of mydeque add up to 60 deque::pop_front删除deque容器中的第一个元素，有效地减小其大小。这破坏了被删除的元素。1void pop_front();Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; mydeque.push_back (100); mydeque.push_back (200); mydeque.push_back (300); std::cout &lt;&lt; \"Popping out the elements in mydeque:\"; while (!mydeque.empty()) &#123; std::cout &lt;&lt; ' ' &lt;&lt; mydeque.front(); mydeque.pop_front(); &#125; std::cout &lt;&lt; \"\\nThe final size of mydeque is \" &lt;&lt; int(mydeque.size()) &lt;&lt; '\\n'; return 0;&#125;Output12Popping out the elements in mydeque: 100 200 300The final size of mydeque is 0 deque::emplace_front在deque的开头插入一个新的元素，就在其当前的第一个元素之前。这个新的元素是用args作为构建的参数来构建的。这有效地增加了一个容器的大小。该元素是通过调用allocator_traits::construct来转换args来创建的。存在一个类似的成员函数push_front，它可以将现有对象复制或移动到容器中。12template &lt;class... Args&gt; void emplace_front (Args&amp;&amp;... args);Example1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_front (111); mydeque.emplace_front (222); std::cout &lt;&lt; \"mydeque contains:\"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mydeque contains: 222 111 10 20 30 deque::emplace_back在deque的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新的元素是用args作为构建的参数来构建的。这有效地增加了一个容器的大小。该元素是通过调用allocator_traits::construct来转换args来创建的。存在一个类似的成员函数push_back，它可以将现有对象复制或移动到容器中12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args);Example1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_back (100); mydeque.emplace_back (200); std::cout &lt;&lt; \"mydeque contains:\"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mydeque contains: 10 20 30 100 200 forward_listforward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。 forward_list::forward_list12345678910111213141516171819default (1) explicit forward_list (const allocator_type&amp; alloc = allocator_type());fill (2) explicit forward_list (size_type n);explicit forward_list (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; forward_list (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) forward_list (const forward_list&amp; fwdlst);forward_list (const forward_list&amp; fwdlst, const allocator_type&amp; alloc);move (5) forward_list (forward_list&amp;&amp; fwdlst);forward_list (forward_list&amp;&amp; fwdlst, const allocator_type&amp; alloc);initializer list (6) forward_list (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type());Example1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; // constructors used in the same order as described above: std::forward_list&lt;int&gt; first; // default: empty std::forward_list&lt;int&gt; second (3,77); // fill: 3 seventy-sevens std::forward_list&lt;int&gt; third (second.begin(), second.end()); // range initialization std::forward_list&lt;int&gt; fourth (third); // copy constructor std::forward_list&lt;int&gt; fifth (std::move(fourth)); // move ctor. (fourth wasted) std::forward_list&lt;int&gt; sixth = &#123;3, 52, 25, 90&#125;; // initializer_list constructor std::cout &lt;&lt; \"first:\" ; for (int&amp; x: first) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"second:\"; for (int&amp; x: second) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"third:\"; for (int&amp; x: third) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"fourth:\"; for (int&amp; x: fourth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"fifth:\"; for (int&amp; x: fifth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"sixth:\"; for (int&amp; x: sixth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Possible output1234567forward_list constructor examples:first:second: 77 77 77third: 77 77 77fourth:fifth: 77 77 77sixth: 3 52 25 90 forward_list::~forward_list forward_list::before_begin返回指向容器中第一个元素之前的位置的迭代器。返回的迭代器不应被解除引用：它是为了用作成员函数的参数emplace_after，insert_after，erase_after或splice_after，指定序列，其中执行该动作的位置的开始位置。12 iterator before_begin() noexcept;const_iterator before_begin() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;20, 30, 40, 50&#125;; mylist.insert_after ( mylist.before_begin(), 11 ); std::cout &lt;&lt; \"mylist contains:\"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mylist contains: 11 20 30 40 50 forward_list::cbefore_begin返回指向容器中第一个元素之前的位置的const_iterator。一个常量性是指向常量内容的迭代器。这个迭代器可以增加和减少（除非它本身也是const），就像forward_list::before_begin返回的迭代器一样，但不能用来修改它指向的内容。返回的价值不得解除引用。1const_iterator cbefore_begin() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;77, 2, 16&#125;; mylist.insert_after ( mylist.cbefore_begin(), 19 ); std::cout &lt;&lt; \"mylist contains:\"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mylist contains: 19 77 2 16 list stack queue priority_queue set multiset mapmap 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种：1typedef pair&lt;const Key, T&gt; value_type;在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施12345template &lt; class Key, // map::key_type class T, // map::mapped_type class Compare = less&lt;Key&gt;, // map::key_compare class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; // map::allocator_type &gt; class map; map::map构造一个映射容器对象，根据所使用的构造器版本初始化其内容：（1）空容器构造函数（默认构造函数）构造一个空的容器，没有元素。（2）范围构造函数构造具有一样多的元素的范围内的容器[第一，最后一个），其中每个元件布设构造的从在该范围内它的相应的元件。（3）复制构造函数（并用分配器复制）使用x中的每个元素的副本构造一个容器。（4）移动构造函数（并与分配器一起移动）构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。（5）初始化列表构造函数用il中的每个元素的副本构造一个容器。12345678910111213141516171819empty (1) explicit map (const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());explicit map (const allocator_type&amp; alloc);range (2) template &lt;class InputIterator&gt; map (InputIterator first, InputIterator last, const key_compare&amp; comp = key_compare(), const allocator_type&amp; = allocator_type());copy (3) map (const map&amp; x);map (const map&amp; x, const allocator_type&amp; alloc);move (4) map (map&amp;&amp; x);map (map&amp;&amp; x, const allocator_type&amp; alloc);initializer list (5) map (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());Example123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;map&gt;bool fncomp (char lhs, char rhs) &#123;return lhs&lt;rhs;&#125;struct classcomp &#123; bool operator() (const char&amp; lhs, const char&amp; rhs) const &#123;return lhs&lt;rhs;&#125;&#125;;int main ()&#123; std::map&lt;char,int&gt; first; first['a']=10; first['b']=30; first['c']=50; first['d']=70; std::map&lt;char,int&gt; second (first.begin(),first.end()); std::map&lt;char,int&gt; third (second); std::map&lt;char,int,classcomp&gt; fourth; // class as Compare bool(*fn_pt)(char,char) = fncomp; std::map&lt;char,int,bool(*)(char,char)&gt; fifth (fn_pt); // function pointer as Compare return 0;&#125; map::begin返回引用map容器中第一个元素的迭代器。由于map容器始终保持其元素的顺序，所以开始指向遵循容器排序标准的元素。如果容器是空的，则返回的迭代器值不应被解除引用。12 iterator begin() noexcept;const_iterator begin() const noexcept;Example1234567891011121314151617#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['b'] = 100; mymap['a'] = 200; mymap['c'] = 300; // show content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output123a &#x3D;&gt; 200b &#x3D;&gt; 100c &#x3D;&gt; 300 map::key_comp返回容器用于比较键的比较对象的副本。1key_compare key_comp() const;Example1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::key_compare mycomp = mymap.key_comp(); mymap['a']=100; mymap['b']=200; mymap['c']=300; std::cout &lt;&lt; \"mymap contains:\\n\"; char highest = mymap.rbegin()-&gt;first; // key value of last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; &#125; while ( mycomp((*it++).first, highest) ); std::cout &lt;&lt; '\\n'; return 0;&#125;Output1234mymap contains:a &#x3D;&gt; 100b &#x3D;&gt; 200c &#x3D;&gt; 300 map::value_comp返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前。1value_compare value_comp() const;Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['x']=1001; mymap['y']=2002; mymap['z']=3003; std::cout &lt;&lt; \"mymap contains:\\n\"; std::pair&lt;char,int&gt; highest = *mymap.rbegin(); // last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; &#125; while ( mymap.value_comp()(*it++, highest) ); return 0;&#125;Output1234mymap contains:x &#x3D;&gt; 1001y &#x3D;&gt; 2002z &#x3D;&gt; 3003 map::find在容器中搜索具有等于k的键的元素，如果找到则返回一个迭代器，否则返回map::end的迭代器。如果容器的比较对象自反地返回假（即，不管元素作为参数传递的顺序），则两个key被认为是等同的。另一个成员函数map::count可以用来检查一个特定的键是否存在。12 iterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator it; mymap['a']=50; mymap['b']=100; mymap['c']=150; mymap['d']=200; it = mymap.find('b'); if (it != mymap.end()) mymap.erase (it); // print content: std::cout &lt;&lt; \"elements in mymap:\" &lt;&lt; '\\n'; std::cout &lt;&lt; \"a =&gt; \" &lt;&lt; mymap.find('a')-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"c =&gt; \" &lt;&lt; mymap.find('c')-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"d =&gt; \" &lt;&lt; mymap.find('d')-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output1234elements in mymap:a &#x3D;&gt; 50c &#x3D;&gt; 150d &#x3D;&gt; 200 map::count在容器中搜索具有等于k的键的元素，并返回匹配的数量。由于地图容器中的所有元素都是唯一的，因此该函数只能返回1（如果找到该元素）或返回零（否则）。如果容器的比较对象自反地返回错误（即，不管按键作为参数传递的顺序），则两个键被认为是等同的。1size_type count (const key_type&amp; k) const;Example1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; char c; mymap ['a']=101; mymap ['c']=202; mymap ['f']=303; for (c='a'; c&lt;'h'; c++) &#123; std::cout &lt;&lt; c; if (mymap.count(c)&gt;0) std::cout &lt;&lt; \" is an element of mymap.\\n\"; else std::cout &lt;&lt; \" is not an element of mymap.\\n\"; &#125; return 0;&#125;Output1234567a is an element of mymap.b is not an element of mymap.c is an element of mymap.d is not an element of mymap.e is not an element of mymap.f is an element of mymap.g is not an element of mymap. map::lower_bound将迭代器返回到下限返回指向容器中第一个元素的迭代器，该元素的键不会在k之前出现（即，它是等价的或者在其后）。该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（element_key，k）将返回false的第一个元素。如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键不小于k。一个类似的成员函数upper_bound具有相同的行为lower_bound，除非映射包含一个key值等于k的元素：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。12 iterator lower_bound (const key_type&amp; k);const_iterator lower_bound (const key_type&amp; k) const;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output12a &#x3D;&gt; 20e &#x3D;&gt; 100 map::upper_bound将迭代器返回到上限返回一个指向容器中第一个元素的迭代器，它的关键字被认为是在k之后。该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（k，element_key）将返回true的第一个元素。如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键大于k。类似的成员函数lower_bound具有与upper_bound相同的行为，除了map包含一个元素，其键值等于k：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。12 iterator upper_bound (const key_type&amp; k);const_iterator upper_bound (const key_type&amp; k) const;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output12a &#x3D;&gt; 20e &#x3D;&gt; 100 map::equal_range获取相同元素的范围返回包含容器中所有具有与k等价的键的元素的范围边界。 由于地图容器中的元素具有唯一键，所以返回的范围最多只包含一个元素。如果没有找到匹配，则返回的范围具有零的长度，与两个迭代器指向具有考虑去后一个密钥对所述第一元件ķ根据容器的内部比较对象（key_comp）。如果容器的比较对象返回false，则两个键被认为是等价的。12pair&lt;const_iterator,const_iterator&gt; equal_range (const key_type&amp; k) const;pair&lt;iterator,iterator&gt; equal_range (const key_type&amp; k);Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['a']=10; mymap['b']=20; mymap['c']=30; std::pair&lt;std::map&lt;char,int&gt;::iterator,std::map&lt;char,int&gt;::iterator&gt; ret; ret = mymap.equal_range('b'); std::cout &lt;&lt; \"lower bound points to: \"; std::cout &lt;&lt; ret.first-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; ret.first-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"upper bound points to: \"; std::cout &lt;&lt; ret.second-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; ret.second-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output12lower bound points to: &#39;b&#39; &#x3D;&gt; 20upper bound points to: &#39;c&#39; &#x3D;&gt; 30 multimap 无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap包括：unordered_setunordered_multisetunordered_mapunordered_multimap都是以哈希表实现的。unordered_set、unodered_multiset结构：unordered_map、unodered_multimap结构： unordered_set unordered_multiset unordered_map unordered_multimap tuple元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。1template &lt;class... Types&gt; class tuple;Example1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;tuple&gt; // std::tuple, std::get, std::tie, std::ignoreint main ()&#123; std::tuple&lt;int,char&gt; foo (10,'x'); auto bar = std::make_tuple (\"test\", 3.1, 14, 'y'); std::get&lt;2&gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get&lt;3&gt;(bar); std::get&lt;0&gt;(foo) = std::get&lt;2&gt;(bar); std::get&lt;1&gt;(foo) = mychar; std::cout &lt;&lt; \"foo contains: \"; std::cout &lt;&lt; std::get&lt;0&gt;(foo) &lt;&lt; ' '; std::cout &lt;&lt; std::get&lt;1&gt;(foo) &lt;&lt; '\\n'; return 0;&#125;Output1foo contains: 100 y tuple::tuple构建一个 tuple（元组）对象。这涉及单独构建其元素，初始化取决于调用的构造函数形式：（1）默认的构造函数构建一个 元组对象的元素值初始化。（2）复制/移动构造函数该对象使用tpl的内容进行初始化 元组目的。tpl的相应元素被传递给每个元素的构造函数。（3）隐式转换构造函数同上。tpl中的所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。（4）初始化构造函数用elems中的相应元素初始化每个元素。elems的相应元素被传递给每个元素的构造函数。（5）对转换构造函数该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。（6）分配器版本和上面的版本一样，除了每个元素都是使用allocator alloc构造的。1234567891011121314151617181920212223242526272829303132333435363738default (1) constexpr tuple();copy / move (2) tuple (const tuple&amp; tpl) = default;tuple (tuple&amp;&amp; tpl) = default;implicit conversion (3) template &lt;class... UTypes&gt; tuple (const tuple&lt;UTypes...&gt;&amp; tpl);template &lt;class... UTypes&gt; tuple (tuple&lt;UTypes...&gt;&amp;&amp; tpl);initialization (4) explicit tuple (const Types&amp;... elems);template &lt;class... UTypes&gt; explicit tuple (UTypes&amp;&amp;... elems);conversion from pair (5) template &lt;class U1, class U2&gt; tuple (const pair&lt;U1,U2&gt;&amp; pr);template &lt;class U1, class U2&gt; tuple (pair&lt;U1,U2&gt;&amp;&amp; pr);allocator (6) template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&amp;&amp; tpl);template&lt;class Alloc,class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&lt;UTypes...&gt;&amp; tpl);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&lt;UTypes...&gt;&amp;&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const Types&amp;... elems);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, UTypes&amp;&amp;... elems);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const pair&lt;U1,U2&gt;&amp; pr);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, pair&lt;U1,U2&gt;&amp;&amp; pr);Example123456789101112131415161718#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::make_pair#include &lt;tuple&gt; // std::tuple, std::make_tuple, std::getint main ()&#123; std::tuple&lt;int,char&gt; first; // default std::tuple&lt;int,char&gt; second (first); // copy std::tuple&lt;int,char&gt; third (std::make_tuple(20,'b')); // move std::tuple&lt;long,char&gt; fourth (third); // implicit conversion std::tuple&lt;int,char&gt; fifth (10,'a'); // initialization std::tuple&lt;int,char&gt; sixth (std::make_pair(30,'c')); // from pair / move std::cout &lt;&lt; \"sixth contains: \" &lt;&lt; std::get&lt;0&gt;(sixth); std::cout &lt;&lt; \" and \" &lt;&lt; std::get&lt;1&gt;(sixth) &lt;&lt; '\\n'; return 0;&#125;Output1sixth contains: 30 and c pair这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。pair是tuple（元组）的一个特例。pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。应用：可以将两个类型数据组合成一个如map&lt;key, value&gt;当某个函数需要两个返回值时1template &lt;class T1, class T2&gt; struct pair; pair::pair构建一个pair对象。这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式：（1）默认的构造函数构建一个 对对象的元素值初始化。（2）复制/移动构造函数（和隐式转换）该对象被初始化为pr的内容 对目的。pr的相应成员被传递给每个成员的构造函数。（3）初始化构造函数会员 第一是由一个和成员构建的第二与b。（4）分段构造构造成员 first 和 second 到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。1234567891011121314default (1) constexpr pair();copy / move (2) template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);pair (const pair&amp; pr) = default;pair (pair&amp;&amp; pr) = default;initialization (3) pair (const first_type&amp; a, const second_type&amp; b);template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);piecewise (4) template &lt;class... Args1, class... Args2&gt; pair (piecewise_construct_t pwc, tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args);Example12345678910111213141516171819#include &lt;utility&gt; // std::pair, std::make_pair#include &lt;string&gt; // std::string#include &lt;iostream&gt; // std::coutint main () &#123; std::pair &lt;std::string,double&gt; product1; // default constructor std::pair &lt;std::string,double&gt; product2 (\"tomatoes\",2.30); // value init std::pair &lt;std::string,double&gt; product3 (product2); // copy constructor product1 = std::make_pair(std::string(\"lightbulbs\"),0.99); // using make_pair (move) product2.first = \"shoes\"; // the type of first is string product2.second = 39.90; // the type of second is double std::cout &lt;&lt; \"The price of \" &lt;&lt; product1.first &lt;&lt; \" is $\" &lt;&lt; product1.second &lt;&lt; '\\n'; std::cout &lt;&lt; \"The price of \" &lt;&lt; product2.first &lt;&lt; \" is $\" &lt;&lt; product2.second &lt;&lt; '\\n'; std::cout &lt;&lt; \"The price of \" &lt;&lt; product3.first &lt;&lt; \" is $\" &lt;&lt; product3.second &lt;&lt; '\\n'; return 0;&#125;Output123The price of lightbulbs is $0.99The price of shoes is $39.9The price of tomatoes is $2.3","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://forwardpeng.github.io/tags/C/"}]}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"面试","slug":"面试","permalink":"http://forwardpeng.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"树","slug":"树","permalink":"http://forwardpeng.github.io/tags/%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法导论","slug":"算法导论","permalink":"http://forwardpeng.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"C++","slug":"C","permalink":"http://forwardpeng.github.io/tags/C/"}]}