{"meta":{"title":"Hello World","subtitle":"","description":"","author":"John Doe","url":"http://forwardpeng.github.io","root":"/"},"pages":[{"title":"书单","date":"2020-04-15T07:51:11.956Z","updated":"2020-04-15T07:51:11.956Z","comments":false,"path":"books/index.html","permalink":"http://forwardpeng.github.io/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-04-15T07:51:41.545Z","updated":"2020-04-15T07:51:41.545Z","comments":true,"path":"links/index.html","permalink":"http://forwardpeng.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-04-15T07:50:12.856Z","updated":"2020-04-15T07:50:12.856Z","comments":false,"path":"repository/index.html","permalink":"http://forwardpeng.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-15T13:50:22.000Z","updated":"2020-04-16T01:51:00.843Z","comments":true,"path":"categories/index.html","permalink":"http://forwardpeng.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-15T14:11:14.000Z","updated":"2020-04-16T01:53:51.407Z","comments":true,"path":"tags/index.html","permalink":"http://forwardpeng.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python-并发编程","slug":"Python-并发编程","date":"2020-04-30T02:26:52.000Z","updated":"2020-04-30T02:27:02.992Z","comments":true,"path":"2020/04/30/Python-并发编程/","link":"","permalink":"http://forwardpeng.github.io/2020/04/30/Python-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Python-文件操作","slug":"Python-文件操作","date":"2020-04-29T10:12:39.000Z","updated":"2020-04-30T02:04:40.530Z","comments":true,"path":"2020/04/29/Python-文件操作/","link":"","permalink":"http://forwardpeng.github.io/2020/04/29/Python-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"","text":"基本操作常见的操作包括创建、删除、修改权限、读取、写入等，这些操作可大致分为以下 2 类：删除、修改权限：作用于文件本身，属于系统级操作。写入、读取：是文件最常用的操作，作用于文件的内容，属于应用级操作。文件的应用级操作可以分为以下3步，每一步都需要借助对应的函数实现：打开文件：使用 open()函数，该函数会返回一个文件对象；对已打开文件做读/写操作：读取文件内容可使用read()、readline() 以及 readlines() 函数；向文件中写入内容，可以使用write()函数。关闭文件：完成对文件的读/写操作之后，最后需要关闭文件，可以使用 close() 函数。 open()函数：打开指定文件open()函数用于创建或打开指定文件，该函数的常用语法格式如下：file = open(file_name [, mode=‘r’ [ , buffering=-1 [ , encoding = None ]]])此格式中，用[]括起来的部分为可选参数，即可以使用也可以省略。其中，各个参数所代表的含义如下：file：表示要创建的文件对象。file_mode：要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。mode：可选参数，用于指定文件的打开模式。可选的打开模式如表 1 所示。如果不写，则默认以只读（r）模式打开文件。buffing：可选参数，用于指定对文件做读写操作时，是否使用缓冲区（本节后续会详细介绍）。encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同，以 Windows 为例，其默认为 cp936（实际上就是 GBK 编码）open()函数支持的文件打开模式如下表：模式意义注意事项r只读模式打开文件，读文件内容的指针会放在文件的开头。操作的文件必须存在。rb以二进制格式、采用只读模式打开文件，读文件内容的指针位于文件的开头，一般用于非文本文件，如图片文件、音频文件等。操作的文件必须存在。r+打开文件后，既可以从头读取文件内容，也可以从开头向文件中写入新的内容，写入的新内容会覆盖文件中等长度的原有内容。操作的文件必须存在。rb+以二进制格式、采用读写模式打开文件，读写文件的指针会放在文件的开头，通常针对非文本文件（如音频文件）。操作的文件必须存在。w以只写模式打开文件，若该文件存在，打开时会清空文件中原有的内容。 若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。wb以二进制格式、只写模式打开文件，一般用于非文本文件（如音频文件）若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。w+打开文件后，会对原有内容进行清空，并对该文件有读写权限。若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。wb+以二进制格式、读写模式打开文件，一般用于非文本文件若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。a以追加模式打开一个文件，对文件只有写入权限，如果文件已经存在，文件指针将放在文件的末尾（即新写入内容会位于已有内容之后）；反之，则会创建新文件。ab以二进制格式打开文件，并采用追加模式，对文件只有写权限。如果该文件已存在，文件指针位于文件末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。a+以读写模式打开文件；如果文件存在，文件指针放在文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。ab+以二进制模式打开文件，并采用追加模式，对文件具有读写权限，如果文件存在，则文件指针位于文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。文件打开模式，直接决定了后续可以对文件做哪些操作。例如，使用 r 模式打开的文件，后续编写的代码只能读取文件，而无法修改文件内容。图1 不同文件打开模式的功能 open()是否需要缓冲区如果buffing参数的值为0（或者 False），则表示在打开指定文件时不使用缓冲区；如果buffing参数值为大于 1 的整数，该整数用于指定缓冲区的大小（单位是字节）；如果buffing参数的值为负数，则代表使用默认的缓冲区大小。使用缓冲区，则程序在执行输出操作时，会先将所有数据都输出到缓冲区中，然后继续执行其它操作，缓冲区中的数据会有外设自行读取处理；同样，当程序执行输入操作时，会先等外设将数据读入缓冲区中，无需同外设做同步读写操作。 open()文件对象常用的属性成功打开文件之后，可以调用文件对象本身拥有的属性获取当前文件的部分信息，其常见的属性为：file.name：返回文件的名称；file.mode：返回打开文件时，采用的文件打开模式；file.encoding：返回打开文件时使用的编码格式；file.closed：判断文件是否己经关闭。 read()函数：按字节(字符)读取文件Python 提供了如下 3 种函数，它们都可以帮我们实现读取文件中数据的操作：read() 函数：逐个字节或者字符读取文件中的内容；readline() 函数：逐行读取文件中的内容；readlines() 函数：一次性读取文件中多行内容。 read()函数如果文件是以文本模式（非二进制模式）打开的，则 read() 函数会逐个字符进行读取；反之，如果文件以二进制模式打开，则 read() 函数会逐个字节进行读取。read() 函数的基本语法格式如下：file.read([size])其中，file表示已打开的文件对象；size 作为一个可选参数，用于指定一次最多可读取的字符（字节）个数，如果省略，则默认一次性读取所有内容。注意，当操作文件结束后，必须调用close() 函数手动将打开的文件进行关闭，这样可以避免程序发生不必要的错误。 readline()函数readline() 函数用于读取文件中的一行，包含最后的换行符“\\n”。此函数的基本语法格式为：file.readline([size])其中，file 为打开的文件对象；size 为可选参数，用于指定读取每一行时，一次最多读取的字符（字节）数。和read()函数一样，此函数成功读取文件数据的前提是，使用 open() 函数指定打开文件的模式必须为可读模式（包括 r、rb、r+、rb+ 4 种）。由于 readline() 函数在读取文件中一行的内容时，会读取最后的换行符“\\n”，再加上 print() 函数输出内容时默认会换行，所以输出结果中会看到多出了一个空行。 readlines()函数readlines() 函数用于读取文件中的所有行，它和调用不指定 size 参数的 read() 函数类似，只不过该函数返回是一个字符串列表，其中每个元素为文件中的一行内容。和readline()函数一样，readlines()函数在读取每一行时，会连同行尾的换行符一块读取。readlines()函数的基本语法格式如下：file.readlines()其中，file 为打开的文件对象。和 read()、readline() 函数一样，它要求打开文件的模式必须为可读模式（包括 r、rb、r+、rb+ 4 种）。 write()和writelines()：向文件中写入数据Python 中的文件对象提供了 write() 函数，可以向文件中写入指定内容。该函数的语法格式如下：file.write(string)其中，file 表示已经打开的文件对象；string 表示要写入文件的字符串（或字节串，仅适用写入二进制文件中）。注意，在使用 write() 向文件中写入数据，需保证使用 open() 函数是以 r+、w、w+、a 或 a+ 的模式打开文件，否则执行 write() 函数会抛出 io.UnsupportedOperation 错误。采用不同的文件打开模式，会直接影响 write() 函数向文件中写入数据的效果。另外，在写入文件完成后，一定要调用 close() 函数将打开的文件关闭，否则写入的内容不会保存到文件中。例如，将上面程序中最后一行 f.close() 删掉，再次运行此程序并打开 a.txt，你会发现该文件是空的。这是因为，当我们在写入文件内容时，操作系统不会立刻把数据写入磁盘，而是先缓存起来，只有调用 close() 函数时，操作系统才会保证把没有写入的数据全部写入磁盘文件中。 writelines()函数Python 的文件对象中，不仅提供了 write() 函数，还提供了 writelines() 函数，可以实现将字符串列表写入文件中。注意，写入函数只有 write() 和 writelines() 函数，而没有名为 writeline 的函数。12345f = open('a.txt', 'r')n = open('b.txt','w+')n.writelines(f.readlines())n.close()f.close()使用 writelines()函数向文件中写入多行数据时，不会自动给各行添加换行符。上面例子中，之所以b.txt文件中会逐行显示数据，是因为readlines()函数在读取各行数据时，读入了行尾的换行符。 colse()函数Python 出于效率的考虑，会先将数据临时存储到缓冲区中，只有使用close()函数关闭文件时，才会将缓冲区中的数据真正写入文件中。语法格式：file.close()当然在某些实际场景中，我们可能需要在将数据成功写入到文件中，但并不想关闭文件。这也是可以实现的，调用 flush() 函数即可。 tell()函数当向文件中写入数据时，如果不是文件的尾部，写入位置的原有数据不会自行向后移动，新写入的数据会将文件中处于该位置的数据直接覆盖掉。基本语法为：file.tell()12345678910# a.txt: http://forwardpeng.clubf = open(\"a.txt\", 'r')print(f.tell())print(f.read(3))print(f.tell())'''0htt3''' seek()函数seek()函数用于将文件指针移动至指定位置，该函数的语法格式如下：file.seek(offset[, whence])其中，各个参数的含义如下：file：表示文件对象；whence：作为可选参数，用于指定文件指针要放置的位置，该参数的参数值有 3 个选择：0 代表文件头（默认值）、1 代表当前位置、2 代表文件尾。offset：表示相对于 whence 位置文件指针的偏移量，正数表示向后偏移，负数表示向前偏移。例如，当whence == 0 &amp;&amp;offset == 3（即 seek(3,0) ），表示文件指针移动至距离文件开头处 3 个字符的位置；当whence == 1 &amp;&amp;offset == 5（即 seek(5,1) ），表示文件指针向后移动，移动至距离当前位置 5 个字符处。注意，当 offset 值非 0 时，Python 要求文件必须要以二进制格式打开，否则会抛出 io.UnsupportedOperation 错误。 pickle模块：实现对象持久化存储pickle 模块提供了以下 4 个函数供我们使用：dumps()：将 Python 中的对象序列化成二进制对象，并返回；loads()：读取给定的二进制对象数据，并将其转换为 Python 对象；dump()：将 Python 中的对象序列化成二进制对象，并写入文件；load()：读取指定的序列化数据文件，并返回对象。以上这4个函数可以分成两类，其中 dumps 和 loads 实现基于内存的 Python 对象与二进制互转；dump 和 load 实现基于文件的 Python 对象与二进制互转。 pickle.dumps()函数用于将 Python 对象转为二进制对象，其语法格式如下：dumps(obj, protocol=None, *, fix_imports=True)此格式中各个参数的含义为：obj：要转换的 Python 对象；protocol：pickle 的转码协议，取值为 0、1、2、3、4，其中 0、1、2 对应 Python 早期的版本，3 和 4 则对应 Python 3.x 版本及之后的版本。未指定情况下，默认为 3。其它参数：为了兼容 Python 2.x 版本而保留的参数，Python 3.x 中可以忽略。 pickle.loads()函数用于将二进制对象转换成 Python 对象，其基本格式如下：loads(data, *, fix_imports=True, encoding=‘ASCII’, errors=‘strict’)其中，data 参数表示要转换的二进制对象，其它参数只是为了兼容Python 2.x版本而保留的，可以忽略。 pickle.dump()用于将 Python 对象转换成二进制文件，其基本语法格式为：dump (obj, file,protocol=None, *, fix mports=True)其中各个参数的具体含义如下：obj：要转换的 Python 对象。file：转换到指定的二进制文件中，要求该文件必须是以&quot;wb&quot;的打开方式进行操作。protocol：和 dumps() 函数中 protocol 参数的含义完全相同，因此这里不再重复描述。 pickle.load()函数用于将二进制对象文件转换成 Python 对象。该函数的基本语法格式为：load(file, *, fix_imports=True, encoding=‘ASCII’, errors=‘strict’)其中，file参数表示要转换的二进制对象文件（必须以 “rb” 的打开方式操作文件）。pickle 不支持并发地访问持久性对象，在复杂的系统环境下，尤其是读取海量数据时，使用 pickle 会使整个系统的I/O读取性能成为瓶颈。这种情况下，可以使用 ZODB。 fileinput模块：逐行读取多个文件fileinput 模块中 input() 该函数的语法格式如下：fileinput.input（files=“filename1, filename2, …”, inplace=False, backup=’’, bufsize=0, mode=‘r’, openhook=None）此函数会返回一个 FileInput 对象，它可以理解为是将多个指定文件合并之后的文件对象。其中，各个参数的含义如下：files：多个文件的路径列表；inplace：用于指定是否将标准输出的结果写回到文件，此参数默认值为 False；backup：用于指定备份文件的扩展名；bufsize：指定缓冲区的大小，默认为 0；mode：打开文件的格式，默认为 r（只读格式）；openhook：控制文件的打开方式，例如编码格式等。fileinput模块常见函数如下表：函数名功能描述fileinput.filename()返回当前正在读取的文件名称。fileinput.fileno()返回当前正在读取文件的文件描述符。fileinput.lineno()返回当前读取了多少行。fileinput.filelineno()返回当前正在读取的内容位于当前文件中的行号。fileinput.isfirstline()判断当前读取的内容在当前文件中是否位于第 1 行。fileinput.nextfile()关闭当前正在读取的文件，并开始读取下一个文件。fileinput.close()关闭 FileInput 对象。 linecache模块：读取指定行linecache模块擅长读取指定文件中的指定行。换句话说，如果我们想读取某个文件中指定行包含的数据，就可以使用 linecache模块。inecache 模块中常用的函数及其功能如下表所示。函数基本格式功能linecache.getline(filename, lineno, module_globals=None)读取指定模块中指定文件的指定行（仅读取指定文件时，无需指定模块）。其中，filename 参数用来指定文件名，lineno 用来指定行号，module_globals 参数用来指定要读取的具体模块名。注意，当指定文件以相对路径的方式传给 filename 参数时，该函数以按照 sys.path 规定的路径查找该文件。linecache.clearcache()如果程序某处，不再需要之前使用 getline() 函数读取的数据，则可以使用该函数清空缓存。linecache.checkcache(filename=None) 检查缓存的有效性，即如果使用 getline() 函数读取的数据，其实在本地已经被修改，而我们需要的是新的数据，此时就可以使用该函数检查缓存的是否为新的数据。注意，如果省略文件名，该函数将检车所有缓存数据的有效性。 os.path模块常见函数方法说明os.path.abspath(path)返回 path 的绝对路径。os.path.basename(path)获取 path 路径的基本名称，即 path 末尾到最后一个斜杠的位置之间的字符串。os.path.commonprefix(list)返回 list（多个路径）中，所有 path 共有的最长的路径。os.path.dirname(path)返回 path 路径中的目录部分。os.path.exists(path)判断 path 对应的文件是否存在，如果存在，返回 True；反之，返回 False。和 lexists() 的区别在于，exists()会自动判断失效的文件链接（类似 Windows 系统中文件的快捷方式），而 lexists() 却不会。os.path.lexists(path)判断路径是否存在，如果存在，则返回 True；反之，返回 False。os.path.expanduser(path)把 path 中包含的 “~” 和 “~user” 转换成用户目录。os.path.expandvars(path)根据环境变量的值替换 path 中包含的 “name&quot;和&quot;name&quot; 和 &quot;name&quot;和&quot;{name}”。os.path.getatime(path)返回 path 所指文件的最近访问时间（浮点型秒数）。os.path.getmtime(path)返回文件的最近修改时间（单位为秒）。os.path.getctime(path)返回文件的创建时间（单位为秒，自 1970 年 1 月 1 日起（又称 Unix 时间））。os.path.getsize(path)返回文件大小，如果文件不存在就返回错误。os.path.isabs(path)判断是否为绝对路径。os.path.isfile(path)判断路径是否为文件。os.path.isdir(path)判断路径是否为目录。os.path.islink(path)判断路径是否为链接文件（类似 Windows 系统中的快捷方式）。os.path.ismount(path)判断路径是否为挂载点。os.path.join(path1[, path2[, …]])把目录和文件名合成一个路径。os.path.normcase(path)转换 path 的大小写和斜杠。os.path.normpath(path)规范 path 字符串形式。os.path.realpath(path)返回 path 的真实路径。os.path.relpath(path[, start])从 start 开始计算相对路径。os.path.samefile(path1, path2)判断目录或文件是否相同。os.path.sameopenfile(fp1, fp2)判断 fp1 和 fp2 是否指向同一文件。os.path.samestat(stat1, stat2)判断 stat1 和 stat2 是否指向同一个文件。os.path.split(path)把路径分割成 dirname 和 basename，返回一个元组。os.path.splitdrive(path)一般用在 windows 下，返回驱动器名和路径组成的元组。os.path.splitext(path)分割路径，返回路径名和文件扩展名的元组。os.path.splitunc(path)把路径分割为加载点与文件。os.path.walk(path, visit, arg)遍历path，进入每个目录都调用 visit 函数，visit 函数必须有 3 个参数(arg, dirname, names)，dirname 表示当前目录的目录名，names 代表当前目录下的所有文件名，args 则为 walk 的第三个参数。os.path.supports_unicode_filenames设置是否可以将任意 Unicode 字符串用作文件名。 fnmatch模块：用于文件名匹配fnmatch模块中，常用的函数及功能如下表：函数名功能fnmatch.filter(names, pattern)对 names 列表进行过滤，返回 names 列表中匹配 pattern 的文件名组成的子集合。fnmatch.fnmatch(filename, pattern)判断 filename 文件名，是否和指定 pattern 字符串匹配fnmatch.fnmatchcase(filename, pattern)和 fnmatch() 函数功能大致相同，只是该函数区分大小写。fnmatch.translate(pattern)将一个UNIX shell风格的pattern字符串，转换为正则表达式fnmatch 模块匹配文件名的模式使用的就是 UNIX shell 风格，其支持使用如下几个通配符：*：可匹配任意个任意字符。？：可匹配一个任意字符。[字符序列]：可匹配中括号里字符序列中的任意字符。该字符序列也支持中画线表示法。比如 [a-c] 可代表 a、b 和 c 字符中任意一个。[!字符序列]：可匹配不在中括号里字符序列中的任意字符。 tempfile模块：生成临时文件和临时目录tempfile 模块函数功能描述tempfile.TemporaryFile(mode=‘w+b’, buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None)创建临时文件。该函数返回一个类文件对象，也就是支持文件 I/O。tempfile.NamedTemporaryFile(mode=‘w+b’, buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True)创建临时文件。该函数的功能与上一个函数的功能大致相同，只是它生成的临时文件在文件系统中有文件名。tempfile.SpooledTemporaryFile(max_size=0, mode=‘w+b’, buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None)创建临时文件。与 TemporaryFile 函数相比，当程序向该临时文件输出数据时，会先输出到内存中，直到超过 max_size 才会真正输出到物理磁盘中。tempfile.TemporaryDirectory(suffix=None, prefix=None, dir=None)生成临时目录。tempfile.gettempdir()获取系统的临时目录。tempfile.gettempdirb()与 gettempdir() 相同，只是该函数返回字节串。tempfile.gettempprefix()返回用于生成临时文件的前缀名。tempfile.gettempprefixb()与 gettempprefix() 相同，只是该函数返回字节串。创建临时文件的方法：第一种方式是手动创建临时文件，读写临时文件后需要主动关闭它，当程序关闭该临时文件时，该文件会被自动删除。第二种方式则是使用 with 语句创建临时文件，这样 with 语句会自动关闭临时文件。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"}]},{"title":"Python-异常处理机制","slug":"Python-异常处理机制","date":"2020-04-29T04:18:06.000Z","updated":"2020-04-30T02:32:28.640Z","comments":true,"path":"2020/04/29/Python-异常处理机制/","link":"","permalink":"http://forwardpeng.github.io/2020/04/29/Python-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","excerpt":"","text":"常见的异常类型异常类型含义实例AssertionError当 assert 关键字后的条件为假时，程序运行会停止并抛出 AssertionError 异常&gt;&gt;&gt; demo_list = [‘C语言中文网’]&gt;&gt;&gt; assert len(demo_list) &gt; 0&gt;&gt;&gt; demo_list.pop()‘C语言中文网’&gt;&gt;&gt; assert len(demo_list) &gt; 0 Traceback (most recent call last):File “&lt;pyshell#6&gt;”, line 1, inassert len(demo_list) &gt; 0 AssertionErrorAttributeError当试图访问的对象属性不存在时抛出的异常&gt;&gt;&gt; demo_list = [‘C语言中文网’]&gt;&gt;&gt; demo_list.len Traceback (most recent call last): File “&lt;pyshell#10&gt;”, line 1, indemo_list.len AttributeError: ‘list’ object has no attribute ‘len’IndexError索引超出序列范围会引发此异常&gt;&gt;&gt; demo_list = [‘C语言中文网’] &gt;&gt;&gt; demo_list[3] Traceback (most recent call last): File “&lt;pyshell#8&gt;”, line 1, indemo_list[3] IndexError: list index out of rangeKeyError字典中查找一个不存在的关键字时引发此异常&gt;&gt;&gt; demo_dict={‘C语言中文网’:“c.biancheng.net”} &gt;&gt;&gt; demo_dict[“C语言”] Traceback (most recent call last):File “&lt;pyshell#12&gt;”, line 1, indemo_dict[“C语言”] KeyError: ‘C语言’NameError尝试访问一个未声明的变量时，引发此异常&gt;&gt;&gt; C语言中文网 Traceback (most recent call last): File “&lt;pyshell#15&gt;”, line 1, inC语言中文网NameError: name ‘C语言中文网’ is not definedTypeError不同类型数据之间的无效操作&gt;&gt;&gt; 1+‘C语言中文网’ Traceback (most recent call last): File “&lt;pyshell#17&gt;”, line 1, in1+‘C语言中文网’ TypeError: unsupported operand type(s) for +: ‘int’ and ‘str’ZeroDivisionError除法运算中除数为 0 引发此异常&gt;&gt;&gt; a = 1/0 Traceback (most recent call last): File “&lt;pyshell#2&gt;”, line 1, ina = 1/0 ZeroDivisionError: division by zero使用 Python 异常处理机制，可以让程序中的异常处理代码和正常业务代码分离，使得程序代码更加优雅，并可以提高程序的健壮性。 try except异常处理Python 中，用try except语句块捕获并处理异常，其基本语法结构如下所示：try:可能产生异常的代码块except [ (Error1, Error2, … ) [as e] ]:处理异常的代码块1except [ (Error3, Error4, … ) [as e] ]:处理异常的代码块2except [Exception]:处理其它异常该格式中，[]括起来的部分可以使用，也可以省略。其中各部分的含义如下：(Error1, Error2,…) 、(Error3, Error4,…)：其中，Error1、Error2、Error3 和 Error4都是具体的异常类型。显然，一个except块可以同时处理多种异常。[as e]：作为可选参数，表示给异常类型起一个别名 e，这样做的好处是方便在except块中调用异常类型（后续会用到）。[Exception]：作为可选参数，可以代指程序可能发生的所有异常情况，其通常用在最后一个except块。当程序发生不同的意外情况时，会对应特定的异常类型，Python 解释器会根据该异常类型选择对应的 except 块来处理该异常。 获取特定异常每种异常类型都提供了如下几个属性和方法，通过调用它们，就可以获取当前处理异常类型的相关信息：args：返回异常的错误编号和描述字符串；str(e)：返回异常信息，但不包括异常信息的类型；repr(e)：返回较全的异常信息，包括异常信息的类型。1234567891011try: 1/0except Exception as e: # 访问异常的错误编号和详细信息 print(e.args) print(str(e)) print(repr(e))Output：('division by zero',)division by zeroZeroDivisionError('division by zero',) 异常处理的底层实现对于可以接收任何异常的 except 来说，其后可以跟Exception，也可以不跟任何参数，但表示的含义都是一样的。 Python 的常见异常类之间的继承关系如图 1：图1 Python 的常见异常类之间的继承关系如果用户要实现自定义异常，不应该继承 BaseException ，而应该继承 Exception 类当一个try块配有多个except块时，这些except块应遵循这样一个排序规则，即可处理全部异常的except块（参数为Exception，也可以什么都不写）要放到所有except块的后面，且所有父类异常的except块要放到子类异常的except块的后面。 try except else详解在原本的try except结构的基础上，Python 异常处理机制还提供了一个 else块，也就是原有try except 语句的基础上再添加一个else块，即try except else结构。使用else包裹的代码，只有当try块没有捕获到任何异常时，才会得到执行；反之，如果try块捕获到异常，即便调用对应的except处理完异常，else块中的代码也不会得到执行。 try except finally：资源回收在整个异常处理机制中，finally语句的功能是：无论try块是否发生异常，最终都要进入finally语句，并执行其中的代码块。基于finally语句的这种特性，在某些情况下，当try块中的程序打开了一些物理资源（文件、数据库连接等）时，由于这些资源必须手动回收，而回收工作通常就放在finally块中。Python垃圾回收机制，只能帮我们回收变量、类对象占用的内存，而无法自动完成类似关闭文件、数据库连接等这些的工作。 异常处理机制结构12345678910111213141516# 语法结构try: #业务实现代码except Exception1 as e: #异常处理块1 ...except Exception2 as e: #异常处理块2 ...#可以有多个 except...else: #正常处理块finally : #资源回收块 ...整个异常处理结构中，只有 try 块是必需的，也就是说：如果没有 try 块，则不能有后面的 except 块、else 块和 * finally 块。但是也不能只使用 try 块，要么使用 try except 结构，要么使用 try finally 结构；except 块、else 块、finally 块都是可选的，当然也可以同时出现；可以有多个 except 块，但捕获父类异常的 except 块应该位于捕获子类异常的 except 块的后面；多个except块必须位于try块之后，finally块必须位于所有的 except 块之后。要使用else块，其前面必须包含 try和except。异常处理语句块的执行流程如下图2：图2 异常处理语句块的执行流程 raise用法raise 语句的基本语法格式为：。raise [exceptionName [(reason)]]其中，用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述。如果可选参数全部省略，则 raise 会把当前错误原样抛出；如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息。也就是说，raise 语句有如下三种常用的用法：raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。如果没有 finally 块，程序才会立即执行 return 或 raise 语句；反之，如果找到 finally 块，系统立即开始执行 finally 块，只有当 finally 块执行完成后，系统才会再次跳回来执行 try 块、except 块里的 return 或 raise 语句。尽量避免在 finally 块里使用 return 或 raise 等导致方法中止的语句，否则可能出现一些很奇怪的情况。但是，如果在 finally 块里也使用了 return 或 raise 等导致方法中止的语句，finally 块己经中止了方法，系统将不会跳回去执行 try 块、except 块里的任何代码。 sys.exc_info()方法：获取异常信息捕获异常时，有 2 种方式可获得更多的异常信息，分别是：使用 sys 模块中的 exc_info 方法；使用 traceback 模块中的相关函数。模块 sys 中，有两个方法可以返回异常的全部信息，分别是 exc_info() 和 last_traceback()，这两个函数有相同的功能和用法，exc_info() 方法会将当前的异常信息以元组的形式返回，该元组中包含 3 个元素，分别为 type、value 和 traceback，它们的含义分别是：type：异常类型的名称，它是 BaseException 的子类（有关 Python 异常类，可阅读《Python常见异常类型》一节）value：捕获到的异常实例。traceback：是一个 traceback 对象。使用 traceback 的 print_exc() 方法输出异常传播信息，print_exc([limit[, file]]) 相当于如下形式：print_exception(sys.exc_etype, sys.exc_value, sys.exc_tb[, limit[, file]])1234# 捕捉异常，并将异常传播信息输出控制台 traceback.print_exc() # 捕捉异常，并将异常传播信息输出指定文件中 traceback.print_exc(file=open('log.txt', 'a')) 自定义异常类1234567891011121314151617class InputError(Exception): '''当输出有误时，抛出此异常''' #自定义异常类型的初始化 def __init__(self, value): self.value = value # 返回异常类对象的说明信息 def __str__(self): return (\"&#123;&#125; is invalid input\".format(repr(self.value))) try: raise InputError(1) # 抛出 MyInputError 这个异常except InputError as err: print('error: &#123;&#125;'.format(err))'''运行结果： error: 1 is invalid input'''注意，只要自定义的类继承自 Exception，则该类就是一个异常类，至于此类中包含的内容，并没有做任何规定。 异常使用规则成功的异常处理应该实现如下 4 个目标：使程序代码混乱最小化。捕获并保留诊断信息。通知合适的人员。采用合适的方式结束异常活动。 不要过度使用异常过度使用异常主要表现在两个方面：把异常和普通错误混淆在一起，不再编写任何错误处理代码，而是以简单地引发异常来代苦所有的错误处理。使用异常处理来代替流程控制。异常处理机制的初衷是将不可预期异常的处理代码和正常的业务逻辑处理代码分离，因此绝不要使用异常处理来代替正常的业务逻辑判断。 不要使用过于庞大的 try 块因为 try 块里的代码过于庞大，业务过于复杂，就会造成 try 块中出现异常的可能性大大增加，从而导致分析异常原因的难度也大大增加。而且当时块过于庞大时，就难免在 try 块后紧跟大量的 except 块才可以针对不同的异常提供不同的处理逻辑。在同一个 try 块后紧跟大量的 except 块则需要分析它们之间的逻辑关系，反而增加了编程复杂度。正确的做法是，把大块的 try 块分割成多个可能出现异常的程序段落，并把它们放在单独的 try 块中，从而分别捕获并处理异常。 不要忽略捕获的异常既然己捕获到异常，那么 except 块理应做些有用的事情，及处理并修复异常。except 块整个为空，或者仅仅打印简单的异常信息都是不妥的！常建议对异常采取适当措施，比如：处理异常。对异常进行合适的修复，然后绕过异常发生的地方继续运行；或者用别的数据进行计算，以代替期望的方法返回值；或者提示用户重新操作……总之，程序应该尽量修复异常，使程序能恢复运行。重新引发新异常。把在当前运行环境下能做的事情尽量做完，然后进行异常转译，把异常包装成当前层的异常，重新传给上层调用者。在合适的层处理异常。如果当前层不清楚如何处理异常，就不要在当前层使用 except 语句来捕获该异常，让上层调用者来负责处理该异常。 logging模块用法logging模块可以很容易地创建自定义的消息记录，这些日志消息将描述程序执行何时到达日志函数调用，并列出指定的任何变量当时的值。123# 程序开头加上import logginglogging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')工作原理：当Python记录一个事件的日志时，它会创建一个LogRecord对象，保存关于该事件的信息。1234567891011121314151617181920212223242526272829303132import logginglogging.basicConfig(level=logging.DEBUG, format=' %(asctime)s - %(levelname)s - %(message)s')logging.debug('Start of program')def factorial(n): logging.debug('Start of factorial(%s%%)' % (n)) total = 1 for i in range(n + 1): total *= i logging.debug('i is ' + str(i) + ', total is ' + str(total)) logging.debug('End of factorial(%s%%)' % (n)) return totalprint(factorial(5))logging.debug('End of program')'''运行结果：2020-04-29 15:48:52,751 - DEBUG - Start of program 2020-04-29 15:48:52,751 - DEBUG - Start of factorial(5%) 2020-04-29 15:48:52,751 - DEBUG - i is 0, total is 0 2020-04-29 15:48:52,751 - DEBUG - i is 1, total is 0 2020-04-29 15:48:52,751 - DEBUG - i is 2, total is 0 2020-04-29 15:48:52,751 - DEBUG - i is 3, total is 0 2020-04-29 15:48:52,751 - DEBUG - i is 4, total is 0 2020-04-29 15:48:52,751 - DEBUG - i is 5, total is 0 2020-04-29 15:48:52,751 - DEBUG - End of factorial(5%) 2020-04-29 15:48:52,751 - DEBUG - End of program0''' logging日志级别级别对应的函数描述DEBUGlogging.debug()最低级别，用于小细节，通常只有在诊断问题时，才会关心这些消息。INFOlogging.info()用于记录程序中一般事件的信息，或确认一切工作正常。WARNINGlogging.warning()用于表示可能的问题，它不会阻止程序的工作，但将来可能会。ERRORlogging.error()用于记录错误，它导致程序做某事失败。CRITICALlogging.critical()最高级别，用于表示致命的错误，它导致或将要导致程序完全停止工作。 logging禁用日志在调试完程序后，可能并不希望所有这些日志消息出现在屏幕上，这时就可以使用 logging.disable() 函数禁用这些日志消息，从而不必进入到程序中，手工删除所有的日志调用。logging.disable() 函数的用法是，向其传入一个日志级别，它会禁止该级别以及更低级别的所有日志消息。因此，如果想要禁用所有日志，只要在程序中添加 logging.disable(logging.CRITICAL) 即可 日志消息输出到文件中将日志消息输出到文件中的实现方法很简单，只需要设置 logging.basicConfig() 函数中的 filename 关键字参数即可，例如：12&gt;&gt;&gt; import logging&gt;&gt;&gt; logging.basicConfig(filename='demo.txt', level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')此程序中，将日志消息存储到了 demo.txt 文件中，该文件就位于运行的程序文件所在的目录。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"}]},{"title":"Python-类特殊成员","slug":"Python-类特殊成员","date":"2020-04-28T15:27:44.000Z","updated":"2020-04-29T04:17:42.880Z","comments":true,"path":"2020/04/28/Python-类特殊成员/","link":"","permalink":"http://forwardpeng.github.io/2020/04/28/Python-%E7%B1%BB%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/","excerpt":"","text":"new()方法new() 是一种负责创建类实例的静态方法，它无需使用 staticmethod 装饰器修饰，且该方法会优先__init__() 初始化方法被调用。一般情况下，覆写__new__()的实现将会使用合适的参数调用其超类的 super().new()，并在返回之前修改实例。12345678910111213141516171819202122class demoClass: instances_created = 0 def __new__(cls,*args,**kwargs): print(\"__new__():\",cls,args,kwargs) instance = super().__new__(cls) instance.number = cls.instances_created cls.instances_created += 1 return instance def __init__(self,attribute): print(\"__init__():\",self,attribute) self.attribute = attributetest1 = demoClass(\"abc\")test2 = demoClass(\"xyz\")print(test1.number,test1.instances_created)print(test2.number,test2.instances_created)# 输出结果#__new__(): &lt;class '__main__.demoClass'&gt; ('abc',) &#123;&#125;#__init__(): &lt;__main__.demoClass object at 0x0000026FC0DF8080&gt; abc#__new__(): &lt;class '__main__.demoClass'&gt; ('xyz',) &#123;&#125;#__init__(): &lt;__main__.demoClass object at 0x0000026FC0DED358&gt; xyz#0 2#1 2 repr()方法：显示属性repr() 会返回和调用者有关的 “类名+object at+内存地址”信息。当然，我们还可以通过在类中重写这个方法，从而实现当输出实例化对象时，输出我们想要的信息。实例：123456789class CLanguage: def __init__(self): self.name = \"C语言中文网\" self.add = \"http://c.biancheng.net\" def __repr__(self): return \"CLanguage[name=\"+ self.name +\",add=\" + self.add +\"]\"clangs = CLanguage()print(clangs)# CLanguage[name=C语言中文网,add=http://c.biancheng.net]repr() 方法是类的实例化对象用来做“自我介绍”的方法，默认情况下，它会返回当前对象的“类名+object at+内存地址”，而如果对该方法进行重写，可以为其制作自定义的自我描述信息。 dir()用法提到了dir() 函数，通过此函数可以某个对象拥有的所有的属性名和方法名，该函数会返回一个包含有所有属性名和方法名的有序列表。 __dict__属性：查看对象内部所有属性名和属性值组成的字典便用户查看类中包含哪些属性，Python 类提供了__dict__属性。需要注意的一点是，该属性可以用类名或者类的实例对象来调用，用类名直接调用 dict，会输出该由类中所有类属性组成的字典；而使用类的实例对象调用 dict，会输出由类中所有实例属性组成的字典。对于具有继承关系的父类和子类来说，父类有自己的__dict__，同样子类也有自己的__dict__，它不会包含父类的__dict__ setattr()、getattr()、hasattr()函数用法 hasattr()函数hasattr() 函数用来判断某个类实例对象是否包含指定名称的属性或方法。该函数的语法格式如下：hasattr(obj, name)无论是属性名还是方法名，都在 hasattr() 函数的匹配范围内。因此，我们只能通过该函数判断实例对象是否包含该名称的属性或方法，但不能精确判断，该名称代表的是属性还是方法。 getattr()函数getattr() 函数获取某个类实例对象中指定属性的值，该函数只会从类对象包含的所有属性中进行查找。getattr() 函数的语法格式如下：getattr(obj, name[, default])其中，obj 表示指定的类实例对象，name 表示指定的属性名，而 default 是可选参数，用于设定该函数的默认返回值，即当函数查找失败时，如果不指定 default 参数，则程序将直接报 AttributeError 错误，反之该函数将返回 default 指定的值。 setattr()函数setattr() 函数的功能相对比较复杂，它最基础的功能是修改类实例对象中的属性值。其次，它还可以实现为实例对象动态添加属性或者方法。setattr() 函数的语法格式如下：setattr(obj, name, value)123456789101112131415def say(self): print(\"我正在学Python\")class CLanguage: def __init__ (self): self.name = \"C语言中文网\" self.add = \"http://c.biancheng.net\"clangs = CLanguage()print(clangs.name)print(clangs.add)setattr(clangs,\"name\",say)clangs.name(clangs)#程序运行结果为：#C语言中文网#http://c.biancheng.net#我正在学Python issubclass和isinstance函数：检查类型Python 提供了如下两个函数来检查类型：issubclass(cls, class_or_tuple)：检查 cls 是否为后一个类或元组包含的多个类中任意类的子类。isinstance(obj, class_or_tuple)：检查 obj 是否为后一个类或元组包含的多个类中任意类的对象。区别只是 issubclass() 的第一个参数是类名，而 isinstance() 的第一个参数是变量，这也与两个函数的意义对应：issubclass 用于判断是否为子类，而 isinstance() 用于判断是否为该类或子类的实例。Python为所有类都提供了一个 bases 属性，通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组。 call()方法功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。Python 中，凡是可以将 () 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。hasattr()的功能是查找类的实例对象中是否包含指定名称的属性或者方法，但该函数有一个缺陷，即它无法判断该指定的名称，到底是类属性还是类方法。1234567891011121314151617class CLanguage: def __init__ (self): self.name = \"C语言中文网\" self.add = \"http://c.biancheng.net\" def say(self): print(\"我正在学Python\")clangs = CLanguage()if hasattr(clangs,\"name\"): print(hasattr(clangs.name,\"__call__\"))print(\"**********\")if hasattr(clangs,\"say\"): print(hasattr(clangs.say,\"__call__\"))执行结果： False ********* True# 由于name是类属性，它没有以__call__为名的__call__()方法；而 say是类方法，它是可调用对象，因此它有__call__()方法。 运算符重载Python 类支持对哪些方法进行重载呢？，列出了 Python 中常用的可重载的运算符，以及各自的含义。重载运算符含义new创建类，在 init 之前创建对象init类的构造函数，其功能是创建类对象时做初始化工作。del析构函数，其功能是销毁对象时进行回收资源的操作add加法运算符 +，当类对象 X 做例如 X+Y 或者 X+=Y 等操作，内部会调用此方法。但如果类中对 iadd 方法进行了重载，则类对象 X 在做 X+=Y 类似操作时，会优先选择调用 iadd 方法。radd当类对象 X 做类似 Y+X 的运算时，会调用此方法。iadd重载 += 运算符，也就是说，当类对象 X 做类似 X+=Y 的操作时，会调用此方法。or“或”运算符repr，str格式转换方法，分别对应函数 repr(X)、str(X)call函数调用，类似于 X(*args, **kwargs) 语句getattr点号运算，用来获取类属性setattr属性赋值语句，类似于 X.any=valuedelattr删除属性，类似于 del X.anygetattribute获取属性，类似于 X.anygetitem索引运算，类似于 X[key]，X[i:j]setitem索引赋值语句，类似于 X[key], X[i:j]=sequencedelitem索引和分片删除get, set, delete描述符属性，类似于 X.attr，X.attr=value，del X.attrlen计算长度，类似于 len(X)lt，gt，le，ge，eq，ne比较，分别对应于 &lt;、&gt;、&lt;=、&gt;=、=、!= 运算符。iter，next迭代环境下，生成迭代器与取下一条，类似于 I=iter(X) 和 next()contains成员关系测试，类似于 item in Xindex整数值，类似于 hex(X)，bin(X)，oct(X)enter，exit在对类对象执行类似 with obj as var 的操作之前，会先调用 enter 方法，其结果会传给 var；在最终结束该操作之前，会调用 Python迭代器迭代器指的就是支持迭代的容器，更确切的说，是支持迭代的容器类对象，这里的容器可以是列表、元组等这些 Python 提供的基础容器，也可以是自定义的容器类对象，只要该容器支持迭代即可。自定义实现一个迭代器，则类中必须实现如下2个方法：next(self)：返回容器的下一个元素。iter(self)：该方法返回一个迭代器（iterator）。Python 内置的 iter() 函数也会返回一个迭代器，该函数的语法格式如下：iter(obj[, sentinel])其中，obj 必须是一个可迭代的容器对象，而 sentinel 作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象。可调用对象，指的是该类的实例对象可以像函数那样，直接以“对象名()”的形式被使用。通过在类中添加 call() 方法，就可以将该类的实例对象编程可调用对象。1个参数的 iter()函数，通过传入一个可迭代的容器对象，我们可以获得一个迭代器，通过调用该迭代器中的__next__()方法即可实现迭代，使用next()内置函数来迭代，即next(myIter)，和__next__()方法是完全一样的。iter()函数第2个参数的作用，如果使用该参数，则要求第一个obj参数必须传入可调用对象（可以不支持迭代），这样当使用返回的迭代器调用__next__()方法时，它会通过执行obj()调用 call()方法，如果该方法的返回值和第 2 个参数值相同，则输出 StopInteration 异常；反之，则输出 call() 方法的返回值。123456789101112131415# 迭代器实现字符串逆序class Reverse: def __init__(self, string): self.__string = string self.__index = len(string) def __iter__(self): return self def __next__(self): if self.__index == 0: raise(StopIteration) self.__index -= 1 return self.__string[self.__index]revstr = Reverse('Python')for c in revstr: print(c,end=\" \") 生成器生成器的创建方式也比迭代器简单很多，大体分为以下 2 步：定义一个以 yield 关键字标识返回值的函数；调用刚刚创建的函数，即可创建一个生成器。和return相比，yield 除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。不仅如此，即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。相比迭代器，生成器最明显的优势就是节省内存空间，即它不会一次性生成所有的数据，而是什么时候需要，什么时候生成。123456def intNum(): print(\"开始执行\") for i in range(5): yield i print(\"继续执行\")num = intNum()即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。想要生成器函数执行，或者想使执行完 yield 语句立即暂停的程序得以继续执行，可以通过：通过生成器调用next()内置函数或者__next__()方法通过for循环遍历生成器 生成器send()方法通过 send() 方法，还可以向生成器中传值。值得一提的是，send()方法可带一个参数，也可以不带任何参数（用 None 表示）。其中，当使用不带参数的send()方法时，它和next()函数的功能完全相同。例如：1234567891011ddef foo(): bar_a = yield \"hello\" bar_b = yield bar_a yield bar_bf = foo()print(f.send(None))print(f.send(\"C语言中文网\"))print(f.send(\"http://c.biancheng.net\"))#hello#C语言中文网#http://c.biancheng.net close()方法生成器函数中遇到yield语句暂停运行时，此时如果调用 close()方法，会阻止生成器函数继续执行，该函数会在程序停止运行的位置抛出 GeneratorExit 异常。12345678910111213141516def foo(): try: yield 1 except GeneratorExit: print('捕获到 GeneratorExit') yield 2 #抛出 RuntimeError 异常f = foo()print(next(f))f.close()'''1捕获到 GeneratorExit Traceback (most recent call last): File \"D:\\python3.6\\1.py\", line 10, in &lt;module&gt; f.close()RuntimeError: generator ignored GeneratorExit''' 生成器throw()方法生成器 throw() 方法的功能是，在生成器函数执行暂停处，抛出一个指定的异常，之后程序会继续执行生成器函数中后续的代码，直到遇到下一个yield语句。需要注意的是，如果到剩余代码执行完毕没有遇到下一个yield语句，则程序会抛出 StopIteration异常。12345678910111213141516def foo(): try: yield 1 except ValueError: print('捕获到 ValueError')f = foo()print(next(f))f.throw(ValueError)'''运行结果：1捕获到 ValueErrorTraceback (most recent call last): File \"D:\\python3.6\\1.py\", line 9, in &lt;module&gt; f.throw(ValueError)StopIteration'''一开始生成器函数在yield 1处暂停执行，当执行throw()方法时，它会先抛出 ValueError异常，然后继续执行后续代码找到下一个 yield语句，该程序中由于后续不再有yield语句，因此程序执行到最后，会抛出一个 StopIteration异常。 函数装饰器及用法Python 内置的 3 种函数装饰器，分别是 ＠staticmethod、＠classmethod 和 @property，其中 staticmethod()、classmethod()和 property()都是Python的内置函数。使用函数装饰器A()去装饰另一个函数B()，其底层执行了如下2步操作：将B作为参数传给A()函数；将A()函数执行完成的返回值反馈回B。1234567891011121314151617def funA(fn): print(\"C语言中文网\") fn() # 执行传入的fn参数 print(\"http://c.biancheng.net\") return \"装饰器函数的返回值\"@funAdef funB(): print(\"学习 Python\")'''C语言中文网学习 Pythonhttp://c.biancheng.net在此基础上，如果在程序末尾添加如下语句：print(funB)其输出结果为：装饰器函数的返回值'''如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名；同样，如果装饰器返回的是一个函数的名称，怎么被修饰的函数名依然表示一个函数。函数装饰器，就是通过装饰器函数，在不修改原函数的前提下，来对函数的功能进行合理的扩充。 带参数的函数装饰器函数装饰器中嵌套一个函数，该函数带有的参数个数和被装饰器修饰的函数相同。例如：12345678910111213def funA(fn): # 定义一个嵌套函数 def say(arc): print(\"Python教程:\",arc) return say@funAdef funB(arc): print(\"funB():\", a)funB(\"http://c.biancheng.net/python\")'''程序执行结果为：Python教程: http://c.biancheng.net/python''' 函数装饰器嵌套上面程序的执行顺序是里到外，所以它等效于下面这行代码：fun = funA( funB ( funC (fun) ) ) 装饰器的应用场景 身份认证12345678910111213141516import functoolsdef authenticate(func): @functools.wraps(func) def wrapper(*args, **kwargs): request = args[0] # 如果用户处于登录状态 if check_user_logged_in(request): # 执行函数 post_comment() return func(*args, **kwargs) else: raise Exception('Authentication failed') return wrapper @authenticatedef post_comment(request, ...) ...定义了装饰器 authenticate，函数 post_comment() 则表示发表用户对某篇文章的评论，每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。 日志记录日志记录同样是很常见的一个案例。在实际工作中，如果你怀疑某些函数的耗时过长，导致整个系统的延迟增加，想在线上测试某些函数的执行时间，那么，装饰器就是一种很常用的手段。123456789101112131415import timeimport functoolsdef log_execution_time(func): @functools.wraps(func) def wrapper(*args, **kwargs): start = time.perf_counter() res = func(*args, **kwargs) print('&#123;&#125; took &#123;&#125; ms'.format(func.__name__, (end - start) * 1000)) return res return wrapper @log_execution_timedef calculate_similarity(items): ...装饰器 log_execution_time 记录某个函数的运行时间，并返回其执行结果。如果你想计算任何函数的执行时间，在这个函数上方加上@log_execution_time即可。 装饰器用于输入合理性检查在大型公司的机器学习框架中，调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检查。这样就可以大大避免输入不正确对机器造成的巨大开销。12345678import functoolsdef validation_check(input): @functools.wraps(func) def wrapper(*args, **kwargs): ...@validation_checkdef neural_network_training(param1, param2,...)很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现。 缓存装饰器ython 中的表示形式是 @lru_cache。@lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除最近最久未使用的数据。正确使用缓存装饰器，往往能极大地提高程序运行效率。12@lru_cachedef check(param1, param2, ...) # 检查用户设备类型、版本号","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"}]},{"title":"Python-类和对象","slug":"Python-类和对象","date":"2020-04-28T04:15:50.000Z","updated":"2020-04-28T12:00:48.953Z","comments":true,"path":"2020/04/28/Python-类和对象/","link":"","permalink":"http://forwardpeng.github.io/2020/04/28/Python-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"Python描述符详解述符就是一个类，只不过它定义了另一个类中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。描述符是Python中复杂属性访问的基础，它在内部被用于实现property、方法、类方法、静态方法和super类型。描述符协议：set(self, obj, type=None)：在设置属性时将调用这一方法（本节后续用 setter 表示）；get(self, obj, value)：在读取属性时将调用这一方法（本节后续用 getter 表示）；delete(self, obj)：对属性调用 del 时将调用这一方法。在每次查找属性时，描述符协议中的方法都由类对象的特殊方法 getattribute()调用（注意不要和__getattr__() 弄混）。也就是说，每次使用类对象.属性（或者 getattr(类对象，属性值)）的调用方式时，都会隐式地调用 getattribute()，它会按照下列顺序查找该属性：验证该属性是否为类实例对象的数据描述符；如果不是，就查看该属性是否能在类实例对象的 dict 中找到；最后，查看该属性是否为类实例对象的非数据描述符。12345678910111213141516171819202122232425class revealAccess: def __init__(self, initval = None, name = 'var'): self.val = initval self.name = name def __get__(self, obj, objtype): print(\"Retrieving\",self.name) return self.val def __set__(self, obj, val): print(\"updating\",self.name) self.val = valclass myClass: x = revealAccess(10,'var \"x\"') y = 5m = myClass()print(m.x)m.x = 20print(m.x)print(m.y)Retrieving var \"x\"10updating var \"x\"Retrieving var \"x\"205如果一个类的某个属性有数据描述符，那么每次查找这个属性时，都会调用描述符的__get__()方法，并返回它的值；同样，每次在对该属性赋值时，也会调用__set__()方法。除了使用描述符类自定义类属性被调用时做的操作外，还可以使用 property()函数或者@property装饰器 property()函数：定义属性Python 中提供了 property() 函数，可以实现在不破坏类封装原则的前提下，让开发者依旧使用“类对象.属性”的方式操作类中的属性。property()函数的基本使用格式如下：属性名=property(fget=None, fset=None, fdel=None, doc=None)其中，fget 参数用于指定获取该属性值的类方法，fset 参数用于指定设置该属性值的方法，fdel 参数用于指定删除该属性值的方法，最后的 doc 是一个文档字符串，用于说明此函数的作用。123456789101112131415161718192021222324252627class CLanguage: #构造函数 def __init__(self,n): self.__name = n #设置 name 属性值的函数 def setname(self,n): self.__name = n #访问nema属性值的函数 def getname(self): return self.__name #删除name属性值的函数 def delname(self): self.__name=\"xxx\" #为name 属性配置 property() 函数 name = property(getname, setname, delname, '指明出处')#调取说明文档的 2 种方式#print(CLanguage.name.__doc__)help(CLanguage.name)clang = CLanguage(\"C语言中文网\")#调用 getname() 方法print(clang.name)#调用 setname() 方法clang.name=\"Python教程\"print(clang.name)#调用 delname() 方法del clang.nameprint(clang.name)由于getname()方法中需要返回 name 属性，如果使用 self.name的话，其本身又被调用 getname()，这将会先入无限死循环。为了避免这种情况的出现，程序中的name属性必须设置为私有属性，即使用__name（前面有2个下划线）。12name = property(getname) # name 属性可读，不可写，也不能删除name = property(getname, setname,delname) #name属性可读、可写、也可删除，就是没有说明文档 @property装饰器保护类的封装特性，又要让开发者可以使用“对象.属性”的方式操作操作类属性，除了使用 property() 函数，Python 还提供了 @property 装饰器。通过 @property 装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对“（）”小括号。语法格式：@propertydef 方法名(self)代码块123456789class Rect: def __init__(self,area): self.__area = area @property def area(self): return self.__arearect = Rect(30)#直接通过方法名来访问 area 方法print(\"矩形的面积是：\",rect.area)使用＠property 修饰了area()方法，这样就使得该方法变成了 area 属性的 getter 方法。需要注意的是，如果类中只包含该方法，那么area属性将是一个只读属性。添加setter方法，需要用到setter装饰器，语法格式：@方法名.setterdef 方法名(self, value):代码块删除deleter装饰器指定属性，语法格式为：@方法名.deleterdef 方法名(self):代码块123456@area.setterdef area(self, value): self.__area = value@area.deleterdef area(self): self.__area = 0 封装Python并没有提供public、private这些修饰符。为了实现类的封装，Python采取了下面的方法：默认情况下，Python 类中的变量和方法都是公有（public）的，它们的名称前都没有下划线（_）；如果类中的变量和函数，其名称以双下划线“__”开头，则该变量（函数）为私有变量（私有函数），其属性等同于 private。定义以单下划线“_”开头的类属性或者类方法（例如 _name、_display(self)），这种类属性和类方法通常被视为私有属性和私有方法，虽然它们也能通过类对象正常访问，但这是一种约定俗称的用法Python 类中还有以双下划线开头和结尾的类方法（例如类的构造函数__init__(self)），这些都是 Python 内部定义的，用于 Python 内部调用。我们自己定义类属性或者类方法时，不要使用这种格式。12345678910111213141516171819202122232425262728293031class CLanguage : def setname(self, name): if len(name) &lt; 3: raise ValueError('名称长度必须大于3！') self.__name = name def getname(self): return self.__name #为 name 配置 setter 和 getter 方法 name = property(getname, setname) def setadd(self, add): if add.startswith(\"http://\"): self.__add = add else: raise ValueError('地址必须以 http:// 开头') def getadd(self): return self.__add #为 add 配置 setter 和 getter 方法 add = property(getadd, setadd) #定义个私有方法 def __display(self): print(self.__name,self.__add)clang = CLanguage()clang.name = \"个人博客\"clang.add = \"http://forwardpeng.club\"print(clang.name)print(clang.add)CLanguage 将 name 和 add 属性都隐藏了起来，但同时也提供了可操作它们的“窗口”，也就是各自的 setter 和 getter 方法，这些方法都是公有（public）的。不仅如此，以add属性的 setadd() 方法为例，通过在该方法内部添加控制逻辑，即通过调用 startswith()方法，控制用户输入的地址必须以“http://”开头，否则程序将会执行 raise 语句抛出 ValueError 异常。raise 这里可简单理解成，如果用户输入不规范，程序将会报错。以双下划线开头命名的类属性或类方法，Python 在底层实现时，将它们的名称都偷偷改成了 “_类名__属性（方法）名” 的格式。私有的类属性（例如 __name 和 __add），其底层的名称也改成了“_类名__属性名”的这种格式。可以通过修改 clang 对象的私有属性 继承机制及其使用Python 类的封装、继承、多态 3 大特性，前面章节已经详细介绍了 Python 类的封装，本节继续讲解 Python 类的继承机制。继承机制经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），但又不想直接将现有类代码复制给新类。也就是说，通过使用继承这种机制，可以轻松实现类的重复使用。1234567class Shape: def draw(self,content): print(\"画\",content)class Form(Shape): def area(self): #.... print(\"此图形的面积为...\")class From(Shape) 就表示 From 继承 Shape。Python中，实现继承的类称为子类，被继承的类称为父类（也可称为基类、超类）。因此在上面这个样例中，From 是子类，Shape 是父类。子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。语法格式如下：class 类名(父类1, 父类2, …)：#类定义部分如果该类没有显式指定继承自哪个类，则默认继承 object 类（object 类是 Python 中所有类的父类，即要么是直接父类，要么是间接父类）。另外，Python 的继承是多继承机制（和 C++ 一样），即一个子类可以同时拥有多个直接父类。继承是相对子类来说的，即子类继承自父类；而派生是相对于父类来说的，即父类派生出子类。子类拥有父类所有的属性和方法，即便该属性或方法是私有（private）的 多继承使用多继承经常需要面临的问题是，多个父类中包含同名的类方法。对于这种情况，Python 的处置措施是：根据子类继承多个父类时这些父类的前后次序决定，即排在前面父类中的类方法会覆盖排在后面父类中的同名类方法。12345678910111213141516171819class People: def __init__(self): self.name = People def say(self): print(\"People类\",self.name)class Animal: def __init__(self): self.name = Animal def say(self): print(\"Animal类\",self.name)#People中的 name 属性和 say() 会遮蔽 Animal 类中的class Person(People, Animal): passzhangsan = Person()zhangsan.name = \"张三\"zhangsan.say()OutPut：People类 张三 父类方法重写类继承了父类，那么子类就拥有了父类所有的类属性和类方法。通常情况下，子类会在此基础上，扩展一些新的类属性和类方法。重写，有时又称覆盖，是一个意思，指的是对类中已有方法的内部实现进行修改。1234567891011121314151617class Bird: #鸟有翅膀 def isWing(self): print(\"鸟有翅膀\") #鸟会飞 def fly(self): print(\"鸟会飞\")class Ostrich(Bird): # 重写Bird类的fly()方法 def fly(self): print(\"鸵鸟不会飞\")# 创建Ostrich对象ostrich = Ostrich()#调用 Ostrich 类中重写的 fly() 类方法ostrich.fly()结果：鸵鸟不会飞 如何调用被重写的方法通过类名调用实例方法的这种方式，又被称为未绑定方法。12345# 创建Ostrich对象ostrich = Ostrich()#调用 Bird 类中的 fly() 方法Bird.fly(ostrich)鸟会飞 使用Python继承机制(子类化内置类型)内置类型子类化，其实就是自定义一个新类，使其继承有类似行为的内置类，通过重定义这个新类实现指定的功能。123456789101112131415class newDictError(ValueError): \"\"\"如果向newDict 添加重复值，则引发此异常\"\"\"class newDict(dict): \"\"\"不接受重复值的字典\"\"\" def __setitem__(self,key,value): if value in self.values(): if ((key in self and self[key]!=value) or (key not in self)): raise newDictError(\"这个值已经存在，并对应不同的键\") super().__setitem__(key,value)demoDict = newDict()demoDict['key']='value'demoDict['other_key']='value2'print(demoDict)demoDict['other_key']='value'print(demoDict)newDict是Python中 dict 类型的子类，所以其大部分行为都和dict内置类相同，唯一不同之处在于，newDict不允许字典中多个键对应相同的值。如果用户试图添加具有相同值的新元素，则会引发 newDictError 异常，并给出提示信息。 super()函数：调用父类构造方法Python 中子类会继承父类所有的类属性和类方法。严格来说，类的构造方法其实就是实例方法，因此毫无疑问，父类的构造方法，子类同样会继承。在子类中的构造方法中，调用父类构造方法的方式有 2 种，分别是：类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要额外备注类名（此方式又称为未绑定方法）；使用 super() 函数。但如果涉及多继承，该函数只能调用第一个直接父类的构造方法。也就是说，涉及到多继承时，在子类构造函数中，调用第一个父类构造方法的方式有以上 2 种，而调用其它父类构造方法的方式只能使用未绑定方法。语法格式如下：super().init(self,…)12345678910111213141516171819202122232425class People: def __init__(self,name): self.name = name def say(self): print(\"我是人，名字为：\",self.name)class Animal: def __init__(self,food): self.food = food def display(self): print(\"我是动物,我吃\",self.food)class Person(People, Animal): #自定义构造方法 def __init__(self,name,food): #调用 People 类的构造方法 super().__init__(name) #super(Person,self).__init__(name) #执行效果和上一行相同 #People.__init__(self,name)#使用未绑定方法调用 People 类构造方法 #调用其它父类的构造方法，需手动给 self 传值 Animal.__init__(self,food) per = Person(\"zhangsan\",\"熟食\")per.say()per.display()# 运行结果： 我是人，名字为： zhangsan 我是动物,我吃 熟食Person类自定义的构造方法中，调用People类构造方法，可以使用super() 函数，也可以使用未绑定方法。但是调用Animal类的构造方法，只能使用未绑定方法。 super()使用注意事项（包含新式类和旧式类的区别）Python 2.x 版本中，为了向后兼容保留了旧式类。该版本中的新式类必须显式继承 object 或者其他新式类：1234class newStyleClass(object): passclass newStyleClass(newStyleClass): passPython3.x中，显式声明某个类继承自object似乎是冗余的。但如果考虑跨版本兼容，那么就必须将 object 作为所有基类的祖先，因为如果不这么做的话，这些类将被解释为旧式类，最终会导致难以诊断的问题。 super()使用注意事项由于基类不会在__init__() 中被隐式地调用，需要程序员显式调用它们。这种情况下，当程序中包含多重继承的类层次结构时，使用super是非常危险的，往往会在类的初始化过程中出现问题。 混用super与显式类调用C类使用了 init() 方法调用它的基类，会造成B类被调用了2次：123456789101112131415161718class A: def __init__(self): print(\"A\",end=\" \") super().__init__()class B: def __init__(self): print(\"B\",end=\" \") super().__init__()class C(A,B): def __init__(self): print(\"C\",end=\" \") A.__init__(self) B.__init__(self)print(\"MRO:\",[x.__name__ for x in C.__mro__])C()运行结果为：MRO: ['C', 'A', 'B', 'object']C A B BC的实例调用A.init(self)，使得super(A,self).init() 调用了B.init()方法。换句话说，super应该被用到整个类的层次结构中。 不同种类的参数1234567891011121314151617 class commonBase: def __init__(self,*args,**kwargs): print(\"commonBase\") super().__init__()class base1(commonBase): def __init__(self,*args,**kwargs): print(\"base1\") super().__init__(*args,**kwargs)class base2(commonBase): def __init__(self,*args,**kwargs): print(\"base2\") super().__init__(*args,**kwargs)class myClass(base1,base2): def __init__(self,arg): print(\"my base\") super().__init__(arg)myClass(10)使用*args和**kwargs包装的参数和关键字参数，但是由于任何参数都可以传入，所有构造函数都可以接受任何类型的参数，这会导致代码变得脆弱。另一种解决方法是在 MyClass 中显式地使用特定类的 init() 调用，但这无疑会导致第一种错误。 总结尽可能避免使用多继承，可以使用一些设计模式来替代它；super的使用必须一致，即在类的层次结构中，要么全部使用super，要么全不用。混用super和传统调用是一种混乱的写法；如果代码需要兼容 Python 2.x，在 Python 3.x中应该显式地继承自 object。在 Python 2.x 中，没有指定任何祖先地类都被认定为旧式类。调用父类时应提前查看类的层次结构，也就是使用类的__mro__属性或者mro()方法查看有关类的MRO。 slots:限制类实例动态添加属性和方法Python 提供了 slots 属性，通过它可以避免用户频繁的给实例对象动态地添加属性或方法。再次声明，slots 只能限制为实例对象动态添加属性和方法，而无法限制动态地为类添加属性和方法。__slots__属性值其实就是一个元组，只有其中指定的元素，才可以作为动态添加的属性或者方法的名称。12class CLanguage: __slots__ = ('name','add','info')对于动态添加的方法，__slots__限制的是其方法名，并不限制参数的个数。只对当前所在的类起限制作用，如果为子类也设置有 slots 属性，那么子类实例对象允许动态添加的属性和方法，是子类中 slots 属性和父类 slots 属性的和。 type()函数：动态创建类type() 函数属于 Python 内置函数，通常用来查看某个变量的具体类型。其实，type() 函数还有一个更高级的用法，即创建一个自定义类型（也就是创建一个类）。type() 函数的语法格式有 2 种，分别如下：type(obj)type(name, bases, dict)以上这 2 种语法格式，各参数的含义及功能分别是：第一种语法格式用来查看某个变量（类对象）的具体类型，obj 表示某个变量或者类对象。第二种语法格式用来创建类，其中 name 表示类的名称；bases 表示一个元组，其中存储的是该类的父类；dict 表示一个字典，用于表示类内定义的属性或者方法。123456789def say(self): print(\"我要学 Python！\")#使用 type() 函数创建类CLanguage = type(\"CLanguage\",(object,),dict(say = say, name = \"个人博客\"))#创建一个 CLanguage 实例对象clangs = CLanguage()#调用 say() 方法和 name 属性clangs.say()print(clangs.name)Python 元组语法规定，当 (object,) 元组中只有一个元素时，最后的逗号（,）不能省略。 MetaClass元类使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法。把一个类设计成MetaClass 元类，其必须符合以下条件：必须显式继承自type类；类中需要定义并实现__new__()方法，该方法一定要返回该类的一个实例对象，因为在使用元类创建类时，该__new__()方法会自动被执行，用来修改新建的类。1234567891011121314#定义一个元类class FirstMetaClass(type): # cls代表动态修改的类 # name代表动态修改的类名 # bases代表被动态修改的类的所有父类 # attr代表被动态修改的类的所有属性、方法组成的字典 def __new__(cls, name, bases, attrs): # 动态为该类添加一个name属性 attrs['name'] = \"个人博客\" attrs['say'] = lambda self: print(\"调用say()实例方法\") return super().__new__(cls,name,bases,attrs)#定义类时，指定元类class CLanguage(object,metaclass=FirstMetaClass): pass Python多态及用法Python是弱类型语言，其最明显的特征是在使用变量时，无需为其指定具体的数据类型。这会导致一种情况，即同一变量可能会被先后赋值不同的类对象，类的多态特性，还要满足以下 2 个前提条件：继承：多态一定是发生在子类和父类之间；重写：子类重写了父类的方法。12345678910111213141516171819class WhoSay: def say(self,who): who.say()class CLanguage: def say(self): print(\"调用的是 Clanguage 类的say方法\")class CPython(CLanguage): def say(self): print(\"调用的是 CPython 类的say方法\")class CLinux(CLanguage): def say(self): print(\"调用的是 CLinux 类的say方法\")a = WhoSay()#调用 CLanguage 类的 say() 方法a.say(CLanguage())#调用 CPython 类的 say() 方法a.say(CPython())#调用 CLinux 类的 say() 方法a.say(CLinux())通过给WhoSay类中的say()函数添加一个who参数，其内部利用传入的who调用 say() 方法。这意味着，当调用 WhoSay 类中的 say() 方法时，我们传给 who 参数的是哪个类的实例对象，它就会调用那个类中的 say()方法。 枚举类定义及使用实例：123456from enum import Enumclass Color(Enum): # 为序列值指定value值 red = 1 green = 2 blue = 3Color 枚举类中，red、green、blue 都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为 name 和 value，其中 name 属性值为该枚举值的变量名（如 red），value 代表该枚举值的序号（序号通常从 1 开始）。1234567# 访问枚举类成员print(Color.red)print(Color['red'])print(Color(1))#调取枚举成员中的 value 和 nameprint(Color.red.value)print(Color.red.name)枚举类成员之间可以用 == 或者 is 进行比较是否相等，但各个成员的值，不能在类的外部做任何修改。Python枚举类中各个成员必须保证 name 互不相同，但value可以相同。可以借助@unique装饰器，这样当枚举类中出现相同值的成员时，程序会报 ValueError错误。实例如下：123456789101112131415161718from enum import Enumclass Color(Enum): # 为序列值指定value值 red = 1 green = 1 blue = 3print(Color['green'])Output Color：redfrom enum import Enum,unique#添加 unique 装饰器@uniqueclass Color(Enum): # 为序列值指定value值 red = 1 green = 1 blue = 3print(Color['green'])ValueError错误除了通过继承 Enum 类的方法创建枚举类，还可以使用Enum()函数创建枚举类。可接受2个参数，第一个用于指定枚举类的类名，第二个参数用于指定枚举类中的多个成员。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"}]},{"title":"Python-代码质量","slug":"Python-代码质量","date":"2020-04-27T09:52:09.000Z","updated":"2020-04-28T04:02:40.301Z","comments":true,"path":"2020/04/27/Python-代码质量/","link":"","permalink":"http://forwardpeng.github.io/2020/04/27/Python-%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/","excerpt":"","text":"参考链接怎样才能写出 Pythonic 的代码？Python优美代码的一些方法 内置函数 enumerate类1234567891011from __future__ import print_functionL = [i*i for i in range(5)]# 普通写法index = 0for data in L: index += 1 print(index, ':', data)# enumerate类的使用for index, data in enumerate(L, 1): print(index, ':', data)在保证代码可读性的前提下，代码越少越好。显然，使用enumerate效果就好很多。 reversedPython中的列表支持切片操作，可以像L[::-1]这样取reverse列表。 any遍历一个二维的元组，判断是否存在Non_unique为0,Null列不为YES的记录123456789# 普通def has_primary_key(): for row in rows: if row[1] == 0 and row[9] != 'YES': return True return False# 使用anydef has_prmary_key1(): return any(row[1] == 0 and row[9] != 'YES' for row in rows) Python中的小细节 raise SystemExit在程序检测某种错误时，打印错误信息，并退出程序1raise SystemExit('It failed!') 文件的x模式需求：写一个文件，如果该文件已经存在，则不写，否则以w模式打开文件并写入：12345678import osif not os.paht.exists('filename'): f.write('Hello\\n')else: print('File already exists!')# 使用x模式with open('filename', 'xt') as f: f.write('Hello\\n') ConfigParser提供生成连接字符串的功能，用于读取配置参数。如下：123456789$cat db.conf[DEFAULT]conn_str&#x3D;%(dbn)s:&#x2F;&#x2F;(%user)s:%(pw)s@%(host)s:%(port)s&#x2F;%(db)sdbn&#x3D;mysqluser&#x3D;rootpw&#x3D;roothost&#x3D;localhostport&#x3D;3306db&#x3D;test 合理的使用数据结构 字典的get传递默认值123port = kwargs.get('port')if port is None: port = 3306字典的get方法支持提供默认参数，在字典没有值的情况下，将返回用户提供的默认参数，高质量的写法：1port = kwargs.get('port', 3306)在调用pop()函数是，需要返回最后一个元素：12345L = [1,2,3,4]last = L[-1]L.pop()# 优化last = L.pop() dfaultdict &amp; Counter需求1：假设字典的value是list，先判断key是否已经存在，如果不存在，新建一个list并赋值给key，如果已经存在，则调用list的append()方法，将值添加进去。12345678910# 普通d = &#123;&#125;for key, value in pairs: if key not in d: d[key] = [] d[key].append(value)# 使用defaultdictd = defaultdict(list)for key, value in pairs: d[key].append(value)需求2：统计一个文件中，每个单词出现的次数，使用字典的写法如下：1234567891011121314# 普通写法d = &#123;&#125;with open('/etc/passwd/) as f: for line in f: for word in line.strip().split(':'): if word not in d: d[word] = 1 else: d[word] += 1# 使用collections中的Counterword_counts = Counter()with open('/etc/passwd') as f: for line in f: word_counts.update(line.strip().split(':'))需求3：打印出现次数最多的三个单词，使用字典如下：1234result = sorted(zip(d.values(),d.keys()), reverse=True)[:3]# Couter直接提供for key, val in (word_counts.most_common(3)): print(key,':', val) nametuple监控系统，可以从/proc/diskstats中获取磁盘的详细信息123$ cat /proc/diskstats 7 0 loop0 59 0 2116 3486 0 0 0 0 0 120 3420 0 0 0 0 7 1 loop1 132 0 2288 3816 0 0 0 0 0 164 3752 0 0 0 0如果使用下标访问，计算较复杂，可以使用Python中的命名元组，即collections中的namedtuple，如下：1234567DiskDevice = collections.namedtuple('DiskDevice', 'major_number minor_number device_name read_count read_merged_count'...)# 有了命名空间，通过命名元组，能够通过属性访问各个字段，获取磁盘监控的代码如下：def get_disk_info(disk_name): with open(\"/proc/diskstats\") as f: for line in f: if line.split()[2] == disk_name: return DiskDevice(*(line.split())) 使用高级并发工具实例：生产者消费者模型，生产者向队列中放东西，消费者从队列中取东西。创建一个锁来保证线程间操作的互斥性，当队列满时，生产者进入等待状态，当队列空的时候，消费者进入等待状态。如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546from threading import Thread, Conditionimport timeimport randomqueue = []MAX_NUM = 10Condition = Condition()class ProducerThread(Thread): def run(self): nums = range(5) global queue while True: Condition.acquire() if len(queue) == MAX_NUM: print(\"Queue full, producer is waiting\") Condition.wait() print(\"Space in queue, Consumer notified the producer\") num = random.choice(nums) queue.append(num) print(\"Produced\", num) Condition.notify() Condition.release() time.sleep(random.random())class ConsumerThread(Thread): def run(self): global queue while True: Condition.acquire() if not queue: print(\"Nothing in queue, consumer is waiting\") Condition.wait() print( \"producer added something queue and notified the consumer\") num = queue.pop() print(\"Consumed\", num) Condition.notify() Condition.release() time.sleep(random.random())ProducerThread().start()ConsumerThread().start()对于同步问题，可以直接使用Queue，Queue提供线程安全的队列，适用解决生产者和消费者问题，支持阻塞读、阻塞写，写法如下：12345678910111213141516171819202122232425262728293031from threading import Threadimport timeimport randomfrom queue import Queuequeue = Queue(10)class ProducThread(Thread): def run(self): nums = range(5) global queue while True: num = random.choice(nums) queue.put(num) print(\"Produced\", num) time.sleep(random.random())class ConsumerThread(Thread): def run(self): global queue while True: num = queue.get() queue.task_done() print(\"Consumed\", num) time.sleep(random.random())ProducThread().start()ConsumerThread().start()使用Queue后，代码量减少。同时，在并发编程，不需要手动启动一个线程或进程，可以使用并发工具，内置的map是单线程运行的，如果涉及到网络请求或大量CPU计算，速度相对会慢很多，需要使用并发的map，如下：123456789101112131415import requestsfrom multiprocessing import Pooldef get_website_data(url): r = requests.get(url) return r.urldef main(): urls = ['http://www.google.com'. 'https://www.baidu.com', 'http://www.163.com'] pool = Pool(2) print(pool.map(get_website_data, urls))main()为了保证线程兼容，模型提供了dummy，用以提供线程池的实现，如下：12from multiprocessing.dummy import Pool# 可以快速的在线程池和进程池之间切换 使用装饰器实例：有两个模块，A模块需要给B模块发消息，B模块检查A模块发送过来的参数，没有问题则进行处理，对于检查参数的操作，使用装饰器的代码如下：12345678910111213141516171819202122232425262728import inspectimport functoolsdef check_args(parameters): \"\"\" check paramenters of action \"\"\" def decorated(f): \"\"\" decorator \"\"\" @functools.wraps def wrapper(*args, **kwargs): func_args = inspect.getcallargs(f, *args, **kwargs) msg = func_args.get('msg') for item in parameters: if msg.body_dict.get(item) is None: return False, \"check faild, %s is not found\" % item return f(*args, **kwargs) return wrapper return decorated#使用装饰器class AsyncMsgHandle(MsgHandler): @check.check_args(['Containerldentifier', 'MonitorSecretKey', \"InstanceID\", \"UUID\"]) def init_container(self, msg): pass Python中的设计模式 单例模式1234class Borg: _shared_state = &#123;&#125; def __init__(self): self.__dict__ = self._shared_state只要所有的实例共享状态、行为一直，就达到单例的目的，通过Borg可以创建任意数量的实例。在Python中，模块初始化一次，import机制是线程安全的，因此模块本身就是单例的实现。 工厂模式123456789101112// CPP的工厂模式实现class Shape class Circle: public Shape class Square: public Shape Shape *Shape::factory(const string &amp;type) &#123; if(type == \"Circle\") return new Circle; if(type == \"Square\") return new Square; &#125;上述单例的Python实现如下：12345678910class Shape: passclass Circle(Shape): passclass Square(Shape): passfor name in [\"Circle\", \"Square\"]: cls = globals()[name] obj = cls()理解：Python中的类是可调用的对象，在import后，存在于当前命名空间中。可以先通过名字获取类，再用类构造出对象，Python比C++少一个需要维护的函数。 优美代码注意事项写代码跟写作文一样，条理要清晰准确无歧义，完整且清晰排版清楚，添加必要的空行添加必要的注释、注意标点符号保证可读性且代码尽可能短小","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"}]},{"title":"Python-流程控制","slug":"Python-流程控制","date":"2020-04-27T03:55:54.000Z","updated":"2020-04-27T09:47:49.784Z","comments":true,"path":"2020/04/27/Python-流程控制/","link":"","permalink":"http://forwardpeng.github.io/2020/04/27/Python-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"","text":"assert断言assert 语句的语法结构为：assert 表达式assert 语句的执行流程可以用 if 判断语句表示，如下所示：if 表达式==True:程序继续执行else:程序报 AssertionError 错误123456#price 为原价，discount 为折扣力度def apply_discount(price, discount): updated_price = price * (1 - discount) assert 0 &lt;= updated_price &lt;= price, '折扣价应在 0 和原价之间' return updated_price# 添加了一个 assert 语句，用来检查折后价格，这里要求新折扣价格必须大于等于 0、小于等于原来的价格，否则就抛出异常。assert 的加入可以有效预防程序漏洞，提高程序的健壮性。循环嵌套结构的代码，Python解释器执行的流程为：当外层循环条件为 True 时，则执行外层循环结构中的循环体；外层循环体中包含了普通程序和内循环，当内层循环的循环条件为 True 时会执行此循环中的循环体，直到内层循环条件为 False，跳出内循环；如果此时外层循环的条件仍为 True，则返回第 2 步，继续执行外层循环体，直到外层循环的循环条件为False；当内层循环的循环条件为False，且外层循环的循环条件也为False，则整个嵌套循环才算执行完毕。 zip函数及其用法zip() 函数是 Python 内置函数之一，它可以将多个序列（列表、元组、字典、集合、字符串以及 range() 区间构成的列表）“压缩”成一个 zip 对象。所谓“压缩”，其实就是将这些序列中对应位置的元素重新组合，生成一个个新的元组。语法格式：zip(iterable, …)其中iterable,… 表示多个列表、元组、字典、集合、字符串，甚至还可以为range()区间。1234&gt;&gt;&gt; my_list = [11,12,13]&gt;&gt;&gt; my_tuple = (21,22,23)&gt;&gt;&gt; print([x for x in zip(my_list,my_tuple)])[(11, 21), (12, 22), (13, 23)] reversed函数及用法对于给定的序列（包括列表、元组、字符串以及 range(n) 区间），该函数可以返回一个逆序序列的迭代器（用于遍历该逆序序列）reserved()函数的语法格式如下：reversed(seq)其中，seq可以是列表，元素，字符串以及range()生成的区间列表。12&gt;&gt;&gt; print([x for x in reversed((1,2,3,4,5))])[5, 4, 3, 2, 1] sorted函数及用法sorted() 作为 Python 内置函数之一，其功能是对序列（列表、元组、字典、集合、还包括字符串）进行排序。sorted()函数的基本语法格式如下：list = sorted(iterable, key=None, reverse=False)其中，iterable表示指定的序列，key 参数可以自定义排序规则；reverse参数指定以升序（False，默认）还是降序（True）进行排序。sorted()函数会返回一个排好序的列表。注意，key 参数和 reverse 参数是可选参数，即可以使用，也可以忽略。12345678910&gt;&gt;&gt; a = &#123;4:1,\\... 5:2,\\... 3:3,\\... 2:6,\\... 1:8&#125;&gt;&gt;&gt; print(sorted(a.items()))[(1, 8), (2, 6), (3, 3), (4, 1), (5, 2)]&gt;&gt;&gt; print(sorted(a.values()))[1, 2, 3, 6, 8]# 函数默认对序列中元素进行升序排序，通过手动将其reverse参数值改为True，可实现降序排序。sorted()函数时，还可传入一个 key参数，它可以接受一个函数，该函数的功能是指定sorted()函数按照什么标准进行排序，实例如下：12345&gt;&gt;&gt; chars = ['sss', 'ss', 'sssss', 's']&gt;&gt;&gt; print(sorted(chars))['s', 'ss', 'sss', 'sssss']&gt;&gt;&gt; print(sorted(chars, key=lambda x:len(x)))['s', 'ss', 'sss', 'sssss'] 函数可变参数*args及**kwargsPython函数可变参数*args及**kwargs，先给出标准答案：*args是arguments单词缩写，表示任意多个无名参数，是一个tuple，如 (1,2,3,‘a’,‘b’,‘c’)**kwargs是keyword arguments单词缩写,表示关键字参数，是一个dict，如{‘a’:1,‘b’:2,‘c’:3}，*args参数必须在**kwargs前1234567891011121314151617181920212223242526272829303132def foo(*args,**kwargs): print 'args=',args print 'kwargs=',kwargs print '*'*20 if __name__=='__main__': #只传参数*args=(1,2,3) foo(1,2,3) #只传参数**kwargs=dict(a=1,b=2,c=3) foo(a=1,b=2,c=3) #传入参数*args=(1,2,3) #传入参数**kwargs=dict(a=1,b=2,c=3) foo(1,2,3,a=1,b=2,c=3) #传入参数*args=(1,'b','c') #传入参数**kwargs=dict(a=1,b='b',c='c') foo(1,'b','c',a=1,b='b',c='c')输出： args= (1, 2, 3)kwargs= &#123;&#125;********************args= ()kwargs= &#123;'a': 1, 'c': 3, 'b': 2&#125;********************args= (1, 2, 3)kwargs= &#123;'a': 1, 'c': 3, 'b': 2&#125;********************args= (1, 'b', 'c')kwargs= &#123;'a': 1, 'c': 'c', 'b': 'b'&#125;******************** 逆向参数收集在列表、元组前添加 *，在字典前添加 **。123456789101112131415&gt;&gt;&gt; def test(a, b):... print(a)... print(b)... &gt;&gt;&gt; vals_1 = [10,20]&gt;&gt;&gt; test(*vals_1)1020&gt;&gt;&gt; vals_2 = &#123;'a':10, 'b':20&#125;&gt;&gt;&gt; test(*vals_2)ab&gt;&gt;&gt; test(**vals_2)1020 None(空值)及其用法有一个特殊的常量None（N 必须大写）。和False不同，它不表示0，也不表示空字符串，而表示没有值，也就是空值。这里的空值并不代表空对象，即None和[]、“” 不同：123456&gt;&gt;&gt; None is []False&gt;&gt;&gt; None is \"\"False&gt;&gt;&gt; type(None)&lt;class 'NoneType'&gt;None 是 NoneType 数据类型的唯一值（其他编程语言可能称这个值为 null、nil 或 undefined），也就是说，我们不能再创建其它 NoneType 类型的变量，但是可以将 None 赋值给任何变量。如果希望变量中存储的东西不与任何其它值混淆，就可以使用 None。 partial偏函数及其用法简单的理解偏函数，它是对原始函数的二次封装，是将现有函数的部分参数预先绑定为指定值，从而得到一个新的函数，该函数就称为偏函数。相比原函数，偏函数具有较少的可变参数，从而降低了函数调用的难度。定义偏函数，需使用 partial 关键字（位于 functools 模块中），其语法格式如下：偏函数名 = partial(func, *args, **kwargs)其中，func 指的是要封装的原函数，*args 和 **kwargs 分别用于接收无关键字实参和关键字实参。12345678&gt;&gt;&gt; def mod( n, m ):... return n % m... &gt;&gt;&gt; mod_by_100 = partial( mod, 100 )&gt;&gt;&gt; print(mod( 100, 7 ))2&gt;&gt;&gt; print(mod_by_100( 7 ))2 变量作用域(全局变量和局部变量)作用域（Scope），就是变量的有效范围，就是变量可以在哪个范围以内使用。有些变量可以在整段代码的任意位置使用，有些变量只能在函数内部使用，有些变量只能在 for 循环内部使用。变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。本节我们只讲解两种变量，局部变量和全局变量。 局部变量在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量（Local Variable）。要知道，当函数被执行时，Python 会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。12345678910&gt;&gt;&gt; def demo():... add = \"http://c.biancheng.net/python/\"... print(\"函数内部 add =\",add)... &gt;&gt;&gt; demo()函数内部 add = http://c.biancheng.net/python/&gt;&gt;&gt; print(\"函数外部 add =\",add)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'add' is not defined 全局变量在函数内部定义变量，Python 还允许在所有函数的外部定义变量，这样的变量称为全局变量（Global Variable）。和局部变量不同，全局变量的默认作用域是整个程序，即全局变量既可以在各个函数的外部使用，也可以在各函数内部使用。定义全局变量的方式有以下2种：在函数体外定义的变量，一定是全局变量，如：12345678&gt;&gt;&gt; add = \"http://c.biancheng.net/shell/\"&gt;&gt;&gt; def text():... print(\"函数体内访问：\",add)... &gt;&gt;&gt; text()函数体内访问： http://c.biancheng.net/shell/&gt;&gt;&gt; print('函数体外访问：',add)函数体外访问： http://c.biancheng.net/shell/在函数体内定义全局变量。即使用 global关键字对变量进行修饰后，该变量就会变为全局变量123456789&gt;&gt;&gt; def text():... global add... add= \"http://c.biancheng.net/java/\"... print(\"函数体内访问：\",add)... &gt;&gt;&gt; text()函数体内访问： http://c.biancheng.net/java/&gt;&gt;&gt; print(add)http://c.biancheng.net/java/注意，在使用 global 关键字修饰变量名时，不能直接给变量赋初值，否则会引发语法错误。 获取指定作用域范围中的变量1.globals()函数globals()函数为Python的内置函数，它可以返回一个包含全局范围内所有变量的字典，该字典中的每个键值对，键为变量名，值为该变量的值。globals()函数返回的字典中，会默认包含有很多变量。123&gt;&gt;&gt; globals()['Pyname'] = \"Python入门教程\"&gt;&gt;&gt; print(Pyname)Python入门教程2.locals()函数locals()函数也是Python内置函数之一，通过调用该函数，我们可以得到一个包含当前作用域内所有变量的字典。这里所谓的“当前作用域”指的是，在函数内部调用 locals() 函数，会获得包含所有局部变量的字典；而在全局范文内调用 locals() 函数，其功能和 globals() 函数相同。123456789101112131415&gt;&gt;&gt; Pyname = \"Python教程\"&gt;&gt;&gt; Pyadd = \"http://c.biancheng.net/python/\"&gt;&gt;&gt; def text():... #局部变量... Shename = \"shell教程\"... Sheadd= \"http://c.biancheng.net/shell/\"... print(\"函数内部的 locals:\")... print(locals())... &gt;&gt;&gt; text()函数内部的 locals:&#123;'Sheadd': 'http://c.biancheng.net/shell/', 'Shename': 'shell教程'&#125;&gt;&gt;&gt; print(\"函数外部的 locals:\")函数外部的 locals:&gt;&gt;&gt; print(locals())3.vars(object)vars() 函数也是 Python 内置函数，其功能是返回一个指定 object 对象范围内所有变量组成的字典。如果不传入object 参数，vars() 和 locals() 的作用完全相同。 同名的全局变量解决方式：方式1：在函数中要定义局部变量时不要与全局变量同名， 即在numCheck( )中定义的局部变量换个名。方式2：进入函数时先定义与全局变量同名的局部变量，就不会报错了，但是这样就没有达到引用全局变量a之后再定义与全局变量同名的局部变量a 的目的，所以引入方式3。方式3：这里涉及到全局变量和局部变量的区分，如果想使用全局变量a之后再使用同名的局部变量a，就应该是把方法和变量定义在类里。通过类的成员变量去引用全局变量。 局部函数及用法（包含nonlocal关键字）123456789101112#全局函数def outdef (): name = \"所在函数中定义的 name 变量\" #局部函数 def indef(): nonlocal name print(name) #修改name变量的值 name = \"局部函数中定义的 name 变量\" indef()#调用全局函数outdef()由于这里的name变量也是局部变量，因此前面章节讲解的globals() 函数或者 globals关键字，并不适用于解决此问题。这里可以使用Python提供的 nonlocal关键字 函数的高级用法Python 函数还支持赋值、作为其他函数的参数以及作为其他函数的返回值。12345678910111213141516def my_def(): print(\"正在执行 my_def 函数\")other = my_defother()正在执行 my_def 函数# Python 还支持函数的返回值也为函数def my_def (): #局部函数 def indef(): print(\"调用局部函数\") #调用局部函数 return indefother_def = my_def()#调用局部的 indef() 函数other_def()调用局部函数 Python的闭包闭包，又称闭包函数或者闭合函数，其实和前面讲的嵌套函数类似，不同之处在于，闭包中外部函数返回的不是一个具体的值，而是一个函数。一般情况下，返回的函数会赋值给一个变量，这个变量可以在后面被继续执行调用。123456789#闭包函数，其中 exponent 称为自由变量def nth_power(exponent): def exponent_of(base): return base ** exponent return exponent_of # 返回值是 exponent_of 函数square = nth_power(2) # 计算一个数的平方cube = nth_power(3) # 计算一个数的立方print(square(2)) # 计算 2 的平方print(cube(2)) # 计算 2 的立方函数开头需要做一些额外工作，当需要多次调用该函数时，如果将那些额外工作的代码放在外部函数，就可以减少多次调用导致的不必要开销，提高程序的运行效率。 闭包的__closure__属性记录着自由变量的地址。当闭包被调用时，系统就会根据该地址找到对应的自由变量，完成整体的函数调用。类型是一个元组，这表明闭包可以支持多个自由变量的形式。 lambda表达式(匿名函数)及其用法lambda 表达式，又称匿名函数，常用来表示内部仅包含 1 行表达式的函数。如果一个函数的函数体仅有 1 行表达式，则该函数就可以用 lambda 表达式来代替。lambda 表达式的语法格式如下：name = lambda [list] : 表达式其中，定义 lambda 表达式，必须使用 lambda 关键字；[list] 作为可选参数，等同于定义函数是指定的参数列表；value 为该表达式的名称。123&gt;&gt;&gt; add = lambda x,y: x + y&gt;&gt;&gt; print(add(3,4))7lamba 表达式具有以下 2 个优势：对于单行函数，使用 lambda 表达式可以省去定义函数的过程，让代码更加简洁；对于不需要多次复用的函数，使用 lambda 表达式可以在用完之后立即释放，提高程序执行的性能。 eval()和exec()函数eval() 和 exec() 函数的功能是相似的，都可以执行一个字符串形式的 Python 代码（代码以字符串的形式提供），相当于一个 Python 的解释器。二者不同之处在于，eval() 执行完要返回结果，而 exec() 执行完不返回结果。eval() 函数的语法格式为：eval(source, globals=None, locals=None, /)而 exec() 函数的语法格式如下：exec(source, globals=None, locals=None, /)二者的语法格式除了函数名，其他都相同，其中各个参数的具体含义如下：expression：这个参数是一个字符串，代表要执行的语句 。该语句受后面两个字典类型参数 globals 和 locals 的限制，只有在 globals 字典和 locals 字典作用域内的函数和变量才能被执行。globals：这个参数管控的是一个全局的命名空间，即 expression 可以使用全局命名空间中的函数。如果只是提供了 globals 参数，而没有提供自定义的 builtins，则系统会将当前环境中的 * builtins 复制到自己提供的 globals 中，然后才会进行计算；如果连 globals 这个参数都没有被提供，则使用 Python 的全局命名空间。locals：这个参数管控的是一个局部的命名空间，和 globals 类似，当它和 globals 中有重复或冲突时，以 locals 的为准。如果 locals 没有被提供，则默认为 globals。注意，builtins 是 Python 的内建模块，平时使用的 int、str、abs 都在这个模块中。通过print(dic[“builtins”]) 语句可以查看 builtins 所对应的 value。1234567&gt;&gt;&gt; a=10&gt;&gt;&gt; b=20&gt;&gt;&gt; c=30&gt;&gt;&gt; g=&#123;'a':6, 'b':8&#125; #定义一个字典&gt;&gt;&gt; t=&#123;'b':100, 'c':10&#125; #定义一个字典&gt;&gt;&gt; print(eval('a+b+c', g, t)) #定义一个字典 116116 exec()和eval()区别12345678910a = 1exec(\"a = 2\") #相当于直接执行 a=2print(a)2a = exec(\"2+3\") #相当于直接执行 2+3，但是并没有返回值，a 应为 Noneprint(a)Nonea = eval('2+3') #执行 2+3，并把结果返回给 aprint(a)5exec() 中最适合放置运行后没有结果的语句，而 eval() 中适合放置有结果返回的语句。 eval() 和 exec() 函数的应用场景客户端向服务端发送一段字符串代码，服务端无需关心具体的内容，直接跳过 eval() 或 exec() 来执行，这样的设计会使服务端与客户端的耦合度更低，系统更易扩展。注意的是，在使用 eval() 或是 exec() 来处理请求代码时，函数 eval() 和 exec() 常常会被黑客利用，成为可以执行系统级命令的入口点，进而来攻击网站。解决方法是：通过设置其命名空间里的可执行函数，来限制 eval() 和 exec() 的执行范围。第一个参数是字符串，而字符串的内容一定要是可执行的代码。在编写代码时，一般会使 repr() 数来生成动态的字符串，再传入到 eval() 或 exec() 函数内，实现动态执行代码的功能。 函数式编程（map()、filter()和reduce()）详解函数式编程的优点，主要在于其纯函数和不可变的特性使程序更加健壮，易于调试和测试；缺点主要在于限制多，难写。注意，纯粹的函数式编程语言（比如 Scala），其编写的函数中是没有变量的，因此可以保证，只要输入是确定的，输出就是确定的；而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出。Python 允许使用变量，所以它并不是一门纯函数式编程语言。Python 仅对函数式编程提供了部分支持，主要包括 map()、filter() 和 reduce() 这 3 个函数，它们通常都结合 lambda 匿名函数一起使用。接下来就对这 3 个函数的用法做逐一介绍。 map()函数map()函数的基本语法格式如下：map(function, iterable)其中，function参数表示要传入一个函数，其可以是内置函数、自定义函数或者 lambda 匿名函数；iterable 表示一个或多个可迭代对象，可以是列表、字符串等。map()函数的功能是对可迭代对象中的每个元素，都调用指定的函数，并返回一个map对象。注意，该函数返回的是一个map对象，不能直接输出，可以通过for循环或者 list() 函数来显示。12345&gt;&gt;&gt; listDemo1 = [1, 2, 3, 4, 5]&gt;&gt;&gt; listDemo2 = [3, 4, 5, 6, 7]&gt;&gt;&gt; new_list = map(lambda x,y: x + y, listDemo1,listDemo2)&gt;&gt;&gt; print(list(new_list))[4, 6, 8, 10, 12]注意，由于 map() 函数是直接由用 C 语言写的，运行时不需要通过 Python 解释器间接调用，并且内部做了诸多优化，所以相比其他方法，此方法的运行效率最高。 filter()函数filter()函数的基本语法格式如下：filter(function, iterable)此格式中，funcition参数表示要传入一个函数，iterable表示一个可迭代对象。filter()函数的功能是对 iterable中的每个元素，都使用 function函数判断，并返回 True 或者 False，最后将返回 True 的元素组成一个新的可遍历的集合。123&gt;&gt;&gt; new_list = map(lambda x,y: x-y&gt;0,[3,5,6],[1,5,8] )&gt;&gt;&gt; print(list(new_list))[True, False, False] reduce()函数reduce()函数通常用来对一个集合做一些累积操作，其基本语法格式为：reduce(function, iterable)其中，function规定必须是一个包含2个参数的函数；iterable 表示可迭代对象。注意，由于 reduce()函数在 Python 3.x中已经被移除，放入了 functools模块，因此在使用该函数之前，需先导入functools模块。1234&gt;&gt;&gt; listDemo = [1, 2, 3, 4, 5]&gt;&gt;&gt; product = functools.reduce(lambda x, y: x * y, listDemo)&gt;&gt;&gt; print(product) # 叠乘120 函数注解（Function Annotations）函数注解语法 可以让你在定义函数的时候对参数和返回值添加注解：123def foobar(a: int, b: \"it's b\", c: str = 5) -&gt; tuple: return a, b, c# foobar.__annotations__获取参数注解a: int 这种是注解参数c: str = 5 是注解有默认值的参数-&gt; tuple 是注解返回值。基于注解可以实现参数类型检查的装饰器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# coding: utf8import collectionsimport functoolsimport inspectdef check(func): msg = ('Expected type &#123;expected!r&#125; for argument &#123;argument&#125;, ' 'but got type &#123;got!r&#125; with value &#123;value!r&#125;') # 获取函数定义的参数 sig = inspect.signature(func) parameters = sig.parameters # 参数有序字典 arg_keys = tuple(parameters.keys()) # 参数名称 @functools.wraps(func) def wrapper(*args, **kwargs): CheckItem = collections.namedtuple('CheckItem', ('anno', 'arg_name', 'value')) check_list = [] # collect args *args 传入的参数以及对应的函数参数注解 for i, value in enumerate(args): arg_name = arg_keys[i] anno = parameters[arg_name].annotation check_list.append(CheckItem(anno, arg_name, value)) # collect kwargs **kwargs 传入的参数以及对应的函数参数注解 for arg_name, value in kwargs.items(): anno = parameters[arg_name].annotation check_list.append(CheckItem(anno, arg_name, value)) # check type for item in check_list: if not isinstance(item.value, item.anno): error = msg.format(expected=item.anno, argument=item.arg_name, got=type(item.value), value=item.value) raise TypeError(error) return func(*args, **kwargs) return wrapper@checkdef foobar(a: int, b:str, c: float=3.2) -&gt; tuple: return a, b, c&gt;&gt;&gt; foobar(1, 'b')(1, 'b', 3.2)&gt;&gt;&gt; foobar('a', 'b')...TypeError: Expected type &lt;class 'int'&gt; for argument a, but got type &lt;class 'str'&gt; with value 'a","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"}]},{"title":"Python-字符串","slug":"Python-字符串","date":"2020-04-27T03:06:19.000Z","updated":"2020-04-27T03:51:44.310Z","comments":true,"path":"2020/04/27/Python-字符串/","link":"","permalink":"http://forwardpeng.github.io/2020/04/27/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"split()分割字符串split() 方法可以实现将一个字符串按照指定的分隔符切分成多个子串，这些子串会被保存到列表中（不包含分隔符），作为方法的返回值反馈回来。该方法的基本语法格式如下：str.split(sep,maxsplit)此方法中各部分参数的含义分别是：str：表示要进行分割的字符串；sep：用于指定分隔符，可以包含多个字符。此参数默认为 None，表示所有空字符，包括空格、换行符“\\n”、制表符“\\t”等。maxsplit：可选参数，用于指定分割的次数，最后列表中子串的个数最多为 maxsplit+1。如果不指定或者指定为 -1，则表示分割次数没有限制。’ join()方法，合并字符串join() 方法的语法格式如下：newstr = str.join(iterable)此方法中各参数的含义如下：newstr：表示合并后生成的新字符串；str：用于指定合并时的分隔符；iterable：做合并操作的源字符串数据，允许以列表、元组等形式提供。 统计字符串出现的次数count 方法用于检索指定字符串在另一字符串中出现的次数，如果检索的字符串不存在，则返回 0，否则返回出现的次数。count方法的语法格式如下：str.count(sub[,start[,end]])此方法中，各参数的具体含义如下：str：表示原字符串；sub：表示要检索的字符串；start：指定检索的起始位置，也就是从什么位置开始检测。如果不指定，默认从头开始检索；end：指定检索的终止位置，如果不指定，则表示一直检索到结尾。12&gt;&gt;&gt; str = \"c.biancheng.net\"&gt;&gt;&gt; str.count('.') find()方法，检测字符串中是否包含某子串find() 方法的语法格式如下：str.find(sub[,start[,end]])此格式中各参数的含义如下：str：表示原字符串；sub：表示要检索的目标字符串；start：表示开始检索的起始位置。如果不指定，则默认从头开始检索；end：表示结束检索的结束位置。如果不指定，则默认一直检索到结尾。123456&gt;&gt;&gt; str.find('.') # 首次出现1&gt;&gt;&gt; str.find('.', 2) # 起始索引位置11&gt;&gt;&gt; str.find('.', 2,4) # 区间-1注意，Python 还提供了 rfind() 方法，与 find() 方法最大的不同在于，rfind()是从字符串右边开始检索。 index()方法：检测字符串中是否包含某子串index() 方法也可以用于检索是否包含指定的字符串，不同之处在于，当指定的字符串不存在时，index() 方法会抛出异常。index()方法的语法格式如下：str.index(sub[,start[,end]])此格式中各参数的含义分别是：str：表示原字符串；sub：表示要检索的子字符串；start：表示检索开始的起始位置，如果不指定，默认从头开始检索；end：表示检索的结束位置，如果不指定，默认一直检索到结尾。1234567&gt;&gt;&gt; str.index('z')Traceback (most recent call last): File \"&lt;pyshell#49&gt;\", line 1, in &lt;module&gt; str.index('z')ValueError: substring not found&gt;&gt;&gt; str.rindex('.')11 字符串对齐方法(ljust()、rjust()和center()) ljust()方法ljust() 方法的功能是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。ljust() 方法的基本格式如下：S.ljust(width[, fillchar])其中各个参数的含义如下：S：表示要进行填充的字符串；width：表示包括 S 本身长度在内，字符串要占的总长度；fillchar：作为可选参数，用来指定填充字符串时所用的字符，默认情况使用空格。1234567&gt;&gt;&gt; S = 'http://c.biancheng.net/python/'&gt;&gt;&gt; addr = 'http://c.biancheng.net'&gt;&gt;&gt; print(S.ljust(35))http://c.biancheng.net/python/ &gt;&gt;&gt; print(addr.ljust(35))http://c.biancheng.net # 该输出结果中除了明显可见的网址字符串外，其后还有空格字符存在，每行一共 35 个字符长度。 rjust()方法rjust() 和 ljust() 方法类似，唯一的不同在于，rjust() 方法是向字符串的左侧填充指定字符，从而达到右对齐文本的目的。rjust() 方法的基本格式如下：S.rjust(width[, fillchar])1234&gt;&gt;&gt; print(S.rjust(35)) http://c.biancheng.net/python/&gt;&gt;&gt; print(addr.rjust(35)) http://c.biancheng.net center()方法center() 字符串方法与 ljust() 和 rjust() 的用法类似，但它让文本居中，而不是左对齐或右对齐。center() 方法的基本格式如下：S.center(width[, fillchar])其中各个参数的含义和 ljust()、rjust()方法相同。 startswith()和endswith()方法 startswith()方法startswith() 方法用于检索字符串是否以指定字符串开头，如果是返回 True；反之返回 False。此方法的语法格式如下：str.startswith(sub[,start[,end]])此格式中各个参数的具体含义如下：str：表示原字符串；sub：要检索的子串；start：指定检索开始的起始位置索引，如果不指定，则默认从头开始检索；end：指定检索的结束位置索引，如果不指定，则默认一直检索在结束。123&gt;&gt;&gt; str = \"c.biancheng.net\"&gt;&gt;&gt; str.startswith(\"http\")False endswith()方法endswith() 方法用于检索字符串是否以指定字符串结尾，如果是则返回 True；反之则返回 False。该方法的语法格式如下：str.endswith(sub[,start[,end]])此格式中各参数的含义如下：str：表示原字符串；sub：表示要检索的字符串；start：指定检索开始时的起始位置索引（字符串第一个字符对应的索引值为 0），如果不指定，默认从头开始检索。end：指定检索的结束位置索引，如果不指定，默认一直检索到结束。 字符串大小写转换（3种）函数及用法 title()方法title() 方法用于将字符串中每个单词的首字母转为大写，其他字母全部转为小写，转换完成后，此方法会返回转换得到的字符串。如果字符串中没有需要被转换的字符，此方法会将字符串原封不动地返回。title()方法的语法格式如下：str.title()其中，str 表示要进行转换的字符串。123&gt;&gt;&gt; str = \"c.biancheng.net\"&gt;&gt;&gt; str.title()'C.Biancheng.Net' lower()方法lower() 方法用于将字符串中的所有大写字母转换为小写字母，转换完成后，该方法会返回新得到的字符串。如果字符串中原本就都是小写字母，则该方法会返回原字符串。lower() 方法的语法格式如下：str.lower() upper()方法upper() 的功能和 lower()方法恰好相反，它用于将字符串中的所有小写字母转换为大写字母，和以上两种方法的返回方式相同，即如果转换成功，则返回新字符串；反之，则返回原字符串。upper()方法的语法格式如下：str.upper() 去除字符串中空格（删除指定字符）的3种方法特殊字符，指的是制表符（\\t）、回车符（\\r）、换行符（\\n）等字符串变量提供了 3 种方法来删除字符串中多余的空格和特殊字符，它们分别是：strip()：删除字符串前后（左右两侧）的空格或特殊字符。lstrip()：删除字符串前面（左边）的空格或特殊字符。rstrip()：删除字符串后面（右边）的空格或特殊字符。 strip()方法strip() 方法用于删除字符串左右两个的空格和特殊字符，该方法的语法格式为：str.strip([chars])其中，str 表示原字符串，[chars] 用来指定要删除的字符，可以同时指定多个，如果不手动指定，则默认会删除空格以及制表符、回车符、换行符等特殊字符。 lstrip()方法lstrip() 方法用于去掉字符串左右的空格和特殊字符。该方法的语法格式如下：str.lstrip([chars])其中，str和chars参数的含义，分别同 strip()语法格式中的str和chars完全相同。123&gt;&gt;&gt; str = \" c.biancheng.net \\t\\n\\r\"&gt;&gt;&gt; str.lstrip()'c.biancheng.net \\t\\n\\r' rstrip()方法rstrip() 方法用于删除字符串右侧的空格和特殊字符，其语法格式为：str.rstrip([chars])str和chars参数的含义和前面2种方法语法格式中的参数完全相同。123&gt;&gt;&gt; str = \" c.biancheng.net \\t\\n\\r\"&gt;&gt;&gt; str.rstrip()' c.biancheng.net' format()格式化输出方法详解format()方法的语法格式如下：str.format(args)此方法中，str用于指定字符串的显示样式；args用于指定要进行格式转换的项，如果有多项，之间有逗号进行分割。使用{}和：来指定占位符，其完整的语法格式为：{ [index][ : [ [fill] align] [sign] [#] [width] [.precision] [type] ] }格式中用[]括起来的参数都是可选参数，即可以使用，也可以不使用。各个参数的含义如下：index：指定：后边设置的格式要作用到 args 中第几个数据，数据的索引值从 0 开始。如果省略此选项，则会根据 args 中数据的先后顺序自动分配。fill：指定空白处填充的字符。注意，当填充字符为逗号(,)且作用于整数或浮点数时，该整数（或浮点数）会以逗号分隔的形式输出，例如（1000000会输出 1,000,000）。align：指定数据的对齐方式，具体的对齐方式如下表所示。align含义&lt;数据左对齐&gt;数据右对齐=数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对数字类型有效。^数据居中，此选项需和 width 参数一起使用。sign：指定有无符号数，此参数的值以及对应的含义如下表：sign参数含义+正数前加正号，负数前加负号。-正数前不加正号，负数前加负号。空格正数前加空格，负数前加负号。#对于二进制数、八进制数和十六进制数，使用此参数，各进制数前会分别显示 0b、0o、0x前缀；反之则不显示前缀。width：指定输出数据时所占的宽度。.precision：指定保留的小数位数。type：指定输出数据的具体类型，如下表：type类型值含义s对字符串类型格式化。d十进制整数。c将十进制整数自动转换成对应的 Unicode 字符。e 或者 E转换成科学计数法后，再格式化输出。g 或 G自动在 e 和 f（或 E 和 F）中切换。b将十进制数自动转换成二进制表示，再格式化输出。o将十进制数自动转换成八进制表示，再格式化输出。x 或者 X将十进制数自动转换成十六进制表示，再格式化输出。f 或者 F转换为浮点数（默认小数点后保留 6 位），再格式化输出。%显示百分比（默认显示小数点后 6 位）。1234567891011&gt;&gt;&gt; print(\"货币形式：&#123;:,d&#125;\".format(1000000))货币形式：1,000,000&gt;&gt;&gt; #科学计数法表示... print(\"科学计数法：&#123;:E&#125;\".format(1200.12))科学计数法：1.200120E+03&gt;&gt;&gt; #以十六进制表示... print(\"100的十六进制：&#123;:#x&#125;\".format(100))100的十六进制：0x64&gt;&gt;&gt; #输出百分比形式... print(\"0.01的百分比表示：&#123;:.0%&#125;\".format(0.01))0.01的百分比表示：1% encode()和decode()方法：字符串编码转换Python 中，有2种常用的字符串类型，分别为str和 bytes 类型，其中 str 用来表示 Unicode 字符，bytes 用来表示二进制数据。str 类型和 bytes 类型之间就需要使用 encode() 和 decode() 方法进行转换。Python 3.x 默认采用 UTF-8 编码格式，有效地解决了中文乱码的问题。 encode()方法encode() 方法为字符串类型（str）提供的方法，用于将 str 类型转换成 bytes 类型，这个过程也称为“编码”。encode()方法的语法格式如下：str.encode([encoding=“utf-8”][,errors=“strict”])注意，格式中用 [] 括起来的参数为可选参数，也就是说，在使用此方法时，可以使用 [] 中的参数，也可以不使用。errors = &quot;strict&quot;指定错误处理方式，其可选择值可以是：strict：遇到非法字符就抛出异常。ignore：忽略非法字符。replace：用“？”替换非法字符。xmlcharrefreplace：使用 xml的字符引用。该参数的默认值为 strict。 decode()方法和 encode() 方法正好相反，decode() 方法用于将 bytes 类型的二进制数据转换为 str 类型，这个过程也称为“解码”。decode()方法的语法格式如下：bytes.decode([encoding=“utf-8”][,errors=“strict”]) dir()和help()帮助函数dir() 函数用来列出某个类或者某个模块中的全部内容，包括变量、方法、函数和类等，它的用法为：dir(obj)obj表示要查看的对象。obj 可以不写，此时 dir() 会列出当前范围内的变量、方法和定义的类型。Python help() 函数用来查看某个函数或者模块的帮助文档，它的用法为：help(obj)obj表示要查看的对象。obj可以不写，此时help()会进入帮助子程序。12345&gt;&gt;&gt; help(str.lower)Help on method_descriptor:lower(self, /) Return a copy of the string converted to lowercase.","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"}]},{"title":"Python-列表元组字典集合","slug":"Python-列表元组字典集合","date":"2020-04-25T07:35:14.000Z","updated":"2020-04-27T02:27:51.423Z","comments":true,"path":"2020/04/25/Python-列表元组字典集合/","link":"","permalink":"http://forwardpeng.github.io/2020/04/25/Python-%E5%88%97%E8%A1%A8%E5%85%83%E7%BB%84%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88/","excerpt":"","text":"介绍Python 序列（Sequence）是指按特定顺序依次排列的一组数据，它们可以占用一块连续的内存，也可以分散到多块内存中。Python 中的序列类型包括列表（list）、元组（tuple）、字典（dict）和集合（set）。在Python编程中，我们既需要独立的变量来保存一份数据，也需要序列来保存大量数据。列表（list）和元组（tuple）比较相似，它们都按顺序保存元素，所有的元素占用一块连续的内存，每个元素都有自己的索引，因此列表和元组的元素都可以通过索引（index）来访问。它们的区别在于：列表是可以修改的，而元组是不可修改的。字典（dict）和集合（set）存储的数据都是无序的，每份元素占用不同的内存，其中字典元素以 key-value的形式保存 Python序列详解（包括序列类型和常用操作）所谓序列，指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可通过每个值所在位置的编号（称为索引）访问它们。集合和字典不支持索引、切片、相加和相乘操作。字符串也是一种常见的序列，它也可以直接通过索引访问字符串内的字符。 序列索引序列中，每个元素都有属于自己的编号（索引）。从起始元素开始，索引值从 0 开始递增，如图1所示。图1 序列索引值示意图Python还支持索引值是负数，此类索引是从右向左计数，换句话说，从最后一个元素开始计数，从索引值 -1 开始，如图 2 所示。图2 负值索引示意图注意，在使用负值作为列序中各元素的索引值时，是从 -1 开始，而不是从 0 开始。 序列切片切片操作是访问序列中元素的另一种方法，它可以访问一定范围内的元素，通过切片操作，可以生成一个新的序列。语法格式：sname[start : end : step]其中，各个参数的含义如下：sname：表示序列的名称；start：表示切片的开始索引位置（包括该位置），此参数也可以不指定，会默认为 0，也就是从序列的开头进行切片；end：表示切片的结束索引位置（不包括该位置），如果不指定，则默认为序列的长度；step：表示在切片过程中，隔几个存储位置（包含当前位置）取一次元素，也就是说，如果step的值大于1，则在进行切片去序列元素时，会“跳跃式”的取元素。如果省略设置step的值，则最后一个冒号就可以省略。1234567&gt;&gt;&gt; str = \"Hello World\"&gt;&gt;&gt; print(str[:2])He&gt;&gt;&gt; print(str[::2])HloWrd&gt;&gt;&gt; print(str[:])Hello World 序列相加Python 中，支持两种类型相同的序列使用“+”运算符做相加操作，它会将两个序列进行连接，但不会去除重复的元素。这里所说的“类型相同”，指的是“+”运算符的两侧序列要么都是序列类型，要么都是元组类型，要么都是字符串。 序列相乘Python 中，使用数字 n 乘以一个序列会生成新的序列，其内容为原来序列被重复n次的结果。12&gt;&gt;&gt; print(str*3)Hello WorldHello WorldHello World 检查元素是否包含在序列中Python 中，可以使用 in 关键字检查某元素是否为序列的成员，其语法格式为：value in sequence 其中，value 表示要检查的元素，sequence 表示指定的序列。与in关键字用法相同，但功能恰好相反的，还有not in关键字，它用法检查某个元素是否不包含在指定的序列中1234&gt;&gt;&gt; print('W' in str)True&gt;&gt;&gt; print('W' not in str)False 序列相关的内置函数Python提供了几个内置函数，可用于实现与序列相关的一些常用操作，如下表：函数功能len()计算序列的长度，即返回序列中包含多少个元素。max()找出序列中的最大元素。注意，对序列使用 sum() 函数时，做加和操作的必须都是数字，不能是字符或字符串，否则该函数将抛出异常，因为解释器无法判定是要做连接操作（+ 运算符可以连接两个序列），还是做加和操作。min()找出序列中的最小元素list()将序列转换为列表str()将序列转换为字符串。sum()计算元素和。sorted()对元素进行排序。reversed()反向序列中的元素。enumerate()将序列组合为一个索引序列，多用在 for 循环中。 Python list列表详解列表可以存储整数、小数、字符串、列表、元组等任何类型的数据，并且同一个列表中元素的类型也可以不同在使用列表时，虽然可以将不同类型的数据放入到同一个列表中，但通常情况下不这么做，同一列表中只放入同一类型的数据，这样可以提高程序的可读性。 Python创建列表在 Python 中，创建列表的方法可分为两种：1.使用[]直接创建列表使用[ ]创建列表后，一般使用=将它赋值给某个变量，具体格式如下：listname = [element1 , element2 , element3 , … , elementn]其中，listname 表示变量名，element1 ~ elementn 表示列表元素。2.使用list()函数创建列表Python 还提供了一个内置的函数 list()，使用它可以将其它数据类型转换为列表类型。例如：1234567&gt;&gt;&gt; list1 = list('hello')&gt;&gt;&gt; print(list1)['h', 'e', 'l', 'l', 'o']&gt;&gt;&gt; dict1 = &#123;'a':100, 'b':42, 'c':9&#125;&gt;&gt;&gt; list2 = list(dict1)&gt;&gt;&gt; print(list2)['a', 'b', 'c'] 访问列表元素列表是 Python 序列的一种，我们可以使用索引（Index）访问列表中的某个元素（得到的是一个元素的值），也可以使用切片访问列表中的一组元素（得到的是一个新的子列表）。listname[i] #索引访问listname[start🔚step] # 切片访问 删除列表对于已经创建的列表，如果不再使用，可以使用del关键字将其删除。Python自带的垃圾回收机制会自动销毁无用的列表，即使不手动删除，Python也会自动将其回收。语法格式：del listname Python list列表添加元素 append()添加元素append() 方法用于在列表的末尾追加元素，该方法的语法格式如下：listname.append(obj)其中，listname 表示要添加元素的列表；obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等。1234567&gt;&gt;&gt; l = ['python','c++','java']&gt;&gt;&gt; l.append('php')&gt;&gt;&gt; l['python', 'c++', 'java', 'php']&gt;&gt;&gt; l.append(['Ruby','SQL'])&gt;&gt;&gt; l['python', 'c++', 'java', 'php', ['Ruby', 'SQL']] extend()方法添加元素extend() 和 append() 的不同之处在于：extend() 不会把列表或者元祖视为一个整体，而是把它们包含的元素逐个添加到列表中。语法格式如下：listname.extend(obj)1234&gt;&gt;&gt; t = ('JS', 'C#', 'Go')&gt;&gt;&gt; l.extend(t)&gt;&gt;&gt; print(l)['python', 'c++', 'java', 'php', ['Ruby', 'SQL'], 'JS', 'C#', 'Go'] insert()方法插入元素append()和extend()方法只能在列表末尾插入元素，如果希望在列表中间某个位置插入元素，那么可以使用 insert()方法。语法格式：listname.insert(index, obj)其中，index 表示指定位置的索引值。insert() 会将 obj 插入到 listname 列表第 index 个元素的位置。123456789&gt;&gt;&gt; l = ['Python', 'C++', 'Java']&gt;&gt;&gt; l['Python', 'C++', 'Java']&gt;&gt;&gt; l.insert(1, 'C')&gt;&gt;&gt; l['Python', 'C', 'C++', 'Java']&gt;&gt;&gt; l.insert(3, ['Ruby', 'SQL'])&gt;&gt;&gt; l['Python', 'C', 'C++', ['Ruby', 'SQL'], 'Java'] list列表删除元素(4种方法)在 Python 列表中删除元素主要分为以下 3 种场景：根据目标元素所在位置的索引进行删除，可以使用 del 关键字或者 pop() 方法；根据元素本身的值进行删除，可使用列表（list类型）提供的 remove() 方法；将列表中所有元素全部删除，可使用列表（list类型）提供的clear()方法。 del:根据索引值删除元素del 是 Python 中的关键字，专门用来执行删除操作，它不仅可以删除整个列表，还可以删除列表中的某些元素。语法格式如下：del listname[index] # index表示索引del listname[start:end] # 中间一段连续的元素 pop():根据索引值删除元素用于删除列表中指定索引处的元素，语法格式：listname.pop(index) #类似于数据结构中的“出栈”操作。1234567&gt;&gt;&gt; nums = [40,36,89,2,36,100,7]&gt;&gt;&gt; nums.pop(3)2&gt;&gt;&gt; nums.pop()7&gt;&gt;&gt; print(nums)[40, 36, 89, 36, 100] remove():根据元素值进行删除remove()方法只会删除第一个和指定值相同的元素，而且必须保证该元素是存在的，否则会引发ValueError错误。使用 remove() 删除元素时最好提前判断一下。 clear():删除列表所有元素用来删除列表的所有元素，也即清空列表。 list列表修改元素Python提供了两种修改列表（list）元素的方法，你可以每次修改单个元素，也可以每次修改一组元素（多个）。 修改单个元素修改单个元素非常简单，直接对元素赋值即可。实例如下：12345&gt;&gt;&gt; nums = [40,36,89,2,36,100,7]&gt;&gt;&gt; nums[2] = -26&gt;&gt;&gt; nums[-3] = 66.22&gt;&gt;&gt; print(nums)[40, 36, -26, 2, 66.22, 100, 7] 修改一组元素Python支持通过切片语法给一组元素赋值。在进行这种操作时，如果不指定步长（step 参数），Python就不要求新赋值的元素个数与原来的元素个数相同；这意味，该操作既可以为列表添加元素，也可以为列表删除元素。12345678910&gt;&gt;&gt; nums = [40,36,89,2,36,100,7]&gt;&gt;&gt; nums[1:4] = [45,25, -77, -52.5]&gt;&gt;&gt; print(nums)[40, 45, 25, -77, -52.5, 36, 100, 7]# 对空切片(slice)赋值，相当于插入一组新元素&gt;&gt;&gt; nums = [40,36,89,2,36,100,7]&gt;&gt;&gt; nums[4:4] = [-77, -52.5, 999]&gt;&gt;&gt; print(nums)[40, 36, 89, 2, -77, -52.5, 999, 36, 100, 7]# 使用切片语法赋值时，Python 不支持单个值 list列表查找元素Python 列表（list）提供了index()和count()方法，它们都可以用来查找元素。 index()方法index()方法用来查找某个元素在列表中出现的位置（也就是索引），如果该元素不存在，则会导致ValueError错误，所以在查找之前最好使用count()方法判断一下。语法格式：listname.index(obj, start, end)其中，listname表示列表名称，obj 表示要查找的元素，start表示起始位置，end表示结束位置。start和end参数用来指定检索范围：start和end可以都不写，此时会检索整个列表；如果只写start不写end，那么表示检索从start到末尾的元素；如果start和end都写，那么表示检索 start 和 end 之间的元素。index()方法会返回元素所在列表中的索引值。示例如下：1234567[40, 36, 89, 2, -77, -52.5, 999, 36, 100, 7]&gt;&gt;&gt; print(nums.index(100,3,))8&gt;&gt;&gt; print(nums.index(55))Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;ValueError: 55 is not in list count()方法count() 方法用来统计某个元素在列表中出现的次数，基本语法格式为：listname.count(obj)如果count()返回 0，就表示列表中不存在该元素，所以count()也可以用来判断列表中的某个元素是否存在。 Python tuple元组元组和列表（list）的不同之处在于：列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列；而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。语法格式：(element1, element2, … , elementn) 创建元组1.使用()直接创建通过( )创建元组后，一般使用=将它赋值给某个变量，具体格式为：tuplename = (element1, element2, …, elementn)需要注意的一点是，当创建的元组中只有一个字符串类型的元素时，该元素后面必须要加一个逗号,，否则 Python 解释器会将它视为字符串。2.使用tuple()函数创建tuple() 的语法格式如下：tuple(data) 访问元组元素使用索引访问元组元素的格式为：tuplename[i]其中，tuplename 表示元组名字，i 表示索引值。元组的索引可以是正数，也可以是负数。使用切片访问元组元素的格式为：tuplename[start : end : step]其中，start 表示起始索引，end 表示结束索引，step 表示步长。 修改元组组是不可变序列，元组中的元素不能被修改，所以我们只能创建一个新的元组去替代旧的元组。 删除元组使用del关键字删除元组 Python元组和列表的区别元组和列表最大的区别就是，列表中的元素可以进行任意修改；而元组中的元素无法修改，除非将元组整体替换掉。tuple元组是只读版本的list。123456&gt;&gt;&gt; listdemo = []&gt;&gt;&gt; listdemo.__sizeof__()40&gt;&gt;&gt; tupleDemo = ()&gt;&gt;&gt; tupleDemo.__sizeof__()24由于列表是动态的，它需要存储指针来指向对应的元素（占用 8 个字节）。另外，由于列表中元素可变，所以需要额外存储已经分配的长度大小（占用 8 个字节）。但是对于元组，情况就不同了，元组长度大小固定，且存储元素不可变，所以存储空间也是固定的。元组要比列表更加轻量级，所以从总体上来说，元组的性能速度要由于列表。另外，Python 会在后台，对静态数据做一些资源缓存。通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python 就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。但是对于一些静态变量（比如元组），如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样的话，当下次再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。元组的不可替代性体现在以下这些场景中：元组作为很多内置函数和序列类型方法的返回值存在，也就是说，在使用某些函数或者方法时，它的返回值会元组类型，因此你必须对元组进行处理。元组比列表的访问和处理速度更快，因此，当需要对指定元素进行访问，且不涉及修改元素的操作时，建议使用元组。元组可以在映射（和集合的成员）中当做“键”使用，而列表不行 Python dict字典详解Python字典（dict）是一种无序的、可变的序列，它的元素以“键值对（key-value）”的形式存储。相对地，列表（list）和元组（tuple）都是有序的序列，它们的元素在底层是挨着存放的。将各元素对应的索引称为键（key），各个键对应的元素称为值（value），键及其关联的值称为“键值对”。字典的主要特征如下表：主要特征解释通过键而不是通过索引来读取元素字典类型有时也称为关联数组或者散列表 （hash）。它是通过键将一系列的值联系起来的，这样就可以通过键从字典中获取指定项，但不能通过索引来获取。字典是任意数据类型的无序集合和列表、元组不同，通常会将索引值 0 对应的元素称为第一个元素，而字典中的元素是无序的。字典是可变的，并且可以任意嵌套字典可以在原处增长或者缩短（无需生成一个副本），并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其它的字典。字典中的键必须唯一字典中，不支持同一个键出现多次，否则只会保留最后一个键值对。字典中的键必须不可变字典中的值是不可变的，只能使用数字、字符串或者元组，不能使用列表。 Python创建字典1.使用{}创建字典由于字典中每个元素都包含两部分，分别是键（key）和值（value），因此在创建字典时，键和值之间使用冒号:分隔，相邻元素之间使用逗号,分隔，所有元素放在大括号{ }中。语法格式如下：dictname = {‘key’:‘value1’, ‘key2’:‘value2’,…,‘keyn’:‘vakyen’}其中dictname表示字典变量名，keyn :valuen表示各个元素的键值对。需要注意的是，同一字典中的各个键必须唯一，不能重复。123456&gt;&gt;&gt; scores = &#123;'数学': 95, '英语': 92, '语文': 84&#125;&gt;&gt;&gt; print(scores)&#123;'数学': 95, '英语': 92, '语文': 84&#125;&gt;&gt;&gt; dict1 = &#123;(20, 30): 'great', 30: [1,2,3]&#125;&gt;&gt;&gt; print(dict1)&#123;(20, 30): 'great', 30: [1, 2, 3]&#125;2.通过fromkeys()方法创建字典使用dict字典类型提供的fromkeys()方法创建带有默认值的字典，具体格式为：dictname = dict.fromkeys(list，value=None)1234&gt;&gt;&gt; knowledge = &#123;'语文', '数学', '英语'&#125;&gt;&gt;&gt; scores = dict.fromkeys(knowledge, 60)&gt;&gt;&gt; scores&#123;'英语': 60, '数学': 60, '语文': 60&#125;3.通过dict()映射函数创建字典创建格式注意事项a = dict(str1=value1, str2=value2, str3=value3)str 表示字符串类型的键，value 表示键对应的值。使用此方式创建字典时，字符串不能带引号。#方式1 demo = [(‘two’,2), (‘one’,1), (‘three’,3)]#方式2 demo = [[‘two’,2], [‘one’,1], [‘three’,3]]#方式3 demo = ((‘two’,2), (‘one’,1), (‘three’,3)) #方式4 demo = ([‘two’,2], [‘one’,1], [‘three’,3])a = dict(demo) 向 dict() 函数传入列表或元组，而它们中的元素又各自是包含 2 个元素的列表或元组，其中第一个元素作为键，第二个元素作为值。keys = [‘one’, ‘two’, ‘three’] #还可以是字符串或元组values = [1, 2, 3] #还可以是字符串或元组a = dict( zip(keys, values))通过应用 dict() 函数和 zip() 函数，可将前两个列表转换为对应的字典。无论采用以上哪种方式创建字典，字典中各元素的键都只能是字符串、元组或数字，不能是列表。列表是可变的，不能作为键。 访问字典列表和元组是通过下标来访问元素的，而字典不同，它通过键来访问对应的值。因为字典中的元素是无序的，每个元素的位置都不固定，所以字典也不能像列表和元组那样，采用切片的方式一次性访问多个元素。Python访问字典元素的具体格式为：dictname[key]其中，dictname 表示字典变量的名字，key 表示键名。注意，键必须是存在的，否则会抛出异常。除了上面这种方式外，Python更推荐使用dict类型提供的get()方法来获取指定键对应的值。当指定的键不存在时，get()方法不会抛出异常。12345678910111213&gt;&gt;&gt; tup = (['two',26], ['one',88], ['three',100], ['four',-59])&gt;&gt;&gt; dic = dict(tup)&gt;&gt;&gt; print(dic['one']) #键存在88&gt;&gt;&gt; print(dic['five']) #键不存在Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 'five'&gt;&gt;&gt; a = dict(two=0.65, one=88, three=100, four=-59)&gt;&gt;&gt; print( a.get('one') )88&gt;&gt;&gt; print( a.get('five', '该键不存在') )该键不存在 Python dict字典基本操作（包括添加、修改、删除键值对）由于字典属于可变序列，所以我们可以任意操作字典中的键值对（key-value）。Python 中，常见的字典操作有以下几种：向现有字典中添加新的键值对。修改现有字典中的键值对。从现有字典中删除指定的键值对。判断现有字典中是否存在指定的键值对。字典是由一个一个的key-value构成的，key是找到数据的关键，Python对字典的操作都是通过key来完成的。 Python字典添加键值对字典添加新的键值对很简单，直接给不存在的 key 赋值即可，具体语法格式如下：dictname[key] = value对各个部分的说明：dictname表示字典名称。key表示新的键。value表示新的值，只要是Python支持的数据类型都可以。1234567891011&gt;&gt;&gt; a = &#123;'数学':95&#125;&gt;&gt;&gt; print(a)&#123;'数学': 95&#125;&gt;&gt;&gt; #添加新键值对... a['语文'] = 89&gt;&gt;&gt; print(a)&#123;'数学': 95, '语文': 89&#125;&gt;&gt;&gt; #再次添加新键值对... a['英语'] = 90&gt;&gt;&gt; print(a)&#123;'数学': 95, '语文': 89, '英语': 90&#125; Python字典修改键值对Python 字典中键（key）的名字不能被修改，只能修改值（value）。字典中各元素的键必须是唯一的，因此，如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的。123&gt;&gt;&gt; a['语文'] = 100&gt;&gt;&gt; print(a)&#123;'数学': 95, '语文': 100, '英语': 90&#125; Python字典删除键值对删除字典中的键值对，使用del语句，如下：1234&gt;&gt;&gt; a = &#123;'数学': 95, '语文': 89, '英语': 90&#125;&gt;&gt;&gt; del a['语文']&gt;&gt;&gt; a&#123;'数学': 95, '英语': 90&#125; 判断字典中是否存在指定键值对先应判断字典中是否有对应的键。判断字典是否包含指定键值对的键，可以使用 in 或 not in 运算符。需要指出的是，对于 dict 而言，in 或 not in 运算符都是基于 key 来判断的。12&gt;&gt;&gt; print('物理' in a)False keys、values()和items()方法它们都用来获取字典中的特定数据：keys() 方法用于返回字典中的所有键（key）；values()方法用于返回字典中所有键对应的值（value）；items()用于返回字典中所有的键值对（key-value）。12345678910111213&gt;&gt;&gt; res = &#123;'数学': 95, '语文': 89, '英语': 90&#125;&gt;&gt;&gt; print(res.keys())dict_keys(['数学', '语文', '英语'])&gt;&gt;&gt; print(res.values())dict_values([95, 89, 90])&gt;&gt;&gt; print(res.items())dict_items([('数学', 95), ('语文', 89), ('英语', 90)])&gt;&gt;&gt; for k,v in res.items():... print(\"key:\",k,\" value:\",v)... key: 数学 value: 95key: 语文 value: 89key: 英语 value: 90 copy()方法copy()方法返回一个字典的拷贝，也即返回一个具有相同键值对的新字典1234&gt;&gt;&gt; a = &#123;'one': 1, 'two': 2, 'three': [1,2,3]&#125;&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; print(b)&#123;'one': 1, 'two': 2, 'three': [1, 2, 3]&#125;注意，copy() 方法所遵循的拷贝原理，既有深拷贝，也有浅拷贝。拿拷贝字典a为例，copy()方法只会对最表层的键值对进行深拷贝，也就是说，它会再申请一块内存用来存放 {‘one’: 1, ‘two’: 2, ‘three’: []}；而对于某些列表类型的值来说，此方法对其做的是浅拷贝，也就是说，b 中的 [1,2,3] 的值不是自己独有，而是和a共有。123456789101112&gt;&gt;&gt; a = &#123;'one': 1, 'two': 2, 'three': [1,2,3]&#125;&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; a['four']=100&gt;&gt;&gt; print(a)&#123;'one': 1, 'two': 2, 'three': [1, 2, 3], 'four': 100&#125;&gt;&gt;&gt; print(b)&#123;'one': 1, 'two': 2, 'three': [1, 2, 3]&#125;&gt;&gt;&gt; a['three'].remove(1)&gt;&gt;&gt; print(a)&#123;'one': 1, 'two': 2, 'three': [2, 3], 'four': 100&#125;&gt;&gt;&gt; print(b)&#123;'one': 1, 'two': 2, 'three': [2, 3]&#125; update()方法update() 方法可以使用一个字典所包含的键值对来更新己有的字典。在执行 update() 方法时，如果被更新的字典中己包含对应的键值对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的键值对，则该键值对被添加进去。1234&gt;&gt;&gt; a = &#123;'one': 1, 'two': 2, 'three': 3&#125;&gt;&gt;&gt; a.update(&#123;'one':4.5, 'four':9.3&#125;)&gt;&gt;&gt; a&#123;'one': 4.5, 'two': 2, 'three': 3, 'four': 9.3&#125; pop()hepopitem()方法pop() 和 popitem() 都用来删除字典中的键值对，不同的是，pop() 用来删除指定的键值对，而 popitem() 用来随机删除一个键值对，它们的语法格式如下：dictname.pop(key)dictname.popitem()12345678910&gt;&gt;&gt; a = &#123;'数学': 95, '语文': 89, '英语': 90, '化学': 83, '生物': 98, '物理': 89&#125;&gt;&gt;&gt; print(a)&#123;'数学': 95, '语文': 89, '英语': 90, '化学': 83, '生物': 98, '物理': 89&#125;&gt;&gt;&gt; a.pop('化学')83&gt;&gt;&gt; print(a)&#123;'数学': 95, '语文': 89, '英语': 90, '生物': 98, '物理': 89&#125;&gt;&gt;&gt; a.popitem()('物理', 89)&gt;&gt;&gt; print(a)&#123;'数学': 95, '语文': 89, '英语': 90, '生物': 98&#125;键值对在底层也是有存储顺序的，popitem() 总是弹出底层中的最后一个 key-value setdefault()方法setdefault()方法用来返回某个key对应的value，其语法格式如下：dictname.setdefault(key, defaultvalue)1234567891011121314151617&gt;&gt;&gt; a = &#123;'数学': 95, '语文': 89, '英语': 90&#125;&gt;&gt;&gt; print(a)&#123;'数学': 95, '语文': 89, '英语': 90&#125;&gt;&gt;&gt; #key不存在，指定默认值... a.setdefault('物理', 94)94&gt;&gt;&gt; print(a)&#123;'数学': 95, '语文': 89, '英语': 90, '物理': 94&#125;&gt;&gt;&gt; #key不存在，不指定默认值... a.setdefault('化学')&gt;&gt;&gt; print(a)&#123;'数学': 95, '语文': 89, '英语': 90, '物理': 94, '化学': None&#125;&gt;&gt;&gt; #key存在，指定默认值... a.setdefault('数学', 100)95&gt;&gt;&gt; print(a)&#123;'数学': 95, '语文': 89, '英语': 90, '物理': 94, '化学': None&#125; 使用字典格式化字符串在字符串模板中按 key 指定变量，然后通过字典为字符串模板中的 key 设置值。举例如下：1234&gt;&gt;&gt; temp = '教程是:%(name)s, 价格是:%(price)010.2f, 出版社是:%(publish)s'&gt;&gt;&gt; book = &#123;'name':'Python基础教程', 'price': 99, 'publish': 'C语言中文网'&#125;&gt;&gt;&gt; print(temp % book)教程是:Python基础教程, 价格是:0000099.00, 出版社是:C语言中文网 Python set集合详解Python 中的集合，和数学中的集合概念一样，用来保存不重复的元素，即集合中的元素都是唯一的，互不相同。Python 集合会将所有元素放在一对大括号 {} 中，相邻元素之间用“,”分隔，如下所示：{element1,element2,…,elementn}同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型。数据必须保证是唯一的，因为集合对于每种数据元素，只会保留一份。 Python 中的 set 集合是无序的，所以每次输出时元素的排序顺序可能都不相同。其实，Python 中有两种集合类型，一种是set类型的集合，另一种是 frozenset类型的集合，它们唯一的区别是，set类型集合可以做添加、删除元素的操作，而forzenset类型集合不行。 创建set集合Python 提供了 2 种创建 set 集合的方法，分别是使用 {} 创建和使用 set() 函数将列表、元组等类型数据转换为集合。1.使用 {} 创建在 Python 中，创建 set 集合可以像列表、元素和字典一样，直接将集合赋值给变量，从而实现创建集合的目的，其语法格式如下：setname = {element1,element2,…,elementn}其中，setname 表示集合的名称，起名时既要符合 Python 命名规范，也要避免与 Python 内置函数重名。2.set()函数创建集合set() 函数为 Python 的内置函数，其功能是将字符串、列表、元组、range 对象等可迭代对象转换成集合。该函数的语法格式如下：setname = set(iteration)如果要创建空集合，只能使用 set() 函数实现。因为直接使用一对 {}，Python 解释器会将其视为一个空字典。123456&gt;&gt;&gt; set2 = set([1,2,3,4,5])&gt;&gt;&gt; set3 = set((1,2,3,4,5))&gt;&gt;&gt; print(\"set2:\",set2)set2: &#123;1, 2, 3, 4, 5&#125;&gt;&gt;&gt; print(\"set3:\",set3)set3: &#123;1, 2, 3, 4, 5&#125; 访问set集合元素由于集合中的元素是无序的，因此无法向列表那样使用下标访问元素。Python 中，访问集合元素最常用的方法是使用循环结构，将集合中的数据逐一读取出来。 删除set集合手动函数集合类型，使用del()语句删除。 Python set集合基本操作（添加、删除、交集、并集、差集）常用的操作是向集合中添加、删除元素，以及集合之间做交集、并集、差集等运算。 向set集合中添加元素set集合添加元素，使用set类型提供的add()方法实现，语法格式：setname.add(element)其中，setname表示添加元素的集合，element表示要添加的元素内容。使用 add() 方法添加的元素，只能是数字、字符串、元组或者布尔类型（True 和 False）值，不能添加列表、字典、集合这类可变的数据，否则 Python 解释器会报 TypeError 错误。 set集合中删除元素删除现有 set 集合中的指定元素，可以使用 remove() 方法，该方法的语法格式如下：setname.remove(element) set集合做交集、并集、差集运算集合最常做的操作就是进行交集、并集、差集以及对称差集运算。运算操作Python运算符含义例子交集&amp;取两集合公共的元素&gt;&gt;&gt; set1 &amp; set2{3}并集|取两集合全部的元素&gt;&gt;&gt; set1{1,2,3,4,5}差集-取一个集合中另一集合没有的元素&gt;&gt;&gt; set1 - set2 {1,2} &gt;&gt;&gt; set2 - set1对称差集^取集合 A 和 B 中不属于 A&amp;B 的元素&gt;&gt;&gt; set1 ^ set2 {1,2,4,5}","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"}]},{"title":"Python-变量类型和运算符","slug":"Python-变量类型和运算符","date":"2020-04-24T12:25:38.000Z","updated":"2020-04-25T07:19:18.309Z","comments":true,"path":"2020/04/24/Python-变量类型和运算符/","link":"","permalink":"http://forwardpeng.github.io/2020/04/24/Python-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"Python变量的定义和使用变量保存的数据可以被多次修改，而常量一旦保存某个数据之后就不能修改了。 Python变量的赋值将数据放入变量的过程叫做赋值（Assignment）。Python使用等号=作为赋值运算符，具体格式为：name = valuename表示变量名；value表示值，也就是要存储的数据。注意，变量是标识符的一种，它的名字不能随便起，要遵守Python标识符命名规范，还要避免和Python内置函数以及Python保留字重名。 Python变量的使用使用 Python 变量时，只要知道变量的名字即可。几乎在Python代码的任何地方都能使用变量。12345678910&gt;&gt;&gt; print(n) #将变量传递给函数10&gt;&gt;&gt; m = n * 10 + 5 #将变量作为四则运算的一部分&gt;&gt;&gt; print(m)105&gt;&gt;&gt; print(m-30) #将由变量构成的表达式作为参数传递给函数75&gt;&gt;&gt; m = m * 2 #将变量本身的值翻倍&gt;&gt;&gt; print(m)210 Python是弱类型的语言C语言、C++、Java 是强类型语言的代表。和强类型语言相对应的是弱类型语言，Python、JavaScript、PHP 等脚本语言一般都是弱类型的。弱类型语言有两个特点：变量无须声明就可以直接赋值，对一个不存在的变量赋值就相当于定义了一个新变量。变量的数据类型可以随时改变，比如，同一个变量可以一会儿被赋值为整数，一会儿被赋值为字符串。 Python整数类型(int)详解整数就是没有小数部分的数字，Python中的整数包括正整数、0和负整数。有些强类型的编程语言会提供多种整数类型，每种类型的长度都不同，能容纳的整数的大小也不同，开发者要根据实际数字的大小选用不同的类型。例如C语言提供了short、int、long、long long四种类型的整数，它们的长度依次递增，初学者在选择整数类型时往往比较迷惑，有时候还会导致数值溢出。而Python则不同，它的整数不分类型，或者说它只有一种类型的整数。Python整数的取值范围是无限的，不管多大或者多小的数字，Python 都能轻松处理。当所用数值超过计算机自身的计算能力时，Python 会自动转用高精度计算（大数计算）。 整数的不同进制十进制形式：使用十进制形式的整数不能以 0 作为开头，除非这个数值本身就是 0。二进制形式：由0和1两个数字组成，书写时以0b或0B开头。例如，101对应十进制数是5。八进制：八进制整数由0~7共八个数字组成，以0o或0O开头。注意，第一个符号是数字 0，第二个符号是大写或小写的字母 O。十六进制形式：由 0~9 十个数字以及 A~F（或 a~f）六个字母组成，书写时以0x或0X开头。 数字分隔符Python 3.x 允许使用下划线_作为数字（包括整数和小数）的分隔符。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。下划线不会影响数字本身的值。 Python小数／浮点数(float)类型详解小数通常以浮点数的形式存储。浮点数和定点数是相对的：小数在存储过程中如果小数点发生移动，就称为浮点数；如果小数点不动，就称为定点数。Python中的小数有两种书写形式：十进制形式：平时看到的小数形式，例如 34.6、346.0、0.346。书写小数时必须包含一个小数点，否则会被Python当作整数处理。指数形式：小数的指数形式为aEn或aen，a为尾数部分，是一个十进制数；n为指数部分，是一个十进制整数；E或e是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于a×10na×10^{n}a×10n。举例：2.1E5=2.1×105，其中2.1是尾数，5是指数。3.7E-2 = 3.7×10-2，其中3.7是尾数，-2是指数。0.5E7=0.5×107，其中 0.5是尾数，7是指数。Python 只有一种小数类型，就是 float。C语言有两种小数类型，分别是 float 和 double：float 能容纳的小数范围比较小，double 能容纳的小数范围比较大。123456789101112131415&gt;&gt;&gt; f1 = 12.5&gt;&gt;&gt; print('f1Value:', f1)f1Value: 12.5&gt;&gt;&gt; print('f1Type:', type(f1))f1Type: &lt;class 'float'&gt;&gt;&gt;&gt; f5 = 12e4&gt;&gt;&gt; print(\"f5Value: \", f5)f5Value: 120000.0&gt;&gt;&gt; print(\"f5Type: \", type(f5))f5Type: &lt;class 'float'&gt;&gt;&gt;&gt; f6 = 12.3 * 0.1&gt;&gt;&gt; print(\"f6Value: \", f6)f6Value: 1.2300000000000002&gt;&gt;&gt; print(\"f6Type: \", type(f6))f6Type: &lt;class 'float'&gt; 为什么Python浮点类型存在误差主要还是因浮点数在计算机中实际是以二进制保存的，有些数不精确。比如说: 0.1是十进制，转化为二进制后它是个无限循环的数：0.00011001100110011001100110011001100110011001100110011001100而python是以双精度(64)位来保存浮点数，多余的位会被截掉，所以看到的是0.1，但在电脑上实际保存的已不是精确的0.1，参与运算后，也就有可能点误差。12345# 解决方法 from decimal import *a = Decimal('4.2')b = Decimal('2.1')c = a * b Python复数类型(complex)详解复数由实部（real）和虚部（imag）构成，在Python中，复数的虚部以j或者J作为后缀，具体格式为：a + bj # a表示实部，b表示虚部。 Python字符串详解（包含长字符串和原始字符串）字符串必须由双引号&quot; &quot;或者单引号’ '包围，具体格式为：“字符串内容”‘字符串内容’字符串的内容可以包含字母、标点、特殊符号、中文、日文等全世界的所有文字。字符串中的双引号和单引号没有任何区别，而有些编程语言的双引号字符串可以解析变量，单引号字符串一律原样输出。 处理字符串中的引号当字符串内容中出现引号时，我们需要进行特殊处理，否则Python会解析出错，处理方案如下：1.对引号进行转义在引号前面添加反斜杠\\就可以对引号进行转义，让 Python 把它作为普通文本对待，例如：123456&gt;&gt;&gt; str1 = 'I\\'m a great Person'&gt;&gt;&gt; print(str1)I'm a great Person&gt;&gt;&gt; str2 = \"引文双引号是\\\",中文双引号是\"&gt;&gt;&gt; print(str2)引文双引号是\",中文双引号是2.使用不同的引号包围字符串字符串内容中出现了单引号，那么我们可以使用双引号包围字符串，反之亦然。123&gt;&gt;&gt; str1 = \"I'm a great coder!\"&gt;&gt;&gt; print(str1)I'm a great coder! 字符串的换行Python 不是格式自由的语言，它对程序的换行、缩进都有严格的语法要求。要想换行书写一个比较长的字符串，必须在行尾添加反斜杠\\，ｐｙｔｈｏｎ也支持表达式的换行。12345&gt;&gt;&gt; s2 = \"It took six months to writer \\... Please give me more support. \\... I will keep !\"&gt;&gt;&gt; print(s2)It took six months to writer Please give me more support. I will keep ! Python原始字符串为了解决转义字符的问题，Python 支持原始字符串。在原始字符串中，\\不会被当作转义字符，所有的内容都保持“原汁原味”的样子。在普通字符串或者长字符串的开头加上r前缀，就变成了原始字符串，具体格式为：str1 = r’原始字符串内容’str2 = r&quot;&quot;“原始字符串内容”&quot;&quot;123&gt;&gt;&gt; str1 = r'I\\'m a great coder!'&gt;&gt;&gt; print(str1)I\\'m a great coder!Python 原始字符串中的反斜杠仍然会对引号进行转义，因此原始字符串的结尾处不能是反斜杠，否则字符串结尾处的引号会被转义，导致字符串不能正确结束。在 Python 中有两种方式解决这个问题：一种方式是改用长字符串的写法，不要使用原始字符串；另一种方式是单独书写反斜杠。123&gt;&gt;&gt; str1 = r'D:\\Program Files\\Python 3.8' '\\\\'&gt;&gt;&gt; print(str1)D:\\Program Files\\Python 3.8\\ 编码格式ASCII码，全称为美国信息交换标准代码，是基于拉丁字母的一套字符编码，主要用于显示现代英语，因为万维网的出现，使得 ASCII码广为使用，其直到2007年12月才逐渐被Unicode取代。nicode字符集可以使用的编码方案有三种，分别是：UTF-8：一种变长的编码方案，使用1~6个字节来存储；UTF-32：一种固定长度的编码方案，不管字符编号大小，始终使用4个字节来存储；UTF-16：介于UTF-8和UTF-32之间，使用2个或者4个字节来存储，长度既固定又可变。 Python使用的字符编码Ｐython3.x中，字符串采用的是Unicode字符集，可以用如下代码来查看当前环境的编码格式：123456789101112&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getdefaultencoding()'utf-8'# 使用ord()和chr()函数实现字符和编码数字之间的转换&gt;&gt;&gt; ord('Q')81&gt;&gt;&gt; chr(81)'Q'&gt;&gt;&gt; ord(\"网\")32593&gt;&gt;&gt; chr(32593)'网'虽然Python默认采用UTF-8编码，但它也提供了encode()方法，可以轻松实现将Unicode编码格式的字符串转化为其它编码格式。 Bytes类型及其用法字节串（bytes）和字符串（string）的对比：字符串由若干个字符组成，以字符为单位进行操作；字节串由若干个字节组成，以字节为单位进行操作。字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法都基本相同。字节串和字符串都是不可变序列，不能随意增加和删除数据。bytes只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。如果字符串的内容都是ASCII字符，那么直接在字符串前面添加b前缀就可以转换成 bytes。bytes是一个类，调用它的构造方法，也就是bytes()，可以将字符串按照指定的字符集转换成bytes；如果不指定字符集，那么默认采用UTF-8。字符串本身有一个encode()方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8。123&gt;&gt;&gt; b5 = \"个人博客\".encode('UTF-8')&gt;&gt;&gt; print(b5)b'\\xe4\\xb8\\xaa\\xe4\\xba\\xba\\xe5\\x8d\\x9a\\xe5\\xae\\xa2' Python bool布尔类型Python提供了bool 类型来表示真（对）或假（错），比如常见的5&gt;3比较算式，这个是正确的，在程序世界里称之为真（对），Python 使用 True 来代表；再比如4 &gt; 20比较算式，这个是错误的，在程序世界里称之为假（错），Python 使用 False 来代表。 Python的缓存重用机制Python 缓冲机制是为提高程序执行的效率服务的，实际上就是在 Python 解释器启动时从内存空间中开辟出一小部分，用来存储高频使用的数据，这样可以大大减少高频使用的数据创建时申请内存和销毁时撤销内存的开销。Python 在存储数据时，会根据数据的读取频繁程度以及内存占用情况来考虑，是否按照一定的规则将数据存储缓存中。那么问题来了，内存重用机制适用于哪些基本数据类型呢？数据类型是否可以重用生效范围范围在[-5,256]之间的小整数如果之前在程序中创建过，就直接存入缓存，后续不再创建。全局bool类型字符串类型数据大于 256 的整数只要在本代码块内创建过，就直接缓存，后续不再创建。本代码块大于0的浮点型小数小于0的浮点型小数不进行缓存，每次都需要额外创建。小于 -5 的整数12345678910&gt;&gt;&gt; #范围在 [-5, 256] 之间的小整数... int1 = -5&gt;&gt;&gt; int2 = -5&gt;&gt;&gt; print(\"[-5, 256] 情况下的两个变量：\", id(int1), id(int2))[-5, 256] 情况下的两个变量： 10914304 10914304&gt;&gt;&gt; #bool类型... bool1 = True&gt;&gt;&gt; bool2 = True&gt;&gt;&gt; print(\"bool类型情况下的两个变量：\",id(bool1),id(bool2))bool类型情况下的两个变量： 10302848 10302848 Python input()函数：获取用户输入的字符串input() 函数的用法为：str = input(tipmsg)说明：str 表示一个字符串类型的变量，input 会将读取到的字符串放入 str 中。tipmsg 表示提示信息，它会显示在控制台上，告诉用户应该输入什么样的内容；如果不写 tipmsg，就不会有任何提示信息。可以使用 Python 内置函数将字符串转换成想要的类型，比如：int(string) 将字符串转换成 int 类型；float(string) 将字符串转换成 float 类型；bool(string) 将字符串转换成 bool 类型。 Print()函数的高级用法使用 print() 函数时，都只输出了一个变量，但实际上 print() 函数完全可以同时输出多个变量，而且它具有更多丰富的功能。详细语法格式如下：print (value,…,sep=’’,end=’\\n’,file=sys.stdout,flush=False)value 参数可以接受任意多个变量或值，因此 print() 函数完全可以输出多个值。例如如下代码：12345678910&gt;&gt;&gt; user_name='Charlie'&gt;&gt;&gt; user_age = 8&gt;&gt;&gt; print(\"读者名：\",user_name,\"年龄：\",user_age)读者名： Charlie 年龄： 8# 指定分隔符&gt;&gt;&gt; print(\"读者名：\",user_name,\"年龄：\",user_age, sep='|')读者名：|Charlie|年龄：|8#设置end 参数，指定输出之后不再换行&gt;&gt;&gt; print(40,'\\t',end=\"\")40 &gt;&gt;&gt;file 参数指定 print() 函数的输出目标，file 参数的默认值为 sys.stdout，该默认值代表了系统标准输出，也就是屏幕，因此 print() 函数默认输出到屏幕。1234f = open(\"./demo.txt\", \"w\")print('沧海月明珠有泪', file=f)print('蓝回日暖玉生烟', file=f)f.close() Python格式化字符串print() 函数使用以%开头的转换说明符对各种类型的数据进行格式化输出。转换说明符解释%d、%i转换为带符号的十进制整数%o转换为带符号的八进制整数%x、%X转换为带符号的十六进制整数%e转化为科学计数法表示的浮点数（e 小写）%E转化为科学计数法表示的浮点数（E 大写）%f、%F转化为十进制浮点数%g智能选择使用 %f 或 %e 格式%G智能选择使用 %F 或 %E 格式%c格式化字符及其 ASCII 码%r使用 repr() 函数将表达式转换为字符串%s使用 str() 函数将表达式转换为字符串 指定最小输出宽度当使用表1中的转换说明符时，可以使用下面的格式指定最小输出宽度（至少占用多少个字符的位置）：%10d 表示输出的整数宽度至少为 10；%20s 表示输出的字符串宽度至少为 20。12345&gt;&gt;&gt; n = 1234567&gt;&gt;&gt; print(\"n(10):%10d.\" % n)n(10): 1234567.&gt;&gt;&gt; print(\"n(5):%5d.\" % n)n(5):1234567. 指定对齐方式默认情况下，print()输出的数据总是右对齐的。也就是说，当数据不够宽时，数据总是靠右边输出，而在左边补充空格以达到指定的宽度。Python 允许在最小宽度之前增加一个标志来改变对齐方式，Python 支持的标志如下：标志说明-指定左对齐+表示输出的数字总要带着符号；整数带+，负数带-。0表示宽度不足时补充 0，而不是补充空格。说明：对于整数，指定左对齐时，在右边补0是没有效果的，因为这样会改变整数的值。对于小数，以上三个标志可以同时存在。对于字符串，只能使用-标志，因为符号对于字符串没有意义，而补0会改变字符串的值。1234567891011&gt;&gt;&gt; n = 123456&gt;&gt;&gt; print(\"n(09):%09d\" % n)n(09):000123456&gt;&gt;&gt; print(\"n(+9):%+9d\" % n)n(+9): +123456&gt;&gt;&gt; f = 140.5&gt;&gt;&gt; print(\"f(-+0):%-+010f\" % f)f(-+0):+140.500000&gt;&gt;&gt; s = \"Hello\"&gt;&gt;&gt; print(\"s(-10):%-10s.\" % s)s(-10):Hello . 指定小数精度对于小数（浮点数），print() 还允许指定小数点后的数字位数，也即指定小数的输出精度。精度值需要放在最小宽度之后，中间用点号.隔开；也可以不写最小宽度，只写精度。具体格式如下：%m.nf %.nf # m表示最小宽度，n表示输出精度，.是必须存在的。1234567&gt;&gt;&gt; f = 3.141592653&gt;&gt;&gt; print(\"%8.3f\" % f) 3.142&gt;&gt;&gt; print(\"%08.3f\" % f)0003.142&gt;&gt;&gt; print(\"%+08.3f\" % f)+003.142 转义字符及用法ASCII 编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能用转义字符的形式来表示。不过，直接使用ASCII 码记忆不方便，也不容易理解，所以，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下。转义字符说明\\n换行符，将光标位置移到下一行开头\\r回车符，将光标位置移到本行开头\\t水平制表符，Tab键，相当于四个空格\\b退格（Backspace），将光标位置移到前一列\\反斜线’单引号&quot;双引号\\在字符串行尾的续行符，即一行未完，转到下一行继续写。 Python数据类型转换Python 已经为我们提供了多种可实现数据类型转换的函数，如下表：函数作用int(x)将x转换成整数类型float(x)将x转换成浮点数类型complex(real, [,image])创建一个复数str(x)将x转换成字符串repr(x)将x转换为表达式字符串eval(str)计算在字符串中的有效 Python 表达式，并返回一个对象chr(x)将整数x转换为一个字符ord(x)将一个字符x转换为它对应的整数值hex(x)将一个整数x转换为一个十六进制字符串oct(x)将一个整数 x 转换为一个八进制的字符串 Python算术运算符及用法详解算术运算符也即数学运算符，用来对数字进行数学运算，比如加减乘除。下表列出了 Python 支持所有基本算术运算符。运算符说明实例结果+加12.45+1527.45-减4.56-0.264.3*乘5*3.618.0/除法7/23.5//整除7//23%取余7%21**幂运算/次方运算，即返回 x 的 y 次方2**416，即242^{4}24 Python赋值运算符赋值运算符用来把右侧的值传递给左侧的变量（或者常量）；可以直接将右侧的值交给左侧的变量，也可以进行某些运算后再交给左侧的变量，比如加减乘除、函数调用、逻辑运算等。= 和 == 是两个不同的运算符，= 用来赋值，而 == 用来判断两边的值是否相等，千万不要混淆。Python扩展赋值运算符如下表： Python位运算符Python 位运算按照数据在内存中的二进制位（Bit）进行操作，它一般用于底层开发（算法设计、驱动、图像处理、单片机等），在应用层开发（Web 开发、Linux 运维等）中并不常见。Python 支持的位运算符如下表所示。位运算符说明使用形式举例&amp;按位与a&amp;b4&amp;5|按位或a|b4|5^按位异或a^b4^5~按位取反~a~4&lt;&lt;按位左移a&lt;&lt;b4&lt;&lt;2表示整数4按位左移2位&gt;&gt;按位右移a&gt;&gt;b4 &gt;&gt; 2，表示整数 4 按位右移 2 位 Python比较运算符比较运算符，也称关系运算符，用于对常量、变量或表达式的结果进行大小比较。如果这种比较是成立的，则返回True（真），反之则返回False（假）。支持的比较运算符如表所示：比较运算符 说明&gt;大于，如果&gt;前面的值大于后面的值，则返回 True，否则返回 False。&lt;小于，如果&lt;前面的值小于后面的值，则返回 True，否则返回 False。==等于，如果==两边的值相等，则返回 True，否则返回 False。&gt;=大于等于（等价于数学中的 ≥），如果&gt;=前面的值大于或者等于后面的值，则返回 True，否则返回 False。&lt;=小于等于（等价于数学中的 ≤），如果&lt;=前面的值小于或者等于后面的值，则返回 True，否则返回 False。!=不等于（等价于数学中的 ≠），如果!=两边的值不相等，则返回 True，否则返回 False。is判断两个变量所引用的对象是否相同，如果相同则返回 True，否则返回 False。is not判断两个变量所引用的对象是否不相同，如果不相同则返回 True，否则返回 False。123456import time #引入time模块t1 = time.gmtime() # gmtime()用来获取当前时间t2 = time.gmtime()print(t1 == t2) #输出Trueprint(t1 is t2) #输出False# t1与t2值相等，但是两个不同的对象 Python的逻辑运算符及其用法常用逻辑运算符及功能如下：逻辑运算符含义基本格式说明and逻辑与运算，等价于数学中的“且”a and b当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。or逻辑或运算，等价于数学中的“或”a or b当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。not逻辑非运算，等价于数学中的“非”not a如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。Python 逻辑运算符用于操作 bool 类型的表达式，执行结果也是 bool 类型，这两点其实都是错误的！实例如下：123456&gt;&gt;&gt; print(100 and 200)200&gt;&gt;&gt; print(45 and 0)0&gt;&gt;&gt; print(\"\" or \"http://forwardpeng.club/\")http://forwardpeng.club/ 逻辑运算符本质在Python中，and 和or不一定会计算右边表达式的值，有时候只计算左边表达式的值就能得到最终结果。另外，and和or运算符会将其中一个表达式的值作为最终结果，而不是将 True 或者 False 作为最终结果。对于 and 运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 Python 按照下面的规则执行 and 运算：如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时 and 会把左边表达式的值作为最终结果。如果左边表达式的值为真，那么最终值是不能确定的，and 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。对于 or 运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以 Python 按照下面的规则执行 or 运算：如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时 or 会把左边表达式的值作为最终结果。如果左边表达式的值为假，那么最终值是不能确定的，or 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。 Python 三目运算符用法详解if else 实现三目运算符（条件运算符）的格式如下：exp1 if contion else exp2Python三目运算符支持嵌套，如此可以构成更加复杂的表达式。在嵌套时需要注意 if和else的配对，如下：a if a&gt;b else c if c&gt;d else d Python运算符优先级和结合性Python 支持几十种运算符，被划分成将近二十个优先级，有的运算符优先级不同，有的运算符优先级相同，请看下表。虽然 Python 运算符存在优先级的关系，但不推荐过度依赖运算符的优先级，建议：不要把一个表达式写得过于复杂，如果一个表达式过于复杂，可以尝试把它拆分来书写。不要过多地依赖运算符的优先级来控制表达式的执行顺序，这样可读性太差，应尽量使用( )来控制表达式的执行顺序。 运算符结合性结合性，就是当一个表达式中出现多个优先级相同的运算符时，先执行哪个运算符：先执行左边的叫左结合性，先执行右边的叫右结合性。如：100 / 25 * 16，/和*都具有左结合性，因此先执行左边的除法，再执行右边的乘法，最终结果是64。Python中大部分运算符都具有左结合性，也就是从左到右执行；只有单目运算符（例如 not 逻辑非运算符）、赋值运算符和三目运算符例外，它们具有右结合性，也就是从右向左执行。表 1 中列出了所有 Python 运算符的结合性。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"}]},{"title":"Python-基础","slug":"Python-基础","date":"2020-04-24T08:50:45.000Z","updated":"2020-04-24T12:20:25.520Z","comments":true,"path":"2020/04/24/Python-基础/","link":"","permalink":"http://forwardpeng.github.io/2020/04/24/Python-%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Python注释Python 支持两种类型的注释，分别是单行注释和多行注释。 Python单行注释Python使用井号#作为单行注释的符号，语法格式为：#注释内容从井号#开始，直到这行结束为止的所有内容都是注释。Python 解释器遇到#时，会忽略它后面的整行内容。 Python多行注释多行注释指的是一次性注释程序中多行的内容（包含一行）。Python 使用三个连续的单引号’’'或者三个连续的双引号&quot;&quot;&quot;注释多行内容，具体格式如下：‘’’使用 3 个单引号分别作为注释的开头和结尾可以一次性注释多行内容这里面的内容全部是注释内容‘’’ Python缩进规则(包含快捷键)在 Python 中，对于类定义、函数定义、流程控制语句、异常处理语句等，行尾的冒号和下一行的缩进，表示下一个代码块的开始，而缩进的结束则表示此代码块的结束。注意，Python 中实现对代码的缩进，可以使用空格或者 Tab 键实现。但无论是手动敲空格，还是使用 Tab 键，通常情况下都是采用 4 个空格长度作为一个缩进量（默认情况下，一个 Tab 键就表示 4 个空格）。 Python编码规范（PEP 8）Python 采用 PEP 8 作为编码规范，其中 PEP 是 Python Enhancement Proposal（Python 增强建议书）的缩写，8 代表的是 Python 代码的样式指南。每个 import 语句只导入一个模块，尽量避免一次导入多个模块不要在行尾添加分号，也不要用分号将两条命令放在同一行建议每行不超过80个字符，如果超过，建议使用小括号将多行内容隐式的连接起来，而不推荐使用反斜杠\\进行连接。使用必要的空行可以增加代码的可读性，通常在顶级定义（如函数或类的定义）之间空两行，而方法定义之间空一行，另外在用于分隔某些功能的位置也可以空一行。通常情况下，在运算符两侧、函数参数之间以及逗号两侧，都建议使用空格进行分隔。 Python标识符命名规范Python 中标识符的命名不是随意的，而是要遵守一定的命令规则，比如说：标识符是由字符（A~Z 和 a~z）、下划线和数字组成，但第一个字符不能是数字。标识符不能和 Python 中的保留字相同。有关保留字，后续章节会详细介绍。Python中的标识符中，不能包含空格、@、% 以及 $ 等特殊字符。在 Python 中，标识符中的字母是严格区分大小写的，也就是说，两个同样的单词，如果大小格式不一样，多代表的意义也是完全不同的。Python 语言中，以下划线开头的标识符有特殊含义，例如：以单下划线开头的标识符（如 _width），表示不能直接访问的类属性，其无法通过 from…import* 的方式导入；以双下划线开头的标识符（如__add）表示类的私有成员；以双下划线作为开头和结尾的标识符（如 init），是专用标识符。标识符的命名，除了要遵守以上这几条规则外，不同场景中的标识符，其名称也有一定的规范可循，例如：当标识符用作模块名时，应尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母，例如 game_mian、game_register等。当标识符用作包的名称时，应尽量短小，也全部使用小写字母，不推荐使用下划线，例如 com.mr、com.mr.book 等。当标识符用作类名时，应采用单词首字母大写的形式。例如，定义一个图书类，可以命名为 Book。模块内部的类名，可以采用 “下划线+首字母大写” 的形式，如 _Book;函数名、类中的属性名和方法名，应全部使用小写字母，多个单词之间可以用下划线分割；常量命名应全部使用大写字母，单词之间可以用下划线分割； Python关键字(保留字)保留字是 Python 语言中一些已经被赋予特定意义的单词，这就要求开发者在开发程序时，不能用这些保留字作为标识符给变量、函数、类、模板以及其他对象命名。123&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] Python内置函数 abs(x)返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。 all(iterable)如果 iterable 的所有元素为真（或迭代器为空），返回 True 。等价于:12345def all(iterable): for element in iterable: if not element: return False return True any(iterable)如果 iterable 的任一元素为真则返回 True。 如果迭代器为空，返回 False。 等价于:12345def any(iterable): for element in iterable: if element: return True return False ascii(object)像函数repr()，返回一个对象可打印的字符串，但是repr()返回的字符串中非ASCII编码的字符，会使用 \\x、\\u 和 \\U 来转义。生成的字符串和Python2的repr()返回的结果相似。 bin(x)将一个整数转变为一个前缀为“0b”的二进制字符串。结果是一个合法的 Python 表达式。如果x不是 Python的int对象，那它需要定义 index()方法返回一个整数。1234&gt;&gt;&gt; bin(3)'0b11'&gt;&gt;&gt; bin(-10)'-0b1010' class bool([x])返回一个布尔值，True 或者 False。 x使用标准的 真值测试过程 来转换。如果x是假的或者被省略，返回 False；其他情况返回True。bool类是int的子类（参见 数字类型 — int, float, complex）。其他类不能继承自它。它只有False和True两个实例。 breakpoint(*args, **kws)此函数会在调用时将你陷入调试器中。具体来说，它调用sys.breakpointhook() ，直接传递args和kws 。默认情况下， sys.breakpointhook()调用 pdb.set_trace()且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 pdb 且键入尽可能少的代码即可进入调试器。但是，sys.breakpointhook() 可以设置为其他一些函数并被breakpoint()自动调用，以允许进入你想用的调试器。 class bytearray([source[, encoding[, errors]]])返回一个新的bytes数组。 bytearray类是一个可变序列，包含范围为0 &lt;= x &lt; 256的整数。它有可变序列大部分常见的方法，见 可变序列类型的描述；同时有 bytes类型的大部分方法，参见 bytes和bytearray操作。 enumerate(iterable, start=0)返回一个枚举对象。iterable 必须是一个序列，或 iterator，或其他支持迭代的对象。 enumerate() 返回的迭代器的 next() 方法返回一个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代 iterable 获得的值。## divmod(a, b)它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和 (a // b, a % b) 一致。对于浮点数，结果是(q, a % b) ，q通常是 math.floor(a / b) 但可能会比 1 小。在任何情况下， q * b + a % b和a基本相等；如果a % b非零，它的符号和 b 一样，并且 0 &lt;= abs(a % b) &lt; abs(b)。 eval(expression[, globals[, locals]])实参是一个字符串，以及可选的 globals 和 locals。globals 实参必须是一个字典。locals 可以是任何映射对象。expression参数会作为一个 Python表达式（从技术上说是一个条件列表）被解析并求值，使用 globals 和 locals 字典作为全局和局部命名空间。如果 globals 字典存在且不包含以 __builtins__为键的值，则会在解析expression之前插入以此为键的对内置模块builtins的字典的引用。这意味着expression通常具有对标准builtins模块的完全访问权限且受限的环境会被传播。如果省略locals字典则其默认值为 globals字典。如果两个字典同时省略，表达式会在eval()被调用的环境中执行。返回值为表达式求值的结果。语法错误将作为异常被报告。 getattr(object, name[, default])返回对象命名属性的值。name必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， getattr(x, ‘foobar’) 等同于 x.foobar。如果指定的属性不存在，且提供了default值，则返回它，否则触发 AttributeError。 globals()返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。 hasattr(object, name)该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回True，否则返回False。（此功能是通过调用getattr(object, name) 看是否有 AttributeError异常来实现的）。 hash(object)返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。 repr(object)返回包含一个对象的可打印表示形式的字符串。 对于许多类型来说，该函数会尝试返回的字符串将会与该对象被传递给 eval() 时所生成的对象具有相同的值，在其他情况下表示形式会是一个括在尖括号中的字符串，其中包含对象类型的名称与通常包括对象名称和地址的附加信息。 类可以通过定义 repr() 方法来控制此函数为它的实例所返回的内容。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"}]},{"title":"动态内存管理","slug":"动态内存管理","date":"2020-04-23T08:08:46.000Z","updated":"2020-04-24T07:56:30.459Z","comments":true,"path":"2020/04/23/动态内存管理/","link":"","permalink":"http://forwardpeng.github.io/2020/04/23/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"动态内存管理机制 占用块和空闲块对于计算机中的内存来说，称已经分配给用户的的内存区统称为“占用块”；还未分配出去的内存区统称为“空闲块”或者“可利用空间块”。 系统的内存管理对于初始状态下的内存来说，整个空间都是一个空闲块（在编译程序中称为“堆”）。但是随着不同的用户不断地提出存储请求，系统依次分配。整个内存区就会分割成两个大部分：低地址区域会产生很多占用块；高地址区域还是空闲块。图1 动态分配过程中的内存状态当某些用户运行结束，所占用的内存区域就变成了空闲块，如图2：图2 动态分配过程中的内存变化时，就形成了占用块和空闲块犬牙交错的状态。当后续用户请求分配内存时，系统有两种分配方式：系统继续利用高地址区域的连续空闲块分配给用户，不去理会之前分配给用户的内存区域的状态。直到分配无法进行，也就是高地址的空闲块不能满足用户的需求时，系统才会去回收之前的空闲块，重新组织继续分配；当用户运行一结束，系统马上将其所占空间进行回收。当有新的用户请求分配内存时，系统遍历所有的空闲块，从中找出一个合适的空闲块分配给用户。 可利用空间表系统需要建立一张记录所有空闲块信息的表。表的形式有两种：目录表和链表。各自的结构如图3所示：图3 目录表和链表目录表：表中每一行代表一个空闲块，由三部分组成：初始地址：记录每个空闲块的起始地址。空闲块大小：记录每个空闲块的内存大小。使用情况：记录每个空闲块是否存储被占用的状态。链表：表中每个结点代表一个空闲块，每个结点中需要记录空闲块的使用情况、大小和连接下一个空闲块的指针域。由于链表中有指针的存在，所以结点中不需要记录各内存块的起始地址。存储空闲块的可利用空间表有以下不同的结构：如果每次用户请求的存储空间大小相同，对于此类系统中的内存来说，在用户运行初期就将整个内存存储块按照所需大小进行分割，然后通过链表链接。当用户申请空间时，从链表中摘除一个结点归其使用；用完后再链接到可利用空间表上。每次如果用户申请的都是若干种大小规格的存储空间，针对这种情况可以建立若干个可利用空间表，每一个链表中的结点大小相同。当用户申请某一规格大小的存储空间时，就从对应的链表中摘除一个结点供其使用；用完后链接到相同规格大小的链表中。用户申请的内存的大小不固定，所以造成系统分配的内存块的大小也不确定，回收时，链接到可利用空间表中每个结点的大小也各不一样。第 2 种情况下容易面临的问题是：如果同用户申请空间大小相同的链表中没有结点时，就需要找结点更大的链表，从中取出一个结点，一部分给用户使用，剩余部分插入到相应大小的链表中；回收时，将释放的空闲块插入到大小相同的链表中去。如果没有比用户申请的内存空间相等甚至更大的结点时，就需要系统重新组织一些小的连续空间，然后给用户使用。 分配存储空间的方式通常情况下系统中的可利用空间表是第 3 种情况。如图 3© 所示。由于链表中各结点的大小不一，在用户申请内存空间时，就需要从可利用空间表中找出一个合适的结点，有三种查找的方法：首次拟合法：在可利用空间表中从头开始依次遍历，将找到的第一个内存不小于用户申请空间的结点分配给用户，剩余空间仍留在链表中；回收时只要将释放的空闲块插入在链表的表头即可。最佳拟合法：和首次拟合法不同，最佳拟合法是选择一块内存空间不小于用户申请空间，但是却最接近的一个结点分配给用户。为了实现这个方法，首先要将链表中的各个结点按照存储空间的大小进行从小到大排序，由此，在遍历的过程中只需要找到第一块大于用户申请空间的结点即可进行分配；用户运行完成后，需要将空闲块根据其自身的大小插入到链表的相应位置。最差拟合法：和最佳拟合法正好相反，该方法是在不小于用户申请空间的所有结点中，筛选出存储空间最大的结点，从该结点的内存空间中提取出相应的空间给用户使用。为了实现这一方法，可以在开始前先将可利用空间表中的结点按照存储空间大小从大到小进行排序，第一个结点自然就是最大的结点。回收空间时，同样将释放的空闲块插入到相应的位置上。以上三种方法各有所长：最佳拟合法由于每次分配相差不大的结点给用户使用，所以会生成很多存储空间特别小的结点，以至于根本无法使用，使用过程中，链表中的结点存储大小发生两极分化，大的很大，小的很小。该方法适用于申请内存大小范围较广的系统最差拟合法，由于每次都是从存储空间最大的结点中分配给用户空间，所以链表中的结点大小不会起伏太大。依次适用于申请分配内存空间较窄的系统。首次拟合法每次都是随机分配。在不清楚用户申请空间大小的情况下，使用该方法分配空间。 边界标识法管理动态内存使用边界标识法的系统管理内存时，可利用空间表中的结点的构成如图 4：图4 结构构成每个结点中包含3个区域，head域、foot域和space域：space域表示为该内存块的大小，它的大小通过head域中的size值表示。head域中包含有4部分：llink 和rlink分别表示指向当前内存块结点的直接前驱和直接后继。tag值用于标记当前内存块的状态，是占用块（用 1 表示）还是空闲块（用 0 表示）。size用于记录该内存块的存储大小。foot域中包含有2部分：uplink 是指针域，用于指向内存块本身，通过uplink就可以获取该内存块所在内存的首地址。tag同head域中的tag相同，都是记录内存块状态的。注意：head域和foot域在本节中都假设只占用当前存储块的1个存储单位的空间，对于该结点整个存储空间来说，可以忽略不计。也就是说，在可利用空间表中，知道下一个结点的首地址，该值减1就可以找到当前结点的foot域。边界标识法管理的内存块结点代码：12345678910typedef struct WORD&#123; union&#123; struct WORD *llink;//指向直接前驱 struct WORD *uplink;//指向结点本身 &#125;; int tag;//标记域,0表示为空闲块；1表示为占用块 int size;//记录内存块的存储大小 struct WORD *rlink;//指向直接后继 OtherType other;//内存块可能包含的其它的部分&#125;WORD,head,foot,*Space; 分配算法3 种分配方法分别为：首部拟合法、最佳拟合法和最差拟合法。选定一个常量e，每次分配空间时，判断当前内存块向用户分配空间后，如果剩余部分的容量比e小，则将整个内存块全部分配给用户。采用头部拟合法进行分配时，如果每次都从pav指向的结点开始遍历，在若干次后，会出现存储量小的结点密集地分布在pav结点附近的情况，严重影响遍历的时间。解决办法就是：在每次分配空间后，让pav指针指向该分配空间结点的后继结点，然后从新的pav指向的结点开始下一次的分配。首部拟合法具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Space AllocBoundTag(Space *pav, int n)&#123; Space p, f; int e = 10; //设定常亮 e 的值 //如果在遍历过程，当前空闲块的在存储容量比用户申请空间 n 值小，在该空闲块有右孩子的情况下直接跳过 for (p = (*pav); p &amp;&amp; p-&gt;size &lt; n &amp;&amp; p-&gt;rlink != (*pav); p = p-&gt;rlink) ; //跳出循环，首先排除p为空和p指向的空闲块容量小于 n 的情况 if (!p || p-&gt;size &lt; n) &#123; return NULL; &#125; else &#123; //指针f指向p空闲块的foot域 f = FootLoc(p); //调整pav指针的位置，为下次分配做准备 (*pav) = p-&gt;rlink; //如果该空闲块的存储大小比 n 大，比 n+e 小，负责第一种情况，将 p 指向的空闲块全部分配给用户 if (p-&gt;size - n &lt;= e) &#123; if ((*pav) == p) &#123; pav = NULL; &#125; else &#123; //全部分配用户，即从可利用空间表中删除 p 空闲块 (*pav)-&gt;llink = p-&gt;llink; p-&gt;llink-&gt;rlink = (*pav); &#125; //同时调整head域和foot域中的tag值 p-&gt;tag = f-&gt;tag = 1; &#125; //否则，从p空闲块中拿出 大小为 n 的连续空间分配给用户，同时更新p剩余存储块中的信息。 else &#123; //更改分配块foot域的信息 f-&gt;tag = 1; p-&gt;size -= n; //f指针指向剩余空闲块 p 的底部 f = FootLoc(p); f-&gt;tag = 0; f-&gt;uplink = p; p = f + 1; //p指向的是分配给用户的块的head域，也就是该块的首地址 p-&gt;tag = 1; p-&gt;size = n; &#125; return p; &#125;&#125; 回收算法系统需要立即回收被用户占用的存储空间，以备新的用户使用。回收算法中需要解决的问题是：在若干次分配操作后，可利用空间块中会产生很多存储空间很小以致无法使用的空闲块。但是经过回收用户释放的空间后，可利用空间表中可能含有地址相邻的空闲块，回收算法需要将这些地址相邻的空闲块合并为大的空闲块供新的用户使用。合并空闲块有3种情况：该空闲块的左边有相邻的空闲块可以进行合并；该空闲块的右边用相邻的空闲块可以进行合并；该空闲块的左右两侧都有相邻的空闲块可以进行合并；判断当前空闲块左右两侧是否为空闲块的方法是：对于当前空闲块p ，p-1 就是相邻的低地址处的空闲块的foot域，如果foot域中的tag值为0 ，表明其为空闲块； p+p-&gt;size 表示的是高地址处的块的head域，如果head域中的tag值为 0，表明其为空闲块。如果当前空闲块的左右两侧都不是空闲块，而是占用块，此种情况下只需要将新的空闲块按照相应的规则（头部拟合法随意插入，其它两种方法在对应位置插入）插入到可利用空间表中即可。实现代码为：1234567891011121314151617//设定p指针指向的为用户释放的空闲块p-&gt;tag=0;//f指针指向p空闲块的foot域Space f=FootLoc(p);f-&gt;uplink=p;f-&gt;tag=0;//如果pav指针不存在，证明可利用空间表为空，此时设置p为头指针，并重新建立双向循环链表if (!pav) &#123; pav=p-&gt;llink=p-&gt;rlink=p;&#125;else&#123; //否则，在p空闲块插入到pav指向的空闲块的左侧 Space q=pav-&gt;llink; p-&gt;rlink=pav; p-&gt;llink=q; q-&gt;rlink=pav-&gt;llink=p; pav=p;&#125;该空闲块的左侧相邻的块为空闲块，右侧为占用块，处理的方法是：只需要更改左侧空闲块中的size的大小，并重新设置左侧空闲块的foot 域即可（如图2）。图5 空闲块合并（当前块，左侧内存块）实现代码：1234567//常量 n 表示当前空闲块的存储大小int n=p-&gt;size;Space s=(p-1)-&gt;uplink;//p-1 为当前块的左侧块的foot域，foot域中的uplink指向的就是左侧块的首地址，s指针代表的是当前块的左侧存储块s-&gt;size+=n;//设置左侧存储块的存储容量Space f=p+n-1;//f指针指向的是空闲块 p 的foot域f-&gt;uplink=s;//这是foot域的uplink指针重新指向合并后的存储空间的首地址f-&gt;tag=0;//设置foot域的tag标记为空闲块如果当前用户释放掉的空闲块，物理位置上相邻的左右两侧的内存块全部为空闲块，需要将 3 个空闲块合并为一个更大的块，操作的过程为：更新左侧空闲块的 size 的值，同时在可利用空间表中摘除右侧空闲块，最后更新合并后的大的空闲块的 foot域123456789101112 int n=p-&gt;size;Space s=(p-1)-&gt;uplink;//找到释放内存块物理位置相邻的低地址的空闲块Space t=p+p-&gt;size;//找到物理位置相邻的高地址处的空闲块s-&gt;size+=n+t-&gt;size;//更新左侧空闲块的size的值//从可利用空间表中摘除右侧空闲块Space q=t-&gt;llink;Space q1=t-&gt;rlink;q-&gt;rlink=q1;q1-&gt;llink=q;//更新合并后的空闲块的uplink指针的指向Space f=FootLoc(t);f-&gt;uplink=s; 伙伴系统管理动态内存伙伴系统本身是一种动态管理内存的方法，和边界标识法的区别是：使用伙伴系统管理的存储空间，无论是空闲块还是占用块，大小都是 2 的 n 次幂（n 为正整数）。例如，系统中整个存储空间为 2m 个字。那么在进行若干次分配与回收后，可利用空间表中只可能包含空间大小为：20、21、22、…、2m 的空闲块。字是一种计量单位，由若干个字节构成，不同位数的机器，字所包含的字节数不同。例如，8 位机中一个字由 1 个字节组成；16 位机器一个字由 2 个字节组成。 可利用空间表中结点构成图6 结点构成header 域表示为头部结点，由 4 部分构成：llink 和 rlink 为结点类型的指针域，分别用于指向直接前驱和直接后继结点。tag 值：用于标记内存块的状态，是占用块（用 1 表示）还是空闲块（用 0 表示）kval：记录该存储块的容量。由于系统中各存储块都是2的m幂次方，所以kval记录m的值。12345678typedef struct WORD_b&#123; struct WORD_b *llink;//指向直接前驱 int tag;//记录该块是占用块还是空闲块 int kval;//记录该存储块容量大小为2的多少次幂 struct WORD_b *rlink;//指向直接后继 OtherType other;//记录结点的其它信息&#125;WORD_b,head;在伙伴系统中，由于系统会不断地接受用户的内存申请的请求，所以会产生很多大小不同但是都是容量为2m2^{m}2m的内存块，所以为了在分配的时候查找方便，系统采用将大小相同的各自建立一个链表。对于初始容量为 2m2^{m}2m的一整块存储空间来说，形成的链表就有可能有m+1个，为了更好的对这些链表进行管理，系统将这m+1个链表的表头存储在数组中，就类似于邻接表的结构，如图7。图7 伙伴系统的初始状态可利用空间表的代码表示为：12345#define m 16//设定m的初始值typedef struct HeadNode &#123; int nodesize;//记录该链表中存储的空闲块的大小 WORD_b * first;//相当于链表中的next指针的作用&#125;FreeList[m+1];//一维数组 分配算法伙伴系统的分配算法很简单。假设用户向系统申请大小为 n 的存储空间，若2k−1&lt;n&lt;=2k2^{k-1} &lt; n &lt;= 2^{k}2k−1&lt;n&lt;=2k，此时就需要查看可利用空间表中大小为2k2^{k}2k 的链表中有没有可利用的空间结点：如果该链表不为NULL，可以直接采用头插法从头部取出一个结点，提供给用户使用；如果大小为2k2^{k}2k的链表为 NULL，就需要依次查看比2k2^{k}2k大的链表，找到后从链表中删除，截取相应大小的空间给用户使用，剩余的空间，根据大小插入到相应的链表中。用户向系统申请一块大小为7个字的空间，而系统总的内存为242^{4}24个字,按照伙伴系统的分配算法得出：22&lt;7&lt;232^{2} &lt; 7 &lt; 2^{3}22&lt;7&lt;23，所以此时应查看可利用空间表中大小为 23 的链表中是否有空闲结点：如果有，则从该链表中摘除一个结点，直接分配给用户使用；如果没有，则需依次查看比232^{3}23大的各个链表中是否有空闲结点。假设，在大小242^{4}24的链表中有空闲块，则摘除该空闲块，分配给用户232^{3}23个字的空间，剩余232^{3}23个字，该剩余的空闲块添加到大小为232^{3}23的链表中。图8 伙伴系统分配过程 回收算法无论使用什么内存管理机制，在内存回收的问题上都会面临一个共同的问题：如何把回收的内存进行有效地整合，伙伴系统也不例外。当用户申请的内存块不再使用时，系统需要将这部分存储块回收，回收时需要判断是否可以和其它的空闲块进行合并。在寻找合并对象时，伙伴系统和边界标识法不同，在伙伴系统中每一个存储块都有各自的“伙伴”，当用户释放存储块时只需要判断该内存块的伙伴是否为空闲块，如果是则将其合并，然后合并的新的空闲块还需要同其伙伴进行判断整合。反之直接将存储块根据大小插入到可利用空间表中即可。判断一个存储块的伙伴的位置时，采用的方法为：如果该存储块的起始地址为 p，大小为2k2^{k}2k，则其伙伴所在的起始地址为：例如，当大小为282^{8}28 ，起始地址为512的伙伴块的起始地址的计算方式为：由于512 MOD 292^{9}29=0，所以，512+28=768512+2^{8}=768512+28=768，及如果该存储块回收时，只需要查看起始地址为 768 的存储块的状态，如果是空闲块则两者合并，反之直接将回收的释放块链接到大小为282^{8}28的链表中。 总结使用伙伴系统进行存储空间的管理过程中，在用户申请空间时，由于大小不同的空闲块处于不同的链表中，所以分配完成的速度会更快，算法相对简单。回收存储空间时，对于空闲块的合并，不是取决于该空闲块的相邻位置的块的状态；而是完全取决于其伙伴块。所以即使其相邻位置的存储块时空闲块，但是由于两者不是伙伴的关系，所以也不会合并。这也就是该系统的缺点之一：由于在合并时只考虑伙伴，所以容易产生存储的碎片。 垃圾回收机制当用户发出申请空间的请求后，系统向用户分配内存；用户运行结束释放存储空间后，系统回收内存。这两部操作都是在用户给出明确的指令后，系统对存储空间进行有效地分配和回收。但是在实际使用过程中，有时会因为用户申请了空间，但是在使用完成后没有向系统发出释放的指令，导致存储空间既没有被使用也没有被回收，变为了无用单元或者会产生悬挂访问的问题。什么是无用单元？简单来讲，无用单元是一块用户不再使用，但是系统无法回收的存储空间。例如在C语言中，用户可以通过 malloc 和 free 两个功能函数来动态申请和释放存储空间。当用户使用 malloc 申请的空间使用完成后，没有使用 free 函数进行释放，那么该空间就会成为无用单元。悬挂访问也很好理解：假设使用malloc申请了一块存储空间，有多个指针同时指向这块空间，当其中一个指针完成使命后，私自将该存储空间使用free释放掉，导致其他指针处于悬空状态，如果释放掉的空间被再分配后，再通过之前的指针访问，就会造成错误。数据结构中称这种访问为悬挂访问。解决存储空间可能成为无用单元或者产生悬挂访问的方法有两个：每个申请的存储空间设置一个计数域，这个计数域记录的是指向该存储空间的指针数目，只有当计数域的值为 0 时，该存储空间才会被释放。在程序运行时，所有的存储空间无论是处于使用还是空闲的状态，一律不回收，当系统中的可利用空间表为空时，将程序中断，对当前不在使用状态的存储空间一律回收，全部链接成一个新的可利用空间表后，程序继续执行。第二种方法中，在程序运行过程中很难找出此时哪些存储空间是空闲的。解决这个问题的办法是：找当前正在被占用的存储空间，只需要从当前正在工作的指针变量出发依次遍历，就可以找到当前正在被占用的存储空间，剩余的自然就是此时处于空闲状态的存储空间。使用第二种方式，可以分为两步进行：对所有当前正在使用的存储空间加上被占用的标记（对于广义表来说，可以在每个结点结构的基础上，添加一个 mark 的标志域。在初始状态下，所有的存储空间全部标志为 0，被占用时标记为 1）；依次遍历所有的存储空间，将所有标记为 0 的存储空间链接成一个新的可利用空间表。对正在被占用的存储空间进行标记的方法有三种：从当前正在工作的指针变量开始，采用递归算法依次将所有表中的存储结点中的标志域全部设置为 1；*第一种方法中使用递归算法实现的遍历。而递归底层使用的栈的存储结构，所以也可以直接使用栈的方式进行遍历；以上两种方法都是使用栈结构来记录遍历时指针所走的路径，便于在后期可以沿原路返回。所以第三种方式就是使用其他的方法代替栈的作用。 内存紧缩(内存碎片化处理)这些地址连续的未被占用的存储区在编译程序中称为堆。 分配内存空间在分配内存空间时，每次都从可利用空间中选择最低（或者最高）的地址进行分配。具体的实现办法为：设置一个指针（称为堆指针），每次用户申请存储空间时，都是堆的最低（或者最高）地址进行分配。假设当用户申请 N 个单位的存储空间时，堆指针向高地址（或者低地址）移动 N 个存储单位，这 N 个存储单位即为分配给用户使用的空闲块，空闲块的起始地址为堆指针移动之前所在的地址。例如，某一时间段有四个用户（A、B、C、D）分别申请 12 个单位、6 个单位、10 个单位和 8 个单位的存储空间，假设此时堆指针的初值为 0。则分配后存储空间的效果为：图9 内存空间分配 回收算法由于系统中的可利用空间始终都是一个连续的存储空间，所以回收时必须将用户释放的存储块合并到这个堆上才能够重新使用。存储紧缩有两种做法：其一是一旦用户释放所占空间就立即进行回收紧缩；另外一种是在程序执行过程中不立即回收用户释放的存储块，而是等到可利用空间不够分配或者堆指针指向了可利用存储区的最高地址时才进行存储紧缩。具体的实现过程是：计算占用块的新地址。设立两个指针随巡查向前移动，分别用于指示占用块在紧缩之前和之后的原地址和新地址。因此，在每个占用块的第一个存储单位中，除了存储该占用块的大小和标志域之外，还需要新增一个新地址域，用于存储占用块在紧缩后应有的新地址，即建立一张新、旧地址的对照表。修改用户的出事变量表，保证在进行存储紧缩后，用户还能找到自己的占用块。检查每个占用块中存储的数据。如果有指向其它存储块的指针，则需作相应修改。将所有占用块迁移到新地址去，即进行数据的传递。最后，还要将堆指针赋以新的值。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"计算机基础/数据结构","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法导论","slug":"算法导论","permalink":"http://forwardpeng.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}]},{"title":"algo-table","slug":"algo-table","date":"2020-04-22T04:21:14.000Z","updated":"2020-04-23T06:11:24.963Z","comments":true,"path":"2020/04/22/algo-table/","link":"","permalink":"http://forwardpeng.github.io/2020/04/22/algo-table/","excerpt":"","text":"线性表将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。 顺序存储结构和链式存储结构将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构(顺序表)数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构(链表) 前驱和后继数据结构中，一组数据中的每个个体被称为“数据元素”。某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；图1 前驱和后继 顺序表(顺序存储结构)及初始化顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。顺序表存储数据使用的是数组。 顺序表的初始化使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：顺序表申请的存储容量顺序表的长度，元素的个数正常状态下，顺序表申请的存储容量要大于顺序表的长度。自定义顺序表的结构体：C语言实现：123456typedef struct Table&#123; int* head; //动态数组 int length; //顺序表的长度 int size; //顺序表分配的存储容量&#125;table;建立顺序表需要做如下工作：给head动态数据申请足够大小的物理空间；给size和length赋初值；1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define Size 5typedef struct Table&#123; int * head; int length; int size;&#125;table;table initTable()&#123; table t; t.head=(int*)malloc(Size*sizeof(int)); //构造一个空的顺序表，动态申请存储空间 if (!t.head) //如果申请失败，作出提示并直接退出程序 &#123; printf(\"初始化失败\"); exit(0); &#125; t.length=0; //长度为0 t.size=Size; //存储空间为Size return t;&#125;//输出顺序表中元素的函数void displayTable(table t)&#123; for (int i=0;i&lt;t.length;i++) &#123; printf(\"%d \",t.head[i]); &#125; printf(\"\\n\");&#125;int main()&#123; table t=initTable(); //向顺序表中添加元素 for (int i=1; i&lt;=Size; i++) &#123; t.head[i-1]=i; t.length++; &#125; printf(\"顺序表中存储的元素分别是：\\n\"); displayTable(t); return 0;&#125; 顺序表插入元素虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：将要插入位置元素以及后续的元素整体向后移动一个位置；将元素放到腾出来的位置上；12345678910111213141516171819202122232425262728293031//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置table addTable(table t, int elem, int add)&#123; //判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出） if (add &gt; t.length + 1 || add &lt; 1) &#123; printf(\"插入位置有问题\\n\"); return t; &#125; //做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请 if (t.length == t.size) &#123; t.head = (int *)realloc(t.head, (t.size + 1) * sizeof(int)); if (!t.head) &#123; printf(\"存储分配失败\\n\"); return t; &#125; t.size += 1; &#125; //插入操作，需要将从插入位置开始的后续元素，逐个后移 for (int i = t.length - 1; i &gt;= add - 1; i--) &#123; t.head[i + 1] = t.head[i]; &#125; //后移完成后，直接将所需插入元素，添加到顺序表的相应位置 t.head[add - 1] = elem; //由于添加了元素，所以长度+1 t.length++; return t;&#125;注意，动态数组额外申请更多物理空间使用的是 realloc 函数。并且，在实现后续元素整体后移的过程，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。 顺序表删除元素从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。123456789101112table delTable(table t, int add)&#123; printf(\"被删除元素的位置有误\\n\"); return t; &#125; //删除操作 for (int i=add; i&lt;t.length; i++) &#123; t.head[i-1]=t.head[i]; &#125; t.length--; return t;&#125; 顺序表查找元素顺序表中查找目标元素，可以使用多种查找算法实现，比如说二分查找算法、顺序查找等123456789//顺序查找int selectTable(table t,int elem)&#123; for (int i=0; i&lt;t.length; i++) &#123; if (t.head[i]==elem) &#123; return i+1; &#125; &#125; return -1;//如果查找失败，返回-1&#125; 更改元素顺序表更改元素的实现过程是：找到目标元素；直接修改该元素的值；12345table amendTable(table t,int elem,int newElem)&#123; int add=selectTable(t, elem); t.head[add-1]=newElem;//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标 return t;&#125; 单链表与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。通过指针表示数据之间逻辑关系的存储结构就是链式存储结构。 链表的节点链表中每个数据的存储都由以下两部分组成：数据元素本身，其所在的区域称为数据域；指向直接后继元素的指针，所在的区域称为指针域；图2 节点结构链表中每个节点的结构体实现c代码：1234 typedef struct Link&#123; char elem; //代表数据域 struct Link * next; //代表指针域，指向直接后继元素&#125;link; //link为节点名，每个节点都是一个 link 结构体 头节点、头指针和首元节点一个完整的链表需要由以下几部分构成：头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；其他节点：链表中其他的节点；注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。 链表的创建(初始化)创建一个链表步骤如下：声明一个头指针（如果有必要，可以声明一个头节点）；创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；1234567891011121314//创建一个存储 &#123;1,2,3,4&#125; 且含头节点的链表link * initLink()&#123; link * p=(link*)malloc(sizeof(link));//创建一个头结点 link * temp=p;//声明一个指针指向头结点， //生成链表 for (int i=1; i&lt;5; i++) &#123; link *a=(link*)malloc(sizeof(link)); a-&gt;elem=i; a-&gt;next=NULL; temp-&gt;next=a; temp=temp-&gt;next; &#125; return p;&#125; 链表插入元素虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：将新结点的 next 指针指向插入位置后的结点；将插入位置前结点的 next 指针指向插入结点；注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，除非再添加一个指针，作为插入位置后续链表的头指针，否则会导致插入位置后的这部分链表丢失，无法再实现步骤 1。12345678910111213141516171819//p为原链表，elem表示新数据元素，add表示新元素要插入的位置link * insertElem(link * p, int elem, int add) &#123; link * temp = p;//创建临时结点temp //首先找到要插入位置的上一个结点 for (int i = 1; i &lt; add; i++) &#123; temp = temp-&gt;next; if (temp == NULL) &#123; printf(\"插入位置无效\\n\"); return p; &#125; &#125; //创建插入结点c link * c = (link*)malloc(sizeof(link)); c-&gt;elem = elem; //向链表中插入结点 c-&gt;next = temp-&gt;next; temp-&gt;next = c; return p;&#125; 链表删除元素从链表中删除数据元素需要进行以下 2步操作：将结点从链表中摘下来;手动释放掉结点，回收被结点占用的存储空间;temp-&gt;next=temp-&gt;next-&gt;next;执行效果如图3所示：图3 链表删除元素12345678910111213141516//p为原链表，add为要删除元素的值link * delElem(link * p, int add) &#123; link * temp = p; //遍历到被删除结点的上一个结点 for (int i = 1; i &lt; add; i++) &#123; temp = temp-&gt;next; if (temp-&gt;next == NULL) &#123; printf(\"没有该结点\\n\"); return p; &#125; &#125; link * del = temp-&gt;next;//单独设置一个指针指向被删除结点，以防丢失 temp-&gt;next = temp-&gt;next-&gt;next;//删除某个结点的方法就是更改前一个结点的指针域 free(del);//手动释放该结点，防止内存泄漏 return p;&#125; 链表查找元素从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的 NULL（比对失败的标志）。12345678910111213141516//p为原链表，elem表示被查找元素、int selectElem(link * p,int elem)&#123;//新建一个指针t，初始化为头指针 p link * t=p; int i=1; //由于头节点的存在，因此while中的判断为t-&gt;next while (t-&gt;next) &#123; t=t-&gt;next; if (t-&gt;elem==elem) &#123; return i; &#125; i++; &#125; //程序执行至此处，表示查找失败 return -1;&#125; 链表更新元素更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。1234567891011//更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值link *amendElem(link * p,int add,int newElem)&#123; link * temp=p; temp=temp-&gt;next;//在遍历之前，temp指向首元结点 //遍历到待更新结点 for (int i=1; i&lt;add; i++) &#123; temp=temp-&gt;next; &#125; temp-&gt;elem=newElem; return p;&#125; 顺序表和链表的优缺点(区别、特点)顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合，不留一丝空隙，如图4a)所示；链表的存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持，如图4b)所示； 开辟空间的方式顺序表存储数据实行的是 “一次开辟，永久使用”，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。因此，若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。 空间利用率空间利用率的角度上看，顺序表的空间利用率显然要比链表高。链表在存储数据时，每次只申请一个节点的空间，且空间的位置是随机的这种申请存储空间的方式会产生很多空间碎片，一定程序上造成了空间浪费。不仅如此，由于链表中每个数据元素都必须携带至少一个指针，因此，链表对所申请空间的利用率也没有顺序表高。空间碎片，指的是某些容量很小（1KB 甚至更小）以致无法得到有效利用的物理空间。 时间复杂度根据顺序表和链表在存储结构上的差异，问题类型主要分为以下 2 类：问题中主要涉及访问元素的操作，元素的插入、删除和移动操作极少；问题中主要涉及元素的插入、删除和移动，访问元素的需求很少；第 1 类问题适合使用顺序表。这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 O(1)；而在链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为 O(n);第 2 类问题则适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 O(1)；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为 O(n); 静态链表及其创建使用静态链表存储数据，数据全部存储在数组中（和顺序表一样），但存储位置是随机的，数据之间&quot;一对一&quot;的逻辑关系通过一个整形变量（称为&quot;游标&quot;，和指针功能类似）维持（和链表类似）。图4 静态链表存储数据静态链表会将第一个数据元素放到数组下标为 1 的位置（a[1]）中。从 a[1] 存储的数据元素 1 开始，通过存储的游标变量 3，就可以在 a[3] 中找到元素 1 的直接后继元素 2；同样，通过元素 a[3] 存储的游标变量 5，可以在 a[5] 中找到元素 2 的直接后继元素 3，这样的循环过程直到某元素的游标变量为 0 截止（因为 a[0] 默认不存储数据元素）。 静态链表中的节点静态链表存储数据元素也需要自定义数据类型，至少需要包含以下 2 部分信息：数据域：用于存储数据元素的值；游标：其实就是数组下标，表示直接后继元素所在数组中的位置静态链表中节点构成的C语言实现：1234typedef struct &#123; int data;//数据域 int cur;//游标&#125;component; 备用链表备用链表的作用是回收数组中未使用或之前使用过（目前未使用）的存储空间，留待后期使用。也就是说，静态链表使用数组申请的物理空间中，存有两个链表，一条连接数据，另一条连接数组中未使用的空间通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。 静态链表的创建在数据链表未初始化之前，数组中所有位置都处于空闲状态，都被链接到备用链表上。向静态链表添加数据时，需提前从备用链表中摘除节点，供新数据使用。备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样，向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表，耗费的时间复杂度为 O(1)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#define maxSize 6typedef struct&#123; /* data */ int data; int cur;&#125; component;//将结构体数组中所有分量链接到备用链表void reserveArr(component *array);//初始化静态链表int initArr(component *array);//输出函数void displayArr(component *array, int body);//从备用链表上摘下空闲节点int mallocArr(component *array);int main()&#123; component array[maxSize]; int body = initArr(array); printf(\"静态链表：\\n\"); displayArr(array, body); return 0;&#125;//创建备用链表void reserveArr(component *array)&#123; for (int i = 0; i &lt; maxSize; i++) &#123; array[i].cur = i + 1; //将每个数组分量链接到一起 array[i].data = -1; &#125; array[maxSize - 1].cur = 0; //链表最后一个节点的游标为0&#125;//提前分配空间int mallocArr(component *array)&#123; int i = array[0].cur; if (array[0].cur) &#123; array[0].cur = array[i].cur; &#125; return i;&#125;//初始化静态链表int initArr(component *array)&#123; reserveArr(array); int body = mallocArr(array); //声明一个变量，把它当指针使，指向链表的最后的一个结点，因为链表为空，所以和头结点重合 int tempBody = body; for (int i = 1; i &lt; 4; i++) &#123; int j = mallocArr(array); //从备用链表中拿出空闲的分量 array[tempBody].cur = j; //将申请的空闲分量链接在链表的最后一个结点后面 array[j].data = i; //给新申请的分量的数据域初始化 tempBody = j; //将指向链表最后一个结点的指针后移 &#125; array[tempBody].cur = 0; //新的链表最后一个结点的指针设置为0 return body;&#125;void displayArr(component *array, int body)&#123; int tempBody = body; //tempBody准备做遍历使用 while (array[tempBody].cur) &#123; printf(\"%d,%d \", array[tempBody].data, array[tempBody].cur); tempBody = array[tempBody].cur; &#125; printf(\"%d,%d\\n\", array[tempBody].data, array[tempBody].cur);&#125; 静态链表的基本操作 添加元素将元素4添加到静态链表中的第3个位置上，实现过程如下：从备用链表中摘除一个节点，用于存储元素 4；找到表中第 2 个节点（添加位置的前一个节点，这里是数据元素 2），将元素 2 的游标赋值给新元素 4；将元素 4 所在数组中的下标赋值给元素 2 的游标；1234567891011void insertArr(component * array,int body,int add,char a)&#123; int tempBody=body;//tempBody做遍历结构体数组使用 //找到要插入位置的上一个结点在数组中的位置 for (int i=1; i&lt;add; i++) &#123; tempBody=array[tempBody].cur; &#125; int insert=mallocArr(array);//申请空间，准备插入 array[insert].data=a; array[insert].cur=array[tempBody].cur;//新插入结点的游标等于其直接前驱结点的游标 array[tempBody].cur=insert;//直接前驱结点的游标等于新插入结点所在数组中的下标&#125; 删除元素静态链表中删除指定元素，只需实现以下 2 步操作：将存有目标元素的节点从数据链表中摘除；将摘除节点添加到备用链表，以便下次再用；1234567891011121314151617181920212223242526272829//备用链表回收空间的函数，其中array为存储数据的数组，k表示未使用节点所在数组的下标void freeArr(component * array,int k)&#123; array[k].cur=array[0].cur; array[0].cur=k;&#125;//删除结点函数，a 表示被删除结点中数据域存放的数据void deletArr(component * array,int body,char a)&#123; int tempBody=body; //找到被删除结点的位置 while (array[tempBody].data!=a) &#123; tempBody=array[tempBody].cur; //当tempBody为0时，表示链表遍历结束，说明链表中没有存储该数据的结点 if (tempBody==0) &#123; printf(\"链表中没有此数据\"); return; &#125; &#125; //运行到此，证明有该结点 int del=tempBody; tempBody=body; //找到该结点的上一个结点，做删除操作 while (array[tempBody].cur!=del) &#123; tempBody=array[tempBody].cur; &#125; //将被删除结点的游标直接给被删除结点的上一个结点 array[tempBody].cur=array[del].cur; //回收被摘除节点的空间 freeArr(array, del);&#125; 查找元素静态链表查找指定元素，由于我们只知道静态链表第一个元素所在数组中的位置，因此只能通过逐个遍历静态链表的方式，查找存有指定数据元素的节点。1234567891011int selectElem(component * array,int body,char elem)&#123; int tempBody=body; //当游标值为0时，表示链表结束 while (array[tempBody].cur!=0) &#123; if (array[tempBody].data==elem) &#123; return tempBody; &#125; tempBody=array[tempBody].cur; &#125; return -1;//返回-1，表示在链表中没有找到该元素&#125; 更改数据找到目标元素所在的节点，直接更改节点中的数据域即可。12345678void amendElem(component * array,int body,char oldElem,char newElem)&#123; int add=selectElem(array, body, oldElem); if (add==-1) &#123; printf(\"无更改元素\"); return; &#125; array[add].data=newElem;&#125; 静态链表和动态链表区别 静态链表使用静态链表存储数据，需要预先申请足够大的一整块内存空间，也就是说，静态链表存储数据元素的个数从其创建的那一刻就已经确定，后期无法更改。比如，如果创建静态链表时只申请存储10个数据元素的空间，那么在使用静态链表时，数据的存储个数就不能超过10个，否则程序就会发生错误。不仅如此，静态链表是在固定大小的存储空间内随机存储各个数据元素，这就造成了静态链表中需要使用另一条链表（通常称为&quot;备用链表&quot;）来记录空间存储空间的位置，以便后期分配给新添加元素使用，如图 2 所示。这意味着，如果你选择使用静态链表存储数据，你需要通过操控两条链表，一条是存储数据，另一条是记录空闲空间的位置。 动态链表使用动态链表存储数据，不需要预先申请内存空间，而是在需要的时候才向内存申请。也就是说，动态链表存储数据元素的个数是不限的，想存多少就存多少。同时，使用动态链表的整个过程，你也只需操控一条存储数据的链表。当表中添加或删除数据元素时，你只需要通过 malloc 或 free 函数来申请或释放空间即可，实现起来比较简单。 双向链表双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要双向链表中各节点包含以下3部分信息：指针域：用于指向当前节点的直接前驱节点；数据域：用于存储数据元素。指针域：用于指向当前节点的直接后继节点；双链表的节点结构的Ｃ语言实现：12345typedef struct line&#123; struct line * prior; //指向直接前趋 int data; struct line * next; //指向直接后继&#125;line; 双向链表的创建与单链表不同，双链表创建过程中，每创建一个新节点，都要与其前驱节点建立两次联系，分别是：将新节点的 prior 指针指向直接前驱节点；将直接前驱节点的 next 指针指向新节点；12345678910111213141516171819line* initLine(line * head)&#123; head=(line*)malloc(sizeof(line));//创建链表第一个结点（首元结点） head-&gt;prior=NULL; head-&gt;next=NULL; head-&gt;data=1; line * list=head; for (int i=2; i&lt;=3; i++) &#123; //创建并初始化一个新结点 line * body=(line*)malloc(sizeof(line)); body-&gt;prior=NULL; body-&gt;next=NULL; body-&gt;data=i; list-&gt;next=body;//直接前趋结点的next指针指向新结点 body-&gt;prior=list;//新结点指向直接前趋结点 list=list-&gt;next; &#125; return head;&#125; 添加节点123456789101112131415161718192021222324252627282930line * insertLine(line * head,int data,int add)&#123; //新建数据域为data的结点 line * temp=(line*)malloc(sizeof(line)); temp-&gt;data=data; temp-&gt;prior=NULL; temp-&gt;next=NULL; //插入到链表头，要特殊考虑 if (add==1) &#123; temp-&gt;next=head; head-&gt;prior=temp; head=temp; &#125;else&#123; line * body=head; //找到要插入位置的前一个结点 for (int i=1; i&lt;add-1; i++) &#123; body=body-&gt;next; &#125; //判断条件为真，说明插入位置为链表尾 if (body-&gt;next==NULL) &#123; body-&gt;next=temp; temp-&gt;prior=body; &#125;else&#123; body-&gt;next-&gt;prior=temp; temp-&gt;next=body-&gt;next; body-&gt;next=temp; temp-&gt;prior=body; &#125; &#125; return head;&#125; 删除节点1234567891011121314151617//删除结点的函数，data为要删除结点的数据域的值line * delLine(line * head,int data)&#123; line * temp=head; //遍历链表 while (temp) &#123; //判断当前结点中数据域和data是否相等，若相等，摘除该结点 if (temp-&gt;data==data) &#123; temp-&gt;prior-&gt;next=temp-&gt;next; temp-&gt;next-&gt;prior=temp-&gt;prior; free(temp); return head; &#125; temp=temp-&gt;next; &#125; printf(\"链表中无该数据元素\"); return head;&#125; 查找节点12345678910111213141516//双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。//head为原双链表，elem表示被查找元素int selectElem(line * head,int elem)&#123;//新建一个指针t，初始化为头指针 head line * t=head; int i=1; while (t) &#123; if (t-&gt;data==elem) &#123; return i; &#125; i++; t=t-&gt;next; &#125; //程序执行至此处，表示查找失败 return -1;&#125; 更改节点12345678910//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值line *amendElem(line * p,int add,int newElem)&#123; line * temp=p; //遍历到被删除结点 for (int i=1; i&lt;add; i++) &#123; temp=temp-&gt;next; &#125; temp-&gt;data=newElem; return p;&#125; 循环链表将表中最后一个结点的指针指向头结点，虽然循环链表成环状，但本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等。循环链表和普通链表相比，唯一的不同就是循环链表首尾相连，其他都完全一样。 约瑟夫环已知 n 个人（分别用编号 1，2，3，…，n 表示）围坐在一张圆桌周围，从编号为 k 的人开始顺时针报数，数到 m 的那个人出列；他的下一个人又从 1 开始，还是顺时针开始报数，数到 m 的那个人又出列；依次重复下去，直到圆桌上剩余一个人。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node&#123; int number; struct node *next;&#125; person;person *initLink(int n)&#123; person *head = (person *)malloc(sizeof(person)); head-&gt;number = 1; head-&gt;next = NULL; person *cyclic = head; for (int i = 2; i &lt;= n; i++) &#123; person *body = (person *)malloc(sizeof(person)); body-&gt;number = i; body-&gt;next = NULL; cyclic-&gt;next = body; cyclic = cyclic-&gt;next; &#125; cyclic-&gt;next = head; //首尾相连 return head;&#125;void findAndKillK(person *head, int k, int m)&#123; person *tail = head; //找到链表第一个结点的上一个结点，为删除操作做准备 while (tail-&gt;next != head) &#123; tail = tail-&gt;next; &#125; person *p = head; //找到编号为k的人 while (p-&gt;number != k) &#123; tail = p; p = p-&gt;next; &#125; //从编号为k的人开始，只有符合p-&gt;next==p时，说明链表中除了p结点，所有编号都出列了， while (p-&gt;next != p) &#123; //找到从p报数1开始，报m的人，并且还要知道数m-1de人的位置tail，方便做删除操作。 for (int i = 1; i &lt; m; i++) &#123; tail = p; p = p-&gt;next; &#125; tail-&gt;next = p-&gt;next; //从链表上将p结点摘下来 printf(\"出列人的编号为:%d\\n\", p-&gt;number); free(p); p = tail-&gt;next; //继续使用p指针指向出列编号的下一个编号，游戏继续 &#125; printf(\"出列人的编号为:%d\\n\", p-&gt;number); free(p);&#125;int main()&#123; printf(\"输入圆桌上的人数n:\"); int n; scanf(\"%d\", &amp;n); person *head = initLink(n); printf(\"从第k人开始报数(k&gt;1且k&lt;%d)：\", n); int k; scanf(\"%d\", &amp;k); printf(\"数到m的人出列：\"); int m; scanf(\"%d\", &amp;m); findAndKillK(head, k, m); return 0;&#125;","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"计算机基础/数据结构","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法导论","slug":"算法导论","permalink":"http://forwardpeng.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"线性表","slug":"线性表","permalink":"http://forwardpeng.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"}]},{"title":"SQL-函数","slug":"sql-函数","date":"2020-04-21T13:03:54.000Z","updated":"2020-04-21T13:53:18.427Z","comments":true,"path":"2020/04/21/sql-函数/","link":"","permalink":"http://forwardpeng.github.io/2020/04/21/sql-%E5%87%BD%E6%95%B0/","excerpt":"","text":"内建函数 Aggregate函数SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。有用的 Aggregate 函数： AVG()函数用于返回数值列的平均值语法格式：SELECT AVG(column_name) FROM table_name COUNT()函数COUNT() 函数返回匹配指定条件的行数。 SQL COUNT(column_name) 语法COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）：SELECT COUNT(column_name) FROM table_name; SQL COUNT(*) 语法COUNT(*) 函数返回表中的记录数：SELECT COUNT(*) FROM table_name; SQL COUNT(DISTINCT column_name) 语法COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：SELECT COUNT(DISTINCT column_name) FROM table_name; MAX()函数MAX()函数返回指定列的最大值。SQL MAX() 语法SELECT MAX(column_name) FROM table_name; MIN()函数MIN() 函数返回指定列的最小值。SELECT MIN(column_name) FROM table_name; SUM()函数SUM() 函数返回数值列的总数。SELECT SUM(column_name) FROM table_name; Scalar函数SQL Scalar 函数基于输入值，返回一个单一的值。 UCASE() 函数UCASE() 函数把字段的值转换为大写。SELECT UCASE(column_name) FROM table_name; LCASE() 函数LCASE()函数把字段的值转换为小写。SELECT LCASE(column_name) FROM table_name; MID() 函数MID()函数用于从文本字段中提取字符。SELECT MID(column_name,start[,length]) FROM table_name; LENGTH() 函数LENGTH() 函数返回文本字段中值的长度。SELECT LENGTH(column_name) FROM table_name; ROUND()函数ROUND() 函数用于把数值字段舍入为指定的小数位数。SELECT ROUND(column_name,decimals) FROM table_name; NOW()函数NOW() 函数返回当前系统的日期和时间。SELECT NOW() FROM table_name; FORMAT()函数FORMAT() 函数用于对字段的显示进行格式化。SELECT FORMAT(column_name,format) FROM table_name; 自定义函数自定义函数是一种与存储过程十分相似的过程式数据库对象。它与存储过程一样，都是由SQL语句和过程式语句组成的代码片段，并且可以被应用程序和其他SQL语句调用。自定义函数与存储过程之间存在几点区别：自定义函数不能拥有输出参数，这是因为自定义函数自身就是输出参数；而存储过程可以拥有输出参数。自定义函数中必须包含一条RETURN语句，而这条特殊的SQL语句不允许包含于存储过程中。可以直接对自定义函数进行调用而不需要使用CALL语句，而对存储过程的调用需要使用CALL语句。 创建并使用自定义函数使用 CREATE FUNCTION 语句创建自定义函数，语法格式如下：CREATE FUNCTION &lt;函数名&gt; ( [ &lt;参数1&gt; &lt;类型1&gt; [ , &lt;参数2&gt; &lt;类型2&gt;] ] … )RETURNS &lt;类型&gt;&lt;函数主体&gt;语法说明如下：&lt;函数名&gt;：指定自定义函数的名称。注意，自定义函数不能与存储过程具有相同的名称。&lt;参数&gt;&lt;类型&gt;：用于指定自定义函数的参数。这里的参数只有名称和类型，不能指定关键字 IN、OUT 和 INOUT。RETURNS&lt;类型&gt;：用于声明自定义函数返回值的数据类型。其中，&lt;类型&gt;用于指定返回值的数据类型。&lt;函数主体&gt;：自定义函数的主体部分，也称函数体。所有在存储过程中使用的 SQL 语句在自定义函数中同样适用，包括前面所介绍的局部变量、SET 语句、流程控制语句、游标等。除此之外，自定义函数体还必须包含一个 RETURN&lt;值&gt; 语句，其中&lt;值&gt;用于指定自定义函数的返回值。若要查看数据库中存在哪些自定义函数，可以使用 SHOW FUNCTION STATUS 语句；若要查看数据库中某个具体的自定义函数，可以使用 SHOW CREATE FUNCTION&lt;函数名&gt; 语句，其中&lt;函数名&gt;用于指定该自定义函数的名称注意：当使用 DELIMITER 命令时，应该避免使用反斜杠“\\”字符，因为反斜杠是 MySQL 的转义字符。函数调用的语法格式如下：SELECT &lt;自定义函数名&gt; ([&lt;参数&gt; [,…]])实例1：创建存储函数，名称为 StuNameById，该函数返回 SELECT 语句的查询结果，数值类型为字符串类型12345678910111213mysql&gt; CREATE FUNCTION StuNameById() -&gt; RETURNS VARCHAR(45) -&gt; RETURN -&gt; (SELECT name FROM tb_students_info WHERE id=1);Query OK, 0 rows affected (0.00 sec)# 调佣自定义函数mysql&gt; SELECT StuNameById();+---------------+| StuNameById() |+---------------+| peng |+---------------+1 row in set (0.00 sec) 修改自定义函数可以使用 ALTER FUNCTION 语句来修改自定义函数的某些相关特征。若要修改自定义函数的内容，则需要先删除该自定义函数，然后重新创建。 删除自定义函数语法格式：DROP FUNCTION [ IF EXISTS ] &lt;自定义函数名&gt;语法说明：&lt;自定义函数名&gt;：指定要删除的自定义函数的名称。IF EXISTS：指定关键字，用于防止因误删除不存在的自定义函数而引发错误。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-触发器","slug":"sql-触发器","date":"2020-04-21T10:16:10.000Z","updated":"2020-04-21T13:53:07.079Z","comments":true,"path":"2020/04/21/sql-触发器/","link":"","permalink":"http://forwardpeng.github.io/2020/04/21/sql-%E8%A7%A6%E5%8F%91%E5%99%A8/","excerpt":"","text":"触发器简介数据库中触发器是一个特殊的存储过程，不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，只要一个预定义的事件发生就会被 MySQL自动调用。引发触发器执行的事件一般如下：增加一条学生记录时，会自动检查年龄是否符合范围要求。每当删除一条学生信息时，自动删除其成绩表上的对应记录。每当删除一条数据时，在数据库存档表中保留一个备份副本。触发程序的优点：触发程序的执行是自动的，当对触发程序相关表的数据做出相应的修改后立即执行。触发程序可以通过数据库中相关的表层叠修改另外的表。触发程序可以实施比 FOREIGN KEY 约束、CHECK 约束更为复杂的检查和操作。1.INSERT触发器在 INSERT 语句执行之前或之后响应的触发器。使用 INSERT 触发器需要注意以下几点：在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。2.UPDATE触发器在UPDATE语句执行之前或之后响应的触发器。使用UPDATE触发器需要注意以下几点：在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。OLD中的值全部是只读的，不能被更新。注意：当触发器设计对触发表自身的更新操作时，只能使用 BEFORE 类型的触发器，AFTER 类型的触发器将不被允许。DELETE触发器DELETE 语句执行之前或之后响应的触发器。使用 DELETE 触发器需要注意以下几点:在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。OLD 中的值全部是只读的，不能被更新。总体来说，触发器使用的过程中，MySQL会按照以下方式来处理错误。若对于事务性表，如果触发程序失败，以及由此导致的整个语句失败，那么该语句所执行的所有更改将回滚；对于非事务性表，则不能执行此类回滚，即使语句失败，失败之前所做的任何更改依然有效。若 BEFORE 触发程序失败，则MySQL将不执行相应行上的操作。若在BEFORE或AFTER触发程序的执行过程中出现错误，则将导致调用触发程序的整个语句失败。仅当BEFORE触发程序和行操作均已被成功执行，MySQL才会执行AFTER触发程序。 创建触发器(CREATE TRIGGER)触发器是与MySQL数据表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性。语法格式：CREATE &lt;触发器名&gt; &lt; BEFORE | AFTER &gt;&lt;INSERT | UPDATE | DELETE &gt;ON &lt;表名&gt; FOR EACH Row&lt;触发器主体&gt;语法说明如下：1.触发器名：触发器的名称，触发器在当前数据库中必须具有唯一的名称。如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。2.INSERT | UPDATE | DELETE：触发事件，用于指定激活触发器的语句的种类。注意：三种触发器的执行时间如下。INSERT：将新行插入表时激活触发器。例如，INSERT的BEFORE触发器不仅能被MySQL的INSERT语句激活，也能被LOAD DATA 语句激活。DELETE： 从表中删除某一行数据时激活触发器，例如DELETE和REPLACE语句。UPDATE：更改表中某一行数据时激活触发器，例如UPDATE语句。3.BEFORE | AFTER：BEFORE 和 AFTER，触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。若希望验证新数据是否满足条件，则使用 BEFORE 选项；若希望在激活触发器的语句执行之后完成几个或更多的改变，则通常使用 AFTER 选项。4.表名：与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。在该表上触发事件发生时才会激活触发器。同一个表不能拥有两个具有相同触发时刻和事件的触发器。例如，对于一张数据表，不能同时有两个 BEFORE UPDATE 触发器，但可以有一个 BEFORE UPDATE 触发器和一个 BEFORE INSERT 触发器，或一个 BEFORE UPDATE 触发器和一个 AFTER UPDATE 触发器。5.触发器主体：触发器动作主体，包含触发器激活时将要执行的 MySQL 语句。如果要执行多个语句，可使用 BEGIN…END 复合语句结构。6.FOR EACH ROW：一般是指行级触发，对于受触发事件影响的每一行都要激活触发器的动作。例如，使用 INSERT 语句向某个表中插入多行数据时，触发器会对每一行数据的插入都执行相应的触发器动作。注意：每个表都支持 INSERT、UPDATE 和DELETE的BEFORE 与AFTER，因此每个表最多支持6个触发器。每个表的每个事件每次只允许有一个触发器。单一触发器不能与多个事件或多个表关联。 创建BEFORE类型触发器实例1：创建一个名为 SumOfSalary 的触发器，触发的条件是向数据表 tb_emp8 中插入数据之前，对新插入的 salary 字段值进行求和计算。123456789101112131415161718192021mysql&gt; CREATE TRIGGER SumOfSalary -&gt; BEFORE INSERT ON tb_emp8 -&gt; FOR EACH ROW -&gt; SET @sum=@sum+NEW.salary;Query OK, 0 rows affected (0.08 sec)mysql&gt; SET @sum=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; INSERT INTO tb_emp8 -&gt; VALUES(1,'A',1,1000),(2,'B',1,500);Query OK, 2 rows affected (0.04 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; SELECT @sum;+------+| @sum |+------+| 1500 |+------+1 row in set (0.00 sec) 创建AFTER类型触发器实例2：创建一个名为 double_salary 的触发器，触发的条件是向数据表 tb_emp6 中插入数据之后，再向数据表 tb_emp7 中插入相同的数据，并且 salary 为 tb_emp6 中新插入的 salary 字段值的 2 倍。输入的 SQL 语句和执行过程如下所示。123456789101112131415161718192021222324252627mysql&gt; CREATE TRIGGER double_salary -&gt; AFTER INSERT ON tb_emp6 -&gt; FOR EACH ROW -&gt; INSERT INTO tb_emp7 -&gt; VALUE (NEW.id, NEW.name, deptId, 2*NEW.salary);Query OK, 0 rows affected (0.09 sec)mysql&gt; insert into tb_emp6 values(1,'A',1,1000),(2,'B',1,500);Query OK, 2 rows affected (0.04 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; SELECT * FROM tb_emp6;+----+------+--------+--------+| id | name | deptId | salary |+----+------+--------+--------+| 1 | A | 1 | 1000 || 2 | B | 1 | 500 |+----+------+--------+--------+2 rows in set (0.00 sec)mysql&gt; SELECT * FROM tb_emp7;+----+------+--------+--------+| id | name | deptId | salary |+----+------+--------+--------+| 1 | A | NULL | 2000 || 2 | B | NULL | 1000 |+----+------+--------+--------+2 rows in set (0.00 sec) 修改和删除触发器(DROP TRIGGER)语法格式：DROP TRIGGER [ IF EXISTS ] [数据库名] &lt;触发器名&gt;语法说明：触发器名：要删除的触发器名称。数据库名：可选项。指定触发器所在的数据库的名称。若没有指定，则为当前默认的数据库。权限：执行 DROP TRIGGER 语句需要 SUPER 权限。IF EXISTS：避免在没有触发器的情况下删除触发器。注意：删除一个表的同时，也会自动删除该表上的触发器。另外，触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，再重新创建。 删除触发器实例：删除 double_salary 触发器。12345678910111213141516171819202122mysql&gt; INSERT INTO tb_emp6 -&gt; VALUES (3,'C', 1, 200);Query OK, 1 row affected (0.04 sec)mysql&gt; SELECT * FROm tb_emp6;+----+------+--------+--------+| id | name | deptId | salary |+----+------+--------+--------+| 1 | A | 1 | 1000 || 2 | B | 1 | 500 || 3 | C | 1 | 200 |+----+------+--------+--------+3 rows in set (0.01 sec)mysql&gt; SELECT * FROm tb_emp7;+----+------+--------+--------+| id | name | deptId | salary |+----+------+--------+--------+| 1 | A | NULL | 2000 || 2 | B | NULL | 1000 |+----+------+--------+--------+2 rows in set (0.00 sec)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-存储","slug":"sql-存储","date":"2020-04-21T09:11:25.000Z","updated":"2020-04-21T13:53:12.271Z","comments":true,"path":"2020/04/21/sql-存储/","link":"","permalink":"http://forwardpeng.github.io/2020/04/21/sql-%E5%AD%98%E5%82%A8/","excerpt":"","text":"存储引擎 什么是存储引擎数据库存储引擎是数据库底层软件组件，数据库管理系统使用数据引擎进行创建、查询、更新和删除数据操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎还可以获得特定的功能。InnoDB 事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键。MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。MyISAM 是基于 ISAM 的存储引擎，并对其进行扩展，是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事务MEMORY 存储引擎将表中的数据存储到内存中，为查询和引用其他数据提供快速访问。 MySQL 5.7 支持的存储引擎MySQL 5.7 支持的存储引擎有 InnoDB、MyISAM、Memory、Merge、Archive、Federated、CSV、BLACKHOLE 等。可以使用SHOW ENGINES语句查看系统所支持的引擎类型，结果如下：12345678910111213141516mysql&gt; SHOW ENGINES;+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| Engine | Support | Comment | Transactions | XA | Savepoints |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+| InnoDB | DEFAULT | Supports transactions, row-level locking, and foreign keys | YES | YES | YES || MRG_MYISAM | YES | Collection of identical MyISAM tables | NO | NO | NO || MEMORY | YES | Hash based, stored in memory, useful for temporary tables | NO | NO | NO || BLACKHOLE | YES | /dev/null storage engine (anything you write to it disappears) | NO | NO | NO || MyISAM | YES | MyISAM storage engine | NO | NO | NO || CSV | YES | CSV storage engine | NO | NO | NO || ARCHIVE | YES | Archive storage engine | NO | NO | NO || PERFORMANCE_SCHEMA | YES | Performance Schema | NO | NO | NO || FEDERATED | NO | Federated MySQL storage engine | NULL | NULL | NULL |+--------------------+---------+----------------------------------------------------------------+--------------+------+------------+9 rows in set (0.00 sec)# Support 列的值表示某种引擎是否能使用，YES表示可以使用，NO表示不能使用，DEFAULT表示该引擎为当前默认的存储引擎 选择MySQL存储引擎不同的存储引擎都有各自的特点，以适应不同的需求。功能MyISAMMEMORYInnoDBArchive存储限制256TBRAM64TBNone支持事务NoNoYesNo支持全文索引YesNoNoNo支持树索引YesYesYesNo支持哈希索引NoYesNoNo支持数据缓存NoN/AYesNo支持外键NoNoYesNo选择MySQL存储引擎：如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 是一个很好的选择。如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。如果只有 INSERT 和 SELECT 操作，可以选择Archive 引擎，Archive 存储引擎支持高并发的插入操作，但是本身并不是事务安全的。Archive 存储引擎非常适合存储归档数据，如记录日志信息可以使用 Archive 引擎修改数据库临时的默认存储引擎:SET default_storage_engine=&lt; 存储引擎名 &gt; 存储过程简介存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成。优点如下：1.封装性存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。2.可增强 SQL 语句的功能和灵活性存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。3.可减少网络流量由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。4.高性能存储过程执行一次后，产生的二进制代码就驻留在缓冲区，在以后的调用中，只需要从缓冲区中执行二进制代码即可，从而提高了系统的效率和性能。5.提高数据库的安全性和数据完整性使用存储过程可以完成所有数据库操作，并且可以通过编程的方式控制数据库信息访问的权限。 创建存储过程(CREATE PROCEDURE)使用 CREATE PROCEDURE 语句创建存储过程，语法格式如下：CREATE PROCEDURE &lt;过程名&gt; ( [过程参数[,…] ] ) &lt;过程体&gt;[过程参数[,…] ] 格式[ IN | OUT | INOUT ] &lt;参数名&gt; &lt;类型&gt;语法说明如下：1.过程名存储过程的名称，默认在当前数据库中创建。若需要在特定数据库中创建存储过程，则要在名称前面加上数据库的名称，即 db_name.sp_name。需要注意的是，名称应当尽量避免选取与 MySQL 内置函数相同的名称，否则会发生错误。3.过程参数存储过程的参数列表。其中，&lt;参数名&gt;为参数名，&lt;类型&gt;为参数的类型（可以是任何有效的 MySQL 数据类型）。当有多个参数时，参数列表中彼此间用逗号分隔。存储过程可以没有参数（此时存储过程的名称后仍需加上一对括号），也可以有 1 个或多个参数。MySQL 存储过程支持三种类型的参数，即输入参数、输出参数和输入/输出参数，分别用 IN、OUT 和 INOUT 三个关键字标识。其中，输入参数可以传递给一个存储过程，输出参数用于存储过程需要返回一个操作结果的情形，而输入/输出参数既可以充当输入参数也可以充当输出参数。需要注意的是，参数的取名不要与数据表的列名相同，否则尽管不会返回出错信息，但是存储过程的 SQL 语句会将参数名看作列名，从而引发不可预知的结果。3.过程体存储过程的主体部分，也称为存储过程体，包含在过程调用的时候必须执行的 SQL 语句。这个部分以关键字 BEGIN 开始，以关键字 END 结束。若存储过程体中只有一条SQL语句，则可以省略BEGIN-END标志。通常可使用 DELIMITER 命令将结束命令修改为其他字符。语法格式：DELIMITER $$语法说明：$$ 是用户定义的结束符，通常这个符号可以是一些特殊的符号，如两个“?”或两个“￥”等。当使用 DELIMITER 命令时，应该避免使用反斜杠“\\”字符，因为它是MySQL的转义字符。DELIMITER 和分号“;”之间一定要有一个空格。在创建存储过程时，必须具有 CREATE ROUTINE 权限。可以使用 SHOW PROCEDURE STATUS 命令查看数据库中存在哪些存储过程，若要查看某个存储过程的具体信息，则可以使用 SHOW CREATE PROCEDURE &lt;存储过程名&gt;。 创建不带参数的存储过程实例1：创建名称为 ShowStuScore 的存储过程，存储过程的作用是从学生成绩信息表中查询学生的成绩信息123456789101112131415161718192021222324mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE ShowStuScore() -&gt; BEGIN -&gt; SELECT * FROM tb_students_score; -&gt; END //Query OK, 0 rows affected (0.05 sec)mysql&gt; DELIMITER ;mysql&gt; CALL ShowStuScore();+----+--------------+---------------+| id | student_name | student_score |+----+--------------+---------------+| 1 | Dany | 90 || 2 | Green | 99 || 3 | Henry | 95 || 4 | Jane | 98 || 5 | Jim | 88 || 6 | John | 94 || 7 | Lily | 100 || 8 | Susan | 96 || 9 | Thomas | 93 |+----+--------------+---------------+9 rows in set (0.00 sec)Query OK, 0 rows affected (0.00 sec) 创建带参数的存储过程实例2：创建名称为 GetScoreByStu 的存储过程，输入参数是学生姓名。存储过程的作用是通过输入的学生姓名从学生成绩信息表中查询指定学生的成绩信息。1234567891011121314151617mysql&gt; DELIMITER //mysql&gt; CREATE PROCEDURE GetScoreByStu -&gt; (IN name VARCHAR(30)) -&gt; BEGIN -&gt; SELECT student_score FROM tb_students_score -&gt; WHERE student_name=name; -&gt; END //Query OK, 0 rows affected (0.00 sec)mysql&gt; CALL GetScoreByStu('Lily');+---------------+| student_score |+---------------+| 100 |+---------------+1 row in set (0.00 sec)Query OK, 0 rows affected (0.00 sec) 修改存储过程(ALTE PROCEDURE)通过 ALTER PROCEDURE 语句来修改存储过程，语法格式如下：ALTER PROCEDURE 存储过程名[特征…]特征指定存储过程的特征，可能取值有：CONTAINS SQL 表示子程序包含 SQL 语句，但不包含读或写数据的语句。NO SQL 表示子程序中不包含 SQL 语句。READS SQL DATA 表示子程序中包含读数据的语句。MODIFIES SQL DATA 表示子程序中包含写数据的语句。SQL SECURITY { DEFINER |INVOKER } 指明谁有权限来执行。DEFINER 表示只有定义者自己才能够执行。INVOKER 表示调用者可以执行。COMMENT ‘string’ 表示注释信息。实例1：修改存储过程 showstuscore 的定义，将读写权限改为 MODIFIES SQL DATA。123456789101112131415161718mysql&gt; ALTER PROCEDURE showstuscore MODIFIES SQL DATA SQL SECURITY INVOKER;Query OK, 0 rows affected (0.00 sec)mysql&gt; SHOW CREATE PROCEDURE showstuscore \\G*************************** 1. row *************************** Procedure: showstuscore sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION Create Procedure: CREATE DEFINER=`root`@`localhost` PROCEDURE `showstuscore`() MODIFIES SQL DATA SQL SECURITY INVOKERBEGINSELECT * FROM tb_students_score;ENDcharacter_set_client: utf8collation_connection: utf8_general_ci Database Collation: utf8_general_ci1 row in set (0.00 sec)# 访问数据的权限已经变成了 MODIFIES SQL DATA，安全类型也变成了 INVOKE。提示：ALTER PROCEDURE 语句用于修改存储过程的某些特征。如果要修改存储过程的内容，可以先删除原存储过程，再以相同的命名创建新的存储过程；如果要修改存储过程的名称，可以先删除原存储过程，再以不同的命名创建新的存储过程。 删除存储过程(DROP PROCEDURE)使用 DROP PROCEDURE 语句来删除数据库中已经存在的存储过程。语法格式如下：DROP {PROCEDURE | FUNCTION}[IF EXISTS] &lt;过程名&gt;语法说明如下：过程名：指定要删除的存储过程的名称。IF EXISTS：指定这个关键字，用于防止因删除不存在的存储过程而引发的错误。注意：存储过程名称后面没有参数列表，也没有括号，在删除之前，必须确认该存储过程没有任何依赖关系，否则会导致其他与之关联的存储过程无法运行。实例1：删除存储过程 showstuscore，删除后，可以通过查询 information_schema 数据库下的 routines 表来确认上面的删除是否成功。1234mysql&gt; DROP PROCEDURE showstuscore;Query OK, 0 rows affected (0.00 sec)mysql&gt; SELECT * FROM information_schema.routines WHERE routine_name='showstuscore';Empty set (0.03 sec)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-主键及约束","slug":"sql-主键及约束","date":"2020-04-21T05:14:36.000Z","updated":"2020-04-21T13:53:33.060Z","comments":true,"path":"2020/04/21/sql-主键及约束/","link":"","permalink":"http://forwardpeng.github.io/2020/04/21/sql-%E4%B8%BB%E9%94%AE%E5%8F%8A%E7%BA%A6%E6%9D%9F/","excerpt":"","text":"主键(PRIMARY KEY)主键约束是一个列或者列的组合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键，通过它可以强制表的实体完整性。 选取设置主键约束的字段主键约束即在表中定义一个主键来唯一确定表中每一行数据的标识符。主键可以是表中的某一列或者多列的组合，其中由多列组合的主键称为复合主键。主键应该遵守下面的规则：每个表只能定义一个主键。主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在两行数据有相同的主键值。这是唯一性原则。一个列名只能在复合主键列表中出现一次。复合主键不能包含不必要的多余列。当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。这是最小化原则。 在创建表时设置主键约束在 CREATE TABLE 语句中，主键是通过 PRIMARY KEY 关键字来指定的。语法规则：&lt;字段名&gt; &lt;数据类型&gt; PRIMARY KEY [默认值]实例1：在 test_db 数据库中创建 tb_emp 3 数据表，其主键为 id1234567891011121314151617181920mysql&gt; CREATE TABLE tb_emp3 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT -&gt; );Query OK, 0 rows affected (0.37 sec)mysql&gt; DESC tb_emp3 -&gt; ;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)指定主键的语法格式：[CONSTRAINT &lt;约束名&gt;] PRIMARY KEY [字段名]实例2：在 test_db 数据库中创建 tb_emp 4 数据表，其主键为 id1234567891011121314151617181920mysql&gt; CREATE TABLE tb_emp4 -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT, -&gt; PRIMARY KEY(id) -&gt; );Query OK, 0 rows affected (0.34 sec)mysql&gt; DESC tb_emp4;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 在创建表时设置复合主键主键由多个字段联合组成，语法规则如下：PRIMARY KEY [字段1，字段2，…,字段n]实例3：创建数据表 tb_emp5，假设表中没有主键 id，为了唯一确定一个员工，可以把 name、deptId 联合起来作为主键。123456789101112mysql&gt; CREATE TABLE tb_emp5 ( name VARCHAR(25), deptId INT(11), salary FLOAT, PRIMARY KEY(name, deptId) );Query OK, 0 rows affected (0.26 sec)mysql&gt; DESC tb_emp5;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| name | varchar(25) | NO | PRI | NULL | || deptId | int(11) | NO | PRI | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 在修改表时添加主键约束修改数据表时添加主键约束的语法规则为：ALTER TABLE &lt;数据表名&gt; ADD PRIMARY KEY(&lt;列名&gt;);实例4：修改数据表 tb_emp2，将字段 id 设置为主键。1234567891011121314mysql&gt; ALTER TABLE tb_emp3 ADD PRIMARY KEY(id);Query OK, 0 rows affected (0.41 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_emp3;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 外键约束(FOREIGN KEY)外键约束（FOREIGN KEY）用来在两个表的数据之间建立链接，它可以是一列或者多列。一个表可以有一个或多个外键。外键对应的是参照完整性，一个表的外键可以为空值，若不为空值，则每一个外键的值必须等于另一个表中主键的某个值。外键是表的一个字段，不是本表的主键，但对应另一个表的主键。定义外键后，不允许删除另一个表中具有关联关系的行。外键的主要作用是保持数据的一致性、完整性。例如，部门表 tb_dept 的主键是 id，在员工表 tb_emp5 中有一个键 deptId 与这个 id 关联。主表（父表）：对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表。从表（子表）：对于两个具有关联关系的表而言，相关联字段中外键所在的表就是从表。 选取设置MySQL外键约束的字段定义一个外键时，需要遵守下列规则:父表必须已经存在于数据库中，或者是当前正在创建的表。如果是后一种情况，则父表与子表是同一个表，这样的表称为自参照表，这种结构称为自参照完整性。必须为父表定义主键。主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的。在父表的表名后面指定列名或列名的组合。这个列或列的组合必须是父表的主键或候选键。外键中列的数目必须和父表的主键中列的数目相同。外键中列的数据类型必须和父表主键中对应列的数据类型相同。 在创建表时设置外键约束在数据表中创建外键使用 FOREIGN KEY 关键字，具体的语法规则如下：[CONSTRAINT &lt;外键名&gt;] FOREIGN KEY 字段名 [，字段名2，…]REFERENCES &lt;主表名&gt; 主键列1 [，主键列2，…]其中：外键名为定义的外键约束的名称，一个表中不能有相同名称的外键；字段名表示子表需要添加外健约束的字段列；主表名即被子表外键所依赖的表的名称；主键列表示主表中定义的主键列或者列组合。实例1：在 test_db 数据库中创建一个部门表 tb_dept1,表结构如下：字段名称数据类型备注idINT(11)部门编号nameVARCHAR(22)部门名称locationVARCHAR(22)部门位置12345678910111213141516171819202122# 创建tb_dept1的SQL语句mysql&gt; CREATE TABLE tb_dept1 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22) NOT NULL, -&gt; location VARCHAR(50) -&gt; );Query OK, 0 rows affected (0.27 sec)# 创建数据表 tb_emp6，并在表 tb_emp6 上创建外键约束，让它的键 deptId 作为外键关联到表 tb_dept1 的主键 idmysql&gt; CREATE TABLE tb_emp6 ( id INT(11) PRIMARY KEY, name VARCHAR(25), deptId INT(11), salary FLOAT, CONSTRAINT fk_emp_dept1 FOREIGN KEY(deptId) REFERENCES tb_dept1(id) );Query OK, 0 rows affected (0.32 sec)mysql&gt; DESC tb_emp6;+--------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+--------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(25) | YES | | NULL | || deptId | int(11) | YES | MUL | NULL | || salary | float | YES | | NULL | |+--------+-------------+------+-----+---------+-------+4 rows in set (0.01 sec提示：关联指的是关系数据库中，相关表之间的联系。它是通过相同的属性或属性组来表示的。子表的外键必须关联父表的主键，且关联字段的数据类型必须匹配，如果类型不一样，则创建子表时会出现错误“ERROR 1005(HY000)：Can’t create table’database.tablename’(errno：150)” 在修改表时添加外键约束语法规则：ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;索引名&gt;FOREIGN KEY(&lt;列名&gt;) REFERENCES &lt;主表名&gt; (&lt;列名&gt;);实例2：修改数据表 tb_emp2，将字段 deptId 设置为外键，与数据表 tb_dept1 的主键 id 进行关联123456mysql&gt; ALTER TABLE tb_emp3 ADD CONSTRAINT fk_tb_dept1 FOREIGN KEY(deptId) REFERENCES tb_dept1(id);Query OK, 0 rows affected (0.70 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; ALTER TABLE tb_emp3 ADD CONSTRAINT fk_tb_dept1 FOREIGN KEY(deptId) REFERENCES tb_dept1(id);Query OK, 0 rows affected (0.70 sec)Records: 0 Duplicates: 0 Warnings: 0 删除外键约束对于数据库中定义的外键，如果不再需要，可以将其删除。外键一旦删除，就会解除主表和从表间的关联关系，MySQL 中删除外键的语法格式如下：ALTER TABLE &lt;表名&gt; DROP FOREIGN KEY &lt;外键约束名&gt;;实例3：删除数据表 tb_emp2 中的外键约束 fk_tb_dept1。1234567891011121314151617mysql&gt; ALTER TABLE tb_emp3 -&gt; DROP FOREIGN KEY fk_tb_dept1;Query OK, 0 rows affected (0.05 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; SHOW CREATE TABLE tb_emp3\\G*************************** 1. row *************************** Table: tb_emp3Create Table: CREATE TABLE `tb_emp3` ( `id` int(11) NOT NULL, `name` varchar(25) DEFAULT NULL, `deptId` int(11) DEFAULT NULL, `salary` float DEFAULT NULL, PRIMARY KEY (`id`), KEY `fk_tb_dept1` (`deptId`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) 唯一约束(UNIQUE KEY)唯一约束（Unique Key）要求该列唯一，允许为空，但只能出现一个空值。唯一约束可以确保一列或者几列不出现重复值。 创建表时设置唯一约束定义完列之后直接使用 UNIQUE 关键字指定唯一约束，语法规则如下：&lt;字段名&gt; &lt;数据类型&gt; UNIQUE实例1：创建数据表 tb_dept2，指定部门的名称唯一。1234567891011121314151617mysql&gt; CREATE TABLE tb_dept2 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22) UNIQUE, -&gt; location VARCHAR(50) -&gt; );Query OK, 0 rows affected (0.42 sec)mysql&gt; DESC tb_dept2;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | YES | UNI | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)UNIQUE 和 PRIMARY KEY 的区别：一个表可以有多个字段声明为 UNIQUE，但只能有一个 PRIMARY KEY 声明；声明为 PRIMAY KEY 的列不允许有空值，但是声明为 UNIQUE 的字段允许空值的存在。 在修改表时添加唯一约束修改表添加唯一约束的语法格式为：ALTER TABLE &lt;数据表名&gt; ADD CONSTRAINT &lt;唯一约束名&gt; UNIQUE(&lt;列名&gt;);实例2：修改数据表 tb_dept1，指定部门的名称唯一1234567891011121314mysql&gt; ALTER TABLE tb_dept1 -&gt; ADD CONSTRAINT unique_name UNIQUE(name);Query OK, 0 rows affected (0.22 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept1;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | UNI | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 删除唯一约束语法格式：ALTER TABLE &lt;表名&gt; DROP INDEX &lt;唯一约束名&gt;;实例3：删除数据表 tb_dept1 中的唯一约束 unique_name。1234567891011121314mysql&gt; ALTER TABLE tb_dept1 -&gt; DROP INDEX unique_name;Query OK, 0 rows affected (0.50 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept1;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 检查约束(CHECK)检查约束（CHECK）可以通过CREATE TABLE或ALTER TABLE语句实现，根据用户实际的完整性要求来定义。它可以分别对列或表实施 CHECK 约束。 选取设置检查约束的字段检查约束使用 CHECK 关键字，具体的语法格式如下：CHECK &lt;表达式&gt;其中：&lt;表达式&gt;指的就是 SQL 表达式，用于指定需要检查的限定条件。若将 CHECK 约束子句置于表中某个列的定义之后，则这种约束也称为基于列的 CHECK 约束。在更新表数据的时候，系统会检查更新后的数据行是否满足 CHECK 约束中的限定条件。MySQL 可以使用简单的表达式来实现 CHECK 约束，也允许使用复杂的表达式作为限定条件，例如在限定条件中加入子查询。将 CHECK 约束子句置于所有列的定义以及主键约束和外键定义之后，则这种约束也称为基于表的 CHECK 约束。该约束可以同时对表中多个列设置限定条件。 创建表时设置检测约束语法规则：CHECK(&lt;检查约束&gt;)实例1：在 test_db 数据库中创建 tb_emp7 数据表，要求 salary 字段值大于 0 且小于 1000012345678mysql&gt; CREATE TABLE tb_emp7 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT, -&gt; CHECK(salary&gt;0 AND salary&lt;100),FOREIGN KEY(deptId) REFERENCES tb_dept1(id));Query OK, 0 rows affected (0.28 sec) 修改表时添加检查约束语法规则：ALTER TABLE tb_emp7 ADD CONSTRAINT &lt;检查约束名&gt; CHECK(&lt;检查约束&gt;)实例2：修改 tb_dept 数据表，要求 id 字段值大于 012345mysql&gt; ALTER TABLE tb_emp7 -&gt; ADD CONSTRAINT check_id -&gt; CHECK(id&gt;0);Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0 删除检查约束语法规则：ALTER TABLE &lt;数据表名&gt; DROP CONSTRAINT &lt;检查约束名&gt;; 默认值约束(DEFAULT)默认值约束用来指定某列的默认值。 创建表时设置默认值约束创建表时可以使用 DEFAULT 关键字设置默认值约束，具体的语法规则如下：&lt;字段名&gt; &lt;数据类型&gt; DEFAULT &lt;默认值&gt;;实例1：创建数据表 tb_dept3，指定部门位置默认为 Beijing12345678910111213141516mysql&gt; CREATE TABLE tb_dept3 -&gt; ( -&gt; id INT(11) PRIMARY KEY, -&gt; name VARCHAR(22), -&gt; location VARCHAR(50) DEFAULT 'Beijing');Query OK, 0 rows affected (0.26 sec)mysql&gt; DESC tb_dept3;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | YES | | NULL | || location | varchar(50) | YES | | Beijing | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 修改表时添加默认值约束语法规则：ALTER TABLE&lt;数据表名&gt; CHANGE COLUMN&lt;字段名&gt;&lt;数据类型&gt;DEFAULT&lt;默认值&gt;实例2：修改数据表 tb_dept3，将部门位置的默认值修改为 Shanghai。123456789101112131415mysql&gt; ALTER TABLE tb_dept3 -&gt; CHANGE COLUMN location -&gt; location VARCHAR(50) DEFAULT 'Shanghai';Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept3;+----------+-------------+------+-----+----------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+----------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | YES | | NULL | || location | varchar(50) | YES | | Shanghai | |+----------+-------------+------+-----+----------+-------+3 rows in set (0.00 sec) 删除默认值约束修改表时删除默认值约束的语法规则如下：ALTER TABLE &lt;数据库名&gt;CHANGE COLUMN &lt;字段名&gt;&lt;字段名&gt;&lt;数据类型&gt; DEFAULT NULL;实例3：修改数据表 tb_dept3，将部门位置的默认值约束删除。123456789101112mysql&gt; ALTER TABLE tb_dept3 CHANGE COLUMN location location VARCHAR(50) DEFAULT NULL;Query OK, 0 rows affected (0.03 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept3; +----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | YES | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 非空约束(NOT NULL)非空约束可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空。非空约束（Not Null Constraint）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。 创建表时设置非空约束创建表时可以使用 NOT NULL 关键字设置非空约束，具体的语法规则如下：&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;实例1：创建数据表 tb_dept4，指定部门名称不能为空。123456789101112mysql&gt; CREATE TABLE tb_dept4 -&gt; (id INT(11) PRIMARY KEY, name VARCHAR(22) NOT NULL, location VARCHAR(50));Query OK, 0 rows affected (0.36 sec)mysql&gt; DESC tb_dept4;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 修改表时添加非空约束语法规则：ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt;&lt;字段名&gt; &lt;数据类型&gt; NOT NULL;实例2：修改数据表 tb_dept4，指定部门位置不能为空。123456789101112131415mysql&gt; ALTER TABLE tb_dept4 -&gt; CHANGE COLUMN location -&gt; location VARCHAR(50) NOT NULL;Query OK, 0 rows affected (0.62 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept4;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | NO | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 删除非空约束语法规则：ALTER TABLE &lt;数据表名&gt;CHANGE COLUMN &lt;字段名&gt; &lt;字段名&gt; &lt;数据类型&gt; NULL;实例3：修改数据表 tb_dept4，将部门位置的非空约束删除。123456789101112131415mysql&gt; ALTER TABLE tb_dept4 -&gt; CHANGE COLUMN location -&gt; location VARCHAR(50) NULL;Query OK, 0 rows affected (0.49 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC tb_dept4;+----------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| id | int(11) | NO | PRI | NULL | || name | varchar(22) | NO | | NULL | || location | varchar(50) | YES | | NULL | |+----------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec) 查看表中的约束语法格式：SHOW CREATE TABLE &lt;数据表名&gt;;12345678910mysql&gt; SHOW CREATE TABLe tb_dept4\\G*************************** 1. row *************************** Table: tb_dept4Create Table: CREATE TABLE `tb_dept4` ( `id` int(11) NOT NULL, `name` varchar(22) NOT NULL, `location` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-视图","slug":"sql-视图","date":"2020-04-21T02:40:40.000Z","updated":"2020-04-21T13:53:24.007Z","comments":true,"path":"2020/04/21/sql-视图/","link":"","permalink":"http://forwardpeng.github.io/2020/04/21/sql-%E8%A7%86%E5%9B%BE/","excerpt":"","text":"视图简介视图是一个虚拟表，其内容由查询定义。同真实表一样，视图包含一系列带有名称的列和行数据，但视图并不是数据库真实存储的数据表。视图是从一个、多个表或者视图中导出的表，包含一系列带有名称的数据列和若干条数据行。视图并不同于数据表，它们的区别在于以下几点：视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。视图的建立和删除只影响视图本身，不影响对应的基本表。视图与表在本质上虽然不相同，但视图经过定义以后，结构形式和表一样，可以进行查询、修改、更新和删除等操作。同时，视图具有如下优点：1.定制用户数据，聚焦特定的数据在实际的应用过程中，不同的用户可能对不同的数据有不同的要求。例如，当数据库同时存在时，如学生基本信息表、课程表和教师信息表等多种表同时存在时，可以根据需求让不同的用户使用各自的数据。学生查看修改自己基本信息的视图，安排课程人员查看修改课程表和教师信息的视图，教师查看学生信息和课程信息表的视图。2.简化数据操作在使用查询时，很多时候要使用聚合函数，同时还要显示其他字段的信息，可能还需要关联到其他表，语句可能会很长，如果这个动作频繁发生的话，可以创建视图来简化操作。3.提高基表数据的安全性视图是虚拟的，物理上是不存在的。可以只授予用户视图的权限，而不具体指定使用表的权限，来保护基础数据的安全。4.共享所需数据通过使用视图，每个用户不必都定义和存储自己所需的数据，可以共享数据库中的数据，同样的数据只需要存储一次。5.更改数据格式通过使用视图，可以重新格式化检索出的数据，并组织输出到其他应用程序中。6.重用SQL语句视图提供的是对查询操作的封装，本身不包含数据，所呈现的数据是根据视图定义从基础表中检索出来的，如果基础表的数据新增或删除，视图呈现的也是更新后的数据。视图定义后，编写完所需的查询，可以方便地重用该视图。注意：要区别视图和数据表的本质，即视图是基于真实表的一张虚拟的表，其数据来源均建立在真实表的基础上。创建视图需要足够的访问权限。创建视图的数目没有限制。视图可以嵌套，即从其他视图中检索数据的查询来创建视图。视图不能索引，也不能有关联的触发器、默认值或规则。视图可以和表一起使用。视图不包含数据，所以每次使用视图时，都必须执行查询中所需的任何一个检索操作。如果用多个连接和过滤条件创建了复杂的视图或嵌套了视图，可能会发现系统运行性能下降得十分严重。因此，在部署大量视图应用时，应该进行系统测试。 创建视图(CREATE VIEW)视图可以建立在一张表中，也可以建立在多张表中。 基本语法使用CREATE VIEW 语句来创建视图语法格式：CREATE VIEW&lt;视图名&gt;AS&lt;SELECT语句&gt;语法说明如下：&lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。&lt;SELECT语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。对于创建视图中的SELECT语句存在以下限制：用户除了拥有 CREATE VIEW 权限外，还具有操作中涉及的基础表和其他视图的相关权限。SELECT语句不能引用系统或用户变量。SELECT语句不能包含 FROM子句中的子查询。SELECT语句不能引用预处理语句参数。视图定义中引用的表或视图必须存在。但是，创建完视图后，可以删除定义引用的表或视图。可使用 CHECK TABLE 语句检查视图定义是否存在这类问题。视图定义中允许使用 ORDER BY 语句，但是若从特定视图进行选择，而该视图使用了自己的 ORDER BY 语句，则视图定义中的 ORDER BY 将被忽略。视图定义中不能引用TEMPORARY表（临时表），不能创建TEMPORARY视图。WITH CHECK OPTION 的意思是，修改视图时，检查插入的数据是否符合 WHERE 设置的条件。 创建基于单表的视图实例1：在单个数据表上创建视图。在 tb_students_info 表上创建一个名为 view_students_info 的视图123456789101112131415mysql&gt; CREATE VIEW view_students_info -&gt; AS SELECT * FROM tb_students_info;Query OK, 0 rows affected (0.04 sec)mysql&gt; SELECT * FROM view_students_info;+----+------+---------+------+------+--------+---------------------+| id | name | dept_id | age | sex | height | login_date |+----+------+---------+------+------+--------+---------------------+| 1 | peng | 2 | 25 | F | 222 | 1000-01-01 00:00:00 || 2 | jun | 2 | 12 | F | 222 | 1000-01-01 00:00:01 || 3 | Gui | 1 | 44 | M | 170 | 1000-01-01 00:00:01 || 4 | Feng | 2 | 32 | F | 175 | 1000-01-01 00:00:01 || 5 | Qi | 0 | 22 | M | 170 | 1000-01-01 00:00:01 |+----+------+---------+------+------+--------+---------------------+5 rows in set (0.00 sec)实例2：在 tb_students_info 表上创建一个名为 v_students_info 的视图。1234567891011121314mysql&gt; CREATE VIEW v_students_info (s_id, s_name, d_id, s_age, s_sex, s_height, s_date) AS SELECT id, name, dept_id, age, sex, height, login_date FROM tb_students_info;Query OK, 0 rows affected (0.03 sec)mysql&gt; SELECT * FROM v_students_info;+------+--------+------+-------+-------+----------+---------------------+| s_id | s_name | d_id | s_age | s_sex | s_height | s_date |+------+--------+------+-------+-------+----------+---------------------+| 1 | peng | 2 | 25 | F | 222 | 1000-01-01 00:00:00 || 2 | jun | 2 | 12 | F | 222 | 1000-01-01 00:00:01 || 3 | Gui | 1 | 44 | M | 170 | 1000-01-01 00:00:01 || 4 | Feng | 2 | 32 | F | 175 | 1000-01-01 00:00:01 || 5 | Qi | 0 | 22 | M | 170 | 1000-01-01 00:00:01 |+------+--------+------+-------+-------+----------+---------------------+5 rows in set (0.01 sec) 创建基于多表的视图可以在两个以上的表中创建视图，使用 CREATE VIEW 语句创建。 查询视图视图一经定义之后，就可以如同查询数据表一样，使用 SELECT 语句查询视图中的数据，语法和查询基础表的数据一样。主要应用在以下几个方面：使用视图重新格式化检索出的数据使用视图简化复杂的表连接使用视图过滤数据语法格式：DESCRIBE 视图名；实例3：DESCRIBE 语句查看视图 v_students_info 的定义12345678910111213mysql&gt; DESC v_students_info;+----------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+-------+| s_id | int(11) | NO | | NULL | || s_name | varchar(255) | YES | | NULL | || d_id | int(11) | YES | | NULL | || s_age | int(11) | YES | | NULL | || s_sex | char(10) | YES | | NULL | || s_height | int(11) | YES | | NULL | || s_date | datetime | YES | | NULL | |+----------+--------------+------+-----+---------+-------+7 rows in set (0.00 sec) 修改视图(ALTER VIEW)修改数据库中存在的视图，当基本表的某些字段发生变化时，可以通过修改视图来保持与基本表的一致性。语法格式：ALTER VIEW &lt;视图名&gt; AS &lt;SELECT语句&gt;语法说明：&lt;视图名&gt;：指定视图的名称。该名称在数据库中必须是唯一的，不能与其他表或视图同名。&lt;SELECT 语句&gt;：指定创建视图的 SELECT 语句，可用于查询多个基础表或源视图。对于 ALTER VIEW 语句的使用，需要用户具有针对视图的 CREATE VIEW 和 DROP 权限，以及由 SELECT 语句选择的每一列上的某些权限。 修改视图内容视图是一个虚拟表，实际的数据来自于基本表，所以通过插入、修改和删除操作更新视图中的数据，实质上是在更新视图所引用的基本表的数据。某些视图是可更新的。也就是说，可以使用 UPDATE、DELETE 或 INSERT 等语句更新基本表的内容。对于可更新的视图，视图中的行和基本表的行之间必须具有一对一的关系对视图的修改就是对基本表的修改，因此在修改时，要满足基本表的数据定义视图包含以下结构中的任何一种，它就是不可更新的：聚合函数 SUM()、MIN()、MAX()、COUNT() 等。DISTINCT 关键字。GROUP BY 子句。HAVING 子句。UNION 或 UNION ALL 运算符。位于选择列表中的子查询。FROM 子句中的不可更新视图或包含多个表。WHERE 子句中的子查询，引用 FROM 子句中的表。ALGORITHM 选项为 TEMPTABLE（使用临时表总会使视图成为不可更新的）的时候。实例1：使用 ALTER 语句修改视图 view_students_info。123456789101112131415mysql&gt; ALTER VIEW view_students_info -&gt; AS SELECT id,name,age -&gt; FROM tb_students_info;Query OK, 0 rows affected (0.03 sec)mysql&gt; DESC view_students_info;+-------+--------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+--------------+------+-----+---------+-------+| id | int(11) | NO | | NULL | || name | varchar(255) | YES | | NULL | || age | int(11) | YES | | NULL | |+-------+--------------+------+-----+---------+-------+3 rows in set (0.01 sec)# 用户可以通过视图来插入、更新、删除表中的数据，因为视图是一个虚拟的表，没有数据。通过视图更新时转到基本表上进行更新，如果对视图增加或删除记录，实际上是对基本表增加或删除记录。实例2：使用 UPDATE 语句更新视图 view_students_info。12345678910111213141516mysql&gt; UPDATE view_students_info -&gt; SET age=25 WHERE id=1;Query OK, 0 rows affected (0.05 sec)Rows matched: 1 Changed: 0 Warnings: 0mysql&gt; SELECT * FROM view_students_info;+----+------+------+| id | name | age |+----+------+------+| 1 | peng | 25 || 2 | jun | 12 || 3 | Gui | 44 || 4 | Feng | 32 || 5 | Qi | 22 |+----+------+------+5 rows in set (0.00 sec)修改视图的名称可以先将视图删除，然后按照相同的定义语句进行视图的创建，并命名为新的视图名称。 删除视图(DROP VIEW)删除视图时，只能删除视图的定义，不会删除数据。语法格式：DROP VIEW &lt;视图名1&gt; [ , &lt;视图名2&gt; …]其中：&lt;视图名&gt;指定要删除的视图名。DROP VIEW 语句可以一次删除多个视图，但是必须在每个视图上拥有 DROP 权限。实例：删除 v_students_info 视图。123456mysql&gt; DROP VIEW IF EXISTS v_students_info;Query OK, 0 rows affected (0.00 sec)mysql&gt; SHOW CREATE VIEW v_students_info;ERROR 1146 (42S02): Table 'test.v_students_info' doesn't exist# v_students_info 视图已不存在，将其成功删除。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-数据类型","slug":"SQL-数据类型","date":"2020-04-20T07:33:48.000Z","updated":"2020-04-21T10:47:08.216Z","comments":true,"path":"2020/04/20/SQL-数据类型/","link":"","permalink":"http://forwardpeng.github.io/2020/04/20/SQL-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"数据类型简介数据库中的每个列都应该有适当的数据类型，用于限制或允许该列中存储的数据。大概可以分为5种，分别是整数类型、浮点数类型和定点数类型、日期和时间类型、字符串类型、二进制类型等。 数值类型整数类型包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，浮点数类型包括 FLOAT 和 DOUBLE，定点数类型为 DECIMAL。 日期/时间类型包括YEAR、TIME、DATE、DATETIME和TIMESTAMP。 字符串类型包括CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET等。 二进制类型 整数类型(INT、TINYINT、SMALLINT、MEDIUMINT、BIGINT)整数类型其属性字段可添加AUTO-INCREMENT自增约束条件。类型名称说明存储需求TINYINT很小的整数(-128〜127)1个字节SMALLINT小的整数(-32768〜32767)2个字节MEDIUMINT中等大小的整数( -8388608〜8388607)3个字节INT(INTEGHR)普通大小的整数(-2147483648〜2147483647)4个字节BIGINT大整数(-9223372036854775808〜9223372036854775807)8个字节注意：不同的整数类型有不同的取值范围，并且需要不同的存储空间，因此应根据实际需要选择最合适的类型，这样有利于提高查询的效率和节省存储空间。 小数类型使用浮点数和定点数来表示小数，浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL。浮点类型和定点类型都可以用(M, D)来表示，其中M称为精度，表示总共的位数，取值范围M(1255)；D称为标度，表示小数的位数(130，&lt;= M - 2)。小数类型及其存储需求如下：类型名称说明存储需求有符号的取值范围无符号取值范围FLOAT单精度浮点数4个字节-3.402823466E+38～-1.175494351E-380 和 -1.175494351E-38～-3.402823466E+38。DOUBLE双精度浮点数8 个字节-1.7976931348623157E+308～-2.2250738585072014E-3080 和 -2.2250738585072014E-308～-1.7976931348623157E+308DECIMAL (M, D)，DEC压缩的“严格”定点数M+2 个字节NULLNULL定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。 日期和时间类型(DTAETIME、TIMESTAMP、DATE、TIME、YEAR)日期与时间类型：类型名称日期格式日期范围存储需求YEARYYYY1901-21551个字节TIMEHH:MM:SS-838:59:59 ~ 838:59:593 个字节DATEYYYY-MM-DD1000-01-01~9999-12-33 个字节DATETIMEYYYY-MM-DD HH:MM:SS1000-01-01 00:00:00 ~ 9999-12-31 23:59:598 个字节TIMESTAMPYYYY-MM-DD HH:MM:SS1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC4 个字节 YEAR类型YEAR 类型是一个单字节类型，用于表示年，在存储时只需要 1 个字节。可以使用各种格式指定 YEAR，如下所示：以 4 位字符串或者 4 位数字格式表示的 YEAR，范围为 ‘1901’～’2155’。输入格式为 ‘YYYY’ 或者 YYYY，例如，输入 ‘2010’ 或 2010，插入数据库的值均为 2010。以 2 位字符串格式表示的 YEAR，范围为 ‘00’ 到 ‘99’。‘00’～’69’ 和 ‘70’～’99’ 范围的值分别被转换为 2000～2069 和 1970～1999 范围的 YEAR 值。‘0’ 与 ‘00’ 的作用相同。插入超过取值范围的值将被转换为 2000。以 2 位数字表示的 YEAR，范围为 1～99。1～99 和 70～99 范围的值分别被转换为 2001～2069 和 1970～1999 范围的 YEAR 值。注意，在这里0值将被转换为0000，而不是2000两位整数范围与两位字符串范围稍有不同。例如，插入 3000 年，读者可能会使用数字格式的 0 表示 YEAR，实际上，插入数据库的值为 0000，而不是所希望的 3000。只有使用字符串格式的 ‘0’ 或 ‘00’，才可以被正确解释为 3000 TIME类型TIME 类型用于只需要时间信息的值，在存储时需要 3 个字节。格式为 HH:MM:SS。HH表示小时，MM表示分钟，SS表示秒。‘D HH：MM：SS’ 格式的字符串。还可以使用这些“非严格”的语法：‘HH：MM：SS’、‘HH：MM’、‘D HH’ 或 ‘SS’。这里的 D 表示日，可以取 0～34 之间的值。在插入数据库时，D 被转换为小时保存，格式为 “D*24+HH”。‘HHMMSS’ 格式、没有间隔符的字符串或者 HHMMSS 格式的数值，假定是有意义的时间。例如，‘101112’ 被理解为’10：11：12’，但是 ‘106112’ 是不合法的（它有一个没有意义的分钟部分），在存储时将变为 00：00：00。注意：如果没有冒号，MySQL 解释值时，假定最右边的两位表示秒。TIME值中如果使用冒号则肯定被看作当天的时间， DATE类型DATE 类型用于仅需要日期值时，没有时间部分，在存储时需要 3 个字节。日期格式为 ‘YYYY-MM-DD’，其中 YYYY 表示年，MM 表示月，DD 表示日。在给 DATE 类型的字段赋值时，可以使用字符串类型或者数字类型的数据插入，只要符合 DATE 的日期格式即可以 ‘YYYY-MM-DD’ 或者 ‘YYYYMMDD’ 字符中格式表示的日期，取值范围为 ‘1000-01-01’～’9999-12-3’。例如，输入 ‘2015-12-31’ 或者 ‘20151231’，插入数据库的日期为2015-12-31以 ‘YY-MM-DD’ 或者 ‘YYMMDD’ 字符串格式表示日期，在这里YY表示两位的年值。MySQL 解释两位年值的规则：‘00～69’ 范围的年值转换为 ‘20002069’，'7099’ 范围的年值转换为 ‘1970～1999’。例如，输入 ‘15-12-31’，插入数据库的日期为 2015-12-31；输入 ‘991231’，插入数据库的日期为 1999-12-31。以 YYMMDD 数字格式表示的日期，与前面相似，00~69 范围的年值转换为 2000～2069，80～99 范围的年值转换为 1980～1999。例如，输入 151231，插入数据库的日期为 2015-12-31，输入 991231，插入数据库的日期为 1999-12-31。使用 CURRENT_DATE 或者 NOW()，插入当前系统日期。 DATETIME类型DATETIME 类型用于需要同时包含日期和时间信息的值，在存储时需要 8 个字节。日期格式为 ‘YYYY-MM-DD HH：MM：SS’，其中 YYYY 表示年，MM 表示月，DD 表示日，HH 表示小时，MM 表示分钟，SS 表示秒。可以使用字符串类型或者数字类型的数据插入，只要符合 DATETIME 的日期格式即可，如下所示:以 ‘YYYY-MM-DD HH：MM：SS’ 或者 ‘YYYYMMDDHHMMSS’ 字符串格式表示的日期，取值范围为 ‘1000-01-01 00：00：00’～’9999-12-3 23：59：59’。例如，输入 ‘2014-12-31 05：05：05’ 或者 '20141231050505’，插入数据库的 DATETIME 值都为 2014-12-31 05：05：05。以 ‘YY-MM-DD HH：MM：SS’ 或者 ‘YYMMDDHHMMSS’ 字符串格式表示的日期，在这里 YY 表示两位的年值。以 YYYYMMDDHHMMSS 或者 YYMMDDHHMMSS 数字格式表示的日期和时间。 TIMESTAMP类型TIMESTAMP 的显示格式与 DATETIME 相同，显示宽度固定在 19 个字符，日期格式为 YYYY-MM-DD HH：MM：SS，在存储时需要 4 个字节。但是 TIMESTAMP 列的取值范围小于 DATETIME 的取值范围，为 '1970-01-01 00：00：01’UTC～’2038-01-19 03：14：07’UTC。在插入数据时，要保证在合法的取值范围内。DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。 字符串类型(CHAR、VARCHAR、TEXT、ENUM、SET)字符串类型用来存储字符串数据，还可以存储图片和声音的二进制数据。字符串可以区分或者不区分大小写的串比较，还可以进行正则表达式的匹配查找类型名称说明存储需求CHAR(M)固定长度非二进制字符串M 字节，1&lt;=M&lt;=255VARCHAR(M)变长非二进制字符串L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255TINYTEXT非常小的非二进制字符串L+1字节，在此，L&lt;2^8TEXT小的非二进制字符串L+2字节，在此，L&lt;2^16MEDIUMTEXT中等大小的非二进制字符串L+3字节，在此，L&lt;2^24LONGTEXT大的非二进制字符串L+4字节，在此，L&lt;2^32ENUM枚举类型，只能有一个枚举字符串值1或2个字节，取决于枚举值的数目 (最大值为65535)SET一个设置，字符串对象可以有零个或 多个SET成员1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） CHAR 和 VARCHAR类型CHAR(M)为固定长度字符串，在定义时指定字符串列长。当保存时，在右侧填充空格以达到指定的长度。M 表示列的长度，范围是 0～255个字符。插入值CHAR(4)存储需求VARCHAR(4)存储需求‘’’ ’4字节‘’1字节‘ab’‘ab’4字节‘ab’3字节‘abc’‘abc’4字节‘abc’4字节‘abcd’‘abcd’4字节‘abcd’5字节‘abcdef’‘avcd’4字节‘abcd’5字节 TEXT类型TEXT 列保存非二进制字符串，如文章内容、评论等。当保存或查询 TEXT 列的值时，不删除尾部空格。TEXT 类型分为 4 种：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。不同的 TEXT 类型的存储空间和数据长度不同。TINYTEXT 表示长度为255（28-1）字符的TEXT列。TEXT 表示长度为 65535（216-1）字符的TEXT列。MEDIUMTEXT 表示长度为 16777215（224-1）字符的 TEXT 列。LONGTEXT 表示长度为 4294967295 或 4GB（232-1）字符的 TEXT 列。 ENUM类型ENUM 是一个字符串对象，值为表创建时列规定中枚举的一列值。其语法格式如下：&lt;字段名&gt; ENUM( ‘值1’, ‘值1’, …, ‘值n’ )ENUM值在内部用整数表示，每个枚举值均有一个索引值；列表值所允许的成员值从1开始编号，MySQL存储的就是这个索引编号，枚举最多可以有65535 个元素。NUM值依照列索引顺序排列，并且空字符串排在非空字符串前，NULL值排在其他所有枚举值前 SET类型SET 是一个字符串的对象，可以有零或多个值，SET 列最多可以有 64 个成员，值为表创建时规定的一列值。指定包括多个 SET 成员的 SET 列值时，各成员之间用逗号,隔开，语法格式如下：SET( ‘值1’, ‘值2’, …, ‘值n’ )SET值在内部用整数表示，列表中每个值都有一个索引编号。当创建表时，SET成员值的尾部空格将自动删除。但与ENUM类型不同的是，ENUM 类型的字段只能从定义的列值中选择一个值插入，而SET类型的列可从定义的列值中选择多个字符的联合。 二进制类型(BIT、BINARY、VARBINARY、BLOB)支持两类字符型数据：文本字符串和二进制字符串。MySQL中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB。 BIT类型位字段类型。M 表示每个值的位数，范围为 1～64。如果 M 被省略，默认值为 1。如果为 BIT(M) 列分配的值的长度小于 M 位，在值的左边用 0 填充。例如，为 BIT(6) 列分配一个值 b’101’，其效果与分配 b’000101’ 相同。BIT 数据类型用来保存位字段值，例如以二进制的形式保存数据 13，13 的二进制形式为1101，在这里需要位数至少为4位的BIT类型，即可以定义列类型为BIT(4)。大于二进制1111的数据是不能插入BIT(4)类型的字段中的 BINARY和VARBINARY类型BINARY 和 VARBINARY 类型类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字节字符串。使用的语法格式如下：列名称 BINARY(M) 或者 VARBINARY(M)BINARY类型的长度是固定的，指定长度后，不足最大长度的，将在它们右边填充“\\0”补齐，以达到指定长度。例如，指定列数据类型为BINARY(3)，当插入 a 时，存储的内容实际为 “\\a0\\0”，当插入ab时，实际存储的内容为“ab\\0”，无论存储的内容是否达到指定的长度，存储空间均为指定的值M。 BLOB类型BLOB 是一个二进制的对象，用来存储可变数量的数据。BLOB 类型分为 4 种：TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB，它们可容纳值的最大长度不同，如下表所示数据类型存储范围TINYBLOB最大长度为255 (28−12^8-128−1)字节BLOB最大长度为65535 (216−12^{16}-1216−1)字节MEDIUMBLOB最大长度为16777215 (224−12^{24}-1224−1)字节LONGBLOB最大长度为4294967295或4GB (231−12^{31}-1231−1)字节BLOB 列存储的是二进制字符串（字节字符串），TEXT 列存储的是非进制字符串（字符字符串）。BLOB 列是字符集，并且排序和比较基于列值字节的数值；TEXT 列有一个字符集，并且根据字符集对值进行排序和比较。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-查询(二)","slug":"SQL-查询(二)","date":"2020-04-19T14:14:35.000Z","updated":"2020-04-21T13:49:44.286Z","comments":true,"path":"2020/04/19/SQL-查询(二)/","link":"","permalink":"http://forwardpeng.github.io/2020/04/19/SQL-%E6%9F%A5%E8%AF%A2(%E4%BA%8C)/","excerpt":"","text":"子查询子查询指一个查询语句嵌套在另一个查询语句内部的查询，子查询结果作为外层另一个查询的过滤条件，查询可以基于一个表或者多个表。可以添加到 SELECT、UPDATE 和 DELETE 语句中，而且可以进行多层嵌套。子查询也可以使用比较运算符，如“&lt;”、“&lt;=”、“&gt;”、“&gt;=”、“！=”等。 子查询中常见的运算符1.IN子查询关键字 IN 所使用的子查询主要用于判断一个给定值是否存在于子查询的结果集中。其语法格式为：&lt;表达式&gt; [NOT] IN &lt;子查询&gt;语法说明：&lt;表达式&gt;：用于指定表达式。当表达式与子查询返回的结果集中的某个值相等时，返回 TRUE，否则返回 FALSE；若使用关键字 NOT，则返回的值正好相反。&lt;子查询&gt;：用于指定子查询。这里的子查询只能返回一列数据。对于比较复杂的查询要求，可以使用 SELECT 语句实现子查询的多层嵌套。2.比较运算符子查询比较运算符所使用的子查询主要用于对表达式的值和子查询返回的值进行比较运算，语法格式为：&lt;表达式&gt; {= | &lt; | &gt; | &gt;= | &lt;= | &lt;=&gt; | &lt; &gt; | != }{ ALL | SOME | ANY} &lt;子查询&gt;语法说明如下：&lt;子查询&gt;：用于指定子查询。&lt;表达式&gt;：用于指定要进行比较的表达式。ALL、SOME 和 ANY：可选项。用于指定对比较运算的限制。其中，关键字 ALL 用于指定表达式需要与子查询结果集中的每个值都进行比较，当表达式与每个值都满足比较关系时，会返回 TRUE，否则返回 FALSE；关键字 SOME 和 ANY 是同义词，表示表达式只要与子查询结果集中的某个值满足比较关系，就返回 TRUE，否则返回 FALSE。3.EXIST子查询关键字 EXIST 所使用的子查询主要用于判断子查询的结果集是否为空。其语法格式为：EXIST &lt;子查询&gt;若子查询的结果集不为空，则返回 TRUE；否则返回 FALSE。 子查询的应用实例1：先执行内层子查询，再执行外层查询，内层子查询的结果作为外部查询的比较条件。12345678910mysql&gt; select name from tb_students_info where dept_id in (select idept_id from tb_departments where dept_type='A');+------+| name |+------+| peng || jun || Gui || Feng |+------+4 rows in set (0.00 sec)。实例2：在 tb_departments 表中查询 dept_name 等于“Computer”的学院 id，然后在 tb_students_info 表中查询所有该学院的学生的姓名1234567891011mysql&gt; select name from tb_students_info -&gt; where dept_id= -&gt; (select idept_id -&gt; from tb_departments -&gt; where dept_name='Computer');+------+| name |+------+| Gui |+------+1 row in set (0.00 sec)实例3：查询的dept_name不等于’Computer’的学院id，然后查询学生姓名。1234567891011121314mysql&gt; select name from tb_students_info -&gt; where dept_id &lt;&gt; -&gt; (select idept_id -&gt; from tb_departments -&gt; where dept_name='Computer');+------+| name |+------+| peng || jun || Feng || Qi |+------+4 rows in set (0.00 sec) 分组查询(GROUP BY)使用 GROUP BY 子句，将结果集中的数据行根据选择列的值进行逻辑分组，以便能汇总表内容的子集，实现对每个组而不是对整个结果集进行整合。语法格式：GROUP BY { &lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt; } [ASC | DESC]语法说明：&lt;列名&gt;：指定用于分组的列。可以指定多个列，彼此间用逗号分隔。&lt;表达式&gt;：指定用于分组的表达式。通常与聚合函数一块使用，例如可将表达式 COUNT(*)AS’人数’ 作为 SELECT 选择列表清单的一项。&lt;位置&gt;：指定用于分组的选择列在 SELECT 语句结果集中的位置，通常是一个正整数。例如，GROUP BY 2 表示根据 SELECT 语句列清单上的第 2 列的值进行逻辑分组。ASC|DESC：关键字 ASC 表示按升序分组，关键字 DESC 表示按降序分组，其中 ASC 为默认值，注意这两个关键字必须位于对应的列名、表达式、列的位置之后。使用GROUP BY子句时注意：GROUP BY 子句可以包含任意数目的列，使其可以对分组进行嵌套，为数据分组提供更加细致的控制。GROUP BY 子句列出的每个列都必须是检索列或有效的表达式，但不能是聚合函数。若在 SELECT 语句中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。除聚合函数之外，SELECT 语句中的每个列都必须在 GROUP BY 子句中给出。若用于分组的列中包含有 NULL 值，则 NULL 将作为一个单独的分组返回；若该列中存在多个 NULL 值，则将这些 NULL 值所在的行分为一组。实例：据 dept_id 对 tb_students_info 表中的数据进行分组，将每个学院的学生姓名显示出来123456789mysql&gt; select dept_id,GROUP_CONCAT(name) AS names FROM tb_students_info group by dept_id;+---------+---------------+| dept_id | names |+---------+---------------+| 0 | Qi || 1 | Gui || 2 | peng,jun,Feng |+---------+---------------+3 rows in set (0.00 sec) 指定过滤条件(HAVING)使用 HAVING 子句过滤分组，在结果集中规定了包含哪些分组和排除哪些分组。语法格式：HAVING &lt;条件&gt;HAVING 子句和 WHERE 子句非常相似，HAVING 子句支持 WHERE 子句中所有的操作符和语法，存在的差异如下：WHERE 子句主要用于过滤数据行，而 HAVING 子句主要用于过滤分组，即 HAVING 子句基于分组的聚合值而不是特定行的值来过滤数据，主要用来过滤分组。WHERE 子句不可以包含聚合函数，HAVING 子句中的条件可以包含聚合函数。HAVING 子句是在数据分组后进行过滤，WHERE 子句会在数据分组前进行过滤。WHERE 子句排除的行不包含在分组中，可能会影响 HAVING 子句基于这些值过滤掉的分组。实例：根据 dept_id 对 tb_students_info 表中的数据进行分组，并显示学生人数大于1的分组信息，1234567mysql&gt; SELECT dept_id,group_concat(name) as names from tb_students_info group by dept_id having count(name)&gt;1;+---------+---------------+| dept_id | names |+---------+---------------+| 2 | peng,jun,Feng |+---------+---------------+1 row in set (0.00 sec) 正则表达式查询(REGEXP)正则表达式通常被用来检索或替换符合某个模式的文本内容，根据指定的匹配模式匹配文中符合要求的特殊字符串。选项说明例子匹配值实例^匹配文本的开始字符‘^b’ 匹配以字母 b 开头 的字符串book、big、banana、 bike$匹配文本的结果字符'st$’ 匹配以 st 结尾的字 符串中等文本test、resist、persist.匹配任何单个字符'b.t’ 匹配任何 b 和 t 之间有一个字符bit、bat、but、bite*匹配零个或多个在它前面的字符'f*n’ 匹配字符 n 前面有 任意个字符 ffn、fan、faan、abcn+匹配前面的字符 1 次或多次''ba+’ 匹配以 b 开头，后 面至少紧跟一个 aba、bay、bare、battle&lt;字符串&gt;匹配包含指定字符的文本'fa’fan、afa、faad[字符集合]匹配字符集合中的任何一个字 符'[xz]'匹配 x 或者 zdizzy、zebra、x-ray、 extra[^]匹配不在括号中的任何字符'[^abc]’ 匹配任何不包 含 a、b 或 c 的字符串desk、fox、f8ke字符串{n,}匹配前面的字符串至少 n 次b{2} 匹配 2 个或更多 的 bbbb、 bbbb、 bbbbbbb{n,m}匹配前面的字符串至少 n 次， 至多 m 次b{2,4} 匹配最少 2 个， 最多 4 个 bbbb、 bbbb实例1：字符“^”匹配以特定字符或者字符串开头的文本。查询 dept_name 字段以字母“C”开头的记录123456789mysql&gt; select * from tb_departments -&gt; where dept_name REGEXP '^C';+----------+-----------+-----------+| idept_id | dept_name | dept_type |+----------+-----------+-----------+| 1 | Computer | A || 2 | Chinese | A |+----------+-----------+-----------+2 rows in set (0.00 sec)实例2：用符号“.”代替字符串中的任意一个字符。查询 dept_name 字段值包含字母“o”与字母“y”，且两个字母之间只有一个字母的记录123456789mysql&gt; select * from tb_departments -&gt; where dept_name regexp 'o.y';+----------+-----------+-----------+| idept_id | dept_name | dept_type |+----------+-----------+-----------+| 4 | Economy | B || 5 | History | A |+----------+-----------+-----------+2 rows in set (0.00 sec)实例3：查询 dept_name 字段值包含字符串“in”或者“on”的记录123456789mysql&gt; SELECT * FROM tb_departments -&gt; WHERE dept_name REGEXP 'in|on';+---------+-----------+-----------+-----------+| dept_id | dept_name | dept_call | dept_type |+---------+-----------+-----------+-----------+| 3 | Chinese | 3 | B || 4 | Economy | 4 | B |+---------+-----------+-----------+-----------+2 rows in set (0.00 sec实例3：匹配指定字符串。查询 dept_name 字段值包含字符串“in”或者“on”的记录。123456789mysql&gt; SELECT * FROM tb_departments -&gt; WHERE dept_name REGEXP 'in|on';+---------+-----------+-----------+-----------+| dept_id | dept_name | dept_call | dept_type |+---------+-----------+-----------+-----------+| 3 | Chinese | 33333 | B || 4 | Economy | 44444 | B |+---------+-----------+-----------+-----------+2 rows in set (0.00 sec)实例4:匹配不在指定集合中的任何字符。查询 dept_name 字段值包含字母 a~t 以外的字符的记录。12345678910mysql&gt; SELECT * FROM tb_departments -&gt; WHERE dept_name REGEXP '[^a-t]';+---------+-----------+-----------+-----------+| dept_id | dept_name | dept_call | dept_type |+---------+-----------+-----------+-----------+| 1 | Computer | 11111 | A || 4 | Economy | 44444 | B || 5 | History | 55555 | B |+---------+-----------+-----------+-----------+3 rows in set (0.00 sec)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-查询(一)","slug":"SQL-查询(一)","date":"2020-04-18T09:49:11.000Z","updated":"2020-04-21T10:46:32.384Z","comments":true,"path":"2020/04/18/SQL-查询(一)/","link":"","permalink":"http://forwardpeng.github.io/2020/04/18/SQL-%E6%9F%A5%E8%AF%A2(%E4%B8%80)/","excerpt":"","text":"查询数据表SELECT 语句来查询数据。查询数据是指从数据库中根据需求，使用不同的查询方式来获取不同的数据，是使用频率最高、最重要的操作。语法格式如下：SELECT {* | &lt;字段列名&gt;} [ FROM &lt;表 1&gt;, &lt;表 2&gt;… [WHERE &lt;表达式&gt; [GROUP BY &lt;group by definition&gt; [HAVING &lt;expression&gt; [{&lt;operator&gt; &lt;expression&gt;}…]] [ORDER BY &lt;order by definition&gt;] [LIMIT[&lt;offset&gt;,] &lt;row count&gt;] ]其中，各条子句说明如下：{*|&lt;字段列名&gt;}包含星号通配符的字段列表，表示所要查询字段的名称。&lt;表1&gt;，&lt;表2&gt;…，表1和表2表示查询数据的来源，可以是单个或多个。WHERE&lt;表达式&gt;是可选项，如果选择该项，将限定查询数据必须满足该查询条件。GROUP BY&lt;字段&gt;，该子句告诉数据库如何显示查询出来的数据，并按照指定的字段分组。ORDER BY&lt; 字段 &gt;]，按什么样的顺序显示查询出来的数据，可以进行的排序有升序（ASC）和降序（DESC），默认情况下是升序。[LIMIT[&lt;offset&gt;，]&lt;row count&gt;]，该子句告诉 MySQL 每次显示查询出来的数据条数。 查询表中所有字段1. 使用&quot;*&quot;查询表的所有字段语法格式如下：SELECT * FROM 表名;2. 列出表的所有字段SELECT关键字后面的字段名为需要查找的字段，可以使用 DESC 命令查看表的结构。 查询表中指定的字段查询表中的某一个字段的语法格式为：SELECT &lt; 列名 &gt; FROM &lt; 表名 &gt;;123456789mysql&gt; SELECT name FROM tb_students_info;+--------+| name |+--------+| Dany || Thomas || Tom |+--------+10 rows in set (0.00 sec) 去重(过滤重复数据)使用DISTINCT关键字指示 数据库消除重复的记录值。语法格式为：SELECT DISTINCT &lt;字段名&gt; FROM &lt;表名&gt;; 设置别名 为表指定别名当数据表名很长或者执行一些特殊查询的时候，为了方便操作，可以为表指定一个别名，语法格式为：&lt;表名&gt; [AS] &lt;别名&gt;使用示例如下：1234567mysql&gt; SELECT stu.name,stu.height FROM tb_students_info AS stu;+--------+--------+| name | height |+--------+--------+| Dany | 160 || Green | 158 |2 rows in set (0.04 sec) 为字段指定别名每个 SELECT 后面指定输出的字段。有时为了显示结果更加直观，可以为字段指定一个别名。基本语法格式：&lt;字段名&gt; [AS] &lt;别名&gt;使用示例如下：123456mysql&gt; SELECT name AS student_name, age AS student_age FROM tb_students_info;+--------------+-------------+| student_name | student_age |+--------------+-------------+| Dany | 25 || Green | 23 | 限制查询结果的记录条数SELECT语句时往往返回的是所有匹配的行，有些时候我们仅需要返回第一行或者前几行，这时候就需要用到数据库LIMT子句基本的语法格式：&lt;LIMIT&gt; [&lt;位置偏移量&gt;,] &lt;行数&gt;LIMIT接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。1234567mysql&gt; select * from tb_students_info limit 1, 2;+----+------+---------+------+------+--------+---------------------+| id | name | dept_id | age | sex | height | login_date |+----+------+---------+------+------+--------+---------------------+| 2 | jun | 2 | 12 | F | 222 | 1000-01-01 00:00:01 |+----+------+---------+------+------+--------+---------------------+1 row in set (0.00 sec) 对查询结果进行排序ORDER BY 子句主要用来将结果集中的数据按照一定的顺序进行排序。语法格式：ORDER BY {&lt;列名&gt; | &lt;表达式&gt; | &lt;位置&gt;} [ASC|DESC]语法说明如下：列名：指定用于排序的列。可以指定多个列，列名之间用逗号分隔。表达式：指定用于排序的表达式。位置：指定用于排序的列在SELECT语句结果集中的位置，通常是正整数。ASC|DESC：关键字 ASC 表示按升序分组，关键字 DESC 表示按降序分组，其中 ASC 为默认值。这两个关键字必须位于对应的列名、表达式、列的位置之后。使用示例如下：1234567891011121314mysql&gt; select * from tb_students_info ORDER by age;+----+------+---------+------+------+--------+---------------------+| id | name | dept_id | age | sex | height | login_date |+----+------+---------+------+------+--------+---------------------+| 2 | jun | 2 | 12 | F | 222 | 1000-01-01 00:00:01 || 1 | peng | 2 | 25 | F | 222 | 1000-01-01 00:00:00 |+----+------+---------+------+------+--------+---------------------+2 rows in set (0.00 sec)mysql&gt; SELECT name,height FROM tb_student_info ORDER BY height DESC,name ASC;+--------+--------+| name | height |+--------+--------+| Henry | 185 || Thomas | 178 |注意：DESC 关键字只对前面的列进行降序排列，在这里只对 height 排序，而并没有对 name 进行排序，因此，height 按降序排序，而 name 仍按升序排序，如果要对多列进行降序排序，必须要在每一列的后面加 DESC 关键字。 条件查询使用 WHERE 子句来指定查询条件，从 FROM 子句的中间结果中选取适当的数据行，达到数据过滤的效果。语法格式：WHERE &lt;查询条件&gt; {&lt;判定运算1&gt;，&lt;判定运算2&gt;，…}运算的语法分类如下：&lt;表达式1&gt;{=|&lt;|&lt;=|&gt;|&gt;=|&lt;=&gt;|&lt;&gt;|！=}&lt;表达式2&gt;&lt;表达式1&gt;[NOT]LIKE&lt;表达式2&gt;&lt;表达式1&gt;[NOT][REGEXP|RLIKE]&lt;表达式2&gt;&lt;表达式1&gt;[NOT]BETWEEN&lt;表达式2&gt;AND&lt;表达式3&gt;&lt;表达式1&gt;IS[NOT]NULL 单一条件的查询语句语句采用简单的相等过滤，使用示例如下：12345678910mysql&gt; select name, age -&gt; from tb_students_info -&gt; where age&lt;=25;+------+------+| name | age |+------+------+| peng | 25 || jun | 12 |+------+------+2 rows in set (0.00 sec) 多条件的查询语句SQL在WHERE子句中使用AND操作符限定只有满足所有查询条件的记录才会被返回。使用示例如下：12345678910mysql&gt; select * from tb_students_info -&gt; where age&lt;35 and height &gt;170;+----+------+---------+------+------+--------+---------------------+| id | name | dept_id | age | sex | height | login_date |+----+------+---------+------+------+--------+---------------------+| 1 | peng | 2 | 25 | F | 222 | 1000-01-01 00:00:00 || 2 | jun | 2 | 12 | F | 222 | 1000-01-01 00:00:01 || 4 | Feng | 2 | 32 | F | 175 | 1000-01-01 00:00:01 |+----+------+---------+------+------+--------+---------------------+3 rows in set (0.00 sec) 使用LIKE的模糊查询字符串匹配语法格式：&lt;表达式1&gt; [NOT] LIKE &lt;表达式2&gt;相互间进行匹配运算的对象可以是CHAR、VARCHAR、TEXT、DATETIME 等数据类型。运算返回的结果是 TRUE 或 FALSE。通配符如下：1.百分号(%)百分号可以表示任何字符串，并且该字符串可以出现任意次。使用示例如下：1234567891011mysql&gt; SELECT name FROM tb_students_info -&gt; WHERE name LIKE '%e%';+-------+| name |+-------+| Green || Henry || Jane |+-------+3 rows in set (0.00 sec)# 查找所有包含“e”字母的学生姓名sql默认不区分大小写，除非更换字符集的校对规则百分号不匹配空值百分号可以代表搜索模式中给定位置的 0 个、1 个或多个字符。尾空格可能会干扰通配符的匹配，一般可以在搜索模式的最后附加一个百分号。2.下划线(_)下画线只匹配单个字符，而不是多个字符，也不是 0 个字符。123456789mysql&gt; SELECT name FROM tb_students_info -&gt; WHERE name LIKE '____y';+-------+| name |+-------+| Henry |+-------+1 row in set (0.00 sec)# 查找所有以字母“y”结尾，且“y”前面只有 4 个字母 日期字段作为条件的查询语句以日期字段作为条件，可以使用比较运算符设置查询条件，也可以使用 BETWEEN AND 运算符查询某个范围内的值。使用示例如下：1234567mysql&gt; SELECT * FROM tb_students_info -&gt; WHERE login_date&lt;'2016-01-01';+----+-------+---------+------+------+--------+------------+| id | name | dept_id | age | sex | height | login_date |+----+-------+---------+------+------+--------+------------+| 1 | Dany | 1 | 25 | F | 160 | 2015-09-10 || 3 | Henry | 2 | 23 | M | 185 | 2015-05-31 | 内连接查询(INNER JOIN)利用条件表达式来消除交叉连接的某些数据行。关键字 INNER JOIN 连接两张表，并使用 ON 子句来设置连接条件。如果没有任何条件，INNER JOIN 和 CROSS JOIN 在语法上是等同的。语法格式：SELECT &lt;列名1，列名2 …&gt;FROM &lt;表名1&gt; INNER JOIN &lt;表名2&gt; [ ON子句]语法说明如下：&lt;列名1，列名2…&gt;：需要检索的列名。&lt;表名1&gt;&lt;表名2&gt;：进行内连接的两张表的表名。123456789mysql&gt; SELECT id,name,age,dept_name -&gt; FROM tb_students_info,tb_departments -&gt; WHERE tb_students_info.dept_id=tb_departments.dept_id;+----+--------+------+-----------+| id | name | age | dept_name |+----+--------+------+-----------+| 1 | Dany | 25 | Computer || 2 | Green | 23 | Chinese || 3 | Henry | 23 | MathSELECT后面指定的列分别属于两个不同的表，id、name、age在表tb_students_info中，dept_name在表tb_departments。12345678910mysql&gt; SELECT id,name,age,dept_name -&gt; FROM tb_students_info INNER JOIN tb_departments -&gt; WHERE tb_students_info.dept_id=tb_departments.dept_id;+----+--------+------+-----------+| id | name | age | dept_name |+----+--------+------+-----------+| 1 | Dany | 25 | Computer || 2 | Green | 23 | Chinese || 3 | Henry | 23 | Math |# 使用INNER JOIN语法进行内连接查询 外连接查询(LEFT/RIGHT JOIN)外连接更加注重两张表之间的关系。按照连接表的顺序，可以分为左外连接和右外连接。左外连接又称为左连接，在 FROM 子句中使用关键字 LEFT OUTER JOIN 或者 LEFT JOIN，用于接收该关键字左表（基表）的所有行，并用这些行与该关键字右表（参考表）中的行进行匹配，即匹配左表中的每一行及右表中符合条件的行。除了匹配的行之外，还包括左表中有但在右表中不匹配的行，对于这样的行，从右表中选择的列的值被设置为 NULL，即左外连接的结果集中的 NULL 值表示右表中没有找到与左表相符的记录。123456789101112131415mysql&gt; SELECT name,dept_name -&gt; FROM tb_students_info s -&gt; LEFT OUTER JOIN tb_departments d -&gt; ON s.dept_id=d.idept_id;+------+-----------+| name | dept_name |+------+-----------+| peng | Chinese || jun | Chinese || Gui | Computer || Feng | Chinese || Qi | NULL |+------+-----------+5 rows in set (0.00 sec)# 学生Qi在tb_departments表中取出的值为 NULL。右外连接又称为右连接，在 FROM 子句中使用 RIGHT OUTER JOIN 或者 RIGHT JOIN。与左外连接相反，右外连接以右表为基表，连接方法和左外连接相同。在右外连接的结果集中，除了匹配的行外，还包括右表中有但在左表中不匹配的行，对于这样的行，从左表中选择的值被设置为 NULL。1234567891011121314mysql&gt; Select name,dept_name from tb_students_info s right outer join tb_departments d on s.dept_id=d.idept_id;+------+-----------+| name | dept_name |+------+-----------+| peng | Chinese || jun | Chinese || Gui | Computer || Feng | Chinese || NULL | Math || NULL | Economy || NULL | History |+------+-----------+7 rows in set (0.00 sec)# 从 tb_students_info 表中取出的值为 NULL。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-索引","slug":"SQL-索引","date":"2020-04-16T12:02:11.000Z","updated":"2020-04-22T06:57:36.270Z","comments":true,"path":"2020/04/16/SQL-索引/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/SQL-%E7%B4%A2%E5%BC%95/","excerpt":"","text":"索引简介索引是 MySQL 中一种十分重要的数据库对象。它是数据库性能调优技术的基础，常用于实现数据的快速检索。索引就是根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表。1.顺序访问顺序访问是在表中实行全表扫描，从头到尾逐行遍历，直到在无序的行数据中找到符合条件的目标数据。这种方式实现比较简单，但是当表中有大量数据的时候，效率非常低下。例如，在几千万条数据中查找少量的数据时，使用顺序访问方式将会遍历所有的数据，花费大量的时间，显然会影响数据库的处理性能。2.索引访问索引访问是通过遍历索引来直接访问表中记录行的方式。使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。索引存储了指定列数据值的指针，根据指定的排序顺序对这些指针排序。 索引的分类索引的类型和存储引擎有关，每种存储引擎所支持的索引类型不一定完全相同。根据存储方式的不同，MySQL中常用的索引在物理上分为以下两类。B-树索引B-树索引又称为 BTREE 索引，目前大部分的索引都是采用 B-树索引来存储的。B-树索引是一个典型的数据结构，其包含的组件主要有以下几个：叶子节点：包含的条目直接指向表里的数据行。叶子节点之间彼此相连，一个叶子节点有一个指向下一个叶子节点的指针。分支节点：包含的条目指向索引里其他的分支节点或者叶子节点。根节点：一个 B-树索引只有一个根节点，实际上就是位于树的最顶端的分支节点。表中的每一行都会在索引上有一个对应值。因此，在表中进行数据查询时，可以根据索引值一步一步定位到数据所在的行。B-树索引可以进行全键值、键值范围和键值前缀查询，也可以对查询结果进行 ORDER BY排序。但B-树索引必须遵循左边前缀原则，要考虑以下几点约束：查询必须从索引的最左边的列开始。查询不能跳过某一索引列，必须按照从左到右的顺序进行匹配。存储引擎不能使用索引中范围条件右边的列。哈希索引哈希通过散列算法变换成固定长度的输出，该输出就是散列值。哈希索引也称为散列索引或 HASH 索引。MySQL目前仅有MEMORY存储引擎和HEAP存储引擎支持这类索引。其中，MEMORY存储引擎可以支持B-树索引和HASH索引，且将HASH当成默认索引。HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B- 树索引来说，建立哈希索引会耗费更多的时间。不能使用HASH索引排序HASH 索引只支持等值比较，如“=”“IN()”或“&lt;=&gt;”HASH索引不支持键的部分匹配，因为在计算HASH值的时候是通过整个索引值来计算的MySQL中的索引在逻辑上分为以下5 类：普通索引：普通索引是最基本的索引类型，唯一任务是加快对数据的访问速度，没有任何限制。创建普通索引时，通常使用的关键字是INDEX或 KEY。唯一性索引：唯一性索引是不允许索引列具有相同索引值的索引。如果能确定某个数据列只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一性索引。创建唯一性索引的目的往往不是为了提高访问速度，而是为了避免数据出现重复。主键索引：主键索引是一种唯一性索引，即不允许值重复或者值为空，并且每个表只能有一个主键。主键可以在创建表的时候指定，也可以通过修改表的方式添加，必须指定关键字 PRIMARY KEY。每个表只能有一个主键空间索引：空间索引主要用于地理空间数据类型 GEOMETRY。全文索引：全文索引只能在 VARCHAR 或 TEXT 类型的列上创建，并且只能在 MyISAM 表中创建。索引在逻辑上分为以上 5 类，但在实际使用中，索引通常被创建成单列索引和组合索引。单列索引就是索引只包含原表的一个列；组合索引也称为复合索引或多列索引，相对于单列索引来说，组合索引是将原表的多个列共同组成一个索引。为了提高索引的应用性能，MySQL中的索引可以根据具体应用采用不同的索引策略。这些索引策略所对应的索引类型有聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引等 索引的使用原则和注意事项虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下弊端：创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。索引可以在一些情况下加速查询，但是在某些情况下，会降低效率。索引只是提高效率的一个因素，因此在建立索引的时候应该遵循以下原则：在经常需要搜索的列上建立索引，可以加快搜索的速度。在作为主键的列上创建索引，强制该列的唯一性，并组织表中数据的排列结构。在经常使用表连接的列上创建索引，这些列主要是一些外键，可以加快表连接的速度。在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，所以其指定的范围是连续的。在经常需要排序的列上创建索引，因为索引已经排序，所以查询时可以利用索引的排序，加快排序查询在经常使用WHERE子句的列上创建索引，加快条件的判断速度。在某些应用场合下建立索引不能提高 MySQL的工作效率，甚至降低了数据库的工作效率，一般来说不适合创建索引的环境如下：对于那些在查询中很少使用或参考的列不应该创建索引。因为这些列很少使用到，所以有索引或者无索引并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，并增大了空间要求。对于那些只有很少数据值的列也不应该创建索引。因为这些列的取值很少，例如人事表的性别列。查询结果集的数据行占了表中数据行的很大比例，增加索引并不能明显加快检索速度。对于那些定义为 TEXT、IMAGE 和 BIT 数据类型的列不应该创建索引。因为这些列的数据量要么相当大，要么取值很少。当修改性能远远大于检索性能时，不应该创建索引。因为修改性能和检索性能是互相矛盾的。当创建索引时，会提高检索性能，降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。 创建索引(CREATE INDEX)索引的建立对于数据库的高效运行是很重要的，索引可以大大提升SQL的检索速度。 基本语法MySQL提供三种创建索引的方法：1.使用CREATE INDEX语句使用专门用于创建索引的 CREATE INDEX 语句在一个已有的表上创建索引，但该语句不能创建主键。语法格式：CREATE &lt;索引名&gt; ON &lt;表名&gt; (&lt;列名&gt; [&lt;长度&gt;] [ ASC | DESC])语法说明：&lt;索引名&gt;：指定索引名。一个表可以创建多个索引，但每个索引在该表中的名称是唯一的.&lt;表名&gt;：指定要创建索引的表名。&lt;列名&gt;：指定要创建索引的列名。通常可以考虑将查询语句中在 JOIN 子句和 WHERE 子句里经常出现的列作为索引列。&lt;列名&gt;：指定要创建索引的列名。通常可以考虑将查询语句中在 JOIN 子句和 WHERE 子句里经常出现的列作为索引列。ASC|DESC：可选项。ASC指定索引按照升序来排列，DESC指定索引按照降序来排列，默认为ASC.2.使用CREATE TABLE语句索引也可以在创建表（CREATE TABLE）的同时创建。在 CREATE TABLE 语句中添加以下语句。语法格式：CONSTRAINT PRIMARY KEY [索引类型] (&lt;列名&gt;,…)在CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的主键。语法格式1：KEY | INDEX [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)在 CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的索引。语法格式2：UNIQUE [ INDEX | KEY] [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)在 CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的唯一性索引。语法格式3：FOREIGN KEY &lt;索引名&gt; &lt;列名&gt;在 CREATE TABLE 语句中添加此语句，表示在创建新表的同时创建该表的外键。3.使用ALTER TABLE语句CREATE INDEX 语句可以在一个已有的表上创建索引，ALTER TABLE 语句也可以在一个已有的表上创建索引。在使用 ALTER TABLE 语句修改表的同时，可以向已有的表添加索引。具体的做法是在 ALTER TABLE 语句中添加以下语法成分的某一项或几项。语法格式1：ADD INDEX [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加索引。语法格式2：ADD PRIMARY KEY [&lt;索引类型&gt;] (&lt;列名&gt;,…)在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加主键。语法格式3：ADD UNIQUE [ INDEX | KEY] [&lt;索引名&gt;] [&lt;索引类型&gt;] (&lt;列名&gt;,…)在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加唯一性索引。语法格式4：ADD FOREIGN KEY [&lt;索引名&gt;] (&lt;列名&gt;,…)在 ALTER TABLE 语句中添加此语法成分，表示在修改表的同时为该表添加外键 创建一般索引实例1：创建一个表 tb_stu_info，在该表的 height 字段创建一般索引。输入的 SQL 语句和执行过程如下所示。1234567891011121314151617181920212223mysql&gt; create table tb_stu_info -&gt; ( -&gt; id INT NOT NULL, -&gt; nam CHAR(45) DEFAULT NULL, -&gt; dept_id INT DEFAULT NULL\\ -&gt; ,age INT DEFAULT NULL, -&gt; height INT DEFAULT NULL, -&gt; INDEX(height) -&gt; );Query OK, 0 rows affected (0.30 sec)mysql&gt; show create table tb_stu_info\\G*************************** 1. row *************************** Table: tb_stu_infoCreate Table: CREATE TABLE `tb_stu_info` ( `id` int(11) NOT NULL, `nam` char(45) DEFAULT NULL, `dept_id` int(11) DEFAULT NULL, `age` int(11) DEFAULT NULL, `height` int(11) DEFAULT NULL, KEY `height` (`height`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) 创建唯一索引实例2：创建一个表 tb_stu_info2，在该表的 id 字段上使用 UNIQUE 关键字创建唯一索引。1234567891011121314151617181920212223mysql&gt; CREATE TABLE tb_stu_info2 -&gt; ( -&gt; id INT NOT NULL, -&gt; name CHAR(45) DEFAULT NULL, -&gt; dept_id INT DEFAULT NULL, -&gt; age INT DEFAULT NULL, -&gt; height INT DEFAULT NULL, -&gt; UNIQUE INDEX(height) -&gt; );Query OK, 0 rows affected (0.29 sec)mysql&gt; SHOW CREATE TABLE tb_stu_info2\\G*************************** 1. row *************************** Table: tb_stu_info2Create Table: CREATE TABLE `tb_stu_info2` ( `id` int(11) NOT NULL, `name` char(45) DEFAULT NULL, `dept_id` int(11) DEFAULT NULL, `age` int(11) DEFAULT NULL, `height` int(11) DEFAULT NULL, UNIQUE KEY `height` (`height`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) 查看索引查看已创建的索引的情况，可以使用 SHOW INDEX 语句查看表中创建的索引。语法格式：SHOW INDEX FROM &lt;表名&gt; [ FROM &lt;数据库名&gt;]语法说明：&lt;表名&gt;：要显示索引的表。&lt;数据库名&gt;：要显示的表所在的数据库。12mysql&gt; SHOW INDEX FROM course FROM mytest;# 显示数据库mytest的表course的索引情况显示字段说明如下：Table：表的名称。Non_unique：用于显示该索引是否是唯一索引。若不是唯一索引，则该列的值显示为 1；若是唯一索引，则该列的值显示为 0。Key_name：索引的名称。Seq_in_index：索引中的列序列号，从 1 开始计数。Column_name：列名称。Collation：显示列以何种顺序存储在索引中。在 MySQL 中，升序显示值“A”（升序），若显示为 NULL，则表示无分类。Cardinality：显示索引中唯一值数目的估计值。基数根据被存储为整数的统计数据计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。Sub_part：若列只是被部分编入索引，则为被编入索引的字符的数目。若整列被编入索引，则为 NULL。Packed：指示关键字如何被压缩。若没有被压缩，则为 NULL。Null：用于显示索引列中是否包含 NULL。若列含有 NULL，则显示为 YES。若没有，则该列显示为 NO。Index_type：显示索引使用的类型和方法（BTREE、FULLTEXT、HASH、RTREE）。Comment：显示评注。实例：使用 SHOW INDEX 语句查看表 tb_stu_info2 的索引信息12345678910111213141516mysql&gt; SHOW INDEX FROM tb_stu_info2\\G*************************** 1. row *************************** Table: tb_stu_info2 Non_unique: 0 Key_name: height Seq_in_index: 1 Column_name: height Collation: A Cardinality: 0 Sub_part: NULL Packed: NULL Null: YES Index_type: BTREE Comment: Index_comment: 1 row in set (0.00 sec) 修改和删除索引(DROP INDEX)当不再需要索引时，可以使用 DROP INDEX 语句或 ALTER TABLE 语句来对索引进行删除。1.使用DROP INDEX语句语法格式：DROP INDEX &lt;索引名&gt; ON &lt;表名&gt;语法说明：&lt;索引名&gt;：要删除的索引名&lt;表名&gt;：指定该索引所在的表名2.使用ALTER TABLE语句根据 ALTER TABLE 语句的语法可知，该语句也可以用于删除索引。具体使用方法是将 ALTER TABLE 语句的语法中部分指定为以下子句中的某一项。DROP PRIMARY KEY：表示删除表中的主键。一个表只有一个主键，主键也是一个索引。DROP INDEX index_name：表示删除名称为 index_name 的索引。DROP FOREIGN KEY fk_symbol：表示删除外键。 删除索引实例：删除表tb_stu_info中的索引12345678910111213141516mysql&gt; DROP INDEX height -&gt; on tb_stu_info;Query OK, 0 rows affected (0.20 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; show create table tb_stu_info\\G*************************** 1. row *************************** Table: tb_stu_infoCreate Table: CREATE TABLE `tb_stu_info` ( `id` int(11) NOT NULL, `nam` char(45) DEFAULT NULL, `dept_id` int(11) DEFAULT NULL, `age` int(11) DEFAULT NULL, `height` int(11) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"SQL-数据操作语言(DML)","slug":"SQL-数据操作语言","date":"2020-04-16T10:05:27.000Z","updated":"2020-04-21T10:46:52.760Z","comments":true,"path":"2020/04/16/SQL-数据操作语言/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/SQL-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80/","excerpt":"","text":"INSERT INTO-向数据库表中插入数据INSERT语句有两种语法形式，分别是INSERT…VALUES语句和INSERT…SET语句。1. INSERT…VALUES的语法格式为：INSERT INTO &lt;表名&gt; [ &lt;列名1&gt; [ , … &lt;列名n&gt;] ]VALUES (值1) [… , (值n) ];语法说明如下：&lt;表名&gt;：指定被操作的表名。&lt;列名&gt;：指定需要插入数据的列名。若向表中的所有列插入数据，则全部的列名均可以省略，直接采用 INSERT&lt;表名&gt;VALUES(…) 即可。VALUES 或 VALUE 子句：该子句包含要插入的数据清单。数据清单中数据的顺序要和列的顺序相对应。2. INSERT…SET的语法格式为：INSERT INTO &lt;表名&gt;SET &lt;列名1&gt; = &lt;值1&gt;,&lt;列名2&gt; = &lt;值2&gt;,…此语句用于给表中的某些列指定对应的列值，即要插入的数据的列名在SET子句中指定，col_name为指定的列名，等号后面为指定的数据，而对于未指定的列，列值会指定为该列的默认值。INSERT语句的两种形式可是看出：使用 INSERT…VALUES 语句可以向表中插入一行数据，也可以插入多行数据；使用 INSERT…SET 语句可以指定插入行中每列的值，也可以指定部分列的值；INSERT…SELECT 语句向表中插入其他表的数据。采用 INSERT…SET 语句可以向表中插入部分列的值，这种方式更为灵活；NSERT…VALUES 语句可以一次插入多条数据。 向表中的全部字段添加值插入数据时，指定表的所有字段，为每一个字段插入新的值。123456789101112mysql&gt; INSERT INTO tb_courses -&gt; (course_id, course_name, course_grade, course_info) -&gt; values(1, 'Math', 3, 'Computer Math');Query OK, 1 row affected (0.04 sec)mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | Math | 3 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.00 sec)使用INSERT插入数据，允许列名称顺序与定义不同，必须保证值顺序与列字段顺序相同。允许列名称为空，插入顺序必须与数据表中定义的顺序相同。 表中指定字段添加值表的指定字段插入数据，是在 INSERT 语句中只向部分字段中插入值，而其他字段的值为表定义时的默认值，示例如下：12345678910111213mysql&gt; insert into tb_courses -&gt; (course_name, course_grade, course_info) -&gt; values('System',3,'Operation System');Query OK, 1 row affected (0.04 sec)mysql&gt; select * from tb_courses;+-----------+-------------+--------------+------------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+------------------+| 1 | Math | 3 | Computer Math || 2 | System | 3 | Operation System |+-----------+-------------+--------------+------------------+2 rows in set (0.00 sec) INSERT INTO…FROM语句复制表数据SELECT子句返回的是一个查询到的结果集，INSERT语句将这个结果集插入指定表中，结果集中的每行数据的字段数、字段的数据类型都必须与被操作的表完全一致。使用示例如下：123456789101112131415mysql&gt; INSERT INTO tb_courses_new -&gt; (course_id, course_name, course_grade, course_info) -&gt; SELECT course_id, course_name, course_grade, course_info -&gt; FROM tb_courses;Query OK, 2 rows affected (0.05 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from tb_courses_new;+-----------+-------------+--------------+------------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+------------------+| 1 | Math | 3 | Computer Math || 2 | System | 3 | Operation System |+-----------+-------------+--------------+------------------+2 rows in set (0.00 sec) DELETE-从数据库表中删除数据SQL中使用DELETE语句来删除表的一行或者多行数据。 删除单个表中的数据DELETE语句从单个表中删除数据语法格式:DELETE FROM &lt;表名&gt; [WHERE 子句] [ORDER BY 子句] [LIMIT 子句]语法说明如下：&lt;表名&gt;：指定要删除数据的表名。ORDER BY 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。WHERE 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。LIMIT 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。使用示例如下：1234567891011mysql&gt; DELETE FROM tb_courses -&gt; WHERE course_id = 2;Query OK, 1 row affected (0.04 sec)mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | Math | 3 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.00 sec) UPDATE-更新数据库表中的数据UPDATE 语句修改单个表，语法格式为UPDATE &lt;表名&gt; SET 字段 1=值 1 [,字段 2=值 2… ] [WHERE 子句 ][ORDER BY 子句] [LIMIT 子句]语法说明如下：&lt;表名&gt;：用于指定要更新的表名称SET 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。WHERE 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。ORDER BY 子句：可选项。用于限定表中的行被修改的次序。LIMIT 子句：可选项。用于限定被修改的行数。 修改表中的数据使用示例如下：1234567891011mysql&gt; UPDATE tb_courses SET course_grade=4;Query OK, 1 row affected (0.05 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | Math | 4 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.00 sec) 根据条件修改表中的数据使用示例如下：12345678910111213mysql&gt; UPDATE tb_courses -&gt; SET course_name='DB', course_grade=3.5 -&gt; WHERE course_id=1;Query OK, 1 row affected (0.05 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from tb_courses;+-----------+-------------+--------------+---------------+| course_id | course_name | course_grade | course_info |+-----------+-------------+--------------+---------------+| 1 | DB | 3.5 | Computer Math |+-----------+-------------+--------------+---------------+1 row in set (0.01 sec) SELECT-从数据库表中获取数据数据表查询见SQL-查询","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"interview-tree","slug":"interview-tree","date":"2020-04-16T02:24:14.000Z","updated":"2020-04-16T12:06:04.779Z","comments":true,"path":"2020/04/16/interview-tree/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/interview-tree/","excerpt":"","text":"树 二叉树L、D、R分别表示遍历左子树、访问根节点和遍历右子树先序遍历：DLR中序遍历：LDR后序遍历：LRD确定一个二叉树，必须有中序遍历 二叉树的性质性质1：在二叉树中第i层的结点数最多为2i−1（i≥1）2^{i - 1}（i \\geq 1）2i−1（i≥1）性质2：高度为k的二叉树节点其结点总数最多为2k−1（k≥1）2^{k} - 1（k \\geq 1）2k−1（k≥1）性质3：对任意的非空二叉树T，如果叶节点的个数为n0n_{0}n0​，而其度为2的结点数为n2n_{2}n2​，则：n0=n2+1n{0} = n_{2} + 1n0=n2​+1 满二叉树深度为k，且有2k−12^{k} - 12k−1个节点称为满二叉树；性质4：第i层上的结点数为2i−12^{i - 1}2i−1； 完全二叉树深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。性质5：对于具有n个结点的完全二叉树的高度为log2n+1log^{n}_{2} + 1log2n​+1二叉树的构造12345678910111213141516171819class TreeNode: def __init__(self, val=None): self.val = val self.left = None self.right = None self.parent = Noneclass Tree: def __init__(self, data: , n): # if n &gt;= len(data): return if data[n] == '#': return node = TreeNode() node.val = data[n] node.left = Tree(data, n + 1) node.right = Tree(data, n + 2) return node","categories":[{"name":"面试","slug":"面试","permalink":"http://forwardpeng.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"http://forwardpeng.github.io/tags/%E6%A0%91/"}]},{"title":"SQL-数据定义语言(DDL)","slug":"SQL-数据定义语言","date":"2020-04-16T02:21:26.000Z","updated":"2020-04-21T10:47:36.004Z","comments":true,"path":"2020/04/16/SQL-数据定义语言/","link":"","permalink":"http://forwardpeng.github.io/2020/04/16/SQL-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/","excerpt":"","text":"数据库 CREATE DATABASE-创建新数据库语法格式：CREATE DATABASE [IF NOT EXISTS] &lt;数据库名&gt;[[DEFAULT] CHARACTER SET &lt;字符集名&gt;][[DEFAULT] COLLATE &lt;校对规则名&gt;];[]中的内容是可选的。语法说明如下：&lt;数据库名&gt;：创建数据库的名称。MySQL 的数据存储区将以目录方式表示 MySQL 数据库，因此数据库名称必须符合操作系统的文件夹命名规则，不能以数字开头，尽量要有实际意义。注意在 MySQL 中不区分大小写。IF NOT EXISTS：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。[DEFAULT] CHARACTER SET：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。[DEFAULT] COLLATE：指定字符集的默认校对规则。创建数据库的基本示例：1234mysql&gt; CREATE DATABASE IF NOT EXISTS test_db_char -&gt; DEFAULT CHARACTER SET utf8 -&gt; DEFAULT COLLATE utf8_unicode_ci;Query OK, 1 row affected (0.03 sec) ALTER DATABASE-修改数据库语法格式：ALTER DATABASE [数据库名] {[ DEFAULT ] CHARACTER SET &lt;字符集名&gt; |[ DEFAULT ] COLLATE &lt;校对规则名&gt;}语法说明如下：ALTER DATABASE 用于更改数据库的全局特性。使用 ALTER DATABASE 需要获得数据库 ALTER 权限。数据库名称可以忽略，此时语句对应于默认数据库。CHARACTER SET 子句用于更改默认的数据库字符集。修改数据库的示例如下：1234mysql&gt; ALTER CREATE test_db_char -&gt; DEFAULT CHARACTER SET utf8 -&gt; DEFAULT COLLATE utf8_general_ci;Query OK, 1 row affected (0.00 sec) SHOW DATABASE-查看数据库语法格式：SHOW DATABASES [LIKE ‘数据库名’];语法说明如下：LIKE 从句是可选项，用于匹配指定的数据库名称。LIKE 从句可以部分匹配，也可以完全匹配。数据库名使用单引号’ '。查看数据库示例如下：12345678mysql&gt; SHOW DATABSES LIKE '%test%';+-------------------+| Database (%test%) |+-------------------+| test || test_db_char |+-------------------+2 rows in set (0.00 sec) DROP DATABASE-删除数据库语法格式：DROP DATABASE [ IF EXISTS ] &lt;数据库名&gt;语法说明如下：&lt;数据库名&gt;：指定要删除的数据库名。IF EXISTS：用于防止当数据库不存在时发生错误。DROP DATABASE：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 DROP DATABASE，需要获得数据库 DROP 权限。12mysql&gt; DROP DATABASE test;Query OK, 0 rows affected (0.19 sec) 数据表 CREATE TABLE-创建新数据库表语法格式：CREATE TABLE &lt;表名&gt; ([表定义选项])[表选项][分区选项];语法说明如下：CREATE TABLE：用于创建给定名称的表，必须拥有表CREATE的权限。&lt;表名&gt;：指定要创建表的名称，在 CREATE TABLE 之后给出，必须符合标识符命名规则。表名称被指定为 db_name.tbl_name，以便在特定的数据库中创建表。无论是否有当前数据库，都可以通过这种方式创建。在当前数据库中创建表时，可以省略 db-name。如果使用加引号的识别名，则应对数据库和表名称分别加引号。例如，‘mydb’.‘mytbl’ 是合法的，但 ‘mydb.mytbl’ 不合法。&lt;表定义选项&gt;：表创建定义，由列名（col_name）、列的定义（column_definition）以及可能的空值说明、完整性约束或表索引组成。默认的情况是，表被创建到当前的数据库中。若表已存在、没有当前数据库或者数据库不存在，则会出现错误。12345678mysql&gt; CREATE TABLE tb_test -&gt; ( -&gt; id INT(11), -&gt; name VARCHAR(25), -&gt; deptId INT(11), -&gt; salary FLOAT -&gt;);Query OK, 0 rows affected（0.37 sec）DESCRIBE(DESC)&lt;表名&gt;; 用于查看表的字段信息12345678mysql&gt; DESCRIBE join_test1;+-------+-----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-----------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | char(255) | YES | | NULL | |+-------+-----------+------+-----+---------+-------+2 rows in set (0.06 sec)SHOW CREATE TABLE&lt;表名&gt;\\G;12345678mysql&gt; show create table join_test1\\G*************************** 1. row *************************** Table: join_test1Create Table: CREATE TABLE `join_test1` ( `id` int(11) DEFAULT NULL, `name` char(255) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) ALTER TABLE-修改数据库表语法格式：ALTER TABLE &lt;表名&gt; [修改选项]修改选项的语法格式如下：{ ADD COLUMN &lt;列名&gt; &lt;类型&gt;| CHANGE COLUMN &lt;旧列名&gt; &lt;新列名&gt; &lt;新列类型&gt;| ALTER COLUMN &lt;列名&gt; { SET DEFAULT &lt;默认值&gt; | DROP DEFAULT }| MODIFY COLUMN &lt;列名&gt; &lt;类型&gt;| DROP COLUMN &lt;列名&gt;| RENAME TO &lt;新表名&gt; } 添加字段的语法格式如下：ALTER TABLE &lt;表名&gt; ADD &lt;新字段名&gt; &lt;数据类型&gt; [约束条件] [FIRST|AFTER 已存在的字段名]; #FIRST|AFTER用于指定新字段在表中的位置。添加字段的使用示例：1234567891011121314mysql&gt; ALTER TABLE test ADD COLUMN col2 INT FIRST;Query OK, 0 rows affected (0.41 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; desc test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| col2 | int(11) | YES | | NULL | || col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(25) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 修改字段的数据类型语法格式：ALTER TABLE &lt;表名&gt; MODIFY &lt;字段名&gt; &lt;数据类型&gt;其中，表名指要修改数据类型的字段所在表的名称，字段名指需要修改的字段，数据类型指修改后字段的新数据类型。修改字段的使用示例：123456789101112131415mysql&gt; ALTER TABLE test -&gt; MODIFY name varchar(30);Query OK, 0 rows affected (0.07 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| col2 | int(11) | YES | | NULL | || col1 | int(11) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec) 删除字段语法格式：ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;；删除字段的使用示例如下：123456789101112mysql&gt; ALTER TABLE test DROP col1;Query OK, 0 rows affected (0.45 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+2 rows in set (0.00 sec) 修改字段名称ALTER TABLE &lt;表名&gt; CHANGE &lt;旧字段名&gt; &lt;新字段名&gt; &lt;新数据类型&gt;；其中，旧字段名指修改前的字段名；新字段名指修改后的字段名；新数据类型指修改后的数据类型，如果不需要修改字段的数据类型，可以将新数据类型设置成与原来一样，但数据类型不能为空。修改字段名称的使用示例：1234567891011121314mysql&gt; ALTER TABLE test -&gt; CHANGE col1 col3 CHAR(50);Query OK, 0 rows affected (0.81 sec)Records: 0 Duplicates: 0 Warnings: 0mysql&gt; DESC test;+-------+-------------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| col3 | char(50) | YES | | NULL | || id | int(11) | YES | | NULL | || name | varchar(30) | YES | | NULL | |+-------+-------------+------+-----+---------+-------+3 rows in set (0.01 sec) 修改表名语法格式：ALTER TABLE &lt;旧表名&gt; RENAME [TO] &lt;新表名&gt;；修改表名使用示例：123456789101112mysql&gt; ALTER TABLE test -&gt; RENAME TO test_re;Query OK, 0 rows affected (0.13 sec)mysql&gt; show tables;+----------------+| Tables_in_test |+----------------+| join_test1 || test_re |+----------------+2 rows in set (0.00 sec) DROP TABLE-删除表基本语法：DROP TABLE [IF EXISTS] 表名1 [ ,表名2, 表名3 …]语法格式的说明：表名1, 表名2, 表名3 …表示要被删除的数据表的名称。DROP TABLE 可以同时删除多个表，只要将表名依次写在后面，相互之间用逗号隔开即可。IF EXISTS 用于在删除数据表之前判断该表是否存在。如果不加 IF EXISTS，当数据表不存在时 MySQL 将提示错误，中断 SQL 语句的执行；加上 IF EXISTS 后，当数据表不存在时 SQL 语句可以顺利执行，但是会发出警告（warning）。用户必须拥有执行DROP的权限，否则无法删除。表删除后，用户在该表上的权限不会自动删除删除表的使用示例：12mysql&gt; DROP TABLE test_re;Query OK, 0 rows affected (0.15 sec)CREATE INDEX-创建索引、DROP INDEX-删除索引。见SQL-索引","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"算法导论-基本的数据结构","slug":"algo-tree","date":"2020-04-15T15:46:44.000Z","updated":"2020-04-22T07:13:20.900Z","comments":true,"path":"2020/04/15/algo-tree/","link":"","permalink":"http://forwardpeng.github.io/2020/04/15/algo-tree/","excerpt":"","text":"介绍几种基本的结构：栈、队列、链表和有根树。同时介绍由数组构造对象和指针的方法。（参考算法导论第三版P129 - P160） 栈和队列栈与队列属于动态集合，在其进行DELETE操作所移除的元素是预先设定的。栈被删除的是最近插入的元素：栈的实现的是一种后进后出（LIFO）策略 链表 指针和对象的实现 有根树的表示 课后习题","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"数据结构","slug":"计算机基础/数据结构","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法导论","slug":"算法导论","permalink":"http://forwardpeng.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"}]},{"title":"STL标准模板库","slug":"STL标准模板库","date":"2020-04-15T05:47:40.000Z","updated":"2020-04-16T12:05:17.720Z","comments":true,"path":"2020/04/15/STL标准模板库/","link":"","permalink":"http://forwardpeng.github.io/2020/04/15/STL%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/","excerpt":"","text":"STL 网站github . huihut/note/STL.mdcplusplus . stlcppreference . C++ 参考手册CSDN专栏：STL学习笔记 组成容器（containers）算法（algorithms）迭代器（iterators）仿函数（functors）配接器（adapters）空间配置器（allocator） 容器（containers）序列式容器（sequence containers）：元素都是可序（ordered），但未必是有序（sorted）关联式容器（associattive containers） arrayarray是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。在内部，一个数组除了它所包含的元素（甚至不是它的大小，它是一个模板参数，在编译时是固定的）以外不保存任何数据。存储大小与用语言括号语法（[]）声明的普通数组一样高效。这个类只是增加了一层成员函数和全局函数，所以数组可以作为标准容器使用。与其他标准容器不同，数组具有固定的大小，并且不通过分配器管理其元素的分配：它们是封装固定大小数组元素的聚合类型。因此，他们不能动态地扩大或缩小。零大小的数组是有效的，但是它们不应该被解除引用（成员的前面，后面和数据）。与标准库中的其他容器不同，交换两个数组容器是一种线性操作，它涉及单独交换范围内的所有元素，这通常是相当低效的操作。另一方面，这允许迭代器在两个容器中的元素保持其原始容器关联。数组容器的另一个独特特性是它们可以被当作元组对象来处理：array头部重载get函数来访问数组元素，就像它是一个元组，以及专门的tuple_size和tuple_element类型。1template &lt; class T, size_t N &gt; class array; array::begin返回指向数组容器中第一个元素的迭代器。12 iterator begin() noexcept;const_iterator begin() const noexcept;Example12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 5&gt; myarray = &#123;2, 16, 77,34, 50&#125;; std::cout &lt;&lt; \"myarray contains:\"; for(auto it = myarray.begin(); it != myarray.end(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 2 16 77 34 50 array::end返回指向数组容器中最后一个元素之后的理论元素的迭代器。12 iterator end() noexcept;const_iterator end() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 5, 19, 77, 34, 99 &#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.begin(); it != myarray.end(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 5 19 77 34 99 array::rbegin返回指向数组容器中最后一个元素的反向迭代器。12 reverse_iterator rbegin（）noexcept;const_reverse_iterator rbegin（）const noexcept;Example12345678910111213#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125; ; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 14 80 26 4 array::rend返回一个反向迭代器，指向数组中第一个元素之前的理论元素（这被认为是它的反向结束）。12 reverse_iterator rend() noexcept;const_reverse_iterator rend() const noexcept;Example1234567891011121314#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,4&gt; myarray = &#123;4, 26, 80, 14&#125;; std::cout &lt;&lt; \"myarray contains\"; for(auto rit = myarray.rbegin(); rit &lt; myarray.rend(); ++rit) std::cout &lt;&lt; ' ' &lt;&lt; *rit; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 14 80 26 4 array::cbegin返回指向数组容器中第一个元素的常量迭代器（const_iterator）；这个迭代器可以增加和减少，但是不能用来修改它指向的内容。1const_iterator cbegin（）const noexcept;Example12345678910111213141516#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123;2, 16, 77, 34, 50&#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 2 16 77 34 50 array::cend返回指向数组容器中最后一个元素之后的理论元素的常量迭代器（const_iterator）。这个迭代器可以增加和减少，但是不能用来修改它指向的内容。1const_iterator cend() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myarray = &#123; 15, 720, 801, 1002, 3502 &#125;; std::cout &lt;&lt; \"myarray contains:\"; for ( auto it = myarray.cbegin(); it != myarray.cend(); ++it ) std::cout &lt;&lt; ' ' &lt;&lt; *it; // cannot modify *it std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 2 16 77 34 50 array::crbegin返回指向数组容器中最后一个元素的常量反向迭代器（const_reverse_iterator）1const_reverse_iterator crbegin（）const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; \"myarray backwards:\"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray backwards: 60 50 40 30 20 10 array::crend返回指向数组中第一个元素之前的理论元素的常量反向迭代器（const_reverse_iterator），它被认为是其反向结束。1const_reverse_iterator crend() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,6&gt; myarray = &#123;10, 20, 30, 40, 50, 60&#125; ; std::cout &lt;&lt; \"myarray backwards:\"; for ( auto rit=myarray.crbegin() ; rit &lt; myarray.crend(); ++rit ) std::cout &lt;&lt; ' ' &lt;&lt; *rit; // cannot modify *rit std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray backwards: 60 50 40 30 20 10 array::size返回数组容器中元素的数量。1constexpr size_type size（）noexcept;Example1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; myints; std::cout &lt;&lt; \"size of myints:\" &lt;&lt; myints.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"sizeof(myints):\" &lt;&lt; sizeof(myints) &lt;&lt; std::endl; return 0;&#125;Possible Output12size of myints: 5sizeof(myints): 20 array::max_size返回数组容器可容纳的最大元素数。数组对象的max_size与其size一样，始终等于用于实例化数组模板类的第二个模板参数。1constexpr size_type max_size() noexcept;Example1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myints; std::cout &lt;&lt; \"size of myints: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; std::cout &lt;&lt; \"max_size of myints: \" &lt;&lt; myints.max_size() &lt;&lt; '\\n'; return 0;&#125;Output12size of myints: 10max_size of myints: 10 array::empty返回一个布尔值，指示数组容器是否为空，即它的size()是否为0。1constexpr bool empty() noexcept;Example1234567891011#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,0&gt; first; std::array&lt;int,5&gt; second; std::cout &lt;&lt; \"first \" &lt;&lt; (first.empty() ? \"is empty\" : \"is not empty\") &lt;&lt; '\\n'; std::cout &lt;&lt; \"second \" &lt;&lt; (second.empty() ? \"is empty\" : \"is not empty\") &lt;&lt; '\\n'; return 0;&#125;Output:12first is emptysecond is not empt array::operator[]返回数组中第n个位置的元素的引用。与array::at相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。12 reference operator[] (size_type n);const_reference operator[] (size_type n) const;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,10&gt; myarray; unsigned int i; // assign some values: for(i=0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; \"myarray contains:\"; for(i=0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::at返回数组中第n个位置的元素的引用。与array::operator[]相似，但array::at会检查数组边界并通过抛出一个out_of_range异常来判断n是否超出范围，而array::operator[]不检查边界。12 reference at ( size_type n );const_reference at ( size_type n ) const;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main()&#123; std::array&lt;int, 10&gt; myarray; unsigned int i; // assign some values: for (i = 0; i&lt;10; i++) myarray[i] = i; // print content std::cout &lt;&lt; \"myarray contains:\"; for (i = 0; i&lt;10; i++) std::cout &lt;&lt; ' ' &lt;&lt; myarray.at(i); std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 0 1 2 3 4 5 6 7 8 9 array::front返回对数组容器中第一个元素的引用。array::begin返回的是迭代器，array::front返回的是直接引用。在空容器上调用此函数会导致未定义的行为。12 reference front();const_reference front() const;Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;2, 16, 77&#125;; std::cout &lt;&lt; \"front is: \" &lt;&lt; myarray.front() &lt;&lt; std::endl; // 2 std::cout &lt;&lt; \"back is: \" &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.front() = 100; std::cout &lt;&lt; \"myarray now contains:\"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output123front is: 2back is: 77myarray now contains: 100 16 77 array::back返回对数组容器中最后一个元素的引用。array::end返回的是迭代器，array::back返回的是直接引用。在空容器上调用此函数会导致未定义的行为。12 reference back();const_reference back() const;Example123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;5, 19, 77&#125;; std::cout &lt;&lt; \"front is: \" &lt;&lt; myarray.front() &lt;&lt; std::endl; // 5 std::cout &lt;&lt; \"back is: \" &lt;&lt; myarray.back() &lt;&lt; std::endl; // 77 myarray.back() = 50; std::cout &lt;&lt; \"myarray now contains:\"; for ( int&amp; x : myarray ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output123front is: 5back is: 77myarray now contains: 5 19 50 array::data返回指向数组对象中第一个元素的指针。由于数组中的元素存储在连续的存储位置，所以检索到的指针可以偏移以访问数组中的任何元素。12 value_type* data() noexcept;const value_type* data() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;array&gt;int main ()&#123; const char* cstr = \"Test string\"; std::array&lt;char,12&gt; charray; std::memcpy (charray.data(),cstr,12); std::cout &lt;&lt; charray.data() &lt;&lt; '\\n'; return 0;&#125;Output1Test string array::fill用val填充数组所有元素，将val设置为数组对象中所有元素的值。1void fill (const value_type&amp; val);Example123456789101112131415#include &lt;iostream&gt;#include &lt;array&gt;int main () &#123; std::array&lt;int,6&gt; myarray; myarray.fill(5); std::cout &lt;&lt; \"myarray contains:\"; for ( int&amp; x : myarray) &#123; std::cout &lt;&lt; ' ' &lt;&lt; x; &#125; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myarray contains: 5 5 5 5 5 5 array::swap通过x的内容交换数组的内容，这是另一个相同类型的数组对象（包括相同的大小）。与其他容器的交换成员函数不同，此成员函数通过在各个元素之间执行与其大小相同的单独交换操作，以线性时间运行。1void swap (array&amp; x) noexcept(noexcept(swap(declval&lt;value_type&amp;&gt;(),declval&lt;value_type&amp;&gt;())));Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; first = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; second = &#123;11, 22, 33, 44, 55&#125;; first.swap (second); std::cout &lt;&lt; \"first:\"; for (int&amp; x : first) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"second:\"; for (int&amp; x : second) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output12first: 11 22 33 44 55second: 10 20 30 40 50 get（array）形如：std::get&lt;0&gt;(myarray)；传入一个数组容器，返回指定位置元素的引用。123template &lt;size_t I，class T，size_t N&gt; T＆get（array &lt;T，N&gt;＆arr）noexcept; template &lt;size_t I，class T，size_t N&gt; T &amp;&amp; get（array &lt;T，N&gt; &amp;&amp; arr）noexcept; template &lt;size_t I，class T，size_t N&gt; const T＆get（const array &lt;T，N&gt;＆arr）noexcept;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;array&gt;#include &lt;tuple&gt;int main ()&#123; std::array&lt;int,3&gt; myarray = &#123;10, 20, 30&#125;; std::tuple&lt;int,int,int&gt; mytuple (10, 20, 30); std::tuple_element&lt;0,decltype(myarray)&gt;::type myelement; // int myelement myelement = std::get&lt;2&gt;(myarray); std::get&lt;2&gt;(myarray) = std::get&lt;0&gt;(myarray); std::get&lt;0&gt;(myarray) = myelement; std::cout &lt;&lt; \"first element in myarray: \" &lt;&lt; std::get&lt;0&gt;(myarray) &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"first element in mytuple: \" &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; \"\\n\"; return 0;&#125;Output12first element in myarray: 30first element in mytuple: 10 relational operators (array)形如：arrayA != arrayB、arrayA &gt; arrayB；依此比较数组每个元素的大小关系。123456789101112131415161718（1） template &lt;class T，size_T N&gt; bool operator ==（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（2） template &lt;class T，size_T N&gt; bool operator！=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（3） template &lt;class T，size_T N&gt; bool operator &lt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（4） template &lt;class T，size_T N&gt; bool operator &lt;=（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（5） template &lt;class T，size_T N&gt; bool operator&gt;（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;（6） template &lt;class T，size_T N&gt; bool operator&gt; =（const array &lt;T，N&gt;＆lhs，const array &lt;T，N&gt;＆rhs）;Example123456789101112131415161718#include &lt;iostream&gt;#include &lt;array&gt;int main ()&#123; std::array&lt;int,5&gt; a = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; b = &#123;10, 20, 30, 40, 50&#125;; std::array&lt;int,5&gt; c = &#123;50, 40, 30, 20, 10&#125;; if (a==b) std::cout &lt;&lt; \"a and b are equal\\n\"; if (b!=c) std::cout &lt;&lt; \"b and c are not equal\\n\"; if (b&lt;c) std::cout &lt;&lt; \"b is less than c\\n\"; if (c&gt;b) std::cout &lt;&lt; \"c is greater than b\\n\"; if (a&lt;=b) std::cout &lt;&lt; \"a is less than or equal to b\\n\"; if (a&gt;=b) std::cout &lt;&lt; \"a is greater than or equal to b\\n\"; return 0;&#125;Output123456a and b are equalb and c are not equalb is less than cc is greater than ba is less than or equal to ba is greater than or equal to b vectorvector是表示可以改变大小的数组的序列容器。就像数组一样，vector为它们的元素使用连续的存储位置，这意味着它们的元素也可以使用到其元素的常规指针上的偏移来访问，而且和数组一样高效。但是与数组不同的是，它们的大小可以动态地改变，它们的存储由容器自动处理。在内部，vector使用一个动态分配的数组来存储它们的元素。这个数组可能需要重新分配，以便在插入新元素时增加大小，这意味着分配一个新数组并将所有元素移动到其中。就处理时间而言，这是一个相对昂贵的任务，因此每次将元素添加到容器时矢量都不会重新分配。相反，vector容器可以分配一些额外的存储以适应可能的增长，并且因此容器可以具有比严格需要包含其元素（即，其大小）的存储更大的实际容量。库可以实现不同的策略的增长到内存使用和重新分配之间的平衡，但在任何情况下，再分配应仅在对数生长的间隔发生尺寸，使得在所述载体的末端各个元件的插入可以与提供分期常量时间复杂性。因此，与数组相比，载体消耗更多的内存来交换管理存储和以有效方式动态增长的能力。与其他动态序列容器（deques，lists和 forward_lists ）相比，vector非常有效地访问其元素（就像数组一样），并相对有效地从元素末尾添加或移除元素。对于涉及插入或移除除了结尾之外的位置的元素的操作，它们执行比其他位置更差的操作，并且具有比列表和 forward_lists 更不一致的迭代器和引用。针对 vector 的各种常见操作的复杂度（效率）如下：随机访问 - 常数 O(1)在尾部增删元素 - 平摊（amortized）常数 O(1)}}增删元素 - 至 vector 尾部的线性距离 O(n)}}1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; vector::vector（1）empty容器构造函数（默认构造函数）构造一个空的容器，没有元素。（2）fill构造函数用n个元素构造一个容器。每个元素都是val的副本（如果提供）。（3）范围（range）构造器使用与[ range，first，last]范围内的元素相同的顺序构造一个容器，其中的每个元素都是emplace -从该范围内相应的元素构造而成。（4）复制（copy）构造函数（并用分配器复制）按照相同的顺序构造一个包含x中每个元素的副本的容器。（5）移动（move）构造函数（和分配器移动）构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。（6）初始化列表构造函数构造一个容器中的每个元件中的一个拷贝的IL，以相同的顺序。12345678910111213141516171819default (1) explicit vector (const allocator_type&amp; alloc = allocator_type());fill (2) explicit vector (size_type n); vector (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; vector (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) vector (const vector&amp; x);vector (const vector&amp; x, const allocator_type&amp; alloc);move (5) vector (vector&amp;&amp; x);vector (vector&amp;&amp; x, const allocator_type&amp; alloc);initializer list (6) vector (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type());Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; // constructors used in the same order as described above: std::vector&lt;int&gt; first; // empty vector of ints std::vector&lt;int&gt; second(4, 100); // four ints with value 100 std::vector&lt;int&gt; third(second.begin(), second.end());// iterating through second std::vector&lt;int&gt; fourth(third); // a copy of third // the iterator constructor can also be used to construct from arrays: int myints[] = &#123;16,2,77,29&#125;; std::vector&lt;int&gt; fifth(myints, myints + sizeof(myints) / sizeof(int)); std::cout &lt;&lt; \"The contents of fifth are:\"; for(std::vector&lt;int&gt;::iterator it = fifth.begin(); it != fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1The contents of fifth are: 16 2 77 29 vector::~vector销毁容器对象。这将在每个包含的元素上调用allocator_traits::destroy，并使用其分配器释放由矢量分配的所有存储容量。1~vector(); vector::operator=将新内容分配给容器，替换其当前内容，并相应地修改其大小。123456copy (1) vector&amp; operator= (const vector&amp; x);move (2) vector&amp; operator= (vector&amp;&amp; x);initializer list (3) vector&amp; operator= (initializer_list&lt;value_type&gt; il);Example123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,0); std::vector&lt;int&gt; bar (5,0); bar &#x3D; foo; foo &#x3D; std::vector&lt;int&gt;(); std::cout &lt;&lt; &quot;Size of foo: &quot; &lt;&lt; int(foo.size()) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;Size of bar: &quot; &lt;&lt; int(bar.size()) &lt;&lt; &#39;\\n&#39;; return 0;&#125;Output12Size of foo: 0Size of bar: 3 vector::begin vector::end vector::rbegin vector::rend vector::cbegin vector::cend vector::rcbegin vector::rcend vector::size返回vector中元素的数量。这是vector中保存的实际对象的数量，不一定等于其存储容量。1size_type size() const noexcept;Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myints; std::cout &lt;&lt; \"0. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; for (int i=0; i&lt;10; i++) myints.push_back(i); std::cout &lt;&lt; \"1. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; myints.insert (myints.end(),10,100); std::cout &lt;&lt; \"2. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; myints.pop_back(); std::cout &lt;&lt; \"3. size: \" &lt;&lt; myints.size() &lt;&lt; '\\n'; return 0;&#125;Output12340. size: 01. size: 102. size: 203. size: 19 vector::max_size返回该vector可容纳的元素的最大数量。由于已知的系统或库实现限制，这是容器可以达到的最大潜在大小，但容器无法保证能够达到该大小：在达到该大小之前的任何时间，仍然无法分配存储。1size_type max_size() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; \"size: \" &lt;&lt; myvector.size() &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"capacity: \" &lt;&lt; myvector.capacity() &lt;&lt; \"\\n\"; std::cout &lt;&lt; \"max_size: \" &lt;&lt; myvector.max_size() &lt;&lt; \"\\n\"; return 0;&#125;A possible output for this program could be:123size: 100capacity: 128max_size: 1073741823 vector::resize调整容器的大小，使其包含n个元素。如果n小于当前的容器size，内容将被缩小到前n个元素，将其删除（并销毁它们）。如果n大于当前容器size，则通过在末尾插入尽可能多的元素以达到大小n来扩展内容。如果指定了val，则新元素将初始化为val的副本，否则将进行值初始化。如果n也大于当前的容器的capacity（容量），分配的存储空间将自动重新分配。注意这个函数通过插入或者删除元素的内容来改变容器的实际内容。12void resize (size_type n);void resize (size_type n, const value_type&amp; val);Example123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some initial content: for (int i=1;i&lt;10;i++) myvector.push_back(i); myvector.resize(5); myvector.resize(8,100); myvector.resize(12); std::cout &lt;&lt; \"myvector contains:\"; for (int i=0;i&lt;myvector.size();i++) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 1 2 3 4 5 100 100 100 0 0 0 0 vector::capacity返回当前为vector分配的存储空间的大小，用元素表示。这个capacity(容量)不一定等于vector的size。它可以相等或更大，额外的空间允许适应增长，而不需要重新分配每个插入。1size_type capacity() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some content in the vector: for (int i=0; i&lt;100; i++) myvector.push_back(i); std::cout &lt;&lt; \"size: \" &lt;&lt; (int) myvector.size() &lt;&lt; '\\n'; std::cout &lt;&lt; \"capacity: \" &lt;&lt; (int) myvector.capacity() &lt;&lt; '\\n'; std::cout &lt;&lt; \"max_size: \" &lt;&lt; (int) myvector.max_size() &lt;&lt; '\\n'; return 0;&#125;A possible output for this program could be:123size: 100capacity: 128max_size: 1073741823 vector::empty返回vector是否为空（即，它的size是否为0）1bool empty() const noexcept;Example1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); for (int i=1;i&lt;=10;i++) myvector.push_back(i); while (!myvector.empty()) &#123; sum += myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; \"total: \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125;Output1total: 55 vector::reserve请求vector容量至少足以包含n个元素。如果n大于当前vector容量，则该函数使容器重新分配其存储容量，从而将其容量增加到n（或更大）。在所有其他情况下，函数调用不会导致重新分配，并且vector容量不受影响。这个函数对vector大小没有影响，也不能改变它的元素。1void reserve (size_type n);Example12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt;::size_type sz; std::vector&lt;int&gt; foo; sz = foo.capacity(); std::cout &lt;&lt; \"making foo grow:\\n\"; for (int i=0; i&lt;100; ++i) &#123; foo.push_back(i); if (sz!=foo.capacity()) &#123; sz = foo.capacity(); std::cout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n'; &#125; &#125; std::vector&lt;int&gt; bar; sz = bar.capacity(); bar.reserve(100); // this is the only difference with foo above std::cout &lt;&lt; \"making bar grow:\\n\"; for (int i=0; i&lt;100; ++i) &#123; bar.push_back(i); if (sz!=bar.capacity()) &#123; sz = bar.capacity(); std::cout &lt;&lt; \"capacity changed: \" &lt;&lt; sz &lt;&lt; '\\n'; &#125; &#125; return 0;&#125;Possible output1234567891011making foo grow:capacity changed: 1capacity changed: 2capacity changed: 4capacity changed: 8capacity changed: 16capacity changed: 32capacity changed: 64capacity changed: 128making bar grow:capacity changed: 100 vector::shrink_to_fit要求容器减小其capacity(容量)以适应其尺寸。该请求是非绑定的，并且容器实现可以自由地进行优化，并且保持capacity大于其size的vector。 这可能导致重新分配，但对矢量大小没有影响，并且不能改变其元素。1void shrink_to_fit();Example12345678910111213141516#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (100); std::cout &lt;&lt; \"1. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; myvector.resize(10); std::cout &lt;&lt; \"2. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; myvector.shrink_to_fit(); std::cout &lt;&lt; \"3. capacity of myvector: \" &lt;&lt; myvector.capacity() &lt;&lt; '\\n'; return 0;&#125;Possible output1231. capacity of myvector: 1002. capacity of myvector: 1003. capacity of myvector: 10 vector::operator[] vector::at vector::front vector::back vector::data vector::assign将新内容分配给vector，替换其当前内容，并相应地修改其大小。在范围版本（1）中，新内容是从第一个和最后一个范围内的每个元素按相同顺序构造的元素。在填充版本（2）中，新内容是n个元素，每个元素都被初始化为一个val的副本。在初始化列表版本（3）中，新内容是以相同顺序作为初始化列表传递的值的副本。所述内部分配器被用于（通过其性状），以分配和解除分配存储器如果重新分配发生。它也习惯于摧毁所有现有的元素，并构建新的元素。1234567range (1) template &lt;class InputIterator&gt; void assign (InputIterator first, InputIterator last);fill (2) void assign (size_type n, const value_type&amp; val);initializer list (3) void assign (initializer_list&lt;value_type&gt; il);Example123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; first; std::vector&lt;int&gt; second; std::vector&lt;int&gt; third; first.assign (7,100); // 7 ints with a value of 100 std::vector&lt;int&gt;::iterator it; it=first.begin()+1; second.assign (it,first.end()-1); // the 5 central values of first int myints[] = &#123;1776,7,4&#125;; third.assign (myints,myints+3); // assigning from array. std::cout &lt;&lt; \"Size of first: \" &lt;&lt; int (first.size()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"Size of second: \" &lt;&lt; int (second.size()) &lt;&lt; '\\n'; std::cout &lt;&lt; \"Size of third: \" &lt;&lt; int (third.size()) &lt;&lt; '\\n'; return 0;&#125;Output123Size of first: 7Size of second: 5Size of third: 3补充：vector::assign 与 vector::operator= 的区别：vector::assign 实现源码12345678910111213141516void assign(size_type __n, const _Tp&amp; __val) &#123; _M_fill_assign(__n, __val); &#125;template &lt;class _Tp, class _Alloc&gt;void vector&lt;_Tp, _Alloc&gt;::_M_fill_assign(size_t __n, const value_type&amp; __val) &#123; if (__n &gt; capacity()) &#123; vector&lt;_Tp, _Alloc&gt; __tmp(__n, __val, get_allocator()); __tmp.swap(*this); &#125; else if (__n &gt; size()) &#123; fill(begin(), end(), __val); _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val); &#125; else erase(fill_n(begin(), __n, __val), end());&#125;vector::operator= 实现源码12345678910111213141516171819202122232425template &lt;class _Tp, class _Alloc&gt;vector&lt;_Tp,_Alloc&gt;&amp; vector&lt;_Tp,_Alloc&gt;::operator=(const vector&lt;_Tp, _Alloc&gt;&amp; __x)&#123; if (&amp;__x != this) &#123; const size_type __xlen = __x.size(); if (__xlen &gt; capacity()) &#123; iterator __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end()); destroy(_M_start, _M_finish); _M_deallocate(_M_start, _M_end_of_storage - _M_start); _M_start = __tmp; _M_end_of_storage = _M_start + __xlen; &#125; else if (size() &gt;= __xlen) &#123; iterator __i = copy(__x.begin(), __x.end(), begin()); destroy(__i, _M_finish); &#125; else &#123; copy(__x.begin(), __x.begin() + size(), _M_start); uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish); &#125; _M_finish = _M_start + __xlen; &#125; return *this;&#125; vector::push_back在vector的最后一个元素之后添加一个新元素。val的内容被复制（或移动）到新的元素。这有效地将容器size增加了一个，如果新的矢量size超过了当前vector的capacity，则导致所分配的存储空间自动重新分配。12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val);Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int myint; std::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\\n\"; do &#123; std::cin &gt;&gt; myint; myvector.push_back (myint); &#125; while (myint); std::cout &lt;&lt; \"myvector stores \" &lt;&lt; int(myvector.size()) &lt;&lt; \" numbers.\\n\"; return 0;&#125; vector::pop_back删除vector中的最后一个元素，有效地将容器size减少一个。这破坏了被删除的元素。1void pop_back();Example123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int sum (0); myvector.push_back (100); myvector.push_back (200); myvector.push_back (300); while (!myvector.empty()) &#123; sum+=myvector.back(); myvector.pop_back(); &#125; std::cout &lt;&lt; \"The elements of myvector add up to \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125;Output1The elements of myvector add up to 600 vector::insert通过在指定位置的元素之前插入新元素来扩展该vector，通过插入元素的数量有效地增加容器大小。 这会导致分配的存储空间自动重新分配，只有在新的vector的size超过当前的vector的capacity的情况下。由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。1234567891011single element (1) iterator insert (const_iterator position, const value_type&amp; val);fill (2) iterator insert (const_iterator position, size_type n, const value_type&amp; val);range (3) template &lt;class InputIterator&gt;iterator insert (const_iterator position, InputIterator first, InputIterator last);move (4) iterator insert (const_iterator position, value_type&amp;&amp; val);initializer list (5) iterator insert (const_iterator position, initializer_list&lt;value_type&gt; il);Example1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector (3,100); std::vector&lt;int&gt;::iterator it; it = myvector.begin(); it = myvector.insert ( it , 200 ); myvector.insert (it,2,300); // \"it\" no longer valid, get a new one: it = myvector.begin(); std::vector&lt;int&gt; anothervector (2,400); myvector.insert (it+2,anothervector.begin(),anothervector.end()); int myarray [] = &#123; 501,502,503 &#125;; myvector.insert (myvector.begin(), myarray, myarray+3); std::cout &lt;&lt; \"myvector contains:\"; for (it=myvector.begin(); it&lt;myvector.end(); it++) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 501 502 503 300 300 400 400 200 100 100 100补充：insert 迭代器野指针错误：123456789101112131415int main()&#123; std::vector&lt;int&gt; v(5, 0); std::vector&lt;int&gt;::iterator vi; // 获取vector第一个元素的迭代器 vi = v.begin(); // push_back 插入元素之后可能会因为 push_back 的骚操作（创建一个新vector把旧vector的值复制到新vector），导致vector迭代器iterator的指针变成野指针，而导致insert出错 v.push_back(10); v.insert(vi, 2, 300); return 0;&#125;改正：应该把vi = v.begin();放到v.push_back(10);后面 vector::erase从vector中删除单个元素（position）或一系列元素（[first，last））。这有效地减少了被去除的元素的数量，从而破坏了容器的大小。由于vector使用一个数组作为其底层存储，所以删除除vector结束位置之后，或vector的begin之前的元素外，将导致容器将段被擦除后的所有元素重新定位到新的位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。12iterator erase (const_iterator position);iterator erase (const_iterator first, const_iterator last);Example1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; // set some values (from 1 to 10) for (int i=1; i&lt;=10; i++) myvector.push_back(i); // erase the 6th element myvector.erase (myvector.begin()+5); // erase the first 3 elements: myvector.erase (myvector.begin(),myvector.begin()+3); std::cout &lt;&lt; \"myvector contains:\"; for (unsigned i=0; i&lt;myvector.size(); ++i) std::cout &lt;&lt; ' ' &lt;&lt; myvector[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 4 5 7 8 9 10 vector::swap通过x的内容交换容器的内容，x是另一个相同类型的vector对象。尺寸可能不同。在调用这个成员函数之后，这个容器中的元素是那些在调用之前在x中的元素，而x的元素是在这个元素中的元素。所有迭代器，引用和指针对交换对象保持有效。请注意，非成员函数存在具有相同名称的交换，并使用与此成员函数相似的优化来重载该算法。1void swap (vector&amp; x);Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; foo (3,100); // three ints with a value of 100 std::vector&lt;int&gt; bar (5,200); // five ints with a value of 200 foo.swap(bar); std::cout &lt;&lt; \"foo contains:\"; for (unsigned i=0; i&lt;foo.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; foo[i]; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"bar contains:\"; for (unsigned i=0; i&lt;bar.size(); i++) std::cout &lt;&lt; ' ' &lt;&lt; bar[i]; std::cout &lt;&lt; '\\n'; return 0;&#125;Output12foo contains: 200 200 200 200 200 bar contains: 100 100 100 vector::clear从vector中删除所有的元素（被销毁），留下size为0的容器。不保证重新分配，并且由于调用此函数， vector的capacity不保证发生变化。强制重新分配的典型替代方法是使用swap：vector&lt;T&gt;().swap(x); // clear x reallocating1void clear() noexcept;Example1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;void printVector(const std::vector&lt;int&gt; &amp;v)&#123; for (auto it = v.begin(); it != v.end(); ++it) &#123; std::cout &lt;&lt; *it &lt;&lt; ' '; &#125; std::cout &lt;&lt; std::endl;&#125;int main()&#123; std::vector&lt;int&gt; v1(5, 50); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.clear(); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; v1.push_back(11); v1.push_back(22); printVector(v1); std::cout &lt;&lt; \"v1 size = \" &lt;&lt; v1.size() &lt;&lt; std::endl; std::cout &lt;&lt; \"v1 capacity = \" &lt;&lt; v1.capacity() &lt;&lt; std::endl; return 0;&#125;Output12345678950 50 50 50 50v1 size &#x3D; 5v1 capacity &#x3D; 5v1 size &#x3D; 0v1 capacity &#x3D; 511 22v1 size &#x3D; 2v1 capacity &#x3D; 5 vector::emplace通过在position位置处插入新元素args来扩展容器。这个新元素是用args作为构建的参数来构建的。这有效地增加了一个容器的大小。分配存储空间的自动重新分配发生在新的vector的size超过当前向量容量的情况下。由于vector使用数组作为其基础存储，因此除了将元素插入到vector末尾之后，或vector的begin之前，其他位置会导致容器重新定位位置之后的所有元素到他们的新位置。与其他种类的序列容器（例如list或forward_list）执行相同操作的操作相比，这通常是低效的操作。该元素是通过调用allocator_traits::construct来转换args来创建的。插入一个类似的成员函数，将现有对象复制或移动到容器中。12template &lt;class... Args&gt;iterator emplace (const_iterator position, Args&amp;&amp;... args);Example123456789101112131415161718#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector = &#123;10,20,30&#125;; auto it = myvector.emplace ( myvector.begin()+1, 100 ); myvector.emplace ( it, 200 ); myvector.emplace ( myvector.end(), 300 ); std::cout &lt;&lt; \"myvector contains:\"; for (auto&amp; x: myvector) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1myvector contains: 10 200 100 20 30 300 vector::emplace_back在vector的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新元素是用args作为构造函数的参数来构造的。这有效地将容器大小增加了一个，如果新的矢量大小超过了当前的vector容量，则导致所分配的存储空间自动重新分配。该元素是通过调用allocator_traits :: construct来转换args来创建的。与push_back相比，emplace_back可以避免额外的复制和移动操作。12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args);Example12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt; struct President&#123; std::string name; std::string country; int year; President(std::string p_name, std::string p_country, int p_year) : name(std::move(p_name)), country(std::move(p_country)), year(p_year) &#123; std::cout &lt;&lt; \"I am being constructed.\\n\"; &#125; President(President&amp;&amp; other) : name(std::move(other.name)), country(std::move(other.country)), year(other.year) &#123; std::cout &lt;&lt; \"I am being moved.\\n\"; &#125; President&amp; operator=(const President&amp; other) = default;&#125;; int main()&#123; std::vector&lt;President&gt; elections; std::cout &lt;&lt; \"emplace_back:\\n\"; elections.emplace_back(\"Nelson Mandela\", \"South Africa\", 1994); std::vector&lt;President&gt; reElections; std::cout &lt;&lt; \"\\npush_back:\\n\"; reElections.push_back(President(\"Franklin Delano Roosevelt\", \"the USA\", 1936)); std::cout &lt;&lt; \"\\nContents:\\n\"; for (President const&amp; president: elections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125; for (President const&amp; president: reElections) &#123; std::cout &lt;&lt; president.name &lt;&lt; \" was re-elected president of \" &lt;&lt; president.country &lt;&lt; \" in \" &lt;&lt; president.year &lt;&lt; \".\\n\"; &#125;&#125;Output12345678910emplace_back:I am being constructed. push_back:I am being constructed.I am being moved. Contents:Nelson Mandela was elected president of South Africa in 1994.Franklin Delano Roosevelt was re-elected president of the USA in 1936. vector::get_allocator返回与vector关联的构造器对象的副本。1allocator_type get_allocator() const noexcept;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;int main ()&#123; std::vector&lt;int&gt; myvector; int * p; unsigned int i; // allocate an array with space for 5 elements using vector's allocator: p = myvector.get_allocator().allocate(5); // construct values in-place on the array: for (i=0; i&lt;5; i++) myvector.get_allocator().construct(&amp;p[i],i); std::cout &lt;&lt; \"The allocated array contains:\"; for (i=0; i&lt;5; i++) std::cout &lt;&lt; ' ' &lt;&lt; p[i]; std::cout &lt;&lt; '\\n'; // destroy and deallocate: for (i=0; i&lt;5; i++) myvector.get_allocator().destroy(&amp;p[i]); myvector.get_allocator().deallocate(p,5); return 0;&#125;Output1The allocated array contains: 0 1 2 3 4注意：deallocate和destory的关系：deallocate实现的源码：template &lt;class T&gt; inline void _deallocate(T* buffer) { ::operator delete(buffer); //为什么不用 delete [] ? ,operator delete 区别于 delete //operator delete 是一个底层操作符 } destory：template &lt;class T&gt; inline void _destory(T *ptr) { ptr-&gt;~T(); } destory负责调用类型的析构函数，销毁相应内存上的内容（但销毁后内存地址仍保留）deallocate负责释放内存（此时相应内存中的值在此之前应调用destory销毁，将内存地址返回给系统，代表这部分地址使用引用-1） relational operators (vector) swap (vector) vector dequedeque（['dek]）（双端队列）是double-ended queue 的一个不规则缩写。deque是具有动态大小的序列容器，可以在两端（前端或后端）扩展或收缩。特定的库可以以不同的方式实现deques，通常作为某种形式的动态数组。但是在任何情况下，它们都允许通过随机访问迭代器直接访问各个元素，通过根据需要扩展和收缩容器来自动处理存储。因此，它们提供了类似于vector的功能，但是在序列的开始部分也可以高效地插入和删除元素，而不仅仅是在结尾。但是，与vector不同，deques并不保证将其所有元素存储在连续的存储位置：deque通过偏移指向另一个元素的指针访问元素会导致未定义的行为。两个vector和deques提供了一个非常相似的接口，可以用于类似的目的，但内部工作方式完全不同：虽然vector使用单个数组需要偶尔重新分配以增长，但是deque的元素可以分散在不同的块的容器，容器在内部保存必要的信息以提供对其任何元素的持续时间和统一的顺序接口（通过迭代器）的直接访问。因此，deques在内部比vector更复杂一点，但是这使得他们在某些情况下更有效地增长，尤其是在重新分配变得更加昂贵的很长序列的情况下。对于频繁插入或删除开始或结束位置以外的元素的操作，deques表现得更差，并且与列表和转发列表相比，迭代器和引用的一致性更低。deque上常见操作的复杂性（效率）如下：随机访问 - 常数O(1)在结尾或开头插入或移除元素 - 摊销不变O(1)插入或移除元素 - 线性O(n)1template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque; deque::deque构造一个deque容器对象，根据所使用的构造函数版本初始化它的内容：Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; unsigned int i; // constructors used in the same order as described above: std::deque&lt;int&gt; first; // empty deque of ints std::deque&lt;int&gt; second (4,100); // four ints with value 100 std::deque&lt;int&gt; third (second.begin(),second.end()); // iterating through second std::deque&lt;int&gt; fourth (third); // a copy of third // the iterator constructor can be used to copy arrays: int myints[] = &#123;16,2,77,29&#125;; std::deque&lt;int&gt; fifth (myints, myints + sizeof(myints) / sizeof(int) ); std::cout &lt;&lt; \"The contents of fifth are:\"; for (std::deque&lt;int&gt;::iterator it = fifth.begin(); it!=fifth.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1The contents of fifth are: 16 2 77 29 deque::push_back在当前的最后一个元素之后 ，在deque容器的末尾添加一个新元素。val的内容被复制（或移动）到新的元素。这有效地增加了一个容器的大小。12void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val);Example12345678910111213141516171819#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int myint; std::cout &lt;&lt; \"Please enter some integers (enter 0 to end):\\n\"; do &#123; std::cin &gt;&gt; myint; mydeque.push_back (myint); &#125; while (myint); std::cout &lt;&lt; \"mydeque stores \" &lt;&lt; (int) mydeque.size() &lt;&lt; \" numbers.\\n\"; return 0;&#125; deque::push_front在deque容器的开始位置插入一个新的元素，位于当前的第一个元素之前。val的内容被复制（或移动）到插入的元素。这有效地增加了一个容器的大小。12void push_front (const value_type&amp; val);void push_front (value_type&amp;&amp; val);Example12345678910111213141516#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque (2,100); // two ints with a value of 100 mydeque.push_front (200); mydeque.push_front (300); std::cout &lt;&lt; \"mydeque contains:\"; for (std::deque&lt;int&gt;::iterator it = mydeque.begin(); it != mydeque.end(); ++it) std::cout &lt;&lt; ' ' &lt;&lt; *it; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1300 200 100 100 deque::pop_back删除deque容器中的最后一个元素，有效地将容器大小减少一个。这破坏了被删除的元素。1void pop_back();Example123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; int sum (0); mydeque.push_back (10); mydeque.push_back (20); mydeque.push_back (30); while (!mydeque.empty()) &#123; sum+=mydeque.back(); mydeque.pop_back(); &#125; std::cout &lt;&lt; \"The elements of mydeque add up to \" &lt;&lt; sum &lt;&lt; '\\n'; return 0;&#125;Output1The elements of mydeque add up to 60 deque::pop_front删除deque容器中的第一个元素，有效地减小其大小。这破坏了被删除的元素。1void pop_front();Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque; mydeque.push_back (100); mydeque.push_back (200); mydeque.push_back (300); std::cout &lt;&lt; \"Popping out the elements in mydeque:\"; while (!mydeque.empty()) &#123; std::cout &lt;&lt; ' ' &lt;&lt; mydeque.front(); mydeque.pop_front(); &#125; std::cout &lt;&lt; \"\\nThe final size of mydeque is \" &lt;&lt; int(mydeque.size()) &lt;&lt; '\\n'; return 0;&#125;Output12Popping out the elements in mydeque: 100 200 300The final size of mydeque is 0 deque::emplace_front在deque的开头插入一个新的元素，就在其当前的第一个元素之前。这个新的元素是用args作为构建的参数来构建的。这有效地增加了一个容器的大小。该元素是通过调用allocator_traits::construct来转换args来创建的。存在一个类似的成员函数push_front，它可以将现有对象复制或移动到容器中。12template &lt;class... Args&gt; void emplace_front (Args&amp;&amp;... args);Example1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_front (111); mydeque.emplace_front (222); std::cout &lt;&lt; \"mydeque contains:\"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mydeque contains: 222 111 10 20 30 deque::emplace_back在deque的末尾插入一个新的元素，紧跟在当前的最后一个元素之后。这个新的元素是用args作为构建的参数来构建的。这有效地增加了一个容器的大小。该元素是通过调用allocator_traits::construct来转换args来创建的。存在一个类似的成员函数push_back，它可以将现有对象复制或移动到容器中12template &lt;class... Args&gt; void emplace_back (Args&amp;&amp;... args);Example1234567891011121314151617#include &lt;iostream&gt;#include &lt;deque&gt;int main ()&#123; std::deque&lt;int&gt; mydeque = &#123;10,20,30&#125;; mydeque.emplace_back (100); mydeque.emplace_back (200); std::cout &lt;&lt; \"mydeque contains:\"; for (auto&amp; x: mydeque) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mydeque contains: 10 20 30 100 200 forward_listforward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。forward_list（单向链表）被实现为单链表; 单链表可以将它们包含的每个元素存储在不同和不相关的存储位置中。通过关联到序列中下一个元素的链接的每个元素来保留排序。forward_list容器和列表之间的主要设计区别容器是第一个内部只保留一个到下一个元素的链接，而后者每个元素保留两个链接：一个指向下一个元素，一个指向前一个元素，允许在两个方向上有效的迭代，但是每个元素消耗额外的存储空间并且插入和移除元件的时间开销略高。因此，forward_list对象比列表对象更有效率，尽管它们只能向前迭代。与其他基本的标准序列容器（array，vector和deque），forward_list通常在插入，提取和移动容器内任何位置的元素方面效果更好，因此也适用于密集使用这些元素的算法，如排序算法。的主要缺点修饰符Modifiers S和列表相比这些其它序列容器s是说，他们缺乏可以通过位置的元素的直接访问; 例如，要访问forward_list中的第六个元素，必须从开始位置迭代到该位置，这需要在这些位置之间的线性时间。它们还消耗一些额外的内存来保持与每个元素相关联的链接信息（这可能是大型小元素列表的重要因素）。该修饰符Modifiersclass模板的设计考虑到效率：按照设计，它与简单的手写C型单链表一样高效，实际上是唯一的标准容器，为了效率的考虑故意缺少尺寸成员函数：由于其性质作为一个链表，具有一个需要一定时间的大小的成员将需要它保持一个内部计数器的大小（如列表所示）。这会消耗一些额外的存储空间，并使插入和删除操作效率稍低。要获取forward_list对象的大小，可以使用距离算法的开始和结束，这是一个需要线性时间的操作。 forward_list::forward_list12345678910111213141516171819default (1) explicit forward_list (const allocator_type&amp; alloc = allocator_type());fill (2) explicit forward_list (size_type n);explicit forward_list (size_type n, const value_type&amp; val, const allocator_type&amp; alloc = allocator_type());range (3) template &lt;class InputIterator&gt; forward_list (InputIterator first, InputIterator last, const allocator_type&amp; alloc = allocator_type());copy (4) forward_list (const forward_list&amp; fwdlst);forward_list (const forward_list&amp; fwdlst, const allocator_type&amp; alloc);move (5) forward_list (forward_list&amp;&amp; fwdlst);forward_list (forward_list&amp;&amp; fwdlst, const allocator_type&amp; alloc);initializer list (6) forward_list (initializer_list&lt;value_type&gt; il, const allocator_type&amp; alloc = allocator_type());Example1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; // constructors used in the same order as described above: std::forward_list&lt;int&gt; first; // default: empty std::forward_list&lt;int&gt; second (3,77); // fill: 3 seventy-sevens std::forward_list&lt;int&gt; third (second.begin(), second.end()); // range initialization std::forward_list&lt;int&gt; fourth (third); // copy constructor std::forward_list&lt;int&gt; fifth (std::move(fourth)); // move ctor. (fourth wasted) std::forward_list&lt;int&gt; sixth = &#123;3, 52, 25, 90&#125;; // initializer_list constructor std::cout &lt;&lt; \"first:\" ; for (int&amp; x: first) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"second:\"; for (int&amp; x: second) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"third:\"; for (int&amp; x: third) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"fourth:\"; for (int&amp; x: fourth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"fifth:\"; for (int&amp; x: fifth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; std::cout &lt;&lt; \"sixth:\"; for (int&amp; x: sixth) std::cout &lt;&lt; \" \" &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Possible output1234567forward_list constructor examples:first:second: 77 77 77third: 77 77 77fourth:fifth: 77 77 77sixth: 3 52 25 90 forward_list::~forward_list forward_list::before_begin返回指向容器中第一个元素之前的位置的迭代器。返回的迭代器不应被解除引用：它是为了用作成员函数的参数emplace_after，insert_after，erase_after或splice_after，指定序列，其中执行该动作的位置的开始位置。12 iterator before_begin() noexcept;const_iterator before_begin() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;20, 30, 40, 50&#125;; mylist.insert_after ( mylist.before_begin(), 11 ); std::cout &lt;&lt; \"mylist contains:\"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mylist contains: 11 20 30 40 50 forward_list::cbefore_begin返回指向容器中第一个元素之前的位置的const_iterator。一个常量性是指向常量内容的迭代器。这个迭代器可以增加和减少（除非它本身也是const），就像forward_list::before_begin返回的迭代器一样，但不能用来修改它指向的内容。返回的价值不得解除引用。1const_iterator cbefore_begin() const noexcept;Example123456789101112131415#include &lt;iostream&gt;#include &lt;forward_list&gt;int main ()&#123; std::forward_list&lt;int&gt; mylist = &#123;77, 2, 16&#125;; mylist.insert_after ( mylist.cbefore_begin(), 19 ); std::cout &lt;&lt; \"mylist contains:\"; for ( int&amp; x: mylist ) std::cout &lt;&lt; ' ' &lt;&lt; x; std::cout &lt;&lt; '\\n'; return 0;&#125;Output1mylist contains: 19 77 2 16 list stack queue priority_queue set multiset mapmap 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。在映射中，键值通常用于对元素进行排序和唯一标识，而映射的值存储与此键关联的内容。该类型的键和映射的值可能不同，并且在部件类型被分组在一起VALUE_TYPE，这是一种对类型结合两种：1typedef pair&lt;const Key, T&gt; value_type;在内部，映射中的元素总是按照由其内部比较对象（比较类型）指示的特定的严格弱排序标准按键排序。映射容器通常比unordered_map容器慢，以通过它们的键来访问各个元素，但是它们允许基于它们的顺序对子集进行直接迭代。 在该映射值地图可以直接通过使用其相应的键来访问括号运算符（（操作符[] ）。 映射通常如实施12345template &lt; class Key, // map::key_type class T, // map::mapped_type class Compare = less&lt;Key&gt;, // map::key_compare class Alloc = allocator&lt;pair&lt;const Key,T&gt; &gt; // map::allocator_type &gt; class map; map::map构造一个映射容器对象，根据所使用的构造器版本初始化其内容：（1）空容器构造函数（默认构造函数）构造一个空的容器，没有元素。（2）范围构造函数构造具有一样多的元素的范围内的容器[第一，最后一个），其中每个元件布设构造的从在该范围内它的相应的元件。（3）复制构造函数（并用分配器复制）使用x中的每个元素的副本构造一个容器。（4）移动构造函数（并与分配器一起移动）构造一个获取x元素的容器。如果指定了alloc并且与x的分配器不同，那么元素将被移动。否则，没有构建元素（他们的所有权直接转移）。x保持未指定但有效的状态。（5）初始化列表构造函数用il中的每个元素的副本构造一个容器。12345678910111213141516171819empty (1) explicit map (const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());explicit map (const allocator_type&amp; alloc);range (2) template &lt;class InputIterator&gt; map (InputIterator first, InputIterator last, const key_compare&amp; comp = key_compare(), const allocator_type&amp; = allocator_type());copy (3) map (const map&amp; x);map (const map&amp; x, const allocator_type&amp; alloc);move (4) map (map&amp;&amp; x);map (map&amp;&amp; x, const allocator_type&amp; alloc);initializer list (5) map (initializer_list&lt;value_type&gt; il, const key_compare&amp; comp = key_compare(), const allocator_type&amp; alloc = allocator_type());Example123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;map&gt;bool fncomp (char lhs, char rhs) &#123;return lhs&lt;rhs;&#125;struct classcomp &#123; bool operator() (const char&amp; lhs, const char&amp; rhs) const &#123;return lhs&lt;rhs;&#125;&#125;;int main ()&#123; std::map&lt;char,int&gt; first; first['a']=10; first['b']=30; first['c']=50; first['d']=70; std::map&lt;char,int&gt; second (first.begin(),first.end()); std::map&lt;char,int&gt; third (second); std::map&lt;char,int,classcomp&gt; fourth; // class as Compare bool(*fn_pt)(char,char) = fncomp; std::map&lt;char,int,bool(*)(char,char)&gt; fifth (fn_pt); // function pointer as Compare return 0;&#125; map::begin返回引用map容器中第一个元素的迭代器。由于map容器始终保持其元素的顺序，所以开始指向遵循容器排序标准的元素。如果容器是空的，则返回的迭代器值不应被解除引用。12 iterator begin() noexcept;const_iterator begin() const noexcept;Example1234567891011121314151617#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['b'] = 100; mymap['a'] = 200; mymap['c'] = 300; // show content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output123a &#x3D;&gt; 200b &#x3D;&gt; 100c &#x3D;&gt; 300 map::key_comp返回容器用于比较键的比较对象的副本。1key_compare key_comp() const;Example1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::key_compare mycomp = mymap.key_comp(); mymap['a']=100; mymap['b']=200; mymap['c']=300; std::cout &lt;&lt; \"mymap contains:\\n\"; char highest = mymap.rbegin()-&gt;first; // key value of last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; &#125; while ( mycomp((*it++).first, highest) ); std::cout &lt;&lt; '\\n'; return 0;&#125;Output1234mymap contains:a &#x3D;&gt; 100b &#x3D;&gt; 200c &#x3D;&gt; 300 map::value_comp返回可用于比较两个元素的比较对象，以获取第一个元素的键是否在第二个元素之前。1value_compare value_comp() const;Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['x']=1001; mymap['y']=2002; mymap['z']=3003; std::cout &lt;&lt; \"mymap contains:\\n\"; std::pair&lt;char,int&gt; highest = *mymap.rbegin(); // last element std::map&lt;char,int&gt;::iterator it = mymap.begin(); do &#123; std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; &#125; while ( mymap.value_comp()(*it++, highest) ); return 0;&#125;Output1234mymap contains:x &#x3D;&gt; 1001y &#x3D;&gt; 2002z &#x3D;&gt; 3003 map::find在容器中搜索具有等于k的键的元素，如果找到则返回一个迭代器，否则返回map::end的迭代器。如果容器的比较对象自反地返回假（即，不管元素作为参数传递的顺序），则两个key被认为是等同的。另一个成员函数map::count可以用来检查一个特定的键是否存在。12 iterator find (const key_type&amp; k);const_iterator find (const key_type&amp; k) const;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator it; mymap['a']=50; mymap['b']=100; mymap['c']=150; mymap['d']=200; it = mymap.find('b'); if (it != mymap.end()) mymap.erase (it); // print content: std::cout &lt;&lt; \"elements in mymap:\" &lt;&lt; '\\n'; std::cout &lt;&lt; \"a =&gt; \" &lt;&lt; mymap.find('a')-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"c =&gt; \" &lt;&lt; mymap.find('c')-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"d =&gt; \" &lt;&lt; mymap.find('d')-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output1234elements in mymap:a &#x3D;&gt; 50c &#x3D;&gt; 150d &#x3D;&gt; 200 map::count在容器中搜索具有等于k的键的元素，并返回匹配的数量。由于地图容器中的所有元素都是唯一的，因此该函数只能返回1（如果找到该元素）或返回零（否则）。如果容器的比较对象自反地返回错误（即，不管按键作为参数传递的顺序），则两个键被认为是等同的。1size_type count (const key_type&amp; k) const;Example1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; char c; mymap ['a']=101; mymap ['c']=202; mymap ['f']=303; for (c='a'; c&lt;'h'; c++) &#123; std::cout &lt;&lt; c; if (mymap.count(c)&gt;0) std::cout &lt;&lt; \" is an element of mymap.\\n\"; else std::cout &lt;&lt; \" is not an element of mymap.\\n\"; &#125; return 0;&#125;Output1234567a is an element of mymap.b is not an element of mymap.c is an element of mymap.d is not an element of mymap.e is not an element of mymap.f is an element of mymap.g is not an element of mymap. map::lower_bound将迭代器返回到下限返回指向容器中第一个元素的迭代器，该元素的键不会在k之前出现（即，它是等价的或者在其后）。该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（element_key，k）将返回false的第一个元素。如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键不小于k。一个类似的成员函数upper_bound具有相同的行为lower_bound，除非映射包含一个key值等于k的元素：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。12 iterator lower_bound (const key_type&amp; k);const_iterator lower_bound (const key_type&amp; k) const;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output12a &#x3D;&gt; 20e &#x3D;&gt; 100 map::upper_bound将迭代器返回到上限返回一个指向容器中第一个元素的迭代器，它的关键字被认为是在k之后。该函数使用其内部比较对象（key_comp）来确定这一点，将迭代器返回到key_comp（k，element_key）将返回true的第一个元素。如果map类用默认的比较类型（less）实例化，则函数返回一个迭代器到第一个元素，其键大于k。类似的成员函数lower_bound具有与upper_bound相同的行为，除了map包含一个元素，其键值等于k：在这种情况下，lower_bound返回指向该元素的迭代器，而upper_bound返回指向下一个元素的迭代器。12 iterator upper_bound (const key_type&amp; k);const_iterator upper_bound (const key_type&amp; k) const;Example12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; std::map&lt;char,int&gt;::iterator itlow,itup; mymap['a']=20; mymap['b']=40; mymap['c']=60; mymap['d']=80; mymap['e']=100; itlow=mymap.lower_bound ('b'); // itlow points to b itup=mymap.upper_bound ('d'); // itup points to e (not d!) mymap.erase(itlow,itup); // erases [itlow,itup) // print content: for (std::map&lt;char,int&gt;::iterator it=mymap.begin(); it!=mymap.end(); ++it) std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output12a &#x3D;&gt; 20e &#x3D;&gt; 100 map::equal_range获取相同元素的范围返回包含容器中所有具有与k等价的键的元素的范围边界。 由于地图容器中的元素具有唯一键，所以返回的范围最多只包含一个元素。如果没有找到匹配，则返回的范围具有零的长度，与两个迭代器指向具有考虑去后一个密钥对所述第一元件ķ根据容器的内部比较对象（key_comp）。如果容器的比较对象返回false，则两个键被认为是等价的。12pair&lt;const_iterator,const_iterator&gt; equal_range (const key_type&amp; k) const;pair&lt;iterator,iterator&gt; equal_range (const key_type&amp; k);Example12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;map&gt;int main ()&#123; std::map&lt;char,int&gt; mymap; mymap['a']=10; mymap['b']=20; mymap['c']=30; std::pair&lt;std::map&lt;char,int&gt;::iterator,std::map&lt;char,int&gt;::iterator&gt; ret; ret = mymap.equal_range('b'); std::cout &lt;&lt; \"lower bound points to: \"; std::cout &lt;&lt; ret.first-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; ret.first-&gt;second &lt;&lt; '\\n'; std::cout &lt;&lt; \"upper bound points to: \"; std::cout &lt;&lt; ret.second-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; ret.second-&gt;second &lt;&lt; '\\n'; return 0;&#125;Output12lower bound points to: &#39;b&#39; &#x3D;&gt; 20upper bound points to: &#39;c&#39; &#x3D;&gt; 30 multimap 无序容器（Unordered Container）：unordered_set、unordered_multiset、unordered_map、unordered_multimap包括：unordered_setunordered_multisetunordered_mapunordered_multimap都是以哈希表实现的。unordered_set、unodered_multiset结构：unordered_map、unodered_multimap结构： unordered_set unordered_multiset unordered_map unordered_multimap tuple元组是一个能够容纳元素集合的对象。每个元素可以是不同的类型。1template &lt;class... Types&gt; class tuple;Example1234567891011121314151617181920212223242526#include &lt;iostream&gt; // std::cout#include &lt;tuple&gt; // std::tuple, std::get, std::tie, std::ignoreint main ()&#123; std::tuple&lt;int,char&gt; foo (10,'x'); auto bar = std::make_tuple (\"test\", 3.1, 14, 'y'); std::get&lt;2&gt;(bar) = 100; // access element int myint; char mychar; std::tie (myint, mychar) = foo; // unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = bar; // unpack (with ignore) mychar = std::get&lt;3&gt;(bar); std::get&lt;0&gt;(foo) = std::get&lt;2&gt;(bar); std::get&lt;1&gt;(foo) = mychar; std::cout &lt;&lt; \"foo contains: \"; std::cout &lt;&lt; std::get&lt;0&gt;(foo) &lt;&lt; ' '; std::cout &lt;&lt; std::get&lt;1&gt;(foo) &lt;&lt; '\\n'; return 0;&#125;Output1foo contains: 100 y tuple::tuple构建一个 tuple（元组）对象。这涉及单独构建其元素，初始化取决于调用的构造函数形式：（1）默认的构造函数构建一个 元组对象的元素值初始化。（2）复制/移动构造函数该对象使用tpl的内容进行初始化 元组目的。tpl的相应元素被传递给每个元素的构造函数。（3）隐式转换构造函数同上。tpl中的所有类型都可以隐含地转换为构造中它们各自元素的类型元组 目的。（4）初始化构造函数用elems中的相应元素初始化每个元素。elems的相应元素被传递给每个元素的构造函数。（5）对转换构造函数该对象有两个对应于pr.first和的元素pr.second。PR中的所有类型都应该隐含地转换为其中各自元素的类型元组 目的。（6）分配器版本和上面的版本一样，除了每个元素都是使用allocator alloc构造的。1234567891011121314151617181920212223242526272829303132333435363738default (1) constexpr tuple();copy / move (2) tuple (const tuple&amp; tpl) = default;tuple (tuple&amp;&amp; tpl) = default;implicit conversion (3) template &lt;class... UTypes&gt; tuple (const tuple&lt;UTypes...&gt;&amp; tpl);template &lt;class... UTypes&gt; tuple (tuple&lt;UTypes...&gt;&amp;&amp; tpl);initialization (4) explicit tuple (const Types&amp;... elems);template &lt;class... UTypes&gt; explicit tuple (UTypes&amp;&amp;... elems);conversion from pair (5) template &lt;class U1, class U2&gt; tuple (const pair&lt;U1,U2&gt;&amp; pr);template &lt;class U1, class U2&gt; tuple (pair&lt;U1,U2&gt;&amp;&amp; pr);allocator (6) template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&amp;&amp; tpl);template&lt;class Alloc,class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const tuple&lt;UTypes...&gt;&amp; tpl);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, tuple&lt;UTypes...&gt;&amp;&amp; tpl);template&lt;class Alloc&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const Types&amp;... elems);template&lt;class Alloc, class... UTypes&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, UTypes&amp;&amp;... elems);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, const pair&lt;U1,U2&gt;&amp; pr);template&lt;class Alloc, class U1, class U2&gt; tuple (allocator_arg_t aa, const Alloc&amp; alloc, pair&lt;U1,U2&gt;&amp;&amp; pr);Example123456789101112131415161718#include &lt;iostream&gt; // std::cout#include &lt;utility&gt; // std::make_pair#include &lt;tuple&gt; // std::tuple, std::make_tuple, std::getint main ()&#123; std::tuple&lt;int,char&gt; first; // default std::tuple&lt;int,char&gt; second (first); // copy std::tuple&lt;int,char&gt; third (std::make_tuple(20,'b')); // move std::tuple&lt;long,char&gt; fourth (third); // implicit conversion std::tuple&lt;int,char&gt; fifth (10,'a'); // initialization std::tuple&lt;int,char&gt; sixth (std::make_pair(30,'c')); // from pair / move std::cout &lt;&lt; \"sixth contains: \" &lt;&lt; std::get&lt;0&gt;(sixth); std::cout &lt;&lt; \" and \" &lt;&lt; std::get&lt;1&gt;(sixth) &lt;&lt; '\\n'; return 0;&#125;Output1sixth contains: 30 and c pair这个类把一对值（values）结合在一起，这些值可能是不同的类型（T1 和 T2）。每个值可以被公有的成员变量first、second访问。pair是tuple（元组）的一个特例。pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。应用：可以将两个类型数据组合成一个如map&lt;key, value&gt;当某个函数需要两个返回值时1template &lt;class T1, class T2&gt; struct pair; pair::pair构建一个pair对象。这涉及到单独构建它的两个组件对象，初始化依赖于调用的构造器形式：（1）默认的构造函数构建一个 对对象的元素值初始化。（2）复制/移动构造函数（和隐式转换）该对象被初始化为pr的内容 对目的。pr的相应成员被传递给每个成员的构造函数。（3）初始化构造函数会员 第一是由一个和成员构建的第二与b。（4）分段构造构造成员 first 和 second 到位，传递元素first_args 作为参数的构造函数 first，和元素 second_args 到的构造函数 second 。1234567891011121314default (1) constexpr pair();copy / move (2) template&lt;class U, class V&gt; pair (const pair&lt;U,V&gt;&amp; pr);template&lt;class U, class V&gt; pair (pair&lt;U,V&gt;&amp;&amp; pr);pair (const pair&amp; pr) = default;pair (pair&amp;&amp; pr) = default;initialization (3) pair (const first_type&amp; a, const second_type&amp; b);template&lt;class U, class V&gt; pair (U&amp;&amp; a, V&amp;&amp; b);piecewise (4) template &lt;class... Args1, class... Args2&gt; pair (piecewise_construct_t pwc, tuple&lt;Args1...&gt; first_args, tuple&lt;Args2...&gt; second_args);Example12345678910111213141516171819#include &lt;utility&gt; // std::pair, std::make_pair#include &lt;string&gt; // std::string#include &lt;iostream&gt; // std::coutint main () &#123; std::pair &lt;std::string,double&gt; product1; // default constructor std::pair &lt;std::string,double&gt; product2 (\"tomatoes\",2.30); // value init std::pair &lt;std::string,double&gt; product3 (product2); // copy constructor product1 = std::make_pair(std::string(\"lightbulbs\"),0.99); // using make_pair (move) product2.first = \"shoes\"; // the type of first is string product2.second = 39.90; // the type of second is double std::cout &lt;&lt; \"The price of \" &lt;&lt; product1.first &lt;&lt; \" is $\" &lt;&lt; product1.second &lt;&lt; '\\n'; std::cout &lt;&lt; \"The price of \" &lt;&lt; product2.first &lt;&lt; \" is $\" &lt;&lt; product2.second &lt;&lt; '\\n'; std::cout &lt;&lt; \"The price of \" &lt;&lt; product3.first &lt;&lt; \" is $\" &lt;&lt; product3.second &lt;&lt; '\\n'; return 0;&#125;Output123The price of lightbulbs is $0.99The price of shoes is $39.9The price of tomatoes is $2.3","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://forwardpeng.github.io/tags/C/"}]}],"categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Python","slug":"计算机基础/Python","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Python/"},{"name":"数据结构","slug":"计算机基础/数据结构","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"数据库","slug":"计算机基础/数据库","permalink":"http://forwardpeng.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"面试","slug":"面试","permalink":"http://forwardpeng.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://forwardpeng.github.io/tags/Python/"},{"name":"数据结构","slug":"数据结构","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法导论","slug":"算法导论","permalink":"http://forwardpeng.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"},{"name":"线性表","slug":"线性表","permalink":"http://forwardpeng.github.io/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"name":"SQL","slug":"SQL","permalink":"http://forwardpeng.github.io/tags/SQL/"},{"name":"数据库","slug":"数据库","permalink":"http://forwardpeng.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"树","slug":"树","permalink":"http://forwardpeng.github.io/tags/%E6%A0%91/"},{"name":"C++","slug":"C","permalink":"http://forwardpeng.github.io/tags/C/"}]}