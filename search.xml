<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态内存管理机制</title>
      <link href="/2022/12/04/cao-zuo-xi-tong/dong-tai-nei-cun-guan-li/"/>
      <url>/2022/12/04/cao-zuo-xi-tong/dong-tai-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="占用块和空闲块"><a href="#占用块和空闲块" class="headerlink" title="占用块和空闲块"></a>占用块和空闲块</h1><p>对于计算机中的内存来说，称已经分配给用户的的内存区统称为“占用块”；还未分配出去的内存区统称为“空闲块”或者“可利用空间块”。</p><h1 id="系统的内存管理"><a href="#系统的内存管理" class="headerlink" title="系统的内存管理"></a>系统的内存管理</h1><p>对于初始状态下的内存来说，整个空间都是一个空闲块（在编译程序中称为“堆”）。但是随着不同的用户不断地提出存储请求，系统依次分配。</p><p>整个内存区就会分割成两个大部分：低地址区域会产生很多占用块；高地址区域还是空闲块。<br> <div align="center"><img src="/images/动态分配.png" width="800"></div><br> <center>图1 动态分配过程中的内存状态</center></p><p> 当某些用户运行结束，所占用的内存区域就变成了空闲块，如图2：<br>  <div align="center"><img src="/images/内存变化.png" width="800"></div><br> <center>图2 动态分配过程中的内存变化</center></p><p> 时，就形成了占用块和空闲块犬牙交错的状态。当后续用户请求分配内存时，系统有两种分配方式：</p><ul><li>系统继续利用高地址区域的连续空闲块分配给用户，不去理会之前分配给用户的内存区域的状态。直到分配无法进行，也就是高地址的空闲块不能满足用户的需求时，系统才会去回收之前的空闲块，重新组织继续分配；</li><li>当用户运行一结束，系统马上将其所占空间进行回收。当有新的用户请求分配内存时，系统遍历所有的空闲块，从中找出一个合适的空闲块分配给用户。<h1 id="可利用空间表"><a href="#可利用空间表" class="headerlink" title="可利用空间表"></a>可利用空间表</h1>系统需要建立一张记录所有空闲块信息的表。表的形式有两种：目录表和链表。各自的结构如图3所示：<div align="center"><img src="/images/目录表和链表.png" width="800"></div><center>图3 目录表和链表</center></li></ul><p>目录表：表中每一行代表一个空闲块，由三部分组成：</p><ul><li>初始地址：记录每个空闲块的起始地址。</li><li>空闲块大小：记录每个空闲块的内存大小。</li><li>使用情况：记录每个空闲块是否存储被占用的状态。</li></ul><p>链表：表中每个结点代表一个空闲块，每个结点中需要记录空闲块的使用情况、大小和连接下一个空闲块的指针域。</p><blockquote><p>由于链表中有指针的存在，所以结点中不需要记录各内存块的起始地址。</p></blockquote><p>存储空闲块的可利用空间表有以下不同的结构：</p><ul><li>如果每次用户请求的存储空间大小相同，对于此类系统中的内存来说，在用户运行初期就将整个内存存储块按照所需大小进行分割，然后通过链表链接。当用户申请空间时，从链表中摘除一个结点归其使用；用完后再链接到可利用空间表上。</li><li>每次如果用户申请的都是若干种大小规格的存储空间，针对这种情况可以建立若干个可利用空间表，每一个链表中的结点大小相同。当用户申请某一规格大小的存储空间时，就从对应的链表中摘除一个结点供其使用；用完后链接到相同规格大小的链表中。</li><li>用户申请的内存的大小不固定，所以造成系统分配的内存块的大小也不确定，回收时，链接到可利用空间表中每个结点的大小也各不一样。<blockquote><p>第 2 种情况下容易面临的问题是：如果同用户申请空间大小相同的链表中没有结点时，就需要找结点更大的链表，从中取出一个结点，一部分给用户使用，剩余部分插入到相应大小的链表中；回收时，将释放的空闲块插入到大小相同的链表中去。如果没有比用户申请的内存空间相等甚至更大的结点时，就需要系统重新组织一些小的连续空间，然后给用户使用。</p></blockquote></li></ul><h1 id="分配存储空间的方式"><a href="#分配存储空间的方式" class="headerlink" title="分配存储空间的方式"></a>分配存储空间的方式</h1><p>通常情况下系统中的可利用空间表是第 3 种情况。如图 3(C) 所示。由于链表中各结点的大小不一，在用户申请内存空间时，就需要从可利用空间表中找出一个合适的结点，有三种查找的方法：</p><ul><li>首次拟合法：在可利用空间表中从头开始依次遍历，将找到的第一个内存不小于用户申请空间的结点分配给用户，剩余空间仍留在链表中；回收时只要将释放的空闲块插入在链表的表头即可。</li><li>最佳拟合法：和首次拟合法不同，最佳拟合法是选择一块内存空间不小于用户申请空间，但是却最接近的一个结点分配给用户。为了实现这个方法，首先要将链表中的各个结点按照存储空间的大小进行从小到大排序，由此，在遍历的过程中只需要找到第一块大于用户申请空间的结点即可进行分配；用户运行完成后，需要将空闲块根据其自身的大小插入到链表的相应位置。</li><li>最差拟合法：和最佳拟合法正好相反，该方法是在不小于用户申请空间的所有结点中，筛选出存储空间最大的结点，从该结点的内存空间中提取出相应的空间给用户使用。为了实现这一方法，可以在开始前先将可利用空间表中的结点按照存储空间大小从大到小进行排序，第一个结点自然就是最大的结点。回收空间时，同样将释放的空闲块插入到相应的位置上。</li></ul><p>以上三种方法各有所长：</p><ul><li>最佳拟合法由于每次分配相差不大的结点给用户使用，所以会生成很多存储空间特别小的结点，以至于根本无法使用，使用过程中，链表中的结点存储大小发生两极分化，大的很大，小的很小。该方法适用于申请内存大小范围较广的系统</li><li>最差拟合法，由于每次都是从存储空间最大的结点中分配给用户空间，所以链表中的结点大小不会起伏太大。依次适用于申请分配内存空间较窄的系统。</li><li>首次拟合法每次都是随机分配。在不清楚用户申请空间大小的情况下，使用该方法分配空间。<h1 id="边界标识法管理动态内存"><a href="#边界标识法管理动态内存" class="headerlink" title="边界标识法管理动态内存"></a>边界标识法管理动态内存</h1>使用边界标识法的系统管理内存时，可利用空间表中的结点的构成如图 4：<div align="center"><img src="/images/结构构成.png" width="800"></div><center>图4 结构构成</center></li></ul><p>每个结点中包含3个区域，head域、foot域和space域：</p><ul><li>space域表示为该内存块的大小，它的大小通过head域中的size值表示。</li><li>head域中包含有4部分：llink 和rlink分别表示指向当前内存块结点的直接前驱和直接后继。tag值用于标记当前内存块的状态，是占用块（用 1 表示）还是空闲块（用 0 表示）。size用于记录该内存块的存储大小。</li><li>foot域中包含有2部分：uplink 是指针域，用于指向内存块本身，通过uplink就可以获取该内存块所在内存的首地址。tag同head域中的tag相同，都是记录内存块状态的。<blockquote><p>注意：head域和foot域在本节中都假设只占用当前存储块的1个存储单位的空间，对于该结点整个存储空间来说，可以忽略不计。也就是说，在可利用空间表中，知道下一个结点的首地址，该值减1就可以找到当前结点的foot域。</p></blockquote></li></ul><p>边界标识法管理的内存块结点代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> WORD<span class="token punctuation">{</span>    <span class="token keyword">union</span><span class="token punctuation">{</span>        <span class="token keyword">struct</span> WORD <span class="token operator">*</span>llink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向直接前驱</span>        <span class="token keyword">struct</span> WORD <span class="token operator">*</span>uplink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向结点本身</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//标记域,0表示为空闲块；1表示为占用块</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录内存块的存储大小</span>    <span class="token keyword">struct</span> WORD <span class="token operator">*</span>rlink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向直接后继</span>    OtherType other<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//内存块可能包含的其它的部分</span><span class="token punctuation">}</span>WORD<span class="token punctuation">,</span>head<span class="token punctuation">,</span>foot<span class="token punctuation">,</span><span class="token operator">*</span>Space<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h1><blockquote><p>3 种分配方法分别为：首部拟合法、最佳拟合法和最差拟合法。</p><ul><li>选定一个常量e，每次分配空间时，判断当前内存块向用户分配空间后，如果剩余部分的容量比e小，则将整个内存块全部分配给用户。</li><li>采用头部拟合法进行分配时，如果每次都从pav指向的结点开始遍历，在若干次后，会出现存储量小的结点密集地分布在pav结点附近的情况，严重影响遍历的时间。解决办法就是：在每次分配空间后，让pav指针指向该分配空间结点的后继结点，然后从新的pav指向的结点开始下一次的分配。</li></ul></blockquote><p>首部拟合法具体实现：</p><pre class="line-numbers language-c"><code class="language-c">Space <span class="token function">AllocBoundTag</span><span class="token punctuation">(</span>Space <span class="token operator">*</span>pav<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    Space p<span class="token punctuation">,</span> f<span class="token punctuation">;</span>    <span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设定常亮 e 的值</span>    <span class="token comment" spellcheck="true">//如果在遍历过程，当前空闲块的在存储容量比用户申请空间 n 值小，在该空闲块有右孩子的情况下直接跳过</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>size <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rlink <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-></span>rlink<span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//跳出循环，首先排除p为空和p指向的空闲块容量小于 n 的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p <span class="token operator">||</span> p<span class="token operator">-></span>size <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//指针f指向p空闲块的foot域</span>        f <span class="token operator">=</span> <span class="token function">FootLoc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调整pav指针的位置，为下次分配做准备</span>        <span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span> <span class="token operator">=</span> p<span class="token operator">-></span>rlink<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果该空闲块的存储大小比 n 大，比 n+e 小，负责第一种情况，将 p 指向的空闲块全部分配给用户</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>size <span class="token operator">-</span> n <span class="token operator">&lt;=</span> e<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                pav <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//全部分配用户，即从可利用空间表中删除 p 空闲块</span>                <span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span><span class="token operator">-></span>llink <span class="token operator">=</span> p<span class="token operator">-></span>llink<span class="token punctuation">;</span>                p<span class="token operator">-></span>llink<span class="token operator">-></span>rlink <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//同时调整head域和foot域中的tag值</span>            p<span class="token operator">-></span>tag <span class="token operator">=</span> f<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//否则，从p空闲块中拿出 大小为 n 的连续空间分配给用户，同时更新p剩余存储块中的信息。</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//更改分配块foot域的信息</span>            f<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            p<span class="token operator">-></span>size <span class="token operator">-</span><span class="token operator">=</span> n<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//f指针指向剩余空闲块 p 的底部</span>            f <span class="token operator">=</span> <span class="token function">FootLoc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            f<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            f<span class="token operator">-></span>uplink <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> f <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//p指向的是分配给用户的块的head域，也就是该块的首地址</span>            p<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            p<span class="token operator">-></span>size <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h1><p>系统需要立即回收被用户占用的存储空间，以备新的用户使用。回收算法中需要解决的问题是：在若干次分配操作后，可利用空间块中会产生很多存储空间很小以致无法使用的空闲块。但是经过回收用户释放的空间后，可利用空间表中可能含有地址相邻的空闲块，回收算法需要将这些地址相邻的空闲块合并为大的空闲块供新的用户使用。合并空闲块有3种情况：</p><ul><li>该空闲块的左边有相邻的空闲块可以进行合并；</li><li>该空闲块的右边用相邻的空闲块可以进行合并；</li><li>该空闲块的左右两侧都有相邻的空闲块可以进行合并；<blockquote><p>判断当前空闲块左右两侧是否为空闲块的方法是：对于当前空闲块p ，p-1 就是相邻的低地址处的空闲块的foot域，如果foot域中的tag值为0 ，表明其为空闲块； p+p-&gt;size 表示的是高地址处的块的head域，如果head域中的tag值为 0，表明其为空闲块。</p></blockquote></li></ul><p>如果当前空闲块的左右两侧都不是空闲块，而是占用块，此种情况下只需要将新的空闲块按照相应的规则（头部拟合法随意插入，其它两种方法在对应位置插入）插入到可利用空间表中即可。实现代码为：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//设定p指针指向的为用户释放的空闲块</span>p<span class="token operator">-></span>tag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//f指针指向p空闲块的foot域</span>Space f<span class="token operator">=</span><span class="token function">FootLoc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token operator">-></span>uplink<span class="token operator">=</span>p<span class="token punctuation">;</span>f<span class="token operator">-></span>tag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果pav指针不存在，证明可利用空间表为空，此时设置p为头指针，并重新建立双向循环链表</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pav<span class="token punctuation">)</span> <span class="token punctuation">{</span>    pav<span class="token operator">=</span>p<span class="token operator">-></span>llink<span class="token operator">=</span>p<span class="token operator">-></span>rlink<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//否则，在p空闲块插入到pav指向的空闲块的左侧</span>    Space q<span class="token operator">=</span>pav<span class="token operator">-></span>llink<span class="token punctuation">;</span>    p<span class="token operator">-></span>rlink<span class="token operator">=</span>pav<span class="token punctuation">;</span>    p<span class="token operator">-></span>llink<span class="token operator">=</span>q<span class="token punctuation">;</span>    q<span class="token operator">-></span>rlink<span class="token operator">=</span>pav<span class="token operator">-></span>llink<span class="token operator">=</span>p<span class="token punctuation">;</span>    pav<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该空闲块的左侧相邻的块为空闲块，右侧为占用块，处理的方法是：只需要更改左侧空闲块中的size的大小，并重新设置左侧空闲块的foot 域即可（如图2）。</p><div align="center"><img src="/images/空闲块合并.png" width="800"></div> <center>图5 空闲块合并（当前块，左侧内存块）</center><p> 实现代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//常量 n 表示当前空闲块的存储大小</span><span class="token keyword">int</span> n<span class="token operator">=</span>p<span class="token operator">-></span>size<span class="token punctuation">;</span>Space s<span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">-></span>uplink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p-1 为当前块的左侧块的foot域，foot域中的uplink指向的就是左侧块的首地址，s指针代表的是当前块的左侧存储块</span>s<span class="token operator">-></span>size<span class="token operator">+</span><span class="token operator">=</span>n<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置左侧存储块的存储容量</span>Space f<span class="token operator">=</span>p<span class="token operator">+</span>n<span class="token number">-1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//f指针指向的是空闲块 p 的foot域</span>f<span class="token operator">-></span>uplink<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这是foot域的uplink指针重新指向合并后的存储空间的首地址</span>f<span class="token operator">-></span>tag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置foot域的tag标记为空闲块</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 如果当前用户释放掉的空闲块，物理位置上相邻的左右两侧的内存块全部为空闲块，需要将 3 个空闲块合并为一个更大的块，操作的过程为：更新左侧空闲块的 size 的值，同时在可利用空间表中摘除右侧空闲块，最后更新合并后的大的空闲块的 foot域</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">int</span> n<span class="token operator">=</span>p<span class="token operator">-></span>size<span class="token punctuation">;</span>Space s<span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">-></span>uplink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//找到释放内存块物理位置相邻的低地址的空闲块</span>Space t<span class="token operator">=</span>p<span class="token operator">+</span>p<span class="token operator">-></span>size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//找到物理位置相邻的高地址处的空闲块</span>s<span class="token operator">-></span>size<span class="token operator">+</span><span class="token operator">=</span>n<span class="token operator">+</span>t<span class="token operator">-></span>size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更新左侧空闲块的size的值</span><span class="token comment" spellcheck="true">//从可利用空间表中摘除右侧空闲块</span>Space q<span class="token operator">=</span>t<span class="token operator">-></span>llink<span class="token punctuation">;</span>Space q1<span class="token operator">=</span>t<span class="token operator">-></span>rlink<span class="token punctuation">;</span>q<span class="token operator">-></span>rlink<span class="token operator">=</span>q1<span class="token punctuation">;</span>q1<span class="token operator">-></span>llink<span class="token operator">=</span>q<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更新合并后的空闲块的uplink指针的指向</span>Space f<span class="token operator">=</span><span class="token function">FootLoc</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token operator">-></span>uplink<span class="token operator">=</span>s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="伙伴系统管理动态内存"><a href="#伙伴系统管理动态内存" class="headerlink" title="伙伴系统管理动态内存"></a>伙伴系统管理动态内存</h1><p>伙伴系统本身是一种动态管理内存的方法，和边界标识法的区别是：使用伙伴系统管理的存储空间，无论是空闲块还是占用块，大小都是 2 的 n 次幂（n 为正整数）。</p><p>例如，系统中整个存储空间为 2m 个字。那么在进行若干次分配与回收后，可利用空间表中只可能包含空间大小为：20、21、22、…、2m 的空闲块。</p><blockquote><p>字是一种计量单位，由若干个字节构成，不同位数的机器，字所包含的字节数不同。例如，8 位机中一个字由 1 个字节组成；16 位机器一个字由 2 个字节组成。</p></blockquote><h2 id="可利用空间表中结点构成"><a href="#可利用空间表中结点构成" class="headerlink" title="可利用空间表中结点构成"></a>可利用空间表中结点构成</h2><div align="center"><img src="/images/结点构成.png" width="800"></div> <center>图6 结点构成</center><p>header 域表示为头部结点，由 4 部分构成：</p><ul><li><p>llink 和 rlink 为结点类型的指针域，分别用于指向直接前驱和直接后继结点。</p></li><li><p>tag 值：用于标记内存块的状态，是占用块（用 1 表示）还是空闲块（用 0 表示）</p></li><li><p>kval：记录该存储块的容量。由于系统中各存储块都是2的m幂次方，所以kval记录m的值。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> WORD_b<span class="token punctuation">{</span>  <span class="token keyword">struct</span> WORD_b <span class="token operator">*</span>llink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向直接前驱</span>  <span class="token keyword">int</span> tag<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录该块是占用块还是空闲块</span>  <span class="token keyword">int</span> kval<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录该存储块容量大小为2的多少次幂</span>  <span class="token keyword">struct</span> WORD_b <span class="token operator">*</span>rlink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向直接后继</span>  OtherType other<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录结点的其它信息</span><span class="token punctuation">}</span>WORD_b<span class="token punctuation">,</span>head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在伙伴系统中，由于系统会不断地接受用户的内存申请的请求，所以会产生很多大小不同但是都是容量为$2^{m}$的内存块，所以为了在分配的时候查找方便，系统采用将大小相同的各自建立一个链表。对于初始容量为 $2^{m}$的一整块存储空间来说，形成的链表就有可能有m+1个，为了更好的对这些链表进行管理，系统将这m+1个链表的表头存储在数组中，就类似于邻接表的结构，如图7。</p><div align="center"><img src="/images/伙伴系统的初始状态.png" width="800"></div><center>图7 伙伴系统的初始状态</center><p>可利用空间表的代码表示为：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> m 16</span><span class="token comment" spellcheck="true">//设定m的初始值</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> HeadNode <span class="token punctuation">{</span>  <span class="token keyword">int</span> nodesize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录该链表中存储的空闲块的大小</span>  WORD_b <span class="token operator">*</span> first<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//相当于链表中的next指针的作用</span><span class="token punctuation">}</span>FreeList<span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一维数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="分配算法-1"><a href="#分配算法-1" class="headerlink" title="分配算法"></a>分配算法</h1><p>伙伴系统的分配算法很简单。假设用户向系统申请大小为 n 的存储空间，若$2^{k-1} &lt; n &lt;= 2^{k}$，此时就需要查看可利用空间表中大小为$2^{k}$ 的链表中有没有可利用的空间结点：</p></li><li><p>如果该链表不为NULL，可以直接采用头插法从头部取出一个结点，提供给用户使用；</p></li><li><p>如果大小为$2^{k}$的链表为 NULL，就需要依次查看比$2^{k}$大的链表，找到后从链表中删除，截取相应大小的空间给用户使用，剩余的空间，根据大小插入到相应的链表中。</p></li></ul><p>用户向系统申请一块大小为7个字的空间，而系统总的内存为$2^{4}$个字,按照伙伴系统的分配算法得出：$2^{2} &lt; 7 &lt; 2^{3}$，所以此时应查看可利用空间表中大小为 23 的链表中是否有空闲结点：</p><ul><li><p>如果有，则从该链表中摘除一个结点，直接分配给用户使用；</p></li><li><p>如果没有，则需依次查看比$2^{3}$大的各个链表中是否有空闲结点。假设，在大小$2^{4}$的链表中有空闲块，则摘除该空闲块，分配给用户$2^{3}$个字的空间，剩余$2^{3}$个字，该剩余的空闲块添加到大小为$2^{3}$的链表中。</p><div align="center"><img src="/images/分配过程.png" width="800"></div><center>图8 伙伴系统分配过程</center><h1 id="回收算法-1"><a href="#回收算法-1" class="headerlink" title="回收算法"></a>回收算法</h1><p>无论使用什么内存管理机制，在内存回收的问题上都会面临一个共同的问题：如何把回收的内存进行有效地整合，伙伴系统也不例外。</p></li></ul><p>当用户申请的内存块不再使用时，系统需要将这部分存储块回收，回收时需要判断是否可以和其它的空闲块进行合并。</p><p>在寻找合并对象时，伙伴系统和边界标识法不同，在伙伴系统中每一个存储块都有各自的“伙伴”，当用户释放存储块时只需要判断该内存块的伙伴是否为空闲块，如果是则将其合并，然后合并的新的空闲块还需要同其伙伴进行判断整合。反之直接将存储块根据大小插入到可利用空间表中即可。</p><p>判断一个存储块的伙伴的位置时，采用的方法为：如果该存储块的起始地址为 p，大小为$2^{k}$，则其伙伴所在的起始地址为：</p><div align="center"><img src="/images/公式1.png" width="800"></div><p>例如，当大小为$2^{8}$ ，起始地址为512的伙伴块的起始地址的计算方式为：由于512 MOD $2^{9}$=0，所以，$512+2^{8}=768$，及如果该存储块回收时，只需要查看起始地址为 768 的存储块的状态，如果是空闲块则两者合并，反之直接将回收的释放块链接到大小为$2^{8}$的链表中。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用伙伴系统进行存储空间的管理过程中，在用户申请空间时，由于大小不同的空闲块处于不同的链表中，所以分配完成的速度会更快，算法相对简单。</p><p>回收存储空间时，对于空闲块的合并，不是取决于该空闲块的相邻位置的块的状态；而是完全取决于其伙伴块。所以即使其相邻位置的存储块时空闲块，但是由于两者不是伙伴的关系，所以也不会合并。这也就是该系统的缺点之一：由于在合并时只考虑伙伴，所以容易产生存储的碎片。</p><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>当用户发出申请空间的请求后，系统向用户分配内存；用户运行结束释放存储空间后，系统回收内存。这两部操作都是在用户给出明确的指令后，系统对存储空间进行有效地分配和回收。</p><p>但是在实际使用过程中，有时会因为用户申请了空间，但是在使用完成后没有向系统发出释放的指令，导致存储空间既没有被使用也没有被回收，变为了无用单元或者会产生悬挂访问的问题。</p><p>什么是无用单元？简单来讲，无用单元是一块用户不再使用，但是系统无法回收的存储空间。例如在C语言中，用户可以通过 malloc 和 free 两个功能函数来动态申请和释放存储空间。当用户使用 malloc 申请的空间使用完成后，没有使用 free 函数进行释放，那么该空间就会成为无用单元。</p><p>悬挂访问也很好理解：假设使用malloc申请了一块存储空间，有多个指针同时指向这块空间，当其中一个指针完成使命后，私自将该存储空间使用free释放掉，导致其他指针处于悬空状态，如果释放掉的空间被再分配后，再通过之前的指针访问，就会造成错误。数据结构中称这种访问为悬挂访问。</p><p>解决存储空间可能成为无用单元或者产生悬挂访问的方法有两个：</p><ul><li>每个申请的存储空间设置一个计数域，这个计数域记录的是指向该存储空间的指针数目，只有当计数域的值为 0 时，该存储空间才会被释放。</li><li>在程序运行时，所有的存储空间无论是处于使用还是空闲的状态，一律不回收，当系统中的可利用空间表为空时，将程序中断，对当前不在使用状态的存储空间一律回收，全部链接成一个新的可利用空间表后，程序继续执行。</li></ul><p><font color="red">第二种方法中，在程序运行过程中很难找出此时哪些存储空间是空闲的。解决这个问题的办法是：找当前正在被占用的存储空间，只需要从当前正在工作的指针变量出发依次遍历，就可以找到当前正在被占用的存储空间，剩余的自然就是此时处于空闲状态的存储空间。</font></p><p>使用第二种方式，可以分为两步进行：</p><ul><li>对所有当前正在使用的存储空间加上被占用的标记（对于广义表来说，可以在每个结点结构的基础上，添加一个 mark 的标志域。在初始状态下，所有的存储空间全部标志为 0，被占用时标记为 1）；</li><li>依次遍历所有的存储空间，将所有标记为 0 的存储空间链接成一个新的可利用空间表。</li></ul><p>对正在被占用的存储空间进行标记的方法有三种：</p><ul><li>从当前正在工作的指针变量开始，采用递归算法依次将所有表中的存储结点中的标志域全部设置为 1；</li><li>第一种方法中使用递归算法实现的遍历。而递归底层使用的栈的存储结构，所以也可以直接使用栈的方式进行遍历；</li><li>以上两种方法都是使用栈结构来记录遍历时指针所走的路径，便于在后期可以沿原路返回。所以第三种方式就是使用其他的方法代替栈的作用。</li></ul><h1 id="内存碎片化处理"><a href="#内存碎片化处理" class="headerlink" title="内存碎片化处理"></a>内存碎片化处理</h1><p>这些地址连续的未被占用的存储区在编译程序中称为堆。</p><h1 id="分配内存空间"><a href="#分配内存空间" class="headerlink" title="分配内存空间"></a>分配内存空间</h1><p>在分配内存空间时，每次都从可利用空间中选择最低（或者最高）的地址进行分配。具体的实现办法为：设置一个指针（称为堆指针），每次用户申请存储空间时，都是堆的最低（或者最高）地址进行分配。假设当用户申请 N 个单位的存储空间时，堆指针向高地址（或者低地址）移动 N 个存储单位，这 N 个存储单位即为分配给用户使用的空闲块，空闲块的起始地址为堆指针移动之前所在的地址。</p><p>例如，某一时间段有四个用户（A、B、C、D）分别申请 12 个单位、6 个单位、10 个单位和 8 个单位的存储空间，假设此时堆指针的初值为 0。则分配后存储空间的效果为：</p><div align="center"><img src="/images/内存空间分配.png" width="800"></div> <center>图9 内存空间分配</center><h1 id="回收算法-2"><a href="#回收算法-2" class="headerlink" title="回收算法"></a>回收算法</h1><p>由于系统中的可利用空间始终都是一个连续的存储空间，所以回收时必须将用户释放的存储块合并到这个堆上才能够重新使用。存储紧缩有两种做法：其一是一旦用户释放所占空间就立即进行回收紧缩；另外一种是在程序执行过程中不立即回收用户释放的存储块，而是等到可利用空间不够分配或者堆指针指向了可利用存储区的最高地址时才进行存储紧缩。</p><p>具体的实现过程是：</p><ul><li>计算占用块的新地址。设立两个指针随巡查向前移动，分别用于指示占用块在紧缩之前和之后的原地址和新地址。因此，在每个占用块的第一个存储单位中，除了存储该占用块的大小和标志域之外，还需要新增一个新地址域，用于存储占用块在紧缩后应有的新地址，即建立一张新、旧地址的对照表。</li><li>修改用户的出事变量表，保证在进行存储紧缩后，用户还能找到自己的占用块。</li><li>检查每个占用块中存储的数据。如果有指向其它存储块的指针，则需作相应修改。</li><li>将所有占用块迁移到新地址去，即进行数据的传递。</li></ul><p>最后，还要将堆指针赋以新的值。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外卖首页列表排序介绍</title>
      <link href="/2022/11/29/ji-qi-xue-xi/sou-guang-tui/wai-mai-shou-ye-lie-biao-pai-xu-jie-shao/"/>
      <url>/2022/11/29/ji-qi-xue-xi/sou-guang-tui/wai-mai-shou-ye-lie-biao-pai-xu-jie-shao/</url>
      
        <content type="html"><![CDATA[<h2 id="一、产品形态与技术架构"><a href="#一、产品形态与技术架构" class="headerlink" title="一、产品形态与技术架构"></a>一、产品形态与技术架构</h2><h3 id="1-外卖首页列表产品形态"><a href="#1-外卖首页列表产品形态" class="headerlink" title="1. 外卖首页列表产品形态"></a>1. 外卖首页列表产品形态</h3><p>旧首页（2021.4以前）分为商家模式和菜品模式，新首页（2021.6以后）是混排瀑布流</p><ul><li>目标<ul><li>流量目标：UV_RPM（千人展示成交额）、UV_CXR（用户维度-转化率）、PV_CTR（卡片维度-点击率）</li><li>用户运营目标：心智、留存</li><li>商家运营目标：新店冷启动、品类扶持、KA商家扶持</li></ul></li><li>元素<ul><li>广告卡片：铂金广告、点金广告</li><li>自然流量卡片：商家卡片、商品卡片、主题卡片</li></ul></li></ul><h3 id="2-混排服务架构"><a href="#2-混排服务架构" class="headerlink" title="2.混排服务架构"></a>2.混排服务架构</h3><div align="center"><img src="/images/混排.png" width="800"></div><center>混排服务</center><h3 id="3-商家排序服务架构"><a href="#3-商家排序服务架构" class="headerlink" title="3. 商家排序服务架构"></a>3. 商家排序服务架构</h3><div align="center"><img src="/images/商家排序服务架构.png" width="800"></div><center>商家排序服务</center><h2 id="二、商家排序预估模型"><a href="#二、商家排序预估模型" class="headerlink" title="二、商家排序预估模型"></a>二、商家排序预估模型</h2><h3 id="1-召回策略"><a href="#1-召回策略" class="headerlink" title="1. 召回策略"></a>1. 召回策略</h3><ul><li><p>主召回</p><ul><li>XGBoost树模型，对LBS商家打分</li><li>特征：数量30+，包括user特征、item特征（有限）user-item交叉特征、上下文特征</li></ul></li><li><p>旁路召回</p><ul><li>历史行为</li><li>实时行为</li><li>向量召回：基于向量相似度的i2i召回（trigger item：实时点击的商家，向量：word2vec训练、用户点击序列训练、同城负采样）</li></ul></li><li><p>合并</p><ul><li>各个旁路召回截断后插入至主召回头部，去重后整体截断200个</li></ul></li></ul><h3 id="2-精排模型演进路径"><a href="#2-精排模型演进路径" class="headerlink" title="2. 精排模型演进路径"></a>2. 精排模型演进路径</h3><div align="center"><img src="/images/精排模型演进路径.png" width="800"></div><center>精排模型演进</center><h3 id="3-精排策略：行为序列模型"><a href="#3-精排策略：行为序列模型" class="headerlink" title="3. 精排策略：行为序列模型"></a>3. 精排策略：行为序列模型</h3><ul><li>实时点击序列+历史加购序列<ul><li>商家表示：商家向量、商家名关键词、商家品类、主营菜品向量</li><li>上下文信息：小时差、停留时长、加购行为</li><li>序列内部的多样性</li></ul></li><li>线上收益：PV_CTR + 1.23%</li><li>重点方向：<ul><li>商家表示</li><li>上下文信息</li><li>序列抽取（长序列）<div align="center"><img src="/images/行为序列模型.png" width="800"></div><center>行为序列模型</center></li></ul></li></ul><h3 id="4-精排策略：多任务学习"><a href="#4-精排策略：多任务学习" class="headerlink" title="4.精排策略：多任务学习"></a>4.精排策略：多任务学习</h3><ul><li>PLE：Ctr和Cxr两个任务</li><li>不同目标损失函数的权重<ul><li>等权重</li><li>UWL（Uncertainty to Weigh Losses）</li></ul></li><li>线上收益：PV_CTR+0.72%、UV_RPM+1.38%</li><li>收益来源：<ul><li>多目标</li><li>多任务<div align="center"><img src="/images/多任务学习.png" width="800"></div><center>多任务学习</center>   </li></ul></li></ul><h3 id="5-精排策略：大模型"><a href="#5-精排策略：大模型" class="headerlink" title="5. 精排策略：大模型"></a>5. 精排策略：大模型</h3><ul><li><p>商家特征</p><ul><li>商家ID</li><li>主要商品品类ID</li></ul></li><li><p>用户特征</p><ul><li>购买/点击/搜索的文本分词</li></ul></li><li><p>用户-商家交叉特征</p><ul><li>用户：购买/点击Top n商家品类、购买/点击top n商品类</li><li>商家：商家品类、主要商品品类</li></ul></li><li><p>场景-商家交叉特征</p><ul><li>场景：城市、小区/楼宇、地址类型、geohash、时段</li></ul></li><li><p>2个月训练数据</p></li></ul><h2 id="三、机制层排序公式"><a href="#三、机制层排序公式" class="headerlink" title="三、机制层排序公式"></a>三、机制层排序公式</h2><h3 id="1-机制层整体迭代路径"><a href="#1-机制层整体迭代路径" class="headerlink" title="1.机制层整体迭代路径"></a>1.机制层整体迭代路径</h3><div align="center"><img src="/images/机制层整体迭代路径.png" width="800"></div><center>机制层整体迭代路径</center><ul><li>混排模型<ul><li>输入精排预估的pCTR、pCXR以及其他相关特征，回归价值函数</li><li>价值函数：a * click + b * pay + c * 是否扶持</li></ul></li><li>为什么从混排模型迁移到排序公式<ul><li>未引入列表维度信息的情况下，二者等价（随机变量的期望）</li><li>迭代效率与敏感性</li></ul></li><li>校准:分段线性校准，每天离线更新参数</li></ul><h3 id="2-排序公式：如何做流量扶持"><a href="#2-排序公式：如何做流量扶持" class="headerlink" title="2.排序公式：如何做流量扶持"></a>2.排序公式：如何做流量扶持</h3><ul><li>假设按照pCXR排序，同时要给KA商家做流量扶持<ul><li>方式1：常规商家公式pCXR，KA商家公式pCXR+0.01</li><li>公式2：常规商家公式pCXR，KA商家公式1.1 * pCXR</li></ul></li><li>明确流量扶持的目的<ul><li>保证扶持对象的曝光量：如主题卡片，带来展示形式的多样化，关注能否给用户曝光到，进而提升对主题场景的认知</li><li>保证扶持对象的订单量：如KA商家，保证重要客户的单量</li></ul></li><li>问题建模<br>$$\max_{x_{ij}} \sum_{i \in I} \sum_{j \in J(i)} (x_{ij} * CXR_{ij}) $$<br>$$s.t.$$<br>$$\sum_{i \in I} \sum_{j \in J(i)} (x_{ij} * ISKA_{ij} * CXR_{ij}) \ge C^{ka}<em>{order}$$<br>$$\sum</em>{j \in J(i)}(x_{ij}) = 1, \forall i \in I$$<br>$$x_{ij} \in {0,1}, \forall j \in J(i), \forall i \in I$$<br>其中i:第i个曝光位，I：全部曝光位集合；j：第j个候选，J(i)：第i个曝光位下全部候选集合；$x_{ij}$：第i个曝光位是否曝光第j个候选，0-1变量；$C^{ka}_{order}$：KA的最少成单量。</li></ul><h3 id="3-排序公式：如何做流量扶持"><a href="#3-排序公式：如何做流量扶持" class="headerlink" title="3.排序公式：如何做流量扶持"></a>3.排序公式：如何做流量扶持</h3><ul><li><p>结论：</p><ul><li>保订单的扶持：常规商家公式$pCXR$，KA商家公式$（1 + a * ISKA）* pCXR$</li><li>保曝光的扶持：常规商家公式$pCXR$，KA商家公式$pCXR+a*ISKA$</li></ul></li><li><p>简单例子</p><p>共2条请求，假设需要保证KA商家曝光（要求2条请求中至少一条曝光KA商家）</p></li></ul><table><thead><tr><th align="center"></th><th align="center">请求1</th><th align="center">请求2</th></tr></thead><tbody><tr><td align="center">KA</td><td align="center">10</td><td align="center">5</td></tr><tr><td align="center">非KA</td><td align="center">18</td><td align="center">10</td></tr><tr><td align="center">a. 公式(1 + a * ISKA) * pCXR：调节系数到a=1.9即可曝光1次KA，总收益10+10</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">b. 公式pCXR+a* ISKA：调节系数到a=6即可曝光1次KA，总收益18+5</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 看待排序公式的视角：如何用最小的成本置换</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 单词请求视角：两种公式都是将KA的序往前提，不影响每种商家内部的序</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 全局视角：公式的形式会决定哪些请求适合曝光KA，或者将KA的曝光/订单需求分配到哪些请求</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 线上效果：目标是扶持曝光，曝光扶持公式 vs 订单扶持公式UV_CXR+0.66%，PV_CTR+0.17%</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">### 4.排序公式：多目标</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 加法公式 vs 乘法公式</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 举例：均衡PVCTR、PVCXR两个目标的时候，以下两个公式哪个好？排序公式1：$a<em>pCTR + b * pCXR$；排序公式2：$pCTR^{a}</em>pCXR^{b}$</td><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li><p>目标分解到每个曝光位<br>$$PVCTR = \frac{click_count}{expose_count} = \frac{\sum(pCTR)}{expose_count}， PVCXR=\frac{order_count}{expose_count} = \frac{\sum(pCXR)}{expose_count}（假设曝光次数恒定）$$</p></li><li><p>什么样的目标是帕累托最优？</p><ul><li>两个目标相加是帕累托最优：$a * PVCTR + b * PVCXR = a * \sum(pCTR) + b * \sum(pCXR) = \sum(a * pCTR + b * pCXR)$</li><li>两个目标相乘帕累托最优：$PVCTR^{a} * PVCXR^{b} = [\sum(pCTR)]^{a} * [\sum(pCXR)]^b$，乘法目标的情况下不可进一步分解。</li></ul></li><li><p>分场景个性化调节系数a,b是否有空间？</p><ul><li>比如高峰期时间段增大pCXR系数，其他时间段增加pCTR系数</li></ul></li><li><p>简单例子</p><p>  两个请求，每个请求内：从两个候选中选择一个曝光</p></li></ul><table>    <tr>        <td></td>        <td></td>        <td>pCTR</td>        <td>pCXR</td>    </tr>    <tr>        <td rowspan="2">请求1</td>        <td>候选1</td>        <td>4</td>        <td>1</td>    </tr>    <tr>        <td>候选2</td>        <td>2.1</td>        <td>2.1</td>    </tr>    <tr>        <td rowspan="2">请求2</td>        <td>候选1</td>        <td>1</td>        <td>4</td>    </tr>    <tr>        <td>候选2</td>        <td>2.1</td>        <td>2.1</td>    </tr></table><pre><code>a. 公式pCTR + pCXR：两次请求都选择候选1，pCTR总收益5，pCXR总收益为5b. 公式pCTR*pCXR：两次请求都选择候选2，pCTR总收益4.2，pCXR总收益为4.2</code></pre><ul><li><p>模拟实验：画图（alpha * metricA + metricB 优于 power(metricA, alpha) * metricB）</p></li><li><p>线上收益：加法 vs 乘法，UV_CXR+0.60%，PV_CTR+0.15%</p></li></ul><h3 id="5-排序公式：目标不可分"><a href="#5-排序公式：目标不可分" class="headerlink" title="5.排序公式：目标不可分"></a>5.排序公式：目标不可分</h3><ul><li>什么目标不可分：难以直接建模<ul><li>列表维度的指标：UVCXR等</li><li>全局入口下的指标</li></ul></li><li>From 模型做预估 to 模型做决策<ul><li>原因：解空间爆炸</li></ul></li><li>参数搜索：ES、CEM、强化学习</li><li>方案介绍<ul><li>State：用户特征、上下文特征</li><li>Action：排序公式的参数</li><li>Reward：列表维度的权益（也可以从全局入口归因label）</li><li>先在线上随机做action，收集数据，学习critic网络（输入state、action、输出reward）</li><li>接下来固定actor网络参数，学习actor网络（输入state，输出action）</li></ul></li></ul><h2 id="四、总结与思考"><a href="#四、总结与思考" class="headerlink" title="四、总结与思考"></a>四、总结与思考</h2><ul><li>总结-收益分析<ul><li>用户兴趣建模</li><li>多任务学习</li><li>大模型</li><li>混排模型/排序公式</li></ul></li><li>思考<ul><li>对上界的分析</li><li>化繁为简</li><li>保持认知迭代</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广告深度预估技术在到店场景下的突破</title>
      <link href="/2022/11/29/ji-qi-xue-xi/sou-guang-tui/guang-gao-shen-du-yu-gu-ji-zhu-zai-mei-tuan-dao-dian-de-tu-po/"/>
      <url>/2022/11/29/ji-qi-xue-xi/sou-guang-tui/guang-gao-shen-du-yu-gu-ji-zhu-zai-mei-tuan-dao-dian-de-tu-po/</url>
      
        <content type="html"><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><h3 id="1-1-背景"><a href="#1-1-背景" class="headerlink" title="1.1 背景"></a>1.1 背景</h3><ul><li><p>点击率/转化率/交易额预估问题，是广告、推荐领域的核心，预估值准确性与广告/推荐平台的营收和发展直接相关。</p><h3 id="1-2-业务特征与挑战"><a href="#1-2-业务特征与挑战" class="headerlink" title="1.2 业务特征与挑战"></a>1.2 业务特征与挑战</h3></li><li><p>O2O业务的模型整体建模设计有一下空间和时间维度两方面的挑战：</p><ul><li>LBS空间距离约束：线上门店/商品需要在有限的距离约束下表示，不同空间位置的差异性大，带来候选量差异大，上下文刻画重要等挑战。</li><li>长周期性：门店消费习惯具有周期性强，长期行为影响大等特点，常规模型训练方式较难学习周期性，训练方式存在遗忘历史信息挑战。<h3 id="1-3-预估技术简介"><a href="#1-3-预估技术简介" class="headerlink" title="1.3 预估技术简介"></a>1.3 预估技术简介</h3></li></ul></li><li><p>针对LBS距离约束和长周期性两方面的挑战，下文将介绍CTR预估技术方案。CTR预估是有监督机器学习问题$\min_{f} l(f(u,a,c), y)$，最优预测函数$\hat{f}(u,a,c)$被用户(u)、广告(a)、上下文(c)三个维度的函数输入，以及训练过程的函数求解$\min_{f}$所决定，其中上下文包括了请求query、请求列表上下文、请求地理位置等实时信息。结合LBS距离约束和上周期性两个核心挑战，对于CTR预估建模函数进行优化：</p><div align="center"><img src="/images/CTR预估建模关系图.png" width="800"></div><center>CTR预估建模关系图（图1）</center><p>  函数输入：上下文、用户、广告三个方面建模</p><pre><code>  （1）基于位次组合的上下文偏差感知预估（上下文）：由于LBS距离约束挑战，空间位置差异引起不同展示上下文影响大，因此利用深度位置交叉网络将广告和位次组合建模，并基于位次信息强化不同请求的上下文偏差感知。  （2）基于时空依赖的超长序列建模（用户）：针对长周期性和LBS距离约束两方面挑战，一方面基于预训练机制实现了超长序列建模，捕获用户周期性行为；另一方面，实现行为序列的时空联合建模，优化LBS距离约束问题。  （3）广告候选动态化（广告）：由于LBS距离约束挑战，空间差异性引起不同位置候选差异大，广告和用户存在匹配关系，只有保障广告供给的充足性，才能对用户广告进行良好的建模，因此进行广告候选量/候选类型/算力资源的动态化，提高用户需求匹配的供给。</code></pre><p>  函数求解：模型训练方式</p><pre><code>  （1）灾难遗忘和持续学习（训练方式）：针对长周期性挑战，高维稀疏模型在学习最近数据的同时会遗忘历史数据，形成灾难遗忘。通过具备数据回放能力的记忆结构进行持续学习，实现对历史数据有效刻画。  （2）模型整体结构如图2，结合User/Ad/Context/Training几方面优化，实现方式通过表示单元、记忆单元、组合单元三个模块构成高精度高量级的预估系统。其中表示单元通过加载流式数据，结合超长序列和实时序列，构建时空依赖激活；记忆单元集合历史和当前数据，在数据流控制的基础上，一方面提供历史超长序列的表达学习，实现序列长度为2000-10000用户全生命周期兴趣建模。另一方面面对灾难遗忘问题，通过具备数据回放能力的记忆结构进行持续学习，实现高精度的单点预估。组合单元提供组合能力，在广告方面，可以将记忆单元的综合表示与多个泛商品进行组合，在上下文方面，可以与多个位次表示进行组合，将单门店预估能力扩展到多位次多商品，进而感知展示上下文偏差，从而实现高精度高量级的组合预估系统（精排在线预估量级3000+）</code></pre><div align="center"><img src="/images/CTR预估整体网络图.png" width="800"></div><center>CTR预估整体网络图（图2）</center></li></ul><h2 id="二、预估技术突破"><a href="#二、预估技术突破" class="headerlink" title="二、预估技术突破"></a>二、预估技术突破</h2><h3 id="2-1-上下文：基于位次组合的上下文偏差感知预估"><a href="#2-1-上下文：基于位次组合的上下文偏差感知预估" class="headerlink" title="2.1 上下文：基于位次组合的上下文偏差感知预估"></a>2.1 上下文：基于位次组合的上下文偏差感知预估</h3><ul><li>LBS约束下的位次偏差在不同上下文中有明显差异，一线城市广告充足且质量高，靠前位次广告更容易吸引用户点击，更易形成点击靠前位次的行为习惯，三线城市商户质量参差不齐，导致广告受其上下文自然的影响呈现差异。搜索广告场景的用户意图较强，更关注于靠前广告位，位次偏差较大，而在筛选列表广告场景，意图不明确的用户偏向于浏览优质商家，因此上下文偏差较大。</li><li><strong>位次组合预估技术框架</strong>：基于位次偏差问题，首先沉淀了深度位次交叉网络（DIPN）去同时预估多个位次的CTR，DPIN模型由三个模块组成，分别处理J个候选广告的基础模块（Base Module），处理K个（10个）候选广告位次的深度位次交叉模块以及组合J * k个交叉候选的位次组合模块（Position-wise Combination Module），不同模型需要预估的样本数量不同，复杂模块预估样本数量少，简单模块预估样本多，由此提高模型性能和保障服务性能，DPIN预估每个位次上的CTR并学习位次信息和其他信息的深度非线性交叉表示。</li><li><strong>上下文偏差感知学习</strong>：由于自然广告分别排序及广告插入自然列表的业务特点，在广告预估时可以考虑已排序好的自然列表，而多位次预估的技术框架赋予广告感知其局部自然上下文的能力，深度位次交叉模块在考虑位次、上下文、用户位次历史行为的基础上通过上下文自然聚合模块感知聚合局部自然上下文信息，从而更好地缓解上下文偏差。详见SIGIR 2021论文，Deep Position-Wise Interaction Network for CTR Prediction。（<a href="https://tech.meituan.com/2021/06/10/deep-position-wise-interaction-network-for-ctr-prediction.html）" target="_blank" rel="noopener">https://tech.meituan.com/2021/06/10/deep-position-wise-interaction-network-for-ctr-prediction.html）</a><div align="center"><img src="/images/基于时空依赖的超长序列模型图.png" width="800"></div><center>基于时空依赖的超长序列模型图（图3）</center></li></ul><h3 id="2-2-用户：基于时空依赖的超长序列建模"><a href="#2-2-用户：基于时空依赖的超长序列建模" class="headerlink" title="2.2 用户：基于时空依赖的超长序列建模"></a>2.2 用户：基于时空依赖的超长序列建模</h3><ul><li>针对长周期性和LBS约束两个挑战，进行用户建模深度优化。一方面针对长周期问题，基于“长短分离”用户行为序列设计原则，通过预训练方式建模长期兴趣；另一方面针对LBS约束问题，通过时空建模进行时间与空间的多重依赖关系学习，有效刻画在不同时空条件的用户表达。</li><li>在美团O2O场景下，用户行为习惯存在明显月级周期性（如图5所示）， 并且行为间周期性差异较大，例如脱毛/水光针类的周期性大于火锅/烧烤类，用户超长序列建模是捕获周期性行为特点的必要条件。在时空依赖方面，用户点击体现出明显的“长分散、短聚合”特点（如图6所示），即较短时间内用户的地理位置聚集在单点，但拉长来看，用户将漫游到多个地理位置；超长周期内，大部分用户还会有跨省跨城流动。因此时空联合联合建模存在潜能。综上两方面问题，整体建模如下：<br>$$P(Click = 1) = f(a,u,c,h(s))$$<br>$$s.t.$$<br>$$s = {(a_{i},t_{i},g_{i})}<em>{i \in N}$$<br>其中包括：（1）超长序列预训练：h(s)部分，将其建模为一个仅依赖于历史序列作为输入、用户兴趣向量作为输出的子网络，支撑千级别的超长序列推理性能；(2) 时空联合建模：$s = {(a</em>{i},t_{i},g_{i})}_{i \in N}$部分的建模, 下文具体介绍。</li><li><strong>超长序列预训练</strong>：针对以上超长序列的性能问题，基于“长短分离”设计，将超长序列单独预训练，同短期表达分离，超长序列模块负责将用户全生命周期序列进行激活和降维，提取用户长期兴趣的表达。主模型负责将用户长期表达与短期表达结合。线上推理时，超长序列可以直接读取天级别缓存的表达向量，通过短期表达部分补充因无法实时更新的效果损失，然后再进行长短期兴趣表达结合，最终线上性能增加由原先30+ms降至1ms以内，实现千级别序列复杂推理。为能捕捉用户周期性行为兴趣，采用Channel-wise Activator Layer结构设计，利用长期行为兴趣漫游的特点将超长序列切分为能表达不同兴趣的时间子序列（Sub Seq），并增加行为动态时间间隔表征后，同差异性属性进行多通道表达激活，实现基于类目周期性差异的兴趣表达。对比业界基于相关检索的超长序列方案，上述超长序列预训练并没有丢弃不相似的表达，充分建模全部行为。例如烧烤与素食、健身房和快餐之间意图负相关，但互相却又强影响，预训练建模以上负相关等更通用的行为影响，在美团数据集中也取得比检索方法更显著的效果。</li><li><strong>时空联合建模</strong>：依赖美团O2O的业务特点与挑战，我们充分考量其时间与空间属性，对用户的历史时空信息和当前时空信息进行了充分的建模和交互。我们分辨出用户行为的三重时空信息，即：用户点击发生时的时间、用户请求发出的地理位置、用户所点击的商户的地理位置。基于上述三重时空信息，我们提出Spatio-temporal Activator Layer：三边时空注意力机制神经网络来对用户历史行为进行建模，通过对请求经纬度信息、商户经纬度信息和请求时间的交互，囊括了同构空间信息深度交叉（用户历史请求位置和用户当前请求位置、用户历史点击商户位置和用户当前目标商户位置等）、异构空间信息深度交叉（用户历史请求位置和用户当前目标POI位置、用户历史点击商户位置和用户当前请求位置）、时间信息深度交叉的三边时空信息交互机制。针对空间信息交叉，我们进一步采用地理位置哈希编码和球面距离相结合的方式，以综合表达绝对空间信息和相对位置信息；针对时间信息交叉，我们也采用绝对与相对时间相结合的方式，有效实现用户行为序列在不同时空条件下的三边表达。从业务角度，针对不同的业务特性，我们进行空间信息表达的动态归一。比如在美食业务中，我们刻画用户搜索地和商户的相对距离信息；而在空间变迁属性更强的酒店业务中，当用户搜索词包含地址词时，我们刻画该地址和目标商户的相对距离信息。最后，经上述网络编码后的时空信息经过注意力机制网络融合，得到LBS场景下用户超长行为序列对不同请求候选的个性化表达。详情，请参考团队的CIKM 2021论文《Trilateral Spatiotemporal Attention Network for User Behavior Modeling in Location-based Search》</li></ul><h3 id="2-3-广告：广告候选动态化"><a href="#2-3-广告：广告候选动态化" class="headerlink" title="2.3 广告：广告候选动态化"></a>2.3 广告：广告候选动态化</h3><ul><li><p>广告同用户存在着匹配关系，在用户意图精准理解的基础上，充分的广告供给能够进一步释放潜能。而在LBS距离约束挑战下，不同请求的广告候选存在很大差异。因此如图8所示，我们从候选量、候选类型、候选算力三个维度构造广告候选动态化系统，实现精细化的供给匹配，具体优化如下：</p><div align="center"><img src="/images/广告候选动态化三维图.png" width="800"></div><center>广告候选动态化三维图（图4）</center></li><li><p><strong>候选量动态化</strong>：在广告/推荐领域，由于性能和资源限制，召回-&gt;粗排-&gt;精排-&gt;机制，各层之间普遍存在漏斗候选截断，其中的精排候选数一般设置固定值。美团业务的距离约束特点显著，大型城市是小型城市平均候选数的59倍。根据城市、商圈等空间粒度进行候选量动态化后，可以在资源固定下最大限度释放热门地区的排序效果，特别是大型城市效果明显，RPM提升约20%。由于候选量大幅度提升，精排模型有更严重的选择性偏差问题——线上面对的扩量候选与此前系统的候选不一致，为扩量前系统候选的超集。将候选扩量对应的流量理解为Explore流量，对CTR模型训练进行了多阶段优化，进一步取得效果[13]，整体优化在部分筛选列表广告RPS提升5%~10%。</p></li><li><p><strong>候选类型动态化</strong>：在候选量动态化的基础上，我们进一步进行了候选类型动态化。因不同类型均为广告，我们在此处不采用Ad概念，在某些类目上，受LBS限制门店数较少，而每个门店下的泛商品（门店下更细粒度候选，同门店差异见上图，例如在结婚品类下的某婚纱照为商品）较多，将候选类型从门店扩展到门店+泛商品后，候选供给在部分类目可以扩大约30倍。并且在业务中，用户意图逐渐呈现具体化、明确化与多样化特点，例如“写真”等搜索关键词增多，粗粒度的门店候选已经不足以匹配细粒度用户意图。通过深度个性化的异构候选混排，能够匹配细粒度的用户意图，给用户展示最符合其兴趣偏好的候选类型。如图9所示，我们通过组合预估实现异构混排系统，主网络的高复杂性门店表征通过共有表达的迁移学习，和商品网络的高数量级商品表征进行维度动态转换对齐，实现数千量级的门店/泛商品异构混排系统。在部分筛选列表广告RPM提升10%~15%。</p></li><li><p><strong>候选算力动态化</strong>：通过动态的候选供给我们发现更多的候选能够带来效果空间，在此基础上我们进一步进行算力动态化，从性能角度进一步提升候选量级。广告系统收到请求后，会经过召回、粗排、精排、机制模块，最终生成广告展现顺序。其中各模块的超时时间和资源是固定的，导致总体算力缺乏弹性，容易因候选过多出现总体请求超时而不出广告的情况，或是候选过少出现多余算力浪费的现象。因此我们进行候选算力动态化，根据流量价值调整每个模块的耗时，通过全局优化实现在有限算力下收益最大化：首先在工程架构上增加各个服务算力弹性变量，如超时时间、模型复杂度和计算并行度等等，实现了效果和算力的灵活兑换。之后在算法上通过流量价值预估模块预估当前请求价值，确定各阶段打分数。在接下来的各服务阶段，结合当前算力消耗与预估价值情况，即时调整后续阶段算力弹性变量，进一步释放了效果空间。在筛选列表广告RPM提升约2%。</p></li></ul><h3 id="2-3-训练方式：灾难遗忘与持续学习"><a href="#2-3-训练方式：灾难遗忘与持续学习" class="headerlink" title="2.3 训练方式：灾难遗忘与持续学习"></a>2.3 训练方式：灾难遗忘与持续学习</h3><ul><li>灾难遗忘(Catastrophic Forgetting)是模型学习同人脑学习的一个重要差异，指的是同一个网络模型，在学习新的任务的时候，因分布变化而导致老任务学习的模型权重损坏。在美团广告业务，无论是用户和商户均存在周期性特点，并且高维稀疏网络特性会放大这个特点，现象是在拟合新数据模式过程中，遗忘具备周期性的老数据，形成了灾难遗忘。下面会介绍长周期性挑战，与高维稀疏网络结构问题，以及对应的持续学习解决方案。<ul><li><strong>周期性数据模式</strong>：不同于传统机器学习数据独立同分布假设(i.i.d.)，CTR预估模型面临着动态非平稳的外部环境。特别地，在我们的O2O业务中，新用户、新商户不停出现，流行元素如小龙虾、烤肉等不时演变，夹杂着周中简餐周末大餐等节日性、季节性、星期级，小时级特征，对CTR预估模型的持续学习提出了挑战，要求我们的模型能够快速拟合新出现的数据模式。针对这类时变数据的学习任务，一种常见选择是流式训练。流式训练将数据按照时间顺序依次喂入模型，以Regret为目标让模型实时动态地调整模型参数，达到拟合最新数据分布的目的。但是，单纯地流式训练有过分强调新数据模式而遗忘过往学习到的老数据模式的危险。特别地，在我们的O2O业务场景下，存在大量周期性数据模式，下面将以星期级周期为例进行介绍。</li><li><strong>高维稀疏网络的结构匹配性</strong>：不同于NLP/CV领域，广告/推荐领域的DNN模型具有显著的参数不平衡性，即高维度稀疏的Embedding层约有亿级~千亿级别参数量的参数量，而连接Embedding到Output的FC层(Fully Connected Layers)却低维稠密，网络中极度稀疏的Embedding层占据99.99%+的参数量，该不平衡性易于引发老数据模式的遗忘问题。以天级更新模式的星期几特征为例，线上推理的数据是周六(t, w(t) = 6) 数据，训练时在未充分纳t时刻数据时，会更多的拟合在周五(t-1)特征上，而实际上在上一周的周六(t-7)与线上推理数据(t)具有更强的分布一致性。特别地，如果我们使用星期几这一离散特征，在高维稀疏的Embedding层在线上推理的t时刻会直接查询到t-7天的Embedding，而低维稠密的FC层会查询到t-1的FC层，会引起严重的结构不匹配问题，形成星期属性模式的灾难性遗忘。更具一般性地，训练中存在着周中简餐，周末大餐等复杂模式的灾难遗忘，引起效果大幅退化。</li><li><strong>面向未来分布的持续学习</strong>：为系统性地解决上述问题，我们采用持续学习中的数据回放技术，在流式训练的基础上进一步拟合回放的数据，加强模型在无遗忘约束下的持续学习能力。具体地，为结合流式训练和持续学习的数据回放技术，我们采用FC层分多塔的结构来达成预训练模型可流式更新、持续学习模型可依赖最新预训练模型更好地拟合当前数据的效果。如下图所示，通过流式训练我们维护一个预训练模型；而为避免模型过分拟合最新数据而导致历史稀疏Embedding层参数和上层FC层参数不匹配的问题，通过数据控制器(Data Controller)维护一份记忆集(Memory Set)，其中的数据为根据未来分布预测，在历史数据中采样得到，并将该份记忆集提供给基础模型用于持续学习，从而在加强对未来分布数据的模型预估能力。<div align="center"><img src="/images/灾难遗忘和持续学习训练模式.png" width="800"></div><center>灾难遗忘和持续学习训练模式（图5）</center></li></ul></li></ul><h1 id="三、预估技术新趋势"><a href="#三、预估技术新趋势" class="headerlink" title="三、预估技术新趋势"></a>三、预估技术新趋势</h1><ul><li>上文介绍了基于O2O特点的CTR技术突破，我们将优化方法推广在转化率、交易额预估问题，其中LBS距离约束在转化率中起到更重要的影响，因方法接近，不再进行赘述。同一技术的点击率预估优化效果在不同业务类型中也存在一定差异，意图强的搜索广告场景，上下文差异性更大，Context相关优化有更明显效果。而在意图弱的信息流广告场景，User建模有更大的空间。那么预估技术如何持续突破的系统上线？迭代路径从前期通过模型复杂度提升，到现阶段结合问题的模型灵活设计均取得效果，而未来我们认为将越来越剥离模块与目标设置的现状，消除建模中人为的设置假设。<ul><li><strong>模型内推理量级动态化</strong>：广告系统通常分为召回、粗排、精排（预估）等多个模块，模块漏斗遵循的一个核心设计逻辑是简单模块打分量级大（例如粗排），复杂模块打分量级低（例如精排）。以递归视角进一步理解子模块设计，将设计逻辑泛化到模型内，同样存在简单的网络部分打分量大，复杂的网络部分打分量低，同一个网络打分量差异化的优化方式。例如粗排常用的双塔网络结构(Two-tower Network)在User端打分一次，Ad端打分多次。更具一般性的形式并不局限在表达能力受限的双塔结构，而在于更充分的应用打分量与复杂度的关系进行灵活设计，例如本文阐述的DPIN(Deep Position-wise Interaction Network)组合网络部分打分量大，基础网络部分打分量小，同在本文阐述的异构混排网络，超长序列预训练优化同样适用于这一趋势。未来将在更细化的层面进行推理量级动态化，通过每一个局部精度与性能的平衡达到整体的最优平衡。</li><li><strong>问题间评估指标差异化</strong>：评测指标是一个比优化方式甚至更重要的问题，点击率预估最经典的评测指标为AUC，而随着模型精度的提升，离线AUC提升同线上不一致的情况逐渐增多。回归到预估问题本身，实际排序系统是在固定请求固定位次下的最优排序，等价寻优User × Context × Time限定条件的Ad最优序。time条件在持续变化难建模，为简化问题，以User/Context维度分组，近似寻优Ad最优序。基于以上假设，User/Context分组的“组间序”同“组内序”并不具备等价的业务意义。例如个性化优化问题，每一个User作为一组进行分组为例，User Group AUC[12]同线上具有更强的一致性；而在Context中的Position Bias问题中，我们发现通过Position Group AUC(PAUC)评估同线上系统具有更强的一致性。在全局AUC增长挑战性变大的背景下，不同问题进行差异性评估指标设计，进而指导模型优化，是取得效果的一个关键趋势。</li><li><strong>链路模块间目标多元化</strong>：系统整体目标面对排序问题，先是解耦为召回、粗排、精排等多模块独立优化，而后针对整体性排序问题，链路目标一致性优化成为一个明显的演进趋势。在召回-&gt;粗排-&gt;精排目标一致，取得明显效果的同时，存在着因多模块过于同质化、协同共振引起的马太效应。以召回为例，是否应该由其他路模块，例如探索路召回来解决这个问题？更具泛化性地，多路召回之间的强互补性，能够提供给下游更优的候选超集，召回各个路之间面向Diversity Loss进行优化是未来的探索性方向之一。随着模块间关系动态变化，广告系统目标设计存在着一致性与差异性的辩证关系。</li><li><strong>搜索推荐边界模糊化</strong>：从广告视角，团队内的搜索广告、推荐广告间做法呈现逐步边界模糊化特点。传统搜索广告围绕意图明确进行Query理解，进而内容适配。逐渐Query相关的刻画不能完全满足用户意图的细化，搜索问题逐渐转变为在Query约束下的个性化匹配问题。边界模糊化带来的一个技术现象就是全域数据的运用，搜索、推荐间的全方位深度迁移学习是取得效果的一个关键。</li><li><strong>模型学习非监督化</strong>：整个广告系统中，是在用户交互、数据、模型之间不断产生反馈循环，在这个过程中会有偏差循环放大的问题，例如产生偏差的数据会喂入模型影响展示，数据回溯到模型形成进一步归纳偏差。传统的建模方式是将整个动态的系统简化为监督问题进行预估建模，优化集合仅为线上集合的子集，效果限制随迭代愈发明显。未来针对监督模型无法充分建模的候选超集依然有较大空间。在实际动态演化的广告系统中，无论是新目标定义、模型优化还是AB Test评测方式都有较大的探索潜能。Debiasing问题优化详情参照团队的KDD Cup 2020冠军技术分享《KDD Cup 2020 Debiasing比赛冠军技术方案及在美团的实践》<div align="center"><img src="/images/广告系统的反馈环路，偏差积累循环.png" width="800"></div><center>广告系统的反馈环路，偏差积累循环（图6）</center></li></ul></li></ul><ul><li>参考链接：<ul><li><a href="https://baijiahao.baidu.com/s?id=1713737100788779347&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1713737100788779347&amp;wfr=spider&amp;for=pc</a></li><li><a href="https://zhuanlan.zhihu.com/p/380247607" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/380247607</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐排序机制在品类新客优化上的探索与实践</title>
      <link href="/2022/11/29/ji-qi-xue-xi/sou-guang-tui/tui-jian-pai-xu-ji-zhi-zai-pin-lei-xin-ke-you-hua-shang-de-tan-suo/"/>
      <url>/2022/11/29/ji-qi-xue-xi/sou-guang-tui/tui-jian-pai-xu-ji-zhi-zai-pin-lei-xin-ke-you-hua-shang-de-tan-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>&emsp;基于算法的推荐系统存在一个被广为诟病的特性就是“信息茧房”效应：算法通常根据用户在平台的历史行为建模用户兴趣，并在此基础上给用户推荐新的内容，而新推荐的内容又影响到用户接下来的行为。在这种机制上，推荐系统不断强化之前观察到的用户兴趣，让推荐的内容陷入相似信息的“回音室”，导致用户看到的信息陷入一个狭小的范围，限制用户对于信息的感知。</p><p>&emsp;在外卖推荐场景，“信息茧房”对于用户体验的负向影响非常明显，用户在外卖平台存在较强的复购规律，因此系统非常容易给用户推荐之前购买过的商家以及同类型的商家，导致内容同质化。长期来看，用户对于平台的认知更容易局限于某些固定类型的供给上，导致平台无法满足用户寻找不同类型的商家需求。</p><p>&emsp;为了解决这个问题，尝试通过算法的优化和流量的引导，促使用户成交其之前未购买过的商家类型。对于商家类型的刻画，使用外卖场景下现有的商家品类体系，例如火锅、奶茶等。在业务目标上，除了常规的转化效率目标之外，增加了品类新客订单量的目标。</p><p>&emsp;本文分享美团外卖推荐团队在首页feed上进行品类新客订单量优化方面的工作。目标是通过feed的策略优化，给“外卖全局”增加x%的品类新客订单量，同时对首页feed的短期转化效率有一些约束。与大部分推荐系统链路类似，首页feed主要模块包括召回、精排、机制策略等。在算法优化上，首选对召回的供给丰富度和精排模型对于新品类的预估能力进行分析，发现除了一些局部的问题需要优化之外，整体上空间较为有限。因此，重点放在机制策略上：</p><ul><li>增加在首页feed的新品类订单量：主要工作是结合最优化理论，设置排序逻辑，更好平衡多目标，包括品类新客订单量、首页feed转化效率等。</li><li>在前面的基础上，尝试通过调整首页feed的流量分发策略，促进用户在其他场景（搜索）成交新的品类</li><li>最后，对上述策略中的参数进行个性化，主要是使用强化学习，学习不同用户在不同时间、地点下的最优排序参数。</li></ul><h2 id="二、问题与挑战"><a href="#二、问题与挑战" class="headerlink" title="二、问题与挑战"></a>二、问题与挑战</h2><p>首页feed一直以来的优化方向都是短期用户体验和转化效率，例如用户的点击率、订单量、成交额等。对于品类新客的优化，和已有工作目标存在较大区别，其主要的挑战如下：</p><ul><li>新品类短期的转化率通常低于用户经常购买的品类，在带来品类新客订单的同时，需要兼顾短期的转化效率。</li><li>除了要优化首页feed本身的品类新客订单量之外，算法还要考虑如何通过首页feed策略影响用户在其他入口的成单，让全局收益最大化。</li><li>不同用户在不同时间、地点下，对于购买新品类的偏好不一样，因此针对新品类的策略都需要考虑用户本身的特点和用户所处的时空场景。</li></ul><h2 id="三、重点工作"><a href="#三、重点工作" class="headerlink" title="三、重点工作"></a>三、重点工作</h2><h3 id="3-1-推荐技术框架"><a href="#3-1-推荐技术框架" class="headerlink" title="3.1 推荐技术框架"></a>3.1 推荐技术框架</h3><p>&emsp;美团外卖的推荐流量主要集中在首页feed、频道页等，其中以首页feed的流量最大，承载力商家、商品、主题卡片、内容卡片、广告等多种形式的异构内容的流量分发。从技术框架上，最上游的混排模块从商家、商品、广告、主题等服务获取异构资源候选，并融合成最终的排序列表。列表中流量占比最大的是商家卡片。对于品类新客方面的工作，主要放在混排的排序机制方面，此外也花了一小部分精力优化商家排序链路，包括召回、精排、排序策略等模块。</p><div align="center"><img src="/images/首页feed推荐架构.png" width="800"></div><center>图1：首页feed推荐架构</center><h3 id="3-2-流量分发策略"><a href="#3-2-流量分发策略" class="headerlink" title="3.2 流量分发策略"></a>3.2 流量分发策略</h3><p>&emsp;业务逻辑上我们认为一次品类新客成单的价值大于一次复购成单，在此逻辑上流量分发的策略需要往新品类倾斜。通常的流量倾斜有两种方式，一是给额外的固定曝光位置，二是在排序过程中增加权重。在这里我们选择第二种方式，主要考虑点是：1.新品类商家卡片形态与正常商家没有区别，也不属于冷启动商家，因此不需要单独的链路；2.需要将新品类的流量导流到喜欢尝新的用户上去，并且与其他商家做价值的比较和权衡。</p><p>&emsp; 因此，我们选择在排序目标里面加上新品类的额外价值实现流量倾斜。初期，我们通过增加额外的品类新客商家卡片的曝光价值，即将线上的原排序公式设置为：$f = u + \alpha * isNewCategory$（公式一），其中u为原始排序公式，包括点击率、转化率、单价、一些生态项等，但是很快发现新品类的首页feed转化率非常低，导致增加的曝光量不能有效转化为业务需要的订单。因此，我们迭代了一些策略提升新品类的首页feed转化率，主要手段在公式一增加一些特征，例如用户近期对于目标品类的统计行为，即$f = u + \alpha * g(x) * isNewCategory$（公式二），其中g(x)是用户历史统计行为特征的函数，使用了在外卖APP内对目标商家近期点击数量，对目标品类的搜索量等多个特征，而其参数通过人工基于线上实验效果调整确定。这项目工作取得了明显收益，但很快发现线上的排序公式变得过于臃肿，难以持续迭代。参考Linkedin针对广告曝光策略的工作，我们定义了最优化问题如下，这里假设推荐任务是从N个候选商家里面选择1个商家进行曝光。其中效率约束包括整体的点击率、交易额，需要最大化的最新品类的额外价值，而这些价值通常由模型预估得到。<br>$$\underset{x_{ij}}{max}\sum_{i \in I}\sum_{j \in J(i)} x^{n}<em>{ij}v^{n}{ij}$$<br>$$s.t.$$<br>$$sum</em>{i \in I}\sum_{j \in J(i)} (x^{T}<em>{ij}u^{T}</em>{ij} + x^{n}<em>{ij}u^{n}</em>{ij}) \ge C$$<br>$$x^{T}<em>{ij} + x^{n}</em>{ij} = 1$$<br>$$x^{T}<em>{ij},x^{n}</em>{ij} \in {1,0}, \forall j \in J(i), \forall i \in I$$</p><p>其中i表示第i条请求，I：全部请求集合；j为第j个曝光位，J(i)：第i条请求下全部曝光位集合；$x^{T}<em>{ij},x^{n}</em>{ij}$：曝光位0-1变量，如第i条请求下第j个曝光位，选择曝光新品类，则$X^{T}<em>{ij} = 0, X^{n}</em>{ij}=1$，否则$X^{T}<em>{ij} = 1, X^{n}</em>{ij}=0$；$u^{r}<em>{ij}, u^{n}</em>{ij}$：第i条请求下第j个曝光位选择正常商家、新品类商家分别的效率价值；$v^{n}_{ij}$：新品类商家的额外价值；c：整体效率约束。</p><p>&emsp;基于上述优化问题，最终的排序公式为$f = u + \alpha * v_{ij} * isNewCategory$（公式三）。对于新品类而言，额外的价值被定义为新品类的首页feed转化效率。因此，这里的$v_{ij}$是模型预估的曝光到订单的转化率。在此基础上，将公式二里的特征融入到精排模型，再应用公式三，得到等同的效果，但在排序公式里去掉了g(x)里面的特征和需要人工调整的参数，使得复杂度大大降低。</p><p>&emsp;我们进一步对不同形式的排序公式进行了分析和验证，对一次请求而言，公式三和公式一，都是提升新品类商家在排序中的位置，为什么效果差异非常大？而分析上文中的优化问题发现，高效流量倾斜的关机在于将新品类的业务目标分解到哪些用户上，从这个角度考虑，公式三相比于公式一，更容易将流量导往偏好新品类的用户。事实上，不仅限于品类新客这个任务，以上基于最优化的分析可以推广到任一需要平衡多目标的场景。在某个场景下，当我们有a、b、c等N个目标的时候，加入$v_{a} v_{b} … v_{N}$是模型对于这N个目标的价值预估，那么帕累托最优的排序公式是：$f = \alpha_{a} * v_{a} + \alpha_{b} * v_{b} + … + \alpha_{N} * v_{N}$（公式四），而非其他的形式。为了得出这个结论，除了上述理论分析之外，我们还做了一些模拟实验，研究不同排序设定下权衡多目标的Efficient Frontier。在模拟场景下，我们假设每次推荐的请求是从两个候选商家中选择一个，并且关注两个指标metric A 和 metric B，其对应的预估率为$p_{A}$和$p_{B}$。模拟实验得到结论：图中两种不同的公式形式，在效果上存在显著差别，公式四是更优的形式。</p><p>&emsp;采用类似的分析方法，研究了训练模型的过程中进行样本采样产生的预估率和真实目标期望的偏差，对于多目标权衡的影响。比较了使用公式四基于未经校正和经过校准的预估率两种设定进行排序的效果，其中模拟实验下的校准方式参考Facebook的工作。模拟实验结果表明，未经校准的预估率会对多目标的权衡产生影响。基于上述结论，针对商家对于曝光到点击、曝光到转化等预估率分别进行校准。</p><h3 id="3-3-跨入口同品类激发策略"><a href="#3-3-跨入口同品类激发策略" class="headerlink" title="3.3 跨入口同品类激发策略"></a>3.3 跨入口同品类激发策略</h3><p>&emsp;我们的业务目标是外卖全局的新品类订单量，前期我们主要通过增加首页feed新品类订单量的方式，促进全局订单量的提升。实验中发现，首页feed产生的品类新客订单量收益，对其他入口有明显的抢占效应，导致全局的增量相比首页feed入口产生的增量有明显衰减。因此，仅仅通过促使用户在首页feed成单新品类可能是一个次优的方向。从全局收益出发，是否能使用首页feed促进用户在其他入口成交呢？我们给出了进一步的探索。</p><p>&emsp;我们猜想很多用户会因为在推荐列表看到某个品类的商家之后，去其他入口（例如搜索）找到更合适的同品类商家进行成交。例如，用户在首页feed看到一家烤鱼店，但是因为某些因素不合适，于是跳转到搜索入口去搜索同品类商家。类似的规律生活中很常见，不少人在小红书、抖音上看到一些不错的商品后，会打开京东、淘宝等电商平台购买。我们尝试在外卖业务上采用类似的激发策略，让用户在首页feed上对某个新品类产生感知，用户对于品类的感知，我们在首页feed上对该品类的商家发生点击来衡量。因此，从实现手段上，我们通过提升用户对新品类商家的点击量来达到激发的目的。基于前面的增加新品类成交价值的公式三，我们进一步增加了新品类的点击价值。公式三种新品类价值$v_{ij}$，除了考虑新品类的曝光到成单的转化率之外，还考虑新品类的点击率，即：$v_{ij} = \beta * ctr * cvr + \gamma * ctr$，最后实验取得明显效果，在首页feed转化效率持平的情况下提升了0.9%的全局品类新客订单量。进一步剖析策略的微观数据，实验数据显示相比于基线策略，实验策略下“首页feed点击未成单，转而到其他入口成交同品类”的用户占比提升3.6%；同时实验策略下，全局品类新客订单增量相对于首页feed品类新客增量的比率也得到明显提升。</p><h3 id="3-4-个性化排序参数"><a href="#3-4-个性化排序参数" class="headerlink" title="3.4 个性化排序参数"></a>3.4 个性化排序参数</h3><p>&emsp;品类新客项目的中早期进行了很多轮策略迭代，而线上排序公式的系数仍然是人工调节的固定系数。排序公式的输入主要是模型的预估率，预估率是针对单商家卡片的，而我们的业务目标，除了卡片粒度的指标（例如点击率）之外，还包括推荐列表整体和外卖全局整体的收益（例如列表的交易额、全局的品类新客订单量等）。从整体的转化效率来看，对于不同用户、场景而言，最优的排序系数可能是不一样的。例如，有些用户浏览的深度很深，即使单卡片的转化率不高，也会通过增加浏览深度的方式最终在首页feed下单，对于此类用户而言，排序公式中的转化率的权重可以相对低一些，以照顾其他目标。</p><p>&emsp;为了证明个性化排序参数的必要性，我们做了一个验证实验：对于公式三，基于线上生产环境的参数（基准策略），上线了一个小流量实验对于参数$\alpha$进行微调，随后根据业务经验找到一些重要的特征拆分用户群，并分别在不同的用户群上对比实验策略和基线策略的效果。实验数据表明，实验策略相比于基线策略，对于不同人群，在列表交易额、全局品类新客订单等指标上的提升或下降幅度存在明显差异。证明对于不同用户，设置不同的排序系数是必要的。在具体的执行路径上，我们先通过成本比较低的基于规则的方法进行尝试，同时加深对该问题的理解，此后将策略进行模型化。</p><h4 id="3-4-1-基于规则的个性化排序系数"><a href="#3-4-1-基于规则的个性化排序系数" class="headerlink" title="3.4.1 基于规则的个性化排序系数"></a>3.4.1 基于规则的个性化排序系数</h4><p>&emsp;前期通过规则的方式对个性化排序系数进行尝试，其主要难点在于如何高效地针对不同人群和场景确定系数，这里主要借鉴了上文中的分析思路。具体实现方案是：通过上文的实验，我们基于人群和场景特征拆分流量进行业务指标分析，找到实验组相比于对照组各项指标整体上有提升（至少部分指标正向，且其他指标没有明显负向）的人群或场景，此后将这部分人群和场景的排序权重进行相应调整。该方案在转化率不降的情况下，取得了0.5%左右的品类新客订单收益；但也存在一定局限，主要包括两点：1）随着特征组合数量的增加，排序公式的复杂度呈现指数级上升，导致难以进行后续迭代；2）随着线上模型和策略的迭代，上面的方案需要被不断地重复进行执行，以适应新的策略环境；3）无法引入实时的上下文特征，例如当前请求下排序候选集的信息等。</p><h4 id="3-4-2-基于强化学习的个性化排序系数"><a href="#3-4-2-基于强化学习的个性化排序系数" class="headerlink" title="3.4.2 基于强化学习的个性化排序系数"></a>3.4.2 基于强化学习的个性化排序系数</h4><p>&emsp;为了解决个性化系数存在的问题，我们使用模型来进行个性化排序参数的建模。由于排序公式中的参数设定一个policy，最优参数无法观测，难以使用监督学习的方式建模，因此我们尝试通过强化学习方法进行求解。模型通过探索式学习的方式，以用户属性、历史行为、消费场景、实时的候选信息等特征作为输入，输出排序参数，以最大化当前请求内全局品类新客订单量和首页feed的转化率。常用的实现方案包括进化策略ES（Evolution Strategy）、DDPG（Deep Deterministic Policy Gradient）等。其中ES算法是进化算法的一种，其通过扰动神经网络参数，输出排序参数应用于对应的请求上，搜集用户的反馈计算reward并确定模型参数更新的方向和比例。ES算法属于on-policy算法，需要一整套实时训练的流程。DDPG是连续动作off-policy的强化学习模型，理论基础较完备，可以基于离线的探索数据进行学习。</p><p>&emsp;综合考虑线上的调参风险，当前实时训练技术栈完备性等因素，选择基于DDPG算法进行建模。首先选取一个实验桶进行参数随机探索，并搜索离线的训练样本，此后模型在离线样本上进行学习。我们使用标准的DDPG方案进行建模，模型结构包括critic模型和actor模型，critic模型相当于一个评判器，学习不同用户和场景下应用不同的排序参数能获取到的预期reward，reward定义为各项业务目标的加权组合。actor模型决策当前用户和场景下应该给怎样的排序公式参数，才能在critic上获取最大reward，网络结构如下图所示。值得注意的是，大多数强化学习算法试图去优化多步决策的长期累积的收益，而在首页feed场景下，尚且没有数据论证优化长期收益相对于优化短期收益的优势，因此我们目前更多地是利用DDPG的探索式学习特性，学习当次请求下综合多项业务目标最优的排序系数。该策略带来的好处是，将critic的学习简化成纯粹的分类和回归任务，避免使用n-step bootstrap的方式去拟合长期收益，大大降低了critic学习的难度。通过一定方式验证了模型的有效性，主要策略包括：1）使用回归“当次收益”的方式训练模型，在R方、点击转化AUC等评估指标上，判断critic模型的学习效果；2）采用一些简单的学习目标，例如单点击、单订单、单新品类订单等目标，验证模型学到的权重是否合理；3）在多目标设定下，分析模型学习到的权重是否合理；4）根据业务经验，根据不同的特征维度，分析模型的输出权重。此外，由于强化学习缺少比较完备的离线评估体系，因此线下线上的特征一致性非常重要。除了实现上尽量线下线上复用同样的流程之外，我们也校验了线上实际生效的权重和通过离线模型产生的权重的差别，实际生产环境中相对差异在1%之内，主要差异来自于特征同步的延迟。</p><p>&emsp;该方案上线后，在转化率上有轻微下降，在全局品类新客订单上有1.9%的收益。相比之下，通过改变线上的排序系数，在同样转化率降幅下，在全局品类新客订单量只能获得0.7%的收益。后续完善特征、样本方案</p><div align="center"><img src="/images/DDPG模型结构.png" width="800"></div><center>图2：DDPG模型架构</center><h3 id="3-5-其他优化策略"><a href="#3-5-其他优化策略" class="headerlink" title="3.5 其他优化策略"></a>3.5 其他优化策略</h3><p>&emsp;推荐的完整链路由召回、精排、机制、渲染等模块组成，如前所述，我们重点优化了排序机制，但在此过程中，也对其他的模块进行必要的优化。</p><ul><li>召回方面，主要工作包括：a）修改召回的目标，对齐排序机制的多目标设定；b）基于用户的行为扩充新品类商家集合。</li><li>精排方面，主要工作包括：a）基于分维度的点击、转化率分析，针对性补齐一些缺失的特征，提升预测能力；b）对于新品类样本的优化。</li><li>多样性方面，配合机制层的策略，基于规则对新品类商家进行品类的多样性优化。</li><li>链路方面：将首页feed的策略推广到流量占比比较大的推荐频道，例如美团金刚等。</li><li>展示方面：通过下挂菜等方式，通过店内的主营菜品的信息，补充对于商家的描述。</li></ul><h2 id="四、总结与展望"><a href="#四、总结与展望" class="headerlink" title="四、总结与展望"></a>四、总结与展望</h2><p>通过最优化理论推导了最优的流量分发公式，基于业务理解通过优化列表的点击带动了全局的新品类成交，基于强化学习进行自动导参，以及在召回、精排模块、多样性等针对性优化。迭代方向</p><ul><li>更好地品类划分方式：当前品类划分主要基于业务定义的类目树和人工聚类，有较大优化空间。</li><li>基于因果推断等手段建模长期价值：找出对特定用户而言，长期价值更大的商家、品类、优化针对用户的长期收益。</li><li>跨场景策略建模：基于强化学习等手段，找到更加精细的建模手段，联合建模首页、频道页等入口的流量分发策略。</li><li>多样性优化：通过更加精细化的技术手段，例如DPP（Determinantal Point Process）等方式优化列表多样性，并考虑对多样性的个性化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用户行为序列在搜索广告CTR预估场景的探索与实践</title>
      <link href="/2022/11/29/ji-qi-xue-xi/sou-guang-tui/yong-hu-xing-wei-xu-lie-zai-sou-suo-guang-gao-ctr-yu-gu-chang-jing-zhong-de-tan-suo-yu-shi-jian/"/>
      <url>/2022/11/29/ji-qi-xue-xi/sou-guang-tui/yong-hu-xing-wei-xu-lie-zai-sou-suo-guang-gao-ctr-yu-gu-chang-jing-zhong-de-tan-suo-yu-shi-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="用户行为序列在搜索广告CTR预估场景的探索与实践"><a href="#用户行为序列在搜索广告CTR预估场景的探索与实践" class="headerlink" title="用户行为序列在搜索广告CTR预估场景的探索与实践"></a>用户行为序列在搜索广告CTR预估场景的探索与实践</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>&emsp;用户点击率预估在在线广告系统中一直担任着非常重要的角色，其主要用于刻画用户意图在当前上下文场景中和候选广告的相关性，并以此作为广告排序的参考依据。在美团搜索广告系统的场景中，每当用户意图触发了一次搜索请求，其产生的搜索关键词首先会经过召回模块得到粗选的候选广告集合。随后下游的预估模块和机制模块会对该候选广告集合进行最终排序。</p><p>&emsp;CTR预估任务在预估模型中执行，其本质上是二分类问题，可以使用机器学习来解决。典型的学习方法包括逻辑回归、贝叶斯probit回归、GBDT、FM等。随着深度学习技术在近几年不断发展和普及。基于深度学习的CTR预估模型逐渐顺势在各大广告系统中取代传统机器学习模型，且得到广泛应用。在初期，Google提出wide&amp;deep模型及其基于embedding&amp;MLP的学习方式深受喜爱，之后业内大部分创新迭代工作也都是从Embedding&amp;MLP方法延伸而来。核心思想是将原来one-hot/multi-hot表示的高维稀疏特征映射成一个固定长度的低维稠密向量，然后再把所有特征向量拼接起来作为MLP网络的输入来学习高阶的非线性关系。然而，对于某些特殊的特征，例如我们使用用户历史点击/下单的POI序列来刻画用户偏好，最基本做法是将行为序列中每个POI的相关属性通过Embedding的方法进行映射并通过pooling方式聚合。然而这么做存在一些不足，一方面没有利用到这个特征的时序信息；另一方面，包括噪声行为在外，模型无法区分序列中不同行为的权重。受用户行为特征的重要作用所驱动，近两年行业内不断涌现出基于用户行为序列建模的方法来改进上述问题，主要包含对以下两个方面信息的刻画：</p><ul><li>时序信息：当序列信息较为丰富时，常见做法是使用基于RNN的网络结构对行为序列建模；或者在每个序列单元中加入时序相关的偏差（Positional Encoding）；也可以对序列进行Session结构化，然后在使用前面的方式建模。</li><li>相关性权重：在不同建模阶段引入注意力机制（Attention）来学习序列行为的表达权重。例如，在用户序列中加入了与候选广告的attention权重来自适应地学习用户兴趣在不同场景的表达；与借鉴于NLP场景中的self-attention思想来区分不同行为的权重；结合了RNN以及attention机制在自身业务场景上进行了不同形式的创新。主要包括模型建模、实验评估以及性能优化等部分。</li></ul><h2 id="二、模型建模"><a href="#二、模型建模" class="headerlink" title="二、模型建模"></a>二、模型建模</h2><p>&emsp;在进行行为序列模型迭代之前，美团搜索广告场景的预估模型主要基于WDL结构，part_1主要对离散型特征及部分离散化后的连续型特征进行低维稠密的向量化映射，并在之后使用适当的pooling方式进行聚合；part_2主要针对连续型特征，直接与part_1的最后一层拼接在一起做信息融合，随后输入到part_3（MLP）；part_4是模型的“Wide”部分，主要包括曝光位置等记忆性较强的特征。</p><div align="center"><img src="/images/WDL网络结构图.png" width="800"></div><center>搜索广告CTR预估模型WDL网络结构图</center><p>&emsp;针对用户行为序列特征建模的迭代，美团搜索广告场景的探索迭代路线为：Pre-trained Cont.Feature -&gt; E2E + Avg Pooling DIN -&gt; Transformer-based WDL DIEN  -&gt; Session-based WDL。最初采用预训练的方式，选取Word2Vec模型单独对用户行为序列进行建模，生成行为的embedding表示，并将其加入到模型part_2部分，这次迭代带来了超过基线1.4%的离线AUC和线上CTR的提升。然而，采用预训练的方式虽然能够将复杂的序列建模从CTR预估模型里抽离出来进而提高线上预估效率，但后续在序列模型的迭代和更新方面引入一系列难题。于是我们将迭代重心转为端到端的训练方式，在美团点评双侧先后探索DIN、DIEN以及基于Transformer等模型的预估效果。这三个模型的比较总结如下：</p><table>    <tr>        <td>模型</td>        <td>序列建模增加的参数量</td>        <td>各自特点</td>        <td>相似之处</td>    </tr>    <tr>        <td>DIN</td>        <td>$O(Q * k * ff_{DIN})$ Q为一个行为结构体中的属性实体个数；k为一个属性实体映射到embedding的维度；ff_DIN为attention全连接网络第一层单元数</td>        <td>(1) 模型结构相较起来最为简单。(2) Attention的权重基于与候选广告embedding先进行简单拼接和运算后接入一个前向网络得到，并以此对行为序列进行加权求和</td>        <td rowspan="3">使用用户历史点击过的POI作为一个行为结构体，包含该POI的属性实体（如类目、地理位置等）以及行为本身的属性（如时间）；都应用了注意力机制，使用候选广告反向激活序列行为；MLP层的激活函数都没有使用常用Relu，分别采用改进后的激活函数</td>    </tr>    <tr>        <td>DIEN</td>        <td>$O(M^{2} + M *(ff_{auxiliary} + ff_{attention})), M=Q*K$ $ff_{auxiliary}$为auxiliary全连接网络第一层单元数；$ff_{attention}$为attention全连接网络第一层单元数</td>        <td>使用GRU单元来对点击序列进行建模，以此刻画时序信息；引入附加损失，使用第一层GRU输出的状态来预估预估行为，并计算附加损失的梯度来对属性实体embedding参数进行更新</td>    </tr>    <tr>        <td>BST</td>        <td>$O(M^{2} + M * ff_{transformer}), M=Q*k$，其中为a$ff_{transformer}$为Encode中FFN第一层单元数</td>        <td>在行为结构体重加入positional encoding，以此来表达序列时序信息；采用transformer中Encoder模块，将候选广告POI实体与所有行为序列POI实体拼接起来输出到Encoder；序列之间以及序列与候选广告之间都会进行注意力机制的加权</td>    </tr></table><h3 id="Session-based-WDL"><a href="#Session-based-WDL" class="headerlink" title="Session-based WDL"></a>Session-based WDL</h3><p>&emsp;我们在探索DIN和DIEN是，模型使用的序列长度上限为30，迭代过程中，虽然DIEN模型的效果在实验中表现十分出色，并且观察到随着序列长度上线的增加，模型离线AUC也会得到相应提升，但模型的性能开销会随之成倍增加（详见实验评估部分）。这个现象在阿里妈妈的定向广告场景同样存在。为了在序列建模过程中使用更丰富的序列信息，同时兼顾线上线下性能开销，我们对原有的WDL网络结构进行Session序列建模模块的扩展。对此，我们将用户相邻时间的原始行为序列进行了Session结构的拆分，拆分的步骤如下：</p><ul><li>在数据层面上，确保任意一个session内用户相邻行为之间不超过30分钟。</li><li>在通过时间划分好的Session序列上设置窗口大小[L, P]，对训练样本的session个数以及每个session内的原始序列长度分别做最大限制为L和P的截断，不足的部分会做padding；截断原则是优先选择最接近曝光时间的部分。窗口大小[L, P]为模型在对不同业务流量建模是需要适配该业务数据分布的超参数，尽可能提高窗口内原始行为序列的填充率，即减少padding的个数。</li></ul><p>&emsp;通过合理的窗口大小限制，session结构化后的序列长度会远小于原始的序列长度，从而大大减小了后续使用序列进行建模的复杂度。除此之外，采用session结构化建模的另一个重要原因是，我们发现在业务场景中，大部分用户的点击行为在同一个session内部具有较强同质性，并在不同session内具有较强同质性。以点评侧训练样本的用户行为数据为例，选取内部序列长度大于1的session进行统计，session之间的一/二级品类的个数明显大于session内部的个数</p><table>    <tr>        <td>Session内部行为个数</td>        <td>Session内部行为一级品类个数</td>        <td>Session内部行为二级品类个数</td>        <td>不同Session行为一级品类个数</td>        <td>不同Session行为二级品类个数</td>    </tr>    <tr>        <td>均值</td>        <td>6.1</td>        <td>1.41</td>        <td>2.52</td>        <td>4.84</td>        <td>12.25</td>    </tr>    <tr>        <td>中位数</td>        <td>4</td>        <td>1</td>        <td>2</td>        <td>5</td>        <td>12</td>    </tr></table><p>&emsp;建模时，我们将用户的原始行为序列表示为$B = [b_{1};b_{2};…,b_{i},…,b_{T}]$，序列中每个节点$b_{i}$为一个行为结构体。在选取行为结构体中的实体属性时，尽可能在各方面来表达一个用户的点击行为（图3，灰色部分），除了场景POI品类和地理位置等属性外，受BST模型启发，我们把当前请求和历史行为发生的时间差作为一个行为的属性实体来表达时序信息（Positional Encoding），获得显著成效。目前来看，对行为结构体属性的刻画仍是一个可以继续深耕的方向。整个原始行为序列B首先经过Embedding Layer映射为$E_{B} = [b_{e_{1}};b_{e_{2}};…,b_{e_{i}};…,b_{e_{T}}] \in R^{Q*k}$，如图2，随后输入到Session Pooling Layer，基于事先划分好的session结构进行原始行为表征聚合。聚合的方式比较灵活，考虑到session内部数据同质性强的特点，采用average pooling方式不会造成过多信息丢失，同时能降低计算复杂度。</p><p>&emsp;Pooling聚合后的行为序列与Session Bias Encoding进行拼接得到完整的Session序列特征。Session Bias包含session在序列中的相对位置、session所处的时间段/日期、原始行为个数、原始行为是否包含候选广告的地理位置、原始行为是否包含候选广告类目、原始行为是否包含候选广告ID本身等，这些属性是在session粒度上独有的表征，一方面加强了每个session行为的表达能力；从另一方面思考，额外增加的session粒度的信息还能够填补pooling时信息损耗。最终得到session序列表达形式为：<br>$$E_{s} = Concat(E_{p},E_{c}),$$<br>$$E_{p} = [s_{e_{1}};s_{e_{2}};…,s_{e_{i}};…,s_{e_{T^{‘}}}] \in R^{Q<em>K}$$<br>$$E_{c} = [c_{e_{1}};c_{e_{2}};…,c_{e_{i}};…,c_{e_{T^{‘}}}] \in R^{Q</em>K}$$<br>$$s_{e_{1}} = Pooling([b_{e_{1}};…;b_{e_{N_{s1}}})$$<br>$$s.t. N_{s_{1}} \leq L, T \leq P, T \leq T$$</p><p>其中Q为原始序列行为结构体的属性实体个数，Q为bias个数，k为embedding大小，$N_{s_{1}}$为第一个session内部的原始行为序列个数，T为原始行为序列长度，T为session序列长度。</p><p>&emsp;拼接好的session序列$E_{S}$接下来会进行多级attention激活，同时输入到三个不同注意力单元（Attention Unit1 &amp; 2 &amp; 3）进行加权，其结构图如下：</p><ul><li>Attention Unit1：使用候选广告对用户历史行为进行反向激活，表达用户兴趣的多样性。</li><li>Attention Unit2：与搜索关键词相关信息激活得到注意力权重，使得不同的session行为对于不同的用户意图能够自适应地表达。</li><li><ul><li>Attention Unit3：与上下文场景激活得到注意力权重，使得不同的session行为对于不同的上下文环境能够自适应地表达。</li></ul></li></ul><p>&emsp;基于三个注意力单元，Session-based WDL模型在序列建模方面增加的参数量远远低于DIEN和BST，为：$O(Q * K * (ff_{attention1} + ff_{attention2} + ff_{attention3}))$，总的来说，Session-based WDL模型在序列建模的优势在于更高效地应用长序列行为特征进行建模，并且根据业务场景提炼出session结构化后独有的特征来进一步提高模型预估效果。目前，美团点评双侧的主要业务流量都已陆续将此模型全量。</p><h2 id="三、实验与评估"><a href="#三、实验与评估" class="headerlink" title="三、实验与评估"></a>三、实验与评估</h2><p>&emsp;由于不同的序列模型在各个业务线上的效果有所差异，本章节的对比实验室以点评APP到餐和到综的筛选列表页为例进行分析</p><h3 id="1-实验设置"><a href="#1-实验设置" class="headerlink" title="1. 实验设置"></a>1. 实验设置</h3><h4 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h4><p>美团点评双侧都采用全APP的实时数据流，从中获取用户从请求当前截止到最近90天的原始点击行为序列，随后按照上述规则进行切分后得到session结构化序列。</p><h4 id="实验超参"><a href="#实验超参" class="headerlink" title="实验超参"></a>实验超参</h4><table>    <tr>        <td>ps</td>        <td>worker</td>        <td>训练天数</td>        <td>Epoch</td>        <td>学习率</td>        <td>负采样比例</td>        <td>Batch Size</td>        <td>MLP结构</td>        <td>embedding大小（k）</td>    </tr>    <tr>        <td>2</td>        <td>16</td>        <td>90</td>        <td>2</td>        <td>0.0005</td>        <td>0.2</td>        <td>5000</td>        <td>1024512256</td>        <td>8</td>    </tr>    </table><p>对照组</p><ul><li>WDL：图一结构</li><li>E2E：在WDL结构基础上，将序列行为的各个属性实体分别用作不同的sparse特征，多个行为得到的embedding使用average pooling聚合后直接作为part_3(MLP)的输入</li><li>DIN：ff_DIN=16</li><li>BST：额外增加时间差属性实体作为positional encoding，head=1（为2时效果与1相近，但耗时增加明显）；ff_transformer=128</li><li>DIEN：简化原文网络结构，去掉附加损失部分，仅使用单层GRU单元，并使用与候选广告的注意力权重来控制GRU输出。</li></ul><h3 id="2-效果指标"><a href="#2-效果指标" class="headerlink" title="2. 效果指标"></a>2. 效果指标</h3><h4 id="离线评估"><a href="#离线评估" class="headerlink" title="离线评估"></a>离线评估</h4><p>离线以AUC和训练时长为指标，分别在不同的序列长度/session窗口大小的设置下进行对比，结果如下表，发现：</p><ul><li>全APP实时流中的用户行为特征作用明显，仅embedding+average pooling的使用方式就能显著提高预估auc，在到餐和到综流量上分别提升0.81%和0.25%；</li><li>DIN的反向激活单元能够进一步提升模型效果，但与E2E组一样，由于没有考虑时序信息，增加序列长度对模型效果提升不明显。</li><li>对于相同序列长度，DIEN和BST都打败DIN，且序列长度对模型效果提升明显，以DIEN为例，当使用序列长度由30增加到75时，预估auc有显著提升，但训练及预估耗时也成倍增加，由于考虑时序信息的方式不一样，序列长度不同时，两者的表现存在差异；</li><li>session-based WDL用了相比DIEN和BST更短的耗时，达到了更好地效果，且当采用的原始序列长度越长时，其耗时的优势就更明显。另外，session窗口的选取十分重要，同样是上限为75长度的窗口，25<em>3相比15</em>5用了较短的耗时获得了更高的AUC。</li></ul><table>    <tr>        <td>组</td>        <td>序列长度/session窗口</td>        <td>训练时长(mins)</td>        <td>预估时长(sec/batch)</td>        <td>到餐auc diff</td>        <td>到综auc diff</td>    </tr>    <tr>        <td>WDL</td>        <td>-</td>        <td>170</td>        <td>0.220</td>        <td>-</td>        <td>-</td>    </tr>      <tr>        <td rowspan="2">E2E</td>        <td>30</td>        <td>180</td>        <td>0.298</td>        <td>+0.81%</td>        <td>+0.28%</td>    </tr>      <tr>        <td>75</td>        <td>180</td>        <td>0.326</td>        <td>+0.86%</td>        <td>+0.32%</td>    </tr>         <tr>        <td rowspan="2">DIN</td>        <td>30</td>        <td>240</td>        <td>0.410</td>        <td>+1.02%</td>        <td>+0.48%</td>    </tr>      <tr>        <td>75</td>        <td>320</td>        <td>0.686</td>        <td>+1.08%</td>        <td>+0.54%</td>    </tr>     <tr>        <td rowspan="2">DIEN</td>        <td>30</td>        <td>380</td>        <td>0.810</td>        <td>+1.16%</td>        <td>+0.54%</td>    </tr>      <tr>        <td>75</td>        <td>630</td>        <td>1.043</td>        <td>+1.53%</td>        <td>+0.71%</td>    </tr>        <tr>        <td rowspan="2">BST</td>        <td>30</td>        <td>350</td>        <td>0.606</td>        <td>+1.25%</td>        <td>+0.58%</td>    </tr>      <tr>        <td>75</td>        <td>630</td>        <td>1.147</td>        <td>+1.40%</td>        <td>+0.64%</td>    </tr>        <tr>        <td rowspan="3">Session-based WDL</td>        <td>10.3</td>        <td>200</td>        <td>0.327</td>        <td>+1.32%</td>        <td>+0.68%</td>    </tr>      <tr>        <td>15*5</td>        <td>300</td>        <td>0.422</td>        <td>+1.50%</td>        <td>+0.79%</td>    </tr>     <tr>        <td>25*3</td>        <td>270</td>        <td>0.393</td>        <td>+1.61%</td>        <td>+0.86%</td>    </tr>        </table><h4 id="在线评估"><a href="#在线评估" class="headerlink" title="在线评估"></a>在线评估</h4><p>在线A/B实验的实验组和对照组分别为Session-based WDL与WDL模型，在为期一周小流量实验中，实验组模型的线上CTR与RPS（Revenue Per Search）相交对照组显著提升。</p><table>    <tr>        <td></td>        <td>CTR DIFF</td>        <td>RPS DIFF</td>     </tr>    <tr>        <td>到餐流量</td>        <td>+4.3%</td>        <td>+3.32%</td>     </tr>    <tr>        <td>到综流量</td>        <td>+1.58%</td>        <td>+1.62%</td>     </tr></table><h4 id="主要模块效果"><a href="#主要模块效果" class="headerlink" title="主要模块效果"></a>主要模块效果</h4><p>在点评筛选流量中，Session-based WDL模型的优化效果除了来自于行为序列特征本身，下面几个模块发挥了不同程度的作用，通过实验表明，positional encoding与session bias带来的作用最为突出；除此之外，各个attention单元也能对模型的预估效果带来明显提升。</p><table>    <tr>        <td>删减模块</td>        <td>到餐auc diff</td>        <td>到综auc diff</td>     </tr>    <tr>        <td>Attention Unit 1（With Context）</td>        <td>-0.1%</td>        <td>-0.04%</td>     </tr>    <tr>        <td>Attention Unit3（With Target Ads）</td>        <td>-0.08%</td>        <td>-0.11%</td>     </tr>    <tr>        <td>Attention Unit3（With Target Ads）</td>        <td>-0.08%</td>        <td>-0.11%</td>     </tr>    <tr>        <td>positional encoding</td>        <td>-0.43%</td>        <td>-0.25%</td>     </tr>    <tr>        <td>Session bias</td>        <td>-0.22%</td>        <td>-0.35%</td>     </tr></table><ul><li>参考链接：<ul><li><a href="https://zhuanlan.zhihu.com/p/78365283" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/78365283</a></li><li><a href="https://www.jianshu.com/p/de51ec770572" target="_blank" rel="noopener">https://www.jianshu.com/p/de51ec770572</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索广告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战</title>
      <link href="/2022/11/29/ji-qi-xue-xi/suan-fa-shi-jian/ji-qi-xue-xi-shi-zhan/"/>
      <url>/2022/11/29/ji-qi-xue-xi/suan-fa-shi-jian/ji-qi-xue-xi-shi-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习实战笔记"><a href="#机器学习实战笔记" class="headerlink" title="机器学习实战笔记"></a>机器学习实战笔记</h1><h2 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h2><ul><li>聚焦监督学习，以结构化数据的预测问题为主<ul><li>监督学习：y=f(x)，gbdt，nn都是不同类型的f，深度学习就是其中的一类f，y叫label，x叫特征</li><li>分类问题：y是离散的，回归问题：y是连续的</li><li>结构化数据：每个数都有具体的物理意义</li><li>非结构化数据：图像、语音、nlp</li></ul></li><li>强调共性问题，工作中需要注意的基本原则</li><li>Reference<ul><li>《Rules of Machine Learning》  – Google</li></ul></li></ul><p>（1.Rule与创造性之间的关系，rule更多的是原则 2.迁移学习）</p><h2 id="工业界的机器学习"><a href="#工业界的机器学习" class="headerlink" title="工业界的机器学习"></a>工业界的机器学习</h2><div align="center"><img src="/images/machine_learning_systems.png" width="800"></div><center>图1 机器学习</center><h2 id="将机器学习落地的两个步骤"><a href="#将机器学习落地的两个步骤" class="headerlink" title="将机器学习落地的两个步骤"></a>将机器学习落地的两个步骤</h2><p>业务问题转化为机器学习问题，然后不断优化机器学习模型 （机器学习+运筹优化）</p><h2 id="正确分析判断项目的价值"><a href="#正确分析判断项目的价值" class="headerlink" title="正确分析判断项目的价值"></a>正确分析判断项目的价值</h2><ul><li>价值五角星（彼此可能会有影响）<ul><li>开源（效果/用户体验）：业务指标</li><li>节流（成本）：存储、计算资源</li><li>效率：人效</li><li>安全：合规、隐私保护等</li><li>质量：可靠性、性能</li></ul></li><li>预估/判断价值</li></ul><p>(短信司机召回为例从效果上看，短信全发就是召回量的上限；支付方式默选，全部默选美团支付就是份额的上限；供需不平衡的计算资源优化)</p><h2 id="对于新业务问题的处理方法"><a href="#对于新业务问题的处理方法" class="headerlink" title="对于新业务问题的处理方法"></a>对于新业务问题的处理方法</h2><ul><li>模型未动，规则先行。一方面积累线上数据，用于未来的模型训练，同时，也可以观测规则的收益，以此辅助判断模型的收益。</li><li>如果有通用的模型，也可以先用通用模型上线实验。</li></ul><h2 id="对于一个新业务问题第一个定制模型开发前的注意事项"><a href="#对于一个新业务问题第一个定制模型开发前的注意事项" class="headerlink" title="对于一个新业务问题第一个定制模型开发前的注意事项"></a>对于一个新业务问题第一个定制模型开发前的注意事项</h2><ul><li>明确业务目标，包括优化目标以及约束指标。</li><li>明确模型的评价标准，满足什么条件可以扩量，可以全量上线。</li><li>明确模型上线后，是否有方便的数据报表可以观测，通常重要的业务问题需要专门的报表支持。</li><li>明确模型的使用方式，是离线还是在线，如果是在线对于性能要求如何，控制模型的复杂度；是否需要阈值辅助解决，如果需要的话，阈值如何确定。</li><li><font color="red"> 确保第一个模型要简单易用，目的是走通整个流程，一旦出现问题也方便debug。 </font></li><li>通常一个新场景中第一个模型的收益是最大的。</li><li>要对该场景的数据做一些基础的EDA，帮助后面更好的进行样本和label的选择</li><li>要明确模型是一个分类问题、回归问题还是排序问题，并确定相应的线下评估指标。<ul><li>分类：logloss，auc，fscore，gauc，KS</li><li>回归：mape，mae，rmse</li><li>排序：ndcg，map@k</li></ul></li></ul><h2 id="训练样本的选择"><a href="#训练样本的选择" class="headerlink" title="训练样本的选择"></a>训练样本的选择</h2><ul><li>所有的样本选择问题的核心就是线下训练用到的数据分布尽可能与线上场景保持一致</li><li>样本的bias问题<ul><li>绝大多数场景中，线上数据都是有偏的，最典型的例子，信用风险的预测问题。</li><li>无偏样本是稀缺的，不同场景的无偏样本的成本不同，根据实际情况酌情采用。</li><li>有偏样本需要考虑如何debias。广告的位置偏差问题是这类问题的代表。</li><li><font color="red"> 判断bias的严重性，越严重，无偏样本的收益越大。 </font></li></ul></li><li>样本的采样问题<ul><li>时间与样本量的平衡。</li><li>正负样本的平衡，有的时候负样本未必是负样本，比如信息流推荐问题；对于催收预测问题，如果催一次就还了，在日志中只有一条记录，且是正样本，如果总催不还，一个人就存在多条负样本。</li><li>需要探查样本量的增加与模型预测能力的关系曲线</li><li>样本量与特征的关系，如果引入大量的离散特征，需要记着样本量也要跟上。如果是LR+L1正则进行特征选择，100w样本最终大概可以保留1w特征。</li></ul></li><li>样本的清洗<ul><li>由于埋点等工程问题，导致原始log出现问题。比如推荐了A权益，log中记录的是B权益</li></ul></li></ul><h2 id="label的选择"><a href="#label的选择" class="headerlink" title="label的选择"></a>label的选择</h2><ul><li>label的选择要尽可能与业务目标一致，往往越一致效果会越好。在有些场景下，label的选择会比特征、模型的优化收益更大，如：收银台默选促活场景。</li><li>选择label的时候，尽量找简单的、直接的、能够快速反馈的、可归因的<ul><li>正例：点击、电话接通、使用没团支付完成订单</li><li>负例：用户满意度、30天激活率、90天逾期率。</li></ul></li><li>对于确实存在反馈周期慢的业务指标，可以考虑使用代理指标提高反馈的效率，前提是要保证该指标与业务指标正相关。</li><li>对于比较不太直接的业务指标，也需要用代理指标替换。如：用户满意度 -&gt; 点击率 or 在线时长。</li><li>Label也要注意做数据清洗，避免工程问题导致的数据错误。</li><li>对于有些问题label需要人工标注的，需要严格把关标注质量</li><li>对于多个业务目标的问题，可以考虑使用多任务学习。</li></ul><h2 id="示例：美团支付默认-样本和label的选择"><a href="#示例：美团支付默认-样本和label的选择" class="headerlink" title="示例：美团支付默认-样本和label的选择"></a>示例：美团支付默认-样本和label的选择</h2><ul><li>目标：订单转化率 &amp; 美团支付份额</li><li>支付流程：用户提单 -&gt; 选择支付方式 -&gt; 支付成功（支付失败可能会重试并切换支付方式） -&gt; 订单成功（订单流失）</li><li>方案演进：<ul><li>P(订单成功|默认美团支付)  -&gt;  美团份额提升不显著（订单成功不代表会用美团支付）</li><li>P(订单成功|默认美团支付&amp;最终使用美团支付) -&gt; 总订单转化率+2bp、美团支付订单转化率-108bp、美团支付份额+61bp （漏了“使用美团支付失败后切换支付方式”这部分样本）</li><li>P(最终使用美团支付&amp;订单成功 |默认美团支付) -&gt; 总订单转化率+10bp、美团支付订单转化率+341bp、美团支付份额+82bp</li></ul></li></ul><h2 id="验证集与测试集的划分"><a href="#验证集与测试集的划分" class="headerlink" title="验证集与测试集的划分"></a>验证集与测试集的划分</h2><ul><li>大部分结构化数据的场景下，我们都要使用时序划分的方法。即：训练集、验证集、测试集在时间上是先后顺序。</li><li>可以使用k-fold的场景，如：声纹识别、意图识别等非结构化数据的场景。</li><li>通常验证集和测试集一旦确定，就尽量不动，方便新模型与过去模型做对比。如果要调整，最好也把老模型重新跑一遍，重新对齐。</li></ul><h2 id="特征挖掘的思路"><a href="#特征挖掘的思路" class="headerlink" title="特征挖掘的思路"></a>特征挖掘的思路</h2><ul><li><p>数据本身限定了一个问题的天花板，模型和特征都是逼近天花板的方法</p></li><li><p>特征广义上分两个阶段：信息获取与信息提取，通常我们说的特征挖掘都是指的信息提取。</p></li><li><p>信息获取的思路</p><ul><li>从业务出发，思考该场景下影响用户做出某种决策（label）的因素，通常决策越重，信息缺失就越厉害，这个时候信息获取的收益更大。如：电商广告的点击就比转化更容易，转化中可能需要参考竞对价格信息；催收工作中需要了解这个人在其他地方贷款情况。</li><li>从bad case中发现新的机会</li></ul></li><li><p>信息提取的思路：通过数学的方法能够充分提取数据中蕴含的信息。</p><ul><li>实时化与特征组合是两个关键方向</li><li>行为序列特征挖掘需要跟进</li><li>对于神经网模型，不用特别深入优化特征离散化的工作，往往分位数就还不错。</li><li>特征开发的时候可以按照主题设计，方便猴戏复用。</li><li>关键一问：xx特征当前模型是否已经学到了。</li></ul></li></ul><h2 id="特征选择的方法"><a href="#特征选择的方法" class="headerlink" title="特征选择的方法"></a>特征选择的方法</h2><ul><li><p>模型无关的特征选择</p><ul><li>特征选择的方法如信息增益、缺失度、相关性等都是单特征的选择，只能用作参考</li><li>对某个特征进行随机扰动，观察模型预测能力下降的程度，以此作为模型权重的依据，这种方法会考虑到特征之间的相互作用相对更使用（确定模型特征权重的核心思想）</li></ul></li><li><p>模型相关的特征选择</p><ul><li>LR+L1</li><li>GBDT的特征权重，要看“gain”，而不是“split”</li><li>NN的特征权重：看原始特征embedding层的L2范数 or 逐一shuffle特征，看预测结果的下降程度。</li></ul></li><li><p>复杂模型的可解释性主要还是基于特征权重</p></li></ul><h2 id="避免建模过程中引入leak"><a href="#避免建模过程中引入leak" class="headerlink" title="避免建模过程中引入leak"></a>避免建模过程中引入leak</h2><ul><li>如何判断模型中引入了leak<ul><li>线下评估结果异常好</li></ul></li><li>特征维度<ul><li>特征生产过程中不要使用未来的数据，尤其是统计类特征</li><li>与label相关的统计特征尤其要小心，标准的target encoding是需要oof的。</li></ul></li><li>样本维度<ul><li>划分验证集合的时候没有按照时序划分，而是k-fold。</li></ul></li></ul><h2 id="模型优化的思路"><a href="#模型优化的思路" class="headerlink" title="模型优化的思路"></a>模型优化的思路</h2><ul><li>需要考虑模型更新的频率对于线上效果的影响</li><li>可以用树模型作为baseline，并通过树模型去判断特征的方向</li><li>gbdt和nn应该能够解决监督学习的绝大部分问题，对于两种模型都应该有经验参数，在此基础上调整</li><li>深度学习模型的优势<ul><li>在非结构化的问题泛化能力要明显好于结构化数据</li><li>类似非结构化的结构化数据：eta预估、交通流量预估、化学分子表达</li><li>大量id类特征，且更新频率：信息流、广告等</li><li>随着样本增多，模型的预测天花板更高。（待迭代认知）</li></ul></li><li>对于结构化数据的问题，nn也主要通过引入更多信息拿到大部分收益。</li><li>同样的信息对于不同模型的输入会有区别，gbdt更适合连续特征，离散度高的需要进行特征提取。通过大量实验体会模型能学到哪些信息，学不到哪些信息，什么样的模式适合学哪些信息</li></ul><h2 id="模型上线前的注意事项"><a href="#模型上线前的注意事项" class="headerlink" title="模型上线前的注意事项"></a>模型上线前的注意事项</h2><ul><li>线下评测要比之前的模型好</li><li>线下和线上代码尽量保持一致，包括：特征提取、预处理、线上预测。</li><li>线下与线上的特征顺序保持一致</li><li>线上特征最好能够写到日志中，便于后续查错，如果不能全量写入，也可以考虑采样。</li><li>每两次实验中的diff尽量小，方便有效归因，确定后续方向。</li><li>做AA分析，了解当前场景下流量大小与线上稳定性的关系。</li></ul><h2 id="模型上线中要注意的问题"><a href="#模型上线中要注意的问题" class="headerlink" title="模型上线中要注意的问题"></a>模型上线中要注意的问题</h2><ul><li>观察线上指标的抖动情况，确定模型的有效性</li><li>观察线上的变化是否符合预期</li><li>捕捉线上指标变化与线下指标的关系。如：线下提高多少，线上一定能有提升。</li><li>如果线上表现稳定，且与业务侧对齐后扩量继续观察。</li><li><font color="red"> 正确（无论成败）的实验都是有价值的，错误（无论成败）的实验都是负价值的。 </font></li></ul><h2 id="质量保障"><a href="#质量保障" class="headerlink" title="质量保障"></a>质量保障</h2><ul><li>模型管理SOP：待完善</li><li>事前<ul><li>上线前，需要周知所有相关业务方</li><li>静默期不上线（静默期时间：周一至周四11:00-14:00和17:00-20:30；周五、周六和周日全天）</li><li>模型分为立刻运行模型（如默选模型）和窗口期运行模型（如催收模型），立刻运行模型在上线后保证半小时观测，窗口期运行模型在上线后的下一个运行期，需保证进行半小时观察（如运行不超过半小时，则观察全运行周期）</li></ul></li><li>事中（算法工作尤其需要关注）<ul><li>监控指标（业务指标、模型指标、特征相关指标）的配置和报警阈值</li><li>特征生成表要与上游强依赖，特征不更新的损失要比更新错的损失小</li><li>降级方案的制定</li></ul></li><li>事后<ul><li>COE</li></ul></li></ul><h2 id="线上线下不一致可能的原因"><a href="#线上线下不一致可能的原因" class="headerlink" title="线上线下不一致可能的原因"></a>线上线下不一致可能的原因</h2><ul><li>特征分布问题<ul><li>可以用gbdt，用验证集和线上数据训练一个二分类模型，验证集样本为0，线上数据样本为1，根据二分类的准确度以及高权重的特征可以给出大致的分析结果</li><li>线下与线上特征提取的方法不一致</li></ul></li><li>样本问题<ul><li>忽略了样本偏置问题</li></ul></li><li>指标问题  <ul><li>线下评估指标设置不合理。</li></ul></li></ul><h2 id="反事实问题线下评估示例"><a href="#反事实问题线下评估示例" class="headerlink" title="反事实问题线下评估示例"></a>反事实问题线下评估示例</h2><ul><li>权益分配问题：有三种权益，如何分配可以在成本约束情况下，收益最大</li><li>构建线下评估样本：对于集合$\gamma$随机发放权益，作为评估样本</li><li>基于训练好的策略A对评估样本进行预测，其中有1/3的样本是“事实”样本，可以准确计算收益。</li></ul><div align="center"><img src="/images/machine_learning_线下评估示例.png" width="600"></div><center></center><h2 id="简单场景的优化思路"><a href="#简单场景的优化思路" class="headerlink" title="简单场景的优化思路"></a>简单场景的优化思路</h2><ul><li>思考当前引入的信息是否还有缺失</li><li>对于已经引入的信息，是否充分表达。如：行为序列特征。</li><li>模型调参：nn的调参方差会更大一些</li><li>模型融合：尽量用最简单的方法，如线性加权，或者特征融合。比赛用的套路比如stacking，性价比低，且debug困难，随着单模型优化空间变小，该方法也逐步在工业界落地。</li></ul><h2 id="复杂系统的优化思路"><a href="#复杂系统的优化思路" class="headerlink" title="复杂系统的优化思路"></a>复杂系统的优化思路</h2><ul><li>将复杂系统拆解为多个子系统</li><li>分析每个子系统对于最终指标的影响（case分析）</li><li>针对子系统的ROI进行排序（技术难度x收益）</li></ul><h2 id="要建立自己的算法pipline"><a href="#要建立自己的算法pipline" class="headerlink" title="要建立自己的算法pipline"></a>要建立自己的算法pipline</h2><ul><li>作为一门实践科学，高效实验是核心竞争力<ul><li>合理把控实验节奏：上线计划、样本采集计划</li></ul></li><li>机器不会休息<ul><li>调参、特征提取、线下训练</li></ul></li></ul><h2 id="如何入门"><a href="#如何入门" class="headerlink" title="如何入门"></a>如何入门</h2><ul><li>算法基本功<ul><li>编程、数学、数据洞察</li></ul></li><li>如果非要一个学习资料的话<ul><li>李宏毅的机器学习视频（B站）</li></ul></li><li>能动手尽量动作（All models are wrong but some are useful）</li></ul><h2 id="如何精进"><a href="#如何精进" class="headerlink" title="如何精进"></a>如何精进</h2><ul><li>能从纷繁复杂的各种资料中汲取知识是一门学问<ul><li>养成paper reading的习惯，跟进学术圈的前沿进展（google系的paper泛化性更好）</li><li>跟进比赛圈的一些相关问题solution（kaggle）</li><li>跟进工业圈的一些分享（批判地看）</li><li>社交能力（重要）</li></ul></li><li>批判的眼光看待各种问题，不要过拟合自己的经验，吃一堑长一智，其实是一种能力<div align="center"><img src="/images/如何精进.png" width="800"></div><center>流程图</center></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程实践 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解释器模式</title>
      <link href="/2020/05/14/she-ji-mo-shi/jie-shi-qi-mo-shi/"/>
      <url>/2020/05/14/she-ji-mo-shi/jie-shi-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。</p><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>解释器（Interpreter）模式的定义：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p><p>这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。解释器模式是一种类行为型模式，其主要优点如下。</p><ul><li>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</li></ul><p>解释器模式的主要缺点如下。</p><ul><li>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li><li>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li><li>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。<h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1>解释器模式常用于对简单语言的编译或分析实例中，为了掌握好它的结构与实现，必须先了解编译原理中的“文法、句子、语法树”等相关概念。主要角色如下：</li><li>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</li><li>终结符表达式（Terminal    Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</li><li>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</li><li>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</li><li>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</li></ul><p>解释器模式实现的关键是定义文法规则、设计终结符类与非终结符类、画出结构图，必要时构建语法树，其代码结构如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象表达式类</span><span class="token keyword">interface</span> <span class="token class-name">AbstractExpression</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Object <span class="token function">interpret</span><span class="token punctuation">(</span>String info<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//解释方法</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//终结符表达式类</span><span class="token keyword">class</span> <span class="token class-name">TerminalExpression</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractExpression</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Object <span class="token function">interpret</span><span class="token punctuation">(</span>String info<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//对终结符表达式的处理</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//非终结符表达式类</span><span class="token keyword">class</span> <span class="token class-name">NonterminalExpression</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractExpression</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> AbstractExpression exp1<span class="token punctuation">;</span>    <span class="token keyword">private</span> AbstractExpression exp2<span class="token punctuation">;</span>    <span class="token keyword">public</span> Object <span class="token function">interpret</span><span class="token punctuation">(</span>String info<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//非对终结符表达式的处理</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//环境类</span><span class="token keyword">class</span> <span class="token class-name">Context</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> AbstractExpression exp<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//数据初始化</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span>String info<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//调用相关表达式类的解释方法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>当语言的文法较为简单，且执行效率不是关键问题时。</li><li>当问题重复出现，且可以用一种简单的语言来进行表达时。</li><li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。</li></ul><p>注意：解释器模式在实际的软件开发中使用比较少，因为它会引起效率、性能以及维护等问题。如果碰到对表达式的解释，在Java中可以用Expression4J或Jep等来设计。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录模式</title>
      <link href="/2020/05/14/she-ji-mo-shi/bei-wang-lu-mo-shi/"/>
      <url>/2020/05/14/she-ji-mo-shi/bei-wang-lu-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>备忘录（Memento）模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。备忘录模式是一种对象行为型模式，其主要优点如下。</p><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li></ul><p>其主要缺点是：资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>备忘录模式的核心是设计备忘录类以及用于管理备忘录的管理者类，主要角色如下：</p><ul><li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li><li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li><li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>备忘录模式的代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> memento<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MementoPattern</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Originator or<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Originator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Caretaker cr<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Caretaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               or<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token string">"S0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始状态:"</span><span class="token operator">+</span>or<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   cr<span class="token punctuation">.</span><span class="token function">setMemento</span><span class="token punctuation">(</span>or<span class="token punctuation">.</span><span class="token function">createMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//保存状态      </span>        or<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token string">"S1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"新的状态:"</span><span class="token operator">+</span>or<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                or<span class="token punctuation">.</span><span class="token function">restoreMemento</span><span class="token punctuation">(</span>cr<span class="token punctuation">.</span><span class="token function">getMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//恢复状态</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"恢复状态:"</span><span class="token operator">+</span>or<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//备忘录</span><span class="token keyword">class</span> <span class="token class-name">Memento</span><span class="token punctuation">{</span>     <span class="token keyword">private</span> String state<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token function">Memento</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token operator">=</span>state<span class="token punctuation">;</span>     <span class="token punctuation">}</span>         <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token operator">=</span>state<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">return</span> state<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//发起人</span><span class="token keyword">class</span> <span class="token class-name">Originator</span><span class="token punctuation">{</span>     <span class="token keyword">private</span> String state<span class="token punctuation">;</span>         <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token operator">=</span>state<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">return</span> state<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> Memento <span class="token function">createMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Memento</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">restoreMemento</span><span class="token punctuation">(</span>Memento m<span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//管理者</span><span class="token keyword">class</span> <span class="token class-name">Caretaker</span><span class="token punctuation">{</span>     <span class="token keyword">private</span> Memento memento<span class="token punctuation">;</span>           <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMemento</span><span class="token punctuation">(</span>Memento m<span class="token punctuation">)</span>    <span class="token punctuation">{</span>         memento<span class="token operator">=</span>m<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> Memento <span class="token function">getMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">return</span> memento<span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**初始状态:S0新的状态:S1恢复状态:S0*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</li><li>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，Eclipse 等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问者模式</title>
      <link href="/2020/05/14/she-ji-mo-shi/fang-wen-zhe-mo-shi/"/>
      <url>/2020/05/14/she-ji-mo-shi/fang-wen-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。</p><ul><li>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</li><li>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。</li><li>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。</li><li>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</li></ul><p>访问者（Visitor）模式的主要缺点如下。</p><ul><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</li><li>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。</li><li>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>访问者（Visitor）模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类，包含以下角色：</p><ul><li>抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。</li><li>具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。</li><li>抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。</li><li>具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。</li><li>对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> visitor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VisitorPattern</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ObjectStructure os<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ObjectStructure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        os<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteElementA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        os<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteElementB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Visitor visitor<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteVisitorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        os<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        visitor<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteVisitorB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        os<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象访问者</span><span class="token keyword">interface</span> <span class="token class-name">Visitor</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>ConcreteElementA element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>ConcreteElementB element<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体访问者A类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteVisitorA</span> <span class="token keyword">implements</span> <span class="token class-name">Visitor</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>ConcreteElementA element<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体访问者A访问-->"</span><span class="token operator">+</span>element<span class="token punctuation">.</span><span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>ConcreteElementB element<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体访问者A访问-->"</span><span class="token operator">+</span>element<span class="token punctuation">.</span><span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体访问者B类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteVisitorB</span> <span class="token keyword">implements</span> <span class="token class-name">Visitor</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>ConcreteElementA element<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体访问者B访问-->"</span><span class="token operator">+</span>element<span class="token punctuation">.</span><span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>ConcreteElementB element<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体访问者B访问-->"</span><span class="token operator">+</span>element<span class="token punctuation">.</span><span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象元素类</span><span class="token keyword">interface</span> <span class="token class-name">Element</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体元素A类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteElementA</span> <span class="token keyword">implements</span> <span class="token class-name">Element</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"具体元素A的操作。"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体元素B类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteElementB</span> <span class="token keyword">implements</span> <span class="token class-name">Element</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"具体元素B的操作。"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//对象结构角色</span><span class="token keyword">class</span> <span class="token class-name">ObjectStructure</span><span class="token punctuation">{</span>       <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Element<span class="token operator">></span> list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Element<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Iterator<span class="token operator">&lt;</span>Element<span class="token operator">></span> i<span class="token operator">=</span>list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>Element<span class="token punctuation">)</span> i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Element element<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Element element<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**具体访问者A访问-->具体元素A的操作。具体访问者A访问-->具体元素B的操作。------------------------具体访问者B访问-->具体元素A的操作。具体访问者B访问-->具体元素B的操作。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式</title>
      <link href="/2020/05/14/she-ji-mo-shi/die-dai-qi-mo-shi/"/>
      <url>/2020/05/14/she-ji-mo-shi/die-dai-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>“迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。迭代器（Iterator）模式的定义：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式，其主要优点如下。</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了聚合类。</li><li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li></ul><p>其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>迭代器模式是通过将聚合对象的遍历行为分离出来，抽象成迭代器类来实现的，其目的是在不暴露聚合对象的内部结构的情况下，让外部代码透明地访问聚合的内部数据。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>迭代器模式包括以下角色：</p><ul><li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2>```java<br>package iterator;<br>import java.util.*;<br>public class IteratorPattern<br>{<br>  public static void main(String[] args)<br>  {<pre><code>  Aggregate ag=new ConcreteAggregate();   ag.add(&quot;中山大学&quot;);   ag.add(&quot;华南理工&quot;);   ag.add(&quot;韶关学院&quot;);  System.out.print(&quot;聚合的内容有：&quot;);  Iterator it=ag.getIterator();   while(it.hasNext())  {       Object ob=it.next();       System.out.print(ob.toString()+&quot;\t&quot;);   }  Object ob=it.first();  System.out.println(&quot;\nFirst：&quot;+ob.toString());</code></pre>  }<br>}<br>//抽象聚合<br>interface Aggregate<br>{<br>  public void add(Object obj);<br>  public void remove(Object obj);<br>  public Iterator getIterator();<br>}<br>//具体聚合<br>class ConcreteAggregate implements Aggregate<br>{<br>  private List<object> list=new ArrayList<object>();<br>  public void add(Object obj)<br>  { <pre><code>  list.add(obj); </code></pre>  }<br>  public void remove(Object obj)<br>  { <pre><code>  list.remove(obj); </code></pre>  }<br>  public Iterator getIterator()<br>  { <pre><code>  return(new ConcreteIterator(list)); </code></pre>  }<br>}<br>//抽象迭代器<br>interface Iterator<br>{<br>  Object first();<br>  Object next();<br>  boolean hasNext();<br>}<br>//具体迭代器<br>class ConcreteIterator implements Iterator<br>{<br>  private List<object> list=null;<br>  private int index=-1;<br>  public ConcreteIterator(List<object> list)<br>  { <pre><code>  this.list=list; </code></pre>  }<br>  public boolean hasNext()<br>  { <pre><code>  if(index&lt;list.size()-1)  {       return true;  }  else  {      return false;  }</code></pre>  }<br>  public Object first()<br>  {<pre><code>  index=0;  Object obj=list.get(index);;  return obj;</code></pre>  }<br>  public Object next()<br>  { <pre><code>  Object obj=null;   if(this.hasNext())  {       obj=list.get(++index);   }   return obj; </code></pre>  }<br>}<br>/*</object></object></object></object></li><li>聚合的内容有：中山大学    华南理工    韶关学院<br>First：中山大学</li><li>/<br>```<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1></li><li>当需要为聚合对象提供多种遍历方式时。</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li></ul><p>由于聚合与迭代器的关系非常密切，所以大多数语言在实现聚合类时都提供了迭代器类，因此大数情况下使用语言中已有的聚合类的迭代器就已经够了。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中介者模式</title>
      <link href="/2020/05/14/she-ji-mo-shi/zhong-jie-zhe-mo-shi/"/>
      <url>/2020/05/14/she-ji-mo-shi/zhong-jie-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是QQ服务器。所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。</p><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>中介者（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。中介者模式是一种对象行为型模式，其主要优点如下。</p><ul><li>降低了对象之间的耦合性，使得对象易于独立地被复用。</li><li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li></ul><p>其主要缺点是：当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>中介者模式实现的关键是找出“中介者”，中介者模式包含以下主要角色。</p><ul><li>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</li><li>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</li><li>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</li><li>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</li></ul><p>模式的实现代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>mediator<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-14 下午4:29 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediatorPattern</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Mediator md <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteMediator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Colleague c1<span class="token punctuation">,</span> c2<span class="token punctuation">;</span>        c1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteColleague1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteColleague2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        md<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span>        md<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c2<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象中介者</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Mediator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>Colleague colleague<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">relay</span><span class="token punctuation">(</span>Colleague cl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 转发</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ConcreteMediator</span> <span class="token keyword">extends</span> <span class="token class-name">Mediator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Colleague<span class="token operator">></span> colleagues <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Colleague<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>Colleague colleague<span class="token punctuation">)</span><span class="token punctuation">{</span>        colleagues<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>colleague<span class="token punctuation">)</span><span class="token punctuation">;</span>        colleague<span class="token punctuation">.</span><span class="token function">setMedium</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">relay</span><span class="token punctuation">(</span>Colleague cl<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Colleague ob<span class="token operator">:</span>colleagues<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>cl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>Colleague<span class="token punctuation">)</span>ob<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象同事类</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Colleague</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> Mediator mediator<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMedium</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mediator <span class="token operator">=</span> mediator<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span>  <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体同事类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteColleague1</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体同事类1收到请求。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体同事类1发出请求。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">relay</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//请中介者转发</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体同事类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteColleague2</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体同事类2收到请求。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体同事类2发出请求。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">relay</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//请中介者转发</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**具体同事类1发出请求。具体同事类2收到请求。-------------具体同事类2发出请求。具体同事类1收到请求。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>当对象之间存在复杂的网状结构关系而导致依赖关系混乱且难以复用时。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li><li>不定义中介者接口，把具体中介者对象实现成为单例。</li><li>同事对象不持有中介者，而是在需要的时f矣直接获取中介者对象并调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式</title>
      <link href="/2020/05/13/she-ji-mo-shi/guan-cha-zhe-mo-shi/"/>
      <url>/2020/05/13/she-ji-mo-shi/guan-cha-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；还有，当我们开车到交叉路口时，遇到红灯会停，遇到绿灯会行。这样的例子还有很多，例如，股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众、小偷与警察等。软件设计中，Excel 中的数据与折线图、饼状图、柱状图之间的关系；MVC 模式中的模型与视图的关系；事件模型中的事件源与事件处理者。</p><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。观察者模式是一种对象行为型模式，其主要优点如下。</p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>目标与观察者之间建立了一套触发机制。</li></ul><p>它的主要缺点如下。</p><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>实现观察者模式时要注意具体目标对象和具体观察者对象之间不能直接调用，否则将使两者之间紧密耦合起来，这违反了面向对象的设计原则。主要角色如下：</p><ul><li>抽象主题（Subject）角色：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li>具体主题（Concrete    Subject）角色：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。</li><li>抽象观察者（Observer）角色：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li>具体观察者（Concrete Observer）角色：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ul><p>代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>observer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-13 下午11:36 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverPattern</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Subject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Observer obs1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserver1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Observer obs2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserver2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        subject<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obs1<span class="token punctuation">)</span><span class="token punctuation">;</span>        subject<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obs2<span class="token punctuation">)</span><span class="token punctuation">;</span>        subject<span class="token punctuation">.</span><span class="token function">notifyObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象目标</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Observer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//增加观察者方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span><span class="token punctuation">{</span>        observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除观察者方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span><span class="token punctuation">{</span>        observers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">notifyObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//通知观察者方法</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体目标</span><span class="token keyword">class</span> <span class="token class-name">ConcreteSubject</span> <span class="token keyword">extends</span> <span class="token class-name">Subject</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体目标发生改变..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Object obs<span class="token operator">:</span> observers<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>Observer<span class="token punctuation">)</span>obs<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">response</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象观察者</span><span class="token keyword">interface</span> <span class="token class-name">Observer</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">response</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体观察者1</span><span class="token keyword">class</span> <span class="token class-name">ConcreteObserver1</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">response</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体观察者1作出反应！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体观察者1</span><span class="token keyword">class</span> <span class="token class-name">ConcreteObserver2</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">response</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体观察者2作出反应！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***具体目标发生改变...-------具体观察者1作出反应！具体观察者2作出反应！*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>通过前面的分析与应用实例可知观察者模式适合以下几种情形。</p><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>在Java中，通过 java.util.Observable类和 java.util.Observer接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>Observable类是抽象目标类，它有一个Vector向量，用于保存所有要通知的观察者对象，下面来介绍它最重要的3个方法。</p><ul><li>void addObserver(Observer o) 方法：用于将新的观察者对象添加到向量中。</li><li>void notifyObservers(Object arg) 方法：调用向量中的所有观察者对象的 update。方法，通知它们数据发生改变。通常越晚加入向量的观察者越先得到通知。</li><li>void setChange() 方法：用来设置一个boolean类型的内部标志位，注明目标对象发生了变化。当它为真时，notifyObservers()才会通知观察者。</li></ul><p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 void update(Observable o,Object arg) 方法，进行相应的工作。利用 Observable 类和 Observer 接口实现原油期货的观察者模式实例。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>observer<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-13 下午11:50 */</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Observer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Observable<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CrudeOilFutures</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        OilFutures oil<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">OilFutures</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Observer bull<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Bull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//多方</span>        Observer bear<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Bear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//空方</span>        oil<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>bull<span class="token punctuation">)</span><span class="token punctuation">;</span>        oil<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>bear<span class="token punctuation">)</span><span class="token punctuation">;</span>        oil<span class="token punctuation">.</span><span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        oil<span class="token punctuation">.</span><span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体目标类：原油期货</span><span class="token keyword">class</span> <span class="token class-name">OilFutures</span> <span class="token keyword">extends</span> <span class="token class-name">Observable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">float</span> price<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>price<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token keyword">float</span> price<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">setChanged</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//设置内部标志位，注明数据发生变化</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通知观察者价格改变了</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>price<span class="token operator">=</span>price <span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体观察者类：多方</span><span class="token keyword">class</span> <span class="token class-name">Bull</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Observable o<span class="token punctuation">,</span>Object arg<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Float price<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Float<span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floatValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>price<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"油价上涨"</span><span class="token operator">+</span>price<span class="token operator">+</span><span class="token string">"元，多方高兴了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"油价下跌"</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">-</span>price<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"元，多方伤心了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体观察者类：空方</span><span class="token keyword">class</span> <span class="token class-name">Bear</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>Observable o<span class="token punctuation">,</span>Object arg<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Float price<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Float<span class="token punctuation">)</span>arg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">floatValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>price<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"油价上涨"</span><span class="token operator">+</span>price<span class="token operator">+</span><span class="token string">"元，空方伤心了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"油价下跌"</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token operator">-</span>price<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"元，空方高兴了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***油价上涨20.0元，空方伤心了！油价上涨20.0元，多方高兴了！油价下跌5.0元，空方高兴了！油价下跌5.0元，多方伤心了！*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式</title>
      <link href="/2020/05/13/she-ji-mo-shi/zhuang-tai-mo-shi/"/>
      <url>/2020/05/13/she-ji-mo-shi/zhuang-tai-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，放到一系列的状态类当中，这样可以把原来复杂的逻辑判断简单化。如人的情绪有高兴的时候和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。</p><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。状态模式是一种对象行为型模式，其主要优点如下。</p><ul><li>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li></ul><p>状态模式的主要缺点如下。</p><ul><li>状态模式的使用必然会增加系统的类与对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>状态模式把受环境改变的对象行为包装在不同的状态对象里，其意图是让一个对象在其内部状态改变的时候，其行为也随之改变。主要角色如下：</p><ul><li>环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态（Concrete    State）角色：实现抽象状态所对应的行为。</li></ul><p>代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StatePatternClient</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>               Context context<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建环境       </span>        context<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//处理请求</span>        context<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//环境类</span><span class="token keyword">class</span> <span class="token class-name">Context</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> State state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义环境类的初始状态</span>    <span class="token keyword">public</span> <span class="token function">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteStateA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//设置新状态</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>State state<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token operator">=</span>state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//读取状态</span>    <span class="token keyword">public</span> State <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//对请求做处理</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        state<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象状态类</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">State</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">Handle</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体状态A类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteStateA</span> <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Handle</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前状态是 A."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteStateB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体状态B类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteStateB</span> <span class="token keyword">extends</span> <span class="token class-name">State</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Handle</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前状态是 B."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteStateA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***当前状态是 A.当前状态是 B.当前状态是 A.当前状态是 B.*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>用“状态模式”设计一个多线程的状态转换程序。分析：多线程存在5种状态，分别为新建状态、就绪状态、运行状态、阻塞状态和死亡状态，各个状态当遇到相关方法调用或事件触发时会转换到其他状态，其状态转换规律如下图所示。</p><div align="center"><img src="/images/stateConv.png" width="400"></div><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>state<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-13 下午10:44 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadStateTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">getCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">getCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//环境类</span><span class="token keyword">class</span> <span class="token class-name">ThreadContext</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> ThreadState state<span class="token punctuation">;</span>    <span class="token function">ThreadContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        state<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>ThreadState state<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token operator">=</span>state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ThreadState <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>New<span class="token punctuation">)</span> state<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getCPU</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>Runnable<span class="token punctuation">)</span> state<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCPU</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>Running<span class="token punctuation">)</span> state<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>Running<span class="token punctuation">)</span> state<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>Blocked<span class="token punctuation">)</span> state<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象状态类：线程状态</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ThreadState</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> String stateName<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//状态名</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体状态类：新建状态</span><span class="token keyword">class</span> <span class="token class-name">New</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadState</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        stateName<span class="token operator">=</span><span class="token string">"新建状态"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程处于：新建状态."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span>ThreadContext hj<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"调用start()方法-->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stateName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"新建状态"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            hj<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程不是新建状态，不能调用start()方法."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体状态类：就绪状态</span><span class="token keyword">class</span> <span class="token class-name">Runnable</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadState</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        stateName<span class="token operator">=</span><span class="token string">"就绪状态"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程处于：就绪状态."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getCPU</span><span class="token punctuation">(</span>ThreadContext hj<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"获得CPU时间-->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stateName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"就绪状态"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            hj<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程不是就绪状态，不能获取CPU."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体状态类：运行状态</span><span class="token keyword">class</span> <span class="token class-name">Running</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadState</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Running</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        stateName<span class="token operator">=</span><span class="token string">"运行状态"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程处于：运行状态."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspend</span><span class="token punctuation">(</span>ThreadContext hj<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"调用suspend()方法-->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stateName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"运行状态"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            hj<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Blocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程不是运行状态，不能调用suspend()方法."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stop</span><span class="token punctuation">(</span>ThreadContext hj<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"调用stop()方法-->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stateName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"运行状态"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            hj<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Dead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程不是运行状态，不能调用stop()方法."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体状态类：阻塞状态</span><span class="token keyword">class</span> <span class="token class-name">Blocked</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadState</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Blocked</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        stateName<span class="token operator">=</span><span class="token string">"阻塞状态"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程处于：阻塞状态."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span>ThreadContext hj<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"调用resume()方法-->"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>stateName<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"阻塞状态"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            hj<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程不是阻塞状态，不能调用resume()方法."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体状态类：死亡状态</span><span class="token keyword">class</span> <span class="token class-name">Dead</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadState</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Dead</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        stateName<span class="token operator">=</span><span class="token string">"死亡状态"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前线程处于：死亡状态."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**当前线程处于：新建状态.调用start()方法-->当前线程处于：就绪状态.获得CPU时间-->当前线程处于：运行状态.调用suspend()方法-->当前线程处于：阻塞状态.调用resume()方法-->当前线程处于：就绪状态.获得CPU时间-->当前线程处于：运行状态.调用stop()方法-->当前线程处于：死亡状态.*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>通常在以下情况下可以考虑使用状态模式。</p><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li><li>有多个环境对象需要共享一组状态，这时需要引入享元模式，将这些具体状态对象放在集合中供程序共享</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>责任链模式</title>
      <link href="/2020/05/13/she-ji-mo-shi/ze-ren-lian-mo-shi/"/>
      <url>/2020/05/13/she-ji-mo-shi/ze-ren-lian-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。责任链模式也叫职责链模式。</p><p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。<br>责任链模式是一种对象行为型模式，其主要优点如下。</p><ul><li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。<br>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。<br>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。<br>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。<br>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ul><p>其主要缺点如下。<br>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。<br>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。<br>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>通常情况下，可以通过数据链表来实现职责链模式的数据结构。职责链模式主要包含以下角色。</p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><p>代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChainOfResponsibilityPattern</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//组装责任链 </span>        Handler handler1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteHandler1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         Handler handler2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteHandler2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         handler1<span class="token punctuation">.</span><span class="token function">setNext</span><span class="token punctuation">(</span>handler2<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//提交请求 </span>        handler1<span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象处理者角色</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Handler next<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNext</span><span class="token punctuation">(</span>Handler next<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next<span class="token operator">=</span>next<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> Handler <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">return</span> next<span class="token punctuation">;</span>     <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">//处理请求的方法</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体处理者角色1</span><span class="token keyword">class</span> <span class="token class-name">ConcreteHandler1</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体处理者1负责处理该请求！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"没有人处理该请求！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体处理者角色2</span><span class="token keyword">class</span> <span class="token class-name">ConcreteHandler2</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>String request<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体处理者2负责处理该请求！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"没有人处理该请求！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***具体处理者2负责处理该请求！*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>用责任链模式设计一个请假条审批模块。分析：假如规定学生请假小于或等于 2 天，班主任可以批准；小于或等于 7 天，系主任可以批准；小于或等于 10 天，院长可以批准；其他情况不予批准；这个实例适合使用职责链模式实现</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象处理者：领导类</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Leader</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Leader next<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNext</span><span class="token punctuation">(</span>Leader next<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next<span class="token operator">=</span>next<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> Leader <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>         <span class="token keyword">return</span> next<span class="token punctuation">;</span>     <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">//处理请求的方法</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token keyword">int</span> LeaveDays<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体处理者1：班主任类</span><span class="token keyword">class</span> <span class="token class-name">ClassAdviser</span> <span class="token keyword">extends</span> <span class="token class-name">Leader</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token keyword">int</span> LeaveDays<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>LeaveDays<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"班主任批准您请假"</span> <span class="token operator">+</span> LeaveDays <span class="token operator">+</span> <span class="token string">"天。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>LeaveDays<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请假天数太多，没有人批准该假条！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体处理者2：系主任类</span><span class="token keyword">class</span> <span class="token class-name">DepartmentHead</span> <span class="token keyword">extends</span> <span class="token class-name">Leader</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token keyword">int</span> LeaveDays<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>LeaveDays<span class="token operator">&lt;=</span><span class="token number">7</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"系主任批准您请假"</span> <span class="token operator">+</span> LeaveDays <span class="token operator">+</span> <span class="token string">"天。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                  <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>LeaveDays<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请假天数太多，没有人批准该假条！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体处理者3：院长类</span><span class="token keyword">class</span> <span class="token class-name">Dean</span> <span class="token keyword">extends</span> <span class="token class-name">Leader</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token keyword">int</span> LeaveDays<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>LeaveDays<span class="token operator">&lt;=</span><span class="token number">10</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"院长批准您请假"</span> <span class="token operator">+</span> LeaveDays <span class="token operator">+</span> <span class="token string">"天。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>LeaveDays<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请假天数太多，没有人批准该假条！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体处理者4：教务处长类</span><span class="token keyword">class</span> <span class="token class-name">DeanOfStudies</span> <span class="token keyword">extends</span> <span class="token class-name">Leader</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span><span class="token keyword">int</span> LeaveDays<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>LeaveDays<span class="token operator">&lt;=</span><span class="token number">20</span><span class="token punctuation">)</span>         <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"教务处长批准您请假"</span><span class="token operator">+</span>LeaveDays<span class="token operator">+</span><span class="token string">"天。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">!=</span>null<span class="token punctuation">)</span>             <span class="token punctuation">{</span>                <span class="token function">getNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">handleRequest</span><span class="token punctuation">(</span>LeaveDays<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"请假天数太多，没有人批准该假条！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>责任链模式通常在以下几种情况使用。</p><ul><li>有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。</li><li>可动态指定一组对象处理请求，或添加新的处理者。</li><li>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式</title>
      <link href="/2020/05/13/she-ji-mo-shi/ming-ling-mo-shi/"/>
      <url>/2020/05/13/she-ji-mo-shi/ming-ling-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的“功能键”等。</p><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。命令模式的主要优点如下。</p><ul><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li></ul><p>其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>命令模式包含以下主要角色。</p><ul><li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法execute()。</li><li>具体命令角色（ConcreteCommand）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li><li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ul><p>命令模式的代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>command<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-13 下午9:36 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandPattern</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Command cmd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Invoker ir <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span>cmd<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户访问调用者的call()方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ir<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//调用者</span><span class="token keyword">class</span> <span class="token class-name">Invoker</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Command command<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Invoker</span><span class="token punctuation">(</span>Command command<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用者执行命令command..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象命令</span><span class="token keyword">interface</span> <span class="token class-name">Command</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体命令</span><span class="token keyword">class</span> <span class="token class-name">ConcreteCommand</span> <span class="token keyword">implements</span> <span class="token class-name">Command</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token function">ConcreteCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Receiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        receiver<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//接收者</span><span class="token keyword">class</span> <span class="token class-name">Receiver</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收者的action()方法被调用..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***客户访问调用者的call()方法...调用者执行命令command...接收者的action()方法被调用...*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>命令模式通常适用于以下场景。</p><ul><li>当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。</li><li>当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。</li><li>当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。</li><li>当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li><li>命令模式还可以同备忘录（Memento）模式组合使用，这样就变成了可撤销的命令模式</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>策略设计模式</title>
      <link href="/2020/05/13/she-ji-mo-shi/ce-lue-she-ji-mo-shi/"/>
      <url>/2020/05/13/she-ji-mo-shi/ce-lue-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>在软件开发中，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。<br>策略（Strategy）模式的定义：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。策略模式的主要优点如下。</p><ul><li>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。</li><li>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。</li><li>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。</li><li>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li><li>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li></ul><p>其主要缺点如下。</p><ul><li>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。</li><li>策略模式造成很多的策略类。</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>策略模式是准备一组算法，并将这组算法封装到一系列的策略类里面，作为一个抽象策略类的子类。策略模式的重心不是如何实现算法，而是如何组织这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展性</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>策略模式的主要角色如下。</p><ul><li>抽象策略（Strategy）类：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口，环境角色使用这个接口调用不同的算法，一般使用接口或抽象类实现。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> strategy<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StrategyPattern</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Context c<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Strategy s<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteStrategyA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">strategyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"-----------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteStrategyB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        c<span class="token punctuation">.</span><span class="token function">strategyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象策略类</span><span class="token keyword">interface</span> <span class="token class-name">Strategy</span><span class="token punctuation">{</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">strategyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//策略方法</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体策略类A</span><span class="token keyword">class</span> <span class="token class-name">ConcreteStrategyA</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">strategyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略A的策略方法被访问！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体策略类B</span><span class="token keyword">class</span> <span class="token class-name">ConcreteStrategyB</span> <span class="token keyword">implements</span> <span class="token class-name">Strategy</span><span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">strategyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体策略B的策略方法被访问！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//环境类</span><span class="token keyword">class</span> <span class="token class-name">Context</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Strategy strategy<span class="token punctuation">;</span>    <span class="token keyword">public</span> Strategy <span class="token function">getStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStrategy</span><span class="token punctuation">(</span>Strategy strategy<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy<span class="token operator">=</span>strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">strategyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        strategy<span class="token punctuation">.</span><span class="token function">strategyMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***具体策略A的策略方法被访问！-----------------具体策略B的策略方法被访问！*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>策略模式在“大闸蟹”做菜中的应用</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象策略类：大闸蟹加工类</span><span class="token keyword">interface</span> <span class="token class-name">CrabCooking</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">CookingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//做菜方法</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体策略类：清蒸大闸蟹</span><span class="token keyword">class</span> <span class="token class-name">SteamedCrabs</span> <span class="token keyword">extends</span> <span class="token class-name">JLabel</span> <span class="token keyword">implements</span> <span class="token class-name">CrabCooking</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID<span class="token operator">=</span>1L<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">CookingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setIcon</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ImageIcon</span><span class="token punctuation">(</span><span class="token string">"src/strategy/SteamedCrabs.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setHorizontalAlignment</span><span class="token punctuation">(</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体策略类：红烧大闸蟹</span><span class="token keyword">class</span> <span class="token class-name">BraisedCrabs</span> <span class="token keyword">extends</span> <span class="token class-name">JLabel</span> <span class="token keyword">implements</span> <span class="token class-name">CrabCooking</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID<span class="token operator">=</span>1L<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">CookingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setIcon</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ImageIcon</span><span class="token punctuation">(</span><span class="token string">"src/strategy/BraisedCrabs.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setHorizontalAlignment</span><span class="token punctuation">(</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//环境类：厨房</span><span class="token keyword">class</span> <span class="token class-name">Kitchen</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> CrabCooking strategy<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//抽象策略</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStrategy</span><span class="token punctuation">(</span>CrabCooking strategy<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy<span class="token operator">=</span>strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> CrabCooking <span class="token function">getStrategy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">CookingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        strategy<span class="token punctuation">.</span><span class="token function">CookingMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//做菜   </span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>策略模式在很多地方用到，如 Java SE 中的容器布局管理就是一个典型的实例，Java SE 中的每个容器都存在多种布局供用户选择。在程序设计中，通常在以下几种情况中使用策略模式较多。</p><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/2020/05/13/she-ji-mo-shi/mo-ban-fang-fa-mo-shi/"/>
      <url>/2020/05/13/she-ji-mo-shi/mo-ban-fang-fa-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>模板方法（Template Method）模式的定义如下：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。该模式的主要优点如下。</p><ul><li>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。</li><li>它在父类中提取了公共的部分代码，便于代码复用。</li><li>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</li></ul><p>该模式的主要缺点如下。</p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>模板方法模式需要注意抽象类与具体子类之间的协作。它用到了虚函数的多态性技术以及“不用调用我，让我来调用你”的反向控制技术。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>包含以下主要角色：</p><p>1.抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p><p>（1）抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。</p><ul><li>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法</li><li>基本方法：是整个算法中的一个步骤，包含以下几种类型。抽象方法：在抽象类中申明，由具体子类实现。具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</li></ul><p>（2）具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>templateMethod<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-13 下午12:24 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TemplateMethodPattern</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AbstarctClass tm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tm<span class="token punctuation">.</span><span class="token function">TemplateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象类</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstarctClass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">TemplateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//模板方法</span>    <span class="token punctuation">{</span>        <span class="token function">SpecificMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">abstractMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">abstractMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">SpecificMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//具体方法</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抽象类中的具体方法被调用..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">abstractMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">abstractMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体子类</span><span class="token keyword">class</span> <span class="token class-name">ConcreteClass</span> <span class="token keyword">extends</span> <span class="token class-name">AbstarctClass</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">abstractMethod1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抽象方法1的实现被调用..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">abstractMethod2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"抽象方法2的实现被调用..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***抽象类中的具体方法被调用...抽象方法1的实现被调用...抽象方法2的实现被调用...*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>模板方法模式通常适用于以下场景。</p><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>当多个子类存在公共的行为时，可以将其提取出来并集中到一个公共父类中以避免代码重复。首先，要识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</li><li>当需要控制子类的扩展时，模板方法只在特定点调用钩子操作，这样就只允许在这些点进行扩展。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式</title>
      <link href="/2020/05/13/she-ji-mo-shi/zu-he-mo-shi/"/>
      <url>/2020/05/13/she-ji-mo-shi/zu-he-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="组合模式的定义与特点"><a href="#组合模式的定义与特点" class="headerlink" title="组合模式的定义与特点"></a>组合模式的定义与特点</h1><p>组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。在软件开发中如：文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。组合模式的主要优点有：</p><ul><li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；</li><li>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</li></ul><p>其主要缺点是：</p><ul><li>设计较复杂，客户端需要花更多时间理清类之间的层次关系；</li><li>不容易限制容器中的构件；</li><li>不容易用继承的方法来增加构件的新功能</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>组合模式包含以下主要角色。</p><ul><li>抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。</li><li>树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。</li><li>树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild()等方法。<h2 id="透明式组合模式"><a href="#透明式组合模式" class="headerlink" title="透明式组合模式"></a>透明式组合模式</h2>在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无须区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有 Add()、Remove() 及 GetChild() 方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。<h2 id="安全组合模式"><a href="#安全组合模式" class="headerlink" title="安全组合模式"></a>安全组合模式</h2>在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>假如要访问集合 c0={leaf1,{leaf2,leaf3}} 中的元素，其对应的树状图如下图所示：</p><div align="center"><img src="/images/jihe.png" width="400"></div><p>透明式组合模式代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>composite<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-13 上午10:24 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CompositePattern</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Component c0 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Component c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Component leaf1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Component leaf2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Component leaf3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c0<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>leaf1<span class="token punctuation">)</span><span class="token punctuation">;</span>        c0<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>leaf2<span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>leaf3<span class="token punctuation">)</span><span class="token punctuation">;</span>        c0<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象构件</span><span class="token keyword">interface</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Component <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//树叶构件</span><span class="token keyword">class</span> <span class="token class-name">Leaf</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Leaf</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> Component <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"树叶"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">":被访问！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//树枝构件</span><span class="token keyword">class</span> <span class="token class-name">Composite</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> ArrayList<span class="token operator">&lt;</span>Component<span class="token operator">></span> children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Component<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span><span class="token punctuation">{</span>        children<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        children<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Component <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Object obj<span class="token operator">:</span>children<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**树叶1:被访问！树叶2:被访问！树叶3:被访问！*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>用组合模式实现当用户在商店购物后，显示其所选商品信息，并计算所选商品总价的功能。</p><p>说明：假如李先生到韶关“天街e角”生活用品店购物，用 1 个红色小袋子装了 2 包婺源特产（单价 7.9 元）、1 张婺源地图（单价 9.9 元）；用 1 个白色小袋子装了 2 包韶关香藉（单价 68 元）和 3 包韶关红茶（单价 180 元）；用 1 个中袋子装了前面的红色小袋子和 1 个景德镇瓷器（单价 380 元）；用 1 个大袋子装了前面的中袋子、白色小袋子和 1 双李宁牌运动鞋（单价 198 元）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//抽象构件：物品</span><span class="token keyword">interface</span> <span class="token class-name">Articles</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">calculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计算</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//树叶构件：商品</span><span class="token keyword">class</span> <span class="token class-name">Goods</span> <span class="token keyword">implements</span> <span class="token class-name">Articles</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//名字</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> quantity<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数量</span>    <span class="token keyword">private</span> <span class="token keyword">float</span> unitPrice<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//单价</span>    <span class="token keyword">public</span> <span class="token function">Goods</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span><span class="token keyword">int</span> quantity<span class="token punctuation">,</span><span class="token keyword">float</span> unitPrice<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>quantity<span class="token operator">=</span>quantity<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>unitPrice<span class="token operator">=</span>unitPrice<span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">calculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> quantity<span class="token operator">*</span>unitPrice<span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">"(数量："</span><span class="token operator">+</span>quantity<span class="token operator">+</span><span class="token string">"，单价："</span><span class="token operator">+</span>unitPrice<span class="token operator">+</span><span class="token string">"元)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//树枝构件：袋子</span><span class="token keyword">class</span> <span class="token class-name">Bags</span> <span class="token keyword">implements</span> <span class="token class-name">Articles</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//名字   </span>    <span class="token keyword">private</span> ArrayList<span class="token operator">&lt;</span>Articles<span class="token operator">></span> bags<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Articles<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">public</span> <span class="token function">Bags</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>           <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Articles c<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        bags<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Articles c<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        bags<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">public</span> Articles <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> bags<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">calculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">float</span> s<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Object obj<span class="token operator">:</span>bags<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            s<span class="token operator">+=</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Articles<span class="token punctuation">)</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">calculation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Object obj<span class="token operator">:</span>bags<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>Articles<span class="token punctuation">)</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ul><li>在需要表示一个对象整体与部分的层次结构的场合。</li><li>要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>享元模式</title>
      <link href="/2020/05/12/she-ji-mo-shi/xiang-yuan-mo-shi/"/>
      <url>/2020/05/12/she-ji-mo-shi/xiang-yuan-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。</p><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p><p>其主要缺点是：</p><ul><li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li><li>读取享元模式的外部状态会使得运行时间稍微变长。</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>享元模式中存在以下两种状态：</p><ul><li>内部状态，即不会随着环境的改变而改变的可共享部分；</li><li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2>享元模式的主要角色有如下。</li><li>抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</li><li>具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</li><li>非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</li><li>享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>Flyweight<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-12 下午11:57 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightPattern</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FlyweightFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlyweightFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight f01 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight f02<span class="token operator">=</span>factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight f11<span class="token operator">=</span>factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight f12<span class="token operator">=</span>factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f01<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span><span class="token string">"第1次调用a。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f02<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span><span class="token string">"第2次调用a。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f11<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span><span class="token string">"第1次调用b。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f12<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span><span class="token string">"第2次调用b。"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//非享元角色</span><span class="token keyword">class</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String info<span class="token punctuation">;</span>    <span class="token function">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span>String info<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>info<span class="token operator">=</span>info<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> info<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setInfo</span><span class="token punctuation">(</span>String info<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>info<span class="token operator">=</span>info<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象享元角色</span><span class="token keyword">interface</span> <span class="token class-name">Flyweight</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span>UnsharedConcreteFlyweight state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体享元角色</span><span class="token keyword">class</span> <span class="token class-name">ConcreteFlyweight</span> <span class="token keyword">implements</span> <span class="token class-name">Flyweight</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String key<span class="token punctuation">;</span>    <span class="token function">ConcreteFlyweight</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token operator">=</span>key<span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体享元"</span><span class="token operator">+</span>key<span class="token operator">+</span><span class="token string">"被创建！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span>UnsharedConcreteFlyweight outState<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"具体享元"</span><span class="token operator">+</span>key<span class="token operator">+</span><span class="token string">"被调用，"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"非享元信息是:"</span><span class="token operator">+</span>outState<span class="token punctuation">.</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//享元工厂角色</span><span class="token keyword">class</span> <span class="token class-name">FlyweightFactory</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Flyweight<span class="token operator">></span> flyweights<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Flyweight<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Flyweight <span class="token function">getFlyweight</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Flyweight flyweight<span class="token operator">=</span><span class="token punctuation">(</span>Flyweight<span class="token punctuation">)</span>flyweights<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flyweight<span class="token operator">!=</span>null<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体享元"</span><span class="token operator">+</span>key<span class="token operator">+</span><span class="token string">"已经存在，被成功获取！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            flyweight<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ConcreteFlyweight</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            flyweights<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> flyweight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> flyweight<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***具体享元b被创建！具体享元b已经存在，被成功获取！具体享元a被调用，非享元信息是:第1次调用a。具体享元a被调用，非享元信息是:第2次调用a。具体享元b被调用，非享元信息是:第1次调用b。具体享元b被调用，非享元信息是:第2次调用b。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式。</p><ul><li>系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。</li><li>大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。</li><li>由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外观模式</title>
      <link href="/2020/05/12/she-ji-mo-shi/wai-guan-mo-shi/"/>
      <url>/2020/05/12/she-ji-mo-shi/wai-guan-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>软件设计中，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。</p><h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li><li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li></ul><p>外观（Facade）模式的主要缺点如下。</p><ul><li>不能很好地限制客户使用子系统类。</li><li>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>外观（Facade）模式包含以下主要角色。</p><ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li><li>客户（Client）角色：通过一个外观角色访问各个子系统的功能。</li></ul><h1 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h1><p>外观模式的实现如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> facade<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FacadePattern</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Facade f<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Facade</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//外观角色</span><span class="token keyword">class</span> <span class="token class-name">Facade</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> SubSystem01 obj1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SubSystem01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> SubSystem02 obj2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SubSystem02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> SubSystem03 obj3<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SubSystem03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        obj1<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj2<span class="token punctuation">.</span><span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        obj3<span class="token punctuation">.</span><span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//子系统角色</span><span class="token keyword">class</span> <span class="token class-name">SubSystem01</span><span class="token punctuation">{</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子系统01的method1()被调用！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//子系统角色</span><span class="token keyword">class</span> <span class="token class-name">SubSystem02</span><span class="token punctuation">{</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子系统02的method2()被调用！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//子系统角色</span><span class="token keyword">class</span> <span class="token class-name">SubSystem03</span><span class="token punctuation">{</span>    <span class="token keyword">public</span>  <span class="token keyword">void</span> <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"子系统03的method3()被调用！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***子系统01的method1()被调用！子系统02的method2()被调用！子系统03的method3()被调用！*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="外观模式的应用场景"><a href="#外观模式的应用场景" class="headerlink" title="外观模式的应用场景"></a>外观模式的应用场景</h1><p>通常在以下情况下可以考虑使用外观模式。</p><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>装饰模式</title>
      <link href="/2020/05/12/she-ji-mo-shi/zhuang-shi-mo-shi/"/>
      <url>/2020/05/12/she-ji-mo-shi/zhuang-shi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等。在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰模式来实现。</p><p>装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。装饰（Decorator）模式的主要优点有：</p><ul><li>采用装饰模式扩展对象的功能比采用继承方式更加灵活。</li><li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li></ul><p>其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。</p><h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>装饰模式主要包含以下角色。</p><ul><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ul><h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><p>装饰模式的实现代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>DecoratorPattern<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-12 下午5:08 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Decorator_test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Component p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"---------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Component d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecorator</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        d<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象构建角色</span><span class="token keyword">interface</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体构件角色</span><span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"创建具体构件角色"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"调用具体构件角色的方法operation()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象装饰角色</span><span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Component component<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        component<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体装饰角色</span><span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecorator</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addedFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"为具体构建角色增加额外的功能addedFunction()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***创建具体构件角色调用具体构件角色的方法operation()---------------------调用具体构件角色的方法operation()为具体构建角色增加额外的功能addedFunction()*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>用装饰模式实现游戏角色“龙骑士”的变身。分析：在《Dota2》中，游戏角色“龙骑士”的原身是一个战士，但当他变身时，会变成龙形态，当有神杖会变身黑龙形态。这些都可用装饰模式来实现。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>DecoratorPattern<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>swing<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-12 下午5:32 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Dragon_knight</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Dragon d1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">original</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        d1<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Dragon d2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dragonfrom</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>        d2<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Dragon d3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Black_Dragon</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">;</span>        d3<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象构建角色：龙骑士</span><span class="token keyword">interface</span> <span class="token class-name">Dragon</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体构件角色：原画</span><span class="token keyword">class</span> <span class="token class-name">original</span> <span class="token keyword">extends</span> <span class="token class-name">JFrame</span> <span class="token keyword">implements</span> <span class="token class-name">Dragon</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span>  <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 1L<span class="token punctuation">;</span>    <span class="token keyword">private</span> String t <span class="token operator">=</span> <span class="token string">"qishi.jpg"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">original</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"《Dota2》中龙骑士"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setImage</span><span class="token punctuation">(</span>String t<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>t <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setLayout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FlowLayout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JLabel l1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JLabel</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ImageIcon</span><span class="token punctuation">(</span><span class="token string">"/usr/local/github/algo_test/src/Design_Pattern/DecoratorPattern/"</span> <span class="token operator">+</span> t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDefaultCloseOperation</span><span class="token punctuation">(</span>JFrame<span class="token punctuation">.</span>EXIT_ON_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象装饰角色：变形</span><span class="token keyword">class</span> <span class="token class-name">Changer</span> <span class="token keyword">implements</span> <span class="token class-name">Dragon</span><span class="token punctuation">{</span>    Dragon d<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Changer</span><span class="token punctuation">(</span>Dragon d<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>d <span class="token operator">=</span> d<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        d<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体装饰角色：龙形态</span><span class="token keyword">class</span> <span class="token class-name">Dragonfrom</span> <span class="token keyword">extends</span> <span class="token class-name">Changer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Dragonfrom</span><span class="token punctuation">(</span>Dragon d<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setChanger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setChanger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setImage</span><span class="token punctuation">(</span><span class="token string">"long.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体装饰角色：黑龙</span><span class="token keyword">class</span> <span class="token class-name">Black_Dragon</span> <span class="token keyword">extends</span> <span class="token class-name">Changer</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Black_Dragon</span><span class="token punctuation">(</span>Dragon d<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">setChanger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setChanger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setImage</span><span class="token punctuation">(</span><span class="token string">"Along.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序运行结果如下图所示：</p><div align="center"><img src="/images/Decorator_Dragon.png" width="400" height="200"></div><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>装饰模式通常在以下几种情况使用。</p><ul><li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li><li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。</li><li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li></ul><p>装饰模式在Java语言中的最著名的应用莫过于 Java I/O 标准库的设计了。例如，InputStream 的子类 FilterInputStream，OutputStream 的子类 FilterOutputStream，Reader 的子类 BufferedReader 以及 FilterReader，还有 Writer 的子类 BufferedWriter、FilterWriter 以及 PrintWriter 等，它们都是抽象装饰类。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>桥接模式</title>
      <link href="/2020/05/12/she-ji-mo-shi/qiao-jie-mo-shi/"/>
      <url>/2020/05/12/she-ji-mo-shi/qiao-jie-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。优点是：</p><ul><li>由于抽象与实现分离，所以扩展能力强；</li><li>其实现细节对客户透明。</li></ul><p>缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>桥接（Bridge）模式包含以下主要角色。</p><ul><li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li><li>扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li><li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li><li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li></ul><h1 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h1><p>桥接模式代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>bridge<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-12 下午4:07 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BridgeTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Implementor imple <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Abstraction abs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RefineAbstraction</span><span class="token punctuation">(</span>imple<span class="token punctuation">)</span><span class="token punctuation">;</span>        abs<span class="token punctuation">.</span><span class="token function">Operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//实现化角色</span><span class="token keyword">interface</span> <span class="token class-name">Implementor</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">OperationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体实现化角色</span><span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorA</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">OperationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体实现化角色被访问"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象化角色</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Abstraction</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> Implementor imple<span class="token punctuation">;</span>    <span class="token keyword">protected</span> <span class="token function">Abstraction</span><span class="token punctuation">(</span>Implementor imple<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>imple <span class="token operator">=</span> imple<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">Operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//扩展抽象化角色</span><span class="token keyword">class</span> <span class="token class-name">RefineAbstraction</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> <span class="token function">RefineAbstraction</span><span class="token punctuation">(</span>Implementor imple<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>imple<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"扩展抽象化角色被访问！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        imple<span class="token punctuation">.</span><span class="token function">OperationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/***扩展抽象化角色被访问！具体实现化角色被访问*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>用桥接（Bridge）模式模拟女士皮包的选购。分析：女士皮包有很多种，可以按用途分、按皮质分、按品牌分、按颜色分、按大小分等，存在多个维度的变化，所以采用桥接模式来实现女士皮包的选购比较合适。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//实现化角色：颜色</span><span class="token keyword">interface</span> <span class="token class-name">Color</span><span class="token punctuation">{</span>    String <span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体实现化角色：黄色</span><span class="token keyword">class</span> <span class="token class-name">Yellow</span> <span class="token keyword">implements</span> <span class="token class-name">Color</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"yellow"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体实现化角色：红色</span><span class="token keyword">class</span> <span class="token class-name">Red</span> <span class="token keyword">implements</span> <span class="token class-name">Color</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"red"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象化角色：包</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Bag</span><span class="token punctuation">{</span>    <span class="token keyword">protected</span> Color color<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setColor</span><span class="token punctuation">(</span>Color color<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//扩展抽象化角色：挎包</span><span class="token keyword">class</span> <span class="token class-name">HandBag</span> <span class="token keyword">extends</span> <span class="token class-name">Bag</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> color<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"HandBag"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//扩展抽象化角色：钱包</span><span class="token keyword">class</span> <span class="token class-name">Wallet</span> <span class="token keyword">extends</span> <span class="token class-name">Bag</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> color<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">"Wallet"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>接模式通常适用于以下场景。</p><ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li><li>在软件开发中，有时桥接（Bridge）模式可与适配器模式联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来</li></ul><div align="center"><img src="/images/Bridge_Adapter.png" width="400"></div><center>图1 桥接模式与适配器模式联用的结构图</center>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2020/05/12/she-ji-mo-shi/gua-pei-qi-mo-shi/"/>
      <url>/2020/05/12/she-ji-mo-shi/gua-pei-qi-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h1><p>适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。</p><p>该模式的主要优点如下。</p><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li></ul><p>其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。</p><h1 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h1><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口；Java 不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p><h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>适配器模式主要包含以下主要角色</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><p>1.类适配器模式</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>adapter<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-12 下午12:53 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdapterTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"类适配器模式测试："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Target target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//目标接口</span><span class="token keyword">interface</span> <span class="token class-name">Target</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//适配者接口</span><span class="token keyword">class</span> <span class="token class-name">Adapter</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"适配者中的业务代码被调用！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//类适配器类</span><span class="token keyword">class</span> <span class="token class-name">ClassAdapter</span> <span class="token keyword">extends</span> <span class="token class-name">Adapter</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 类适配器模式测试：适配者中的业务代码被调用！*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.对象适配器模式</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>adapter<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author peng * @date 20-5-12 下午1:04 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectAdapterTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"对象适配器模式测试："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Adapter adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Target target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectAdapter</span><span class="token punctuation">(</span>adapter<span class="token punctuation">)</span><span class="token punctuation">;</span>        target<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">ObjectAdapter</span> <span class="token keyword">implements</span>  <span class="token class-name">Target</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Adapter adapter<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ObjectAdapter</span><span class="token punctuation">(</span>Adapter adapter<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>adapter <span class="token operator">=</span> adapter<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        adapter<span class="token punctuation">.</span><span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">*</span><span class="token operator">*</span> <span class="token operator">*</span> 对象适配器模式测试：适配者中的业务代码被调用！ <span class="token operator">*</span> <span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>使用适配器模式模拟新能源汽车的发动机。客户端希望用统一的发动机驱动方法 drive() 访问这两种发动机，所以必须定义一个统一的目标接口 Motor，然后再定义电能适配器（Electric Adapter）和光能适配器（Optical Adapter）去适配这两种发动机。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//目标：发动机</span><span class="token keyword">interface</span>　<span class="token class-name">Motor</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//适配者1：电能发动机</span><span class="token keyword">class</span> <span class="token class-name">ElectricMotor</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">electricDrive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"电能发动机驱动汽车！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//适配者2：光能发动机</span><span class="token keyword">class</span> <span class="token class-name">OpticalMotor</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">opticalDrive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"光能发动机驱动汽车！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//电能适配器</span><span class="token keyword">class</span> <span class="token class-name">ElectricAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">Motor</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> ElectricMotor emotor<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ElectricAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        emotor<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ElectricMotor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        emotor<span class="token punctuation">.</span><span class="token function">electricDrive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//光能适配器</span><span class="token keyword">class</span> <span class="token class-name">OpticalAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">Motor</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> OpticalMotor omotor<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">OpticalAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        omotor<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">OpticalMotor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        omotor<span class="token punctuation">.</span><span class="token function">opticalDrive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>适配器模式（Adapter）通常适用于以下场景。</p><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li><li>适配器模式（Adapter）可扩展为双向适配器模式，双向适配器类既可以把适配者接口转换成目标接口，也可以把目标接口转换成适配者接口</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2020/05/12/she-ji-mo-shi/dai-li-mo-shi/"/>
      <url>/2020/05/12/she-ji-mo-shi/dai-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>代理模式的主要优点有：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><p>其主要缺点是：</p><ul><li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li><li>增加了系统的复杂度；</li></ul><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p><h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>代理模式的主要角色如下。</p><ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。<h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>proxy<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>/**</p><ul><li>@author peng</li><li>@date 20-5-12 上午11:26</li><li>/<br>public class ProxyTest {<br>  public static void main(String[] args) {<pre><code>  Proxy proxy = new Proxy();  proxy.Request();</code></pre>  }<br>}<br>//抽象主题<br>interface Subject{<br>  void Request();<br>}<br>//真实主题<br>class RealSubject implements Subject{<br>  public void Request(){<pre><code>  System.out.println(&quot;访问真实主题方法...&quot;);</code></pre>  }<br>}<br>//代理<br>class Proxy implements Subject{<br>  private RealSubject realSubject;<br>  public void Request(){<pre><code>  if(realSubject == null){      realSubject = new RealSubject();  }  preRequest();  realSubject.Request();  postRequest();</code></pre>  }<br>  public void preRequest(){<pre><code>  System.out.println(&quot;访问真实主题之前的预处理&quot;);</code></pre>  }<br>  public void postRequest(){<pre><code>  System.out.println(&quot;访问真实主题之后的后续处理.&quot;);</code></pre>  }<br>}<br>/**访问真实主题之前的预处理<br>访问真实主题方法…<br>访问真实主题之后的后续处理.<br>*/<br>```<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1>前面分析了代理模式的结构与特点，现在来分析以下的应用场景。<ul><li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li><li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li><li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li><li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li><li>延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建造者模式</title>
      <link href="/2020/05/12/she-ji-mo-shi/jian-zao-zhe-mo-shi/"/>
      <url>/2020/05/12/she-ji-mo-shi/jian-zao-zhe-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h1><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p><p>该模式的主要优点如下：</p><ul><li>各个具体的建造者相互独立，有利于系统的扩展。</li><li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li></ul><p>其缺点如下：</p><ul><li>产品的组成部分必须相同，这限制了其使用范围。</li><li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li></ul><p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</p><h1 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h1><p>建造者（Builder）模式由产品、抽象建造者、具体建造者、指挥者等 4 个要素构成，现在我们来分析其基本结构和实现方法。</p><h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>建造者（Builder）模式的主要角色如下。</p><ul><li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。</li><li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li><li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ul><h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><p>1.产品角色：包含多个组成部件的复杂对象。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Product</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String partA<span class="token punctuation">;</span>    <span class="token keyword">private</span> String partB<span class="token punctuation">;</span>    <span class="token keyword">private</span> String partC<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPartA</span><span class="token punctuation">(</span>String partA<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>partA <span class="token operator">=</span> partA<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPartB</span><span class="token punctuation">(</span>String partB<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>partB<span class="token operator">=</span>partB<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPartC</span><span class="token punctuation">(</span>String partC<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>partC<span class="token operator">=</span>partC<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//显示产品的特性</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.抽象建造者：包含创建产品各个子部件的抽象方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建产品对象</span>    <span class="token keyword">protected</span> Product product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//返回产品对象</span>    <span class="token keyword">public</span> Product <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3.具体建造者：实现抽象建造者接口</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">extends</span> <span class="token class-name">Builder</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token string">"建造 PartA"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token string">"建造 PartB"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPartA</span><span class="token punctuation">(</span><span class="token string">"建造 PartC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.指挥者：调用建造者中的方法完成复杂对象的创建</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Director</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Builder builder<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//产品构建与组装方法</span>    <span class="token keyword">public</span> Product <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        builder<span class="token punctuation">.</span><span class="token function">buildPartA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPartB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPartC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>5.客户类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        BUilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Director director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product <span class="token operator">=</span> director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        product<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>用建造者（Builder）模式描述客厅装修。分析：客厅装修是一个复杂的过程，它包含墙体的装修、电视机的选择、沙发的购买与布局等。客户把装修要求告诉项目经理，项目经理指挥装修工人一步步装修，最后完成整个客厅的装修与布局，所以本实例用建造者模式实现比较适合。结构图如下：</p><div align="center"><img src="/image/Bulider.png" width="400"></div><center>图1 客厅装修的结构图</center><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//产品：客厅</span><span class="token keyword">class</span> <span class="token class-name">Parlour</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> String wall<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//墙</span>    <span class="token keyword">private</span> String TV<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//电视</span>    <span class="token keyword">private</span> String sofa<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//沙发</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setWall</span><span class="token punctuation">(</span>String wall<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>wall <span class="token operator">=</span> wall<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setTV</span><span class="token punctuation">(</span>String TV<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>TV<span class="token operator">=</span>TV<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSofa</span><span class="token punctuation">(</span>String sofa<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>sofa<span class="token operator">=</span>sofa<span class="token punctuation">;</span>    <span class="token punctuation">}</span>       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        JFrame jf<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JFrame</span><span class="token punctuation">(</span><span class="token string">"建造者模式测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Container contentPane<span class="token operator">=</span>jf<span class="token punctuation">.</span><span class="token function">getContentPane</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JPanel p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           JScrollPane sp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JScrollPane</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>          String parlour<span class="token operator">=</span>wall<span class="token operator">+</span>TV<span class="token operator">+</span>sofa<span class="token punctuation">;</span>        JLabel l<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JLabel</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ImageIcon</span><span class="token punctuation">(</span><span class="token string">"src/"</span><span class="token operator">+</span>parlour<span class="token operator">+</span><span class="token string">".jpg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span><span class="token function">setLayout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GridLayout</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span><span class="token function">setBorder</span><span class="token punctuation">(</span>BorderFactory<span class="token punctuation">.</span><span class="token function">createTitledBorder</span><span class="token punctuation">(</span><span class="token string">"客厅"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>        contentPane<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sp<span class="token punctuation">,</span>BorderLayout<span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span>               jf<span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          jf<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">setDefaultCloseOperation</span><span class="token punctuation">(</span>JFrame<span class="token punctuation">.</span>EXIT_ON_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象建造者：装修工人</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Decorator</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//创建产品对象</span>    <span class="token keyword">protected</span> Parlour product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parlour</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildWall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildTV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildSofa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//产品对象</span>    <span class="token keyword">public</span> Parlour <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体建造者：具体装修工人</span><span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator1</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildWall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setWall</span><span class="token punctuation">(</span><span class="token string">"w1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildTV</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setTV</span><span class="token punctuation">(</span><span class="token string">"TV1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildSofa</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setSofa</span><span class="token punctuation">(</span><span class="token string">"sf1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体建造者：具体装修工人2</span><span class="token keyword">class</span> <span class="token class-name">ConcreteDecorator2</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildWall</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setWall</span><span class="token punctuation">(</span><span class="token string">"w2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildTV</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          product<span class="token punctuation">.</span><span class="token function">setTV</span><span class="token punctuation">(</span><span class="token string">"TV2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildSofa</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span>          product<span class="token punctuation">.</span><span class="token function">setSofa</span><span class="token punctuation">(</span><span class="token string">"sf2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//指挥者：项目经理</span><span class="token keyword">class</span> <span class="token class-name">ProjectManager</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Decorator builder<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ProjectManager</span><span class="token punctuation">(</span>Decorator builder<span class="token punctuation">)</span>    <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>builder<span class="token operator">=</span>builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//产品构建与组装方法</span>    <span class="token keyword">public</span> Parlour <span class="token function">decorate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>          builder<span class="token punctuation">.</span><span class="token function">buildWall</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildTV</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildSofa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>建造者(Builder)模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2020/05/11/she-ji-mo-shi/chou-xiang-gong-han-mo-shi/"/>
      <url>/2020/05/11/she-ji-mo-shi/chou-xiang-gong-han-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h1><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p>使用抽象工厂模式一般要满足以下条件。</p><ul><li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li><li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li></ul><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。</p><ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li></ul><p>其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h1 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h1><p>抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。</p><h2 id="1-模式的结构"><a href="#1-模式的结构" class="headerlink" title="1.模式的结构"></a>1.模式的结构</h2><p>抽象工厂模式的主要角色如下：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li></ul><h2 id="2-模式的实现"><a href="#2-模式的实现" class="headerlink" title="2.模式的实现"></a>2.模式的实现</h2><p>(1) 抽象工厂：提供了产品的生成方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Product1 <span class="token function">newProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Product2 <span class="token function">newProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>(2) 具体工厂：实现了产品的生成方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Product1 <span class="token function">newProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体工厂 1 生成-->具体产品 11..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct11</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Product2 <span class="token function">newProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体工厂 1 生成-->具体产品 21..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct21</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p>用抽象工厂模式设计农场类。</p><p>分析：农场中除了像畜牧场一样可以养动物，还可以培养植物，如养马、养牛、种菜、种水果等，所以本实例比前面介绍的畜牧场类复杂，必须用抽象工厂模式来实现。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> Design_Pattern<span class="token punctuation">.</span>AbstractFactory<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>swing<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FarmTest</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">try</span>        <span class="token punctuation">{</span>            Farm f<span class="token punctuation">;</span>            Animal a<span class="token punctuation">;</span>            Plant p<span class="token punctuation">;</span>            f<span class="token operator">=</span><span class="token punctuation">(</span>Farm<span class="token punctuation">)</span> ReadXML<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token operator">=</span>f<span class="token punctuation">.</span><span class="token function">newAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p<span class="token operator">=</span>f<span class="token punctuation">.</span><span class="token function">newPlant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span><span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象产品：动物类</span><span class="token keyword">interface</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体产品：马类</span><span class="token keyword">class</span> <span class="token class-name">Horse</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    JScrollPane sp<span class="token punctuation">;</span>    JFrame jf<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JFrame</span><span class="token punctuation">(</span><span class="token string">"抽象工厂模式测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Horse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Container contentPane<span class="token operator">=</span>jf<span class="token punctuation">.</span><span class="token function">getContentPane</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JPanel p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">setLayout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GridLayout</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">setBorder</span><span class="token punctuation">(</span>BorderFactory<span class="token punctuation">.</span><span class="token function">createTitledBorder</span><span class="token punctuation">(</span><span class="token string">"动物：马"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JScrollPane</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>        contentPane<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sp<span class="token punctuation">,</span> BorderLayout<span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span>        JLabel l1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JLabel</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ImageIcon</span><span class="token punctuation">(</span><span class="token string">"/usr/local/github/algo_test/src/Design_Pattern/AbstractFactory/A_Horse.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">setDefaultCloseOperation</span><span class="token punctuation">(</span>JFrame<span class="token punctuation">.</span>EXIT_ON_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用户点击窗口关闭</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        jf<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体产品：牛类</span><span class="token keyword">class</span> <span class="token class-name">Cattle</span> <span class="token keyword">implements</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    JScrollPane sp<span class="token punctuation">;</span>    JFrame jf<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JFrame</span><span class="token punctuation">(</span><span class="token string">"抽象工厂模式测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Cattle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Container contentPane<span class="token operator">=</span>jf<span class="token punctuation">.</span><span class="token function">getContentPane</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JPanel p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">setLayout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GridLayout</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">setBorder</span><span class="token punctuation">(</span>BorderFactory<span class="token punctuation">.</span><span class="token function">createTitledBorder</span><span class="token punctuation">(</span><span class="token string">"动物：牛"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JScrollPane</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>        contentPane<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sp<span class="token punctuation">,</span> BorderLayout<span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span>        JLabel l1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JLabel</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ImageIcon</span><span class="token punctuation">(</span><span class="token string">"/usr/local/github/algo_test/src/Design_Pattern/AbstractFactory/A_Cattle.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">setDefaultCloseOperation</span><span class="token punctuation">(</span>JFrame<span class="token punctuation">.</span>EXIT_ON_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用户点击窗口关闭</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        jf<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象产品：植物类</span><span class="token keyword">interface</span> <span class="token class-name">Plant</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体产品：水果类</span><span class="token keyword">class</span> <span class="token class-name">Fruitage</span> <span class="token keyword">implements</span> <span class="token class-name">Plant</span><span class="token punctuation">{</span>    JScrollPane sp<span class="token punctuation">;</span>    JFrame jf<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JFrame</span><span class="token punctuation">(</span><span class="token string">"抽象工厂模式测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Fruitage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Container contentPane<span class="token operator">=</span>jf<span class="token punctuation">.</span><span class="token function">getContentPane</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JPanel p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">setLayout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GridLayout</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">setBorder</span><span class="token punctuation">(</span>BorderFactory<span class="token punctuation">.</span><span class="token function">createTitledBorder</span><span class="token punctuation">(</span><span class="token string">"植物：水果"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JScrollPane</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>        contentPane<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sp<span class="token punctuation">,</span> BorderLayout<span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span>        JLabel l1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JLabel</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ImageIcon</span><span class="token punctuation">(</span><span class="token string">"/usr/local/github/algo_test/src/Design_Pattern/AbstractFactory/P_Fruitage.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">setDefaultCloseOperation</span><span class="token punctuation">(</span>JFrame<span class="token punctuation">.</span>EXIT_ON_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用户点击窗口关闭</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        jf<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体产品：蔬菜类</span><span class="token keyword">class</span> <span class="token class-name">Vegetables</span> <span class="token keyword">implements</span> <span class="token class-name">Plant</span><span class="token punctuation">{</span>    JScrollPane sp<span class="token punctuation">;</span>    JFrame jf<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JFrame</span><span class="token punctuation">(</span><span class="token string">"抽象工厂模式测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Vegetables</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        Container contentPane<span class="token operator">=</span>jf<span class="token punctuation">.</span><span class="token function">getContentPane</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JPanel p1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JPanel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">setLayout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">GridLayout</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">setBorder</span><span class="token punctuation">(</span>BorderFactory<span class="token punctuation">.</span><span class="token function">createTitledBorder</span><span class="token punctuation">(</span><span class="token string">"植物：蔬菜"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sp<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JScrollPane</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>        contentPane<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sp<span class="token punctuation">,</span> BorderLayout<span class="token punctuation">.</span>CENTER<span class="token punctuation">)</span><span class="token punctuation">;</span>        JLabel l1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">JLabel</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ImageIcon</span><span class="token punctuation">(</span><span class="token string">"/usr/local/github/algo_test/src/Design_Pattern/AbstractFactory/P_Vegetables.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">pack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        jf<span class="token punctuation">.</span><span class="token function">setDefaultCloseOperation</span><span class="token punctuation">(</span>JFrame<span class="token punctuation">.</span>EXIT_ON_CLOSE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用户点击窗口关闭</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        jf<span class="token punctuation">.</span><span class="token function">setVisible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//抽象工厂：农场类</span><span class="token keyword">interface</span> <span class="token class-name">Farm</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Animal <span class="token function">newAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Plant <span class="token function">newPlant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体工厂：韶关农场类</span><span class="token keyword">class</span> <span class="token class-name">SGfarm</span> <span class="token keyword">implements</span> <span class="token class-name">Farm</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Animal <span class="token function">newAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"新牛出生！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Cattle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Plant <span class="token function">newPlant</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"蔬菜长成！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Vegetables</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//具体工厂：上饶农场类</span><span class="token keyword">class</span> <span class="token class-name">SRfarm</span> <span class="token keyword">implements</span> <span class="token class-name">Farm</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> Animal <span class="token function">newAnimal</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"新马出生！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Horse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Plant <span class="token function">newPlant</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"水果长成！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fruitage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h1><p>抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如 java 的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。抽象工厂模式通常适用于以下场景：</p><ul><li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li><li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li><li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li></ul><p>当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2020/05/11/she-ji-mo-shi/gong-han-fang-fa-mo-shi/"/>
      <url>/2020/05/11/she-ji-mo-shi/gong-han-fang-fa-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h1><p>工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p><p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。</p><p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。工厂方法模式的主要优点有：</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p>其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p><h1 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h1><p>工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等四个要素构成。</p><p><strong>1.模式的结构</strong></p><p>工厂方法模式的主要角色如下。</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法newProduct()来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><p><strong>2.模式的实现</strong></p><pre class="line-numbers language-Java"><code class="language-Java">//AbstractFactoryTest.javapackage Design_Pattern.FactoryMethod;/** * @author peng * @date 20-5-11 下午12:06 */public class AbstractFactoryTest {    public static void main(String[] args) {        try{            Product a;            AbstractFactory af;            af = (AbstractFactory) ReadXML1.getObject();            a = af.newProduct();            a.show();        }catch (Exception e){            System.out.println(e.getMessage());        }    }}interface Product{    public void show();  //抽象产品：产品的接口}//具体产品1：实现抽象方法class ConcreteProduct1 implements Product{    public void show(){        System.out.println("具体产品1...");    }}//具体产品2class ConcreteProduct2 implements Product {    public void show() {        System.out.println("具体产品2");    }}//抽象工厂interface AbstractFactory{    public Product newProduct();}//具体工厂1class ConcreteFactory1 implements AbstractFactory{    public Product newProduct() {        System.out.println("具体工厂1生成-->具体产品1...");        return new ConcreteProduct1();    }}//具体工厂2class ConcreteFactory2 implements AbstractFactory{    public Product newProduct(){        System.out.println("具体工厂2生成-->具体产品2");        return new ConcreteProduct2();    }}//ReadXML1.javapackage Design_Pattern.FactoryMethod;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.w3c.dom.Document;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.File;/** * @author peng * @date 20-5-11 下午12:14 */public class ReadXML1 {    public static Object getObject(){        try{            //文件对象            DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();            DocumentBuilder builder = dFactory.newDocumentBuilder();            Document doc;            doc = builder.parse(new File("/usr/local/github/algo_test/src/Design_Pattern/FactoryMethod/config1.xml"));            //文本节点            NodeList nl = doc.getElementsByTagName("className");            Node classNode = nl.item(0).getFirstChild();            String cName = "Design_Pattern.FactoryMethod." + classNode.getNodeValue();            Class<?> c = Class.forName(cName);            Object obj = c.newInstance();            return obj;        }catch (Exception e){            e.printStackTrace();            return null;        }    }}/** * Output: 具体工厂2生成-->具体产品2具体产品2*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h1><p>工厂方法模式通常适用于以下场景。</p><ul><li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li><li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li><li>客户不关心创建产品的细节，只关心产品的品牌</li></ul><p>当需要生成的产品不多且不会增加，一个具体工厂类就可以完成任务时，可删除抽象工厂类。这时工厂方法模式将退化到简单工厂模式。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">TypeB</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">TypeA</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>type_a <span class="token operator">=</span> TypeA        self<span class="token punctuation">.</span>type_b <span class="token operator">=</span> TypeB    <span class="token keyword">def</span> <span class="token function">get_instance_type_a</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>type_a<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_instance_type_b</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>type_b<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    abstract_factory <span class="token operator">=</span> AbstractFactory<span class="token punctuation">(</span><span class="token punctuation">)</span>    product_a <span class="token operator">=</span> abstract_factory<span class="token punctuation">.</span>get_instance_type_a<span class="token punctuation">(</span><span class="token punctuation">)</span>    product_b <span class="token operator">=</span> abstract_factory<span class="token punctuation">.</span>get_instance_type_b<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型模式</title>
      <link href="/2020/05/11/she-ji-mo-shi/yuan-xing-mo-shi/"/>
      <url>/2020/05/11/she-ji-mo-shi/yuan-xing-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="原型模式的特点"><a href="#原型模式的特点" class="headerlink" title="原型模式的特点"></a>原型模式的特点</h1><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。</p><h1 id="原型模式的结构与实现"><a href="#原型模式的结构与实现" class="headerlink" title="原型模式的结构与实现"></a>原型模式的结构与实现</h1><h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>原型模式包含以下角色</p><ul><li>抽象原型类：规定了具体原型对象必须实现的接口。</li><li>具体原型类：实现抽象原型类的clone()方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的clone()方法来复制新的对象。</li></ul><h2 id="模式的实现"><a href="#模式的实现" class="headerlink" title="模式的实现"></a>模式的实现</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> copy<span class="token keyword">class</span> <span class="token class-name">Prototype</span><span class="token punctuation">:</span>    value <span class="token operator">=</span> <span class="token string">'default'</span>    <span class="token keyword">def</span> <span class="token function">clone</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">**</span>attrs<span class="token punctuation">)</span><span class="token punctuation">:</span>        obj <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        obj<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>update<span class="token punctuation">(</span>attrs<span class="token punctuation">)</span>        <span class="token keyword">return</span> obj<span class="token keyword">class</span> <span class="token class-name">PrototypeDispatcher</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_objects <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">get_objects</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_objects    <span class="token keyword">def</span> <span class="token function">register_object</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_objects<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> obj    <span class="token keyword">def</span> <span class="token function">unregister_object</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">del</span> self<span class="token punctuation">.</span>_objects<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    dispatcher <span class="token operator">=</span> PrototypeDispatcher<span class="token punctuation">(</span><span class="token punctuation">)</span>    prototype <span class="token operator">=</span> Prototype<span class="token punctuation">(</span><span class="token punctuation">)</span>    d <span class="token operator">=</span> prototype<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token punctuation">)</span>    a <span class="token operator">=</span> prototype<span class="token punctuation">.</span>clone<span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">'a-value'</span><span class="token punctuation">,</span>category<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">)</span>    b <span class="token operator">=</span> prototype<span class="token punctuation">.</span>clone<span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">'b-value'</span><span class="token punctuation">,</span>is_checked<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    dispatcher<span class="token punctuation">.</span>register_object<span class="token punctuation">(</span><span class="token string">'objecta'</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span>    dispatcher<span class="token punctuation">.</span>register_object<span class="token punctuation">(</span><span class="token string">'objectb'</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span>    dispatcher<span class="token punctuation">.</span>register_object<span class="token punctuation">(</span><span class="token string">'default'</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">{</span>n<span class="token punctuation">:</span> p<span class="token punctuation">.</span>value<span class="token punctuation">}</span> <span class="token keyword">for</span> n<span class="token punctuation">,</span>p <span class="token keyword">in</span> dispatcher<span class="token punctuation">.</span>get_objects<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">##[{'objecta': 'a-value'}, {'objectb': 'b-value'}, {'default': 'default'}]</span><span class="token keyword">import</span> copy<span class="token keyword">class</span> <span class="token class-name">Prototype</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>_objects <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">register_object</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Register an object"""</span>        self<span class="token punctuation">.</span>_objects<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> obj    <span class="token keyword">def</span> <span class="token function">unregister_object</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Unregister an object"""</span>        <span class="token keyword">del</span> self<span class="token punctuation">.</span>_objects<span class="token punctuation">[</span>name<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">clone</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> <span class="token operator">**</span>attr<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""Clone a registered object and update inner attributes dictionary"""</span>        obj <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_objects<span class="token punctuation">.</span>get<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>        obj<span class="token punctuation">.</span>__dict__<span class="token punctuation">.</span>update<span class="token punctuation">(</span>attr<span class="token punctuation">)</span>        <span class="token keyword">return</span> obj<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span>    prototype <span class="token operator">=</span> Prototype<span class="token punctuation">(</span><span class="token punctuation">)</span>    prototype<span class="token punctuation">.</span>register_object<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>    b <span class="token operator">=</span> prototype<span class="token punctuation">.</span>clone<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>a<span class="token punctuation">,</span> b<span class="token punctuation">.</span>b<span class="token punctuation">,</span> b<span class="token punctuation">.</span>c<span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># &lt;__main__.main.&lt;locals>.A object at 0x7f7c4d0175f8></span><span class="token comment" spellcheck="true"># 1 2 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="原型模式的应用场景"><a href="#原型模式的应用场景" class="headerlink" title="原型模式的应用场景"></a>原型模式的应用场景</h1><p>原型模式通常适用于以下场景。</p><ul><li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li><li>对象的创建过程比较麻烦，但复制比较简单的时候。</li></ul><h1 id="原型模式的扩展"><a href="#原型模式的扩展" class="headerlink" title="原型模式的扩展"></a>原型模式的扩展</h1><p>原型模式可扩展为带原型管理器的原型模式，它在原型模式的基础上增加了一个原型管理器 PrototypeManager 类。该类用 HashMap 保存多个复制的原型，Client 类可以通过管理器的 get(String id) 方法从中获取复制的原型。</p><div align="center"><img src="/images/yxglq.png" width="400"></div><center>图1 带原型管理器的原型模式的结构图</center>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2020/05/10/she-ji-mo-shi/dan-li-mo-shi/"/>
      <url>/2020/05/10/she-ji-mo-shi/dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式的定义与特点"><a href="#单例模式的定义与特点" class="headerlink" title="单例模式的定义与特点"></a>单例模式的定义与特点</h1><p>单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p><p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。单例模式有 3 个特点：</p><ul><li>单例类只有一个实例对象；</li><li>该单例对象必须由单例类自行创建；</li><li>单例类对外提供一个访问该单例的全局访问点；</li></ul><h1 id="单例模式的结构和实现"><a href="#单例模式的结构和实现" class="headerlink" title="单例模式的结构和实现"></a>单例模式的结构和实现</h1><p>单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法调用该构造函数，也就无法生成多个实例。这时该类自身必须定义一个静态私有实例，并向外提供一个静态的公有函数用于创建或获取该静态私有实例。</p><h2 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h2><ul><li>单例类：包含一个实例且能自行创建这个实例的类</li><li>访问类：使用单例的类</li></ul><p>结构如图所示：</p><div align="center"><img src="/images/Singleton.png" width="400"></div><center>图1 单例模式的结构图</center><h2 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h2><p><strong>1.懒汉式单例</strong></p><p>该模式的特点是类加载时没有生成单例，只有当一次调用get_instance方法时才创建这个单例，代码实现如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    __instance <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>__instance<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用__init__, 实例未创建"</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用__init__，实例已经创建："</span><span class="token punctuation">,</span> __instance<span class="token punctuation">)</span>    @classmethod    <span class="token keyword">def</span> <span class="token function">get_instance</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> cls<span class="token punctuation">.</span>__instance<span class="token punctuation">:</span>            cls<span class="token punctuation">.</span>__instance <span class="token operator">=</span> Singleton<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>__instance<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>优点：资源利用合理，不调用get_instance方法不创建单例对象。缺点：线程不安全，多线程时可能会获取到不同单例对象的情况。解决办法是加互斥锁，但会降低效率<br>线程安全的单例</p></blockquote><p><strong>2.饿汉式单例</strong></p><p>该模式的特点是类一旦加载就创建一个单例，保证在调用getinstance方法之前单例已经存在了，实现代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token string">'instance'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cls<span class="token punctuation">.</span>instance <span class="token operator">=</span> super<span class="token punctuation">(</span>Singleton<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>instance<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>优点：线程安全；在类实例化前创建好一个静态对象，调用时反应速度快；直接执行其他方法和静态方法，单例实例不会初始化。缺点：不管使用与否，实例化前就初始化静态对象，资源浪费</p></blockquote><p><strong>3.线程安全的单例</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">def</span> <span class="token function">synchronized</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    func<span class="token punctuation">.</span>__lock__ <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">lock_func</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> func<span class="token punctuation">.</span>__lock__<span class="token punctuation">:</span>            <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> lock_func<span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    instance <span class="token operator">=</span> None    @synchronized    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>       <span class="token keyword">if</span> cls<span class="token punctuation">.</span>instance <span class="token keyword">is</span> None<span class="token punctuation">:</span>           cls<span class="token punctuation">.</span>instance <span class="token operator">=</span> super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>instance    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>a <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">5</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h1><p>前面分析了单例模式的结构与特点，以下是它通常适用的场景的特点。</p><ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li><li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li><li>当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumPy学习</title>
      <link href="/2020/05/05/bian-cheng-yu-yan/python/numpy/"/>
      <url>/2020/05/05/bian-cheng-yu-yan/python/numpy/</url>
      
        <content type="html"><![CDATA[<h1 id="ndarray数组的创建"><a href="#ndarray数组的创建" class="headerlink" title="ndarray数组的创建"></a>ndarray数组的创建</h1><p>首先导入numpy包：</p><blockquote><p>import numpy as np</p></blockquote><p>通过np.+Tab键查看可使用的函数，在对应函数加上?，再运行，就可以很方便地看到如何使用函数的帮助信息。NumPy封装了一个新的数据类型ndarray（N-dimensional Array），它是一个多维数组对象。该对象封装了许多常用的数学运算函数，方便我们做数据处理、数据分析等，生成方式包括：</p><ul><li>从已有数据中创建；</li><li>利用 random 创建；</li><li>创建特定形状的多维数组；</li><li>利用 arange、linspace 函数生成等。</li></ul><h2 id="从已有数据中创建数组"><a href="#从已有数据中创建数组" class="headerlink" title="从已有数据中创建数组"></a>从已有数据中创建数组</h2><p>对Python的基础数据类型（如列表、元组等）进行转换来生成 ndarray：</p><ul><li>将列表转换成ndarray<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npls1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">]</span>nd1 <span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>ls1<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>nd1<span class="token punctuation">)</span><span class="token punctuation">[</span> <span class="token number">10</span>  <span class="token number">42</span>   <span class="token number">0</span> <span class="token operator">-</span><span class="token number">17</span>  <span class="token number">30</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>nd1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'numpy.ndarray'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>嵌套列表转换成多维ndarray<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npls2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span>nd2 <span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>ls2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>nd2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>nd2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''[[ 8 -2  0 34  7][ 6  7  8  9 10]]&lt;class 'numpy.ndarray'>'''</span><span class="token comment" spellcheck="true"># 可以将列表换成元组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用random模块生成数组"><a href="#利用random模块生成数组" class="headerlink" title="利用random模块生成数组"></a>利用random模块生成数组</h2><table><thead><tr><th>数</th><th>描述</th></tr></thead><tbody><tr><td>np.random.random</td><td>生成0到1之间的随机数</td></tr><tr><td>np.random.uniform</td><td>生成均勻分布的随机数</td></tr><tr><td>np.random.randn</td><td>生成标准正态的随机数</td></tr><tr><td>np.random.randint</td><td>生成随机的整数</td></tr><tr><td>np.random.normal</td><td>生成正态分布</td></tr><tr><td>np.random.shuffle</td><td>随机打乱顺序</td></tr><tr><td>np.random.seed</td><td>设置随机数种子</td></tr><tr><td>random_sample</td><td>生成随机的浮点数</td></tr><tr><td>```python</td><td></td></tr><tr><td>import numpy as np</td><td></td></tr><tr><td>nd3 =np.random.random([4, 3])  #生成4行3列的数组</td><td></td></tr><tr><td>print(nd3)</td><td></td></tr><tr><td>print(“nd3的形状为：”,nd3.shape)</td><td></td></tr><tr><td>‘’’</td><td></td></tr><tr><td>[[0.83239801 0.74702617 0.04089187]</td><td></td></tr><tr><td>[0.90023902 0.91950877 0.38947664]</td><td></td></tr><tr><td>[0.76919904 0.90359661 0.38207995]</td><td></td></tr><tr><td>[0.26542428 0.89554719 0.5686561 ]]</td><td></td></tr><tr><td>nd3的形状为： (4, 3)</td><td></td></tr><tr><td>‘’’</td><td></td></tr><tr><td>```</td><td></td></tr><tr><td>## 创建特定形状的多维数组</td><td></td></tr><tr><td>函数</td><td>描述</td></tr><tr><td>np.zeros((3, 4))</td><td>创建 3×4 的元素全为 0 的数组</td></tr><tr><td>np.ones((3, 4))</td><td>创建 3×4 的元素全为 1 的数组</td></tr><tr><td>np.empty((2, 3))</td><td>创建 2×3 的空数组，空数据中的值并不为 0，而是未初始化的垃圾值</td></tr><tr><td>np.zeros_like(ndarr)</td><td>以 ndarr 相同维度创建元素全为  0数组</td></tr><tr><td>np.ones_like(ndarr)</td><td>以 ndarr 相同维度创建元素全为 1 数组</td></tr><tr><td>np.empty_like(ndarr)</td><td>以 ndarr 相同维度创建空数组</td></tr><tr><td>np.eye(5)</td><td>该函数用于创建一个 5×5 的矩阵，对角线为 1，其余为 0</td></tr><tr><td>np.full((3,5), 10)</td><td>创建 3×5 的元素全为 10 的数组，10 为指定值</td></tr></tbody></table></li></ul><p>实例如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> nd7 <span class="token operator">=</span> np<span class="token punctuation">.</span>eye<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> nd8 <span class="token operator">=</span> np<span class="token punctuation">.</span>diag<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> nd7array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> nd8array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">8</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">3</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以把生成的数据保存到文件中，如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npnd9 <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>savetxt<span class="token punctuation">(</span>X<span class="token operator">=</span>nd9<span class="token punctuation">,</span> fname<span class="token operator">=</span><span class="token string">'./data.txt'</span><span class="token punctuation">)</span>nd10 <span class="token operator">=</span> np<span class="token punctuation">.</span>loadtxt<span class="token punctuation">(</span><span class="token string">'./data.txt'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>nd10<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="利用-arange-和-linspace-函数生成数组"><a href="#利用-arange-和-linspace-函数生成数组" class="headerlink" title="利用 arange() 和 linspace() 函数生成数组"></a>利用 arange() 和 linspace() 函数生成数组</h2><p>arange()是numpy模块中的函数，其格式为：</p><blockquote><p>arange([start,] stop[,step,], dtype=None)</p></blockquote><p>其中，start与stop用来指定范围，step用来设定步长。在生成一个ndarray时，start默认为0，步长step可为小数。Python有个内置函数range，其功能与此类似。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">9</span> <span class="token number">8</span> <span class="token number">7</span> <span class="token number">6</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token number">3</span> <span class="token number">2</span> <span class="token number">1</span> <span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>linspace()也是numpy模块中常用的函数，其格式为：</p><blockquote><p>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</p></blockquote><p>linspace()可以根据输入的指定数据范围以及等份数量，自动生成一个线性等分向量，其中endpoint（包含终点）默认为True，等分数量 num默认为50。如果将retstep设置为True，则会返回一个带步长的 ndarray。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">.</span>         <span class="token number">0.11111111</span> <span class="token number">0.22222222</span> <span class="token number">0.33333333</span> <span class="token number">0.44444444</span> <span class="token number">0.55555556</span> <span class="token number">0.66666667</span> <span class="token number">0.77777778</span> <span class="token number">0.88888889</span> <span class="token number">1</span><span class="token punctuation">.</span>        <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="ndarray数据元素的获取"><a href="#ndarray数据元素的获取" class="headerlink" title="ndarray数据元素的获取"></a>ndarray数据元素的获取</h1><p>在NumPy中，既可以获取 ndarray 数组的单个元素，也可以获取一组元素（也即切片），这与 Python 中的列表（list）和元组（tuple）非常类似。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> nd2<span class="token operator">=</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> nd2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">6</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> nd2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">1</span><span class="token punctuation">,</span>  <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">6</span><span class="token punctuation">,</span>  <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">21</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> nd2<span class="token punctuation">[</span><span class="token punctuation">(</span>nd2<span class="token operator">></span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>nd2<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>获取数组中的部分元素除了通过指定索引标签来实现外，还可以通过使用一些函数来实现，如通过random.choice函数从指定的样本中随机抽取数据。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a<span class="token operator">=</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span>dtype<span class="token operator">=</span>float<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> c3<span class="token operator">=</span>nr<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>a<span class="token punctuation">,</span>size<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>p<span class="token operator">=</span>a <span class="token operator">/</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> c3array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span> <span class="token number">9</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">24</span><span class="token punctuation">.</span><span class="token punctuation">,</span>  <span class="token number">4</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h1><p>涉及大量的数组或矩阵运算，本节我们将重点介绍两种常用的运算：</p><ul><li>一种是对应元素相乘，又称为逐元乘法（Element-Wise Product），可以使用 np.multiply() 函数或者*运算符；</li><li>另一种是点积或内积元素，运算符为np.dot()。<h2 id="对应元素相乘"><a href="#对应元素相乘" class="headerlink" title="对应元素相乘"></a>对应元素相乘</h2>对应元素相乘（Element-Wise Product）是两个矩阵中对应元素乘积。np.multiply() 函数用于数组或矩阵对应元素相乘，输出与相乘数组或矩阵的大小一致，其格式如下：<blockquote><p>numpy.multiply(x1, x2, /, out=None, *, where=True,casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p></blockquote></li></ul><p>其中x1、x2之间的对应元素相乘遵守广播规则。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> A <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> B <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> A<span class="token operator">*</span>Barray<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> np<span class="token punctuation">.</span>multiply<span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token operator">*</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token number">2</span><span class="token punctuation">.</span>  <span class="token number">4</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">.</span>  <span class="token number">8</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">##数组通过激活函数，输入输出形状一致</span> <span class="token keyword">import</span> numpy <span class="token keyword">as</span> npX <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">softmoid</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">relu</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>maximum<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">softmax</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">/</span> np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>np<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"输入参数X的形状："</span><span class="token punctuation">,</span> X<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"激活函数softmoid输出形状："</span><span class="token punctuation">,</span> softmoid<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"激活函数relu输出形状："</span><span class="token punctuation">,</span> relu<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"激活函数softmax输出形状："</span><span class="token punctuation">,</span> softmax<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''输入参数X的形状： (2, 3)激活函数softmoid输出形状： (2, 3)激活函数relu输出形状： (2, 3)激活函数softmax输出形状： (2, 3)'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="点积运算"><a href="#点积运算" class="headerlink" title="点积运算"></a>点积运算</h2><p>点积运算（Dot Product）又称为内积，在 NumPy 中用 np.dot() 函数表示，其一般格式为：</p><blockquote><p>numpy.dot(a, b, out=None)</p><pre class="line-numbers language-python"><code class="language-python">X1<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>X2<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>X3<span class="token operator">=</span>np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>X1<span class="token punctuation">,</span>X2<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>X3<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''[[21 24 27][47 54 61]]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h1 id="数组的变形-改变数组形状"><a href="#数组的变形-改变数组形状" class="headerlink" title="数组的变形(改变数组形状)"></a>数组的变形(改变数组形状)</h1><p>在矩阵或者数组的运算中，经常会遇到需要把多个向量或矩阵按某轴方向合并，或展平（如在卷积或循环神经网络中，在全连接层之前，需要把矩阵展平）的情况。下面介绍几种常用的数组变形方法。<br>| 函数/属性       | 描述                                                                    |<br>| ————— | ———————————————————————– |<br>| arr.reshape()   | 重新将向量 arr 维度进行改变，不修改向量本身                             |<br>| arr.resize()    | 重新将向量 arr维度进行改变，修改向量本身                                |<br>| arr.T           | 对向量 arr 进行转置                                                     |<br>| arr.ravel()     | 对向量 arr 进行展平，即将多维数组变成1维数组，不会产生原数组的副本      |<br>| arr.flatten()   | 对向量 arr 进行展平，即将多维数组变成1维数组，返回原数组的副本          |<br>| arr.squeeze()   | 只能对维数为1的维度降维。对多维数组使用时不会报错，但是不会产生任何影响 |<br>| arr.transpose() | 对高维矩阵进行轴对换                                                    |</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 测试几个常用的函数</span><span class="token operator">>></span><span class="token operator">></span> arr <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> arr<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> arr<span class="token punctuation">.</span>resize<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">>></span><span class="token operator">></span> arr<span class="token punctuation">.</span>Tarray<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span>       <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token string">'F'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 按列展平</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">5</span> <span class="token number">1</span> <span class="token number">6</span> <span class="token number">2</span> <span class="token number">7</span> <span class="token number">3</span> <span class="token number">8</span> <span class="token number">4</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>ravel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 按行展平</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># flatten()函数将矩阵转换成向量</span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span>np<span class="token punctuation">.</span>floor<span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">.</span> <span class="token number">8</span><span class="token punctuation">.</span> <span class="token number">5</span><span class="token punctuation">.</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">5</span><span class="token punctuation">.</span> <span class="token number">4</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">.</span> <span class="token number">9</span><span class="token punctuation">.</span> <span class="token number">7</span><span class="token punctuation">.</span> <span class="token number">8</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>flatten<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">.</span> <span class="token number">8</span><span class="token punctuation">.</span> <span class="token number">5</span><span class="token punctuation">.</span> <span class="token number">1</span><span class="token punctuation">.</span> <span class="token number">2</span><span class="token punctuation">.</span> <span class="token number">0</span><span class="token punctuation">.</span> <span class="token number">5</span><span class="token punctuation">.</span> <span class="token number">4</span><span class="token punctuation">.</span> <span class="token number">9</span><span class="token punctuation">.</span> <span class="token number">9</span><span class="token punctuation">.</span> <span class="token number">7</span><span class="token punctuation">.</span> <span class="token number">8</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># transpose() 对高维矩阵进行轴对换</span><span class="token operator">>></span><span class="token operator">></span> arr2 <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>arr2<span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#(2, 3, 4)</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>arr2<span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>shape<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#(3, 4, 2)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ndarray合并数组"><a href="#ndarray合并数组" class="headerlink" title="ndarray合并数组"></a>ndarray合并数组</h1><p>|函数    |描述|<br>|np.append()|    内存占用大|<br>|np.concatenate()    |没有内存问题|<br>|np.stack()    |沿着新的轴加入一系列数组|<br>|np.hstack()    |堆栈数组垂直顺序（行）|<br>|np.vstack()    |堆栈数组垂直顺序（列）|<br>|np.dstack()    |堆栈数组按顺序深入（沿第3维）|<br>|np.vsplit()    |将数组分解成垂直的多个子数组的列表|</p><p>几点说明：</p><ul><li>append()、concatenate() 以及 stack() 都有一个 axis 参数，用于控制数组的合并方式是按行还是按列。</li><li>对于 append() 和 concatenate()，待合并的数组必须有相同的行数或列数（满足一个即可）。</li><li>stack()、hstack()、dstack() 要求待合并的数组必须具有相同的形状（shape）</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> c <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> d <span class="token operator">=</span> np<span class="token punctuation">.</span>concatenate<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">.</span>T<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">4</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># stack，沿指定轴堆叠数组或矩阵</span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>stack<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> axis<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span><span class="token punctuation">]</span>  <span class="token punctuation">[</span><span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">]</span>  <span class="token punctuation">[</span><span class="token number">7</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Numpy批量处理"><a href="#Numpy批量处理" class="headerlink" title="Numpy批量处理"></a>Numpy批量处理</h1><p>如何把大数据拆分成多个批次呢？可采用如下步骤：</p><ul><li>得到数据集</li><li>随机打乱数据</li><li>定义批大小</li><li>批处理数据集</li></ul><p>示例如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npdata_train <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>data_train<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># (2000, 2, 3)</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>data_train<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义批量</span>batch_size <span class="token operator">=</span> <span class="token number">100</span><span class="token comment" spellcheck="true"># 批处理</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">(</span>data_train<span class="token punctuation">)</span><span class="token punctuation">,</span>batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    x_batch_sum<span class="token operator">=</span>np<span class="token punctuation">.</span>sum<span class="token punctuation">(</span>data_train<span class="token punctuation">[</span>i<span class="token punctuation">:</span>i<span class="token operator">+</span>batch_size<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"第{}批次，该批次的数据之和：{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>i<span class="token punctuation">,</span>x_batch_sum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''(2000, 2, 3)第0批次，该批次的数据之和：-2.5597045866733144第100批次，该批次的数据之和：-28.20552534073626第200批次，该批次的数据之和：-39.954399816952744第300批次，该批次的数据之和：15.230660353237122第400批次，该批次的数据之和：3.756517698762309第500批次，该批次的数据之和：2.416672409682702第600批次，该批次的数据之和：-47.262073781065844第700批次，该批次的数据之和：-4.384517680501666第800批次，该批次的数据之和：0.9617151643255646第900批次，该批次的数据之和：27.657472571275203第1000批次，该批次的数据之和：39.91121481922393第1100批次，该批次的数据之和：-37.02521264944135第1200批次，该批次的数据之和：-19.19864630328485第1300批次，该批次的数据之和：37.92424857767804第1400批次，该批次的数据之和：-17.742587465605805第1500批次，该批次的数据之和：-9.856616675258884第1600批次，该批次的数据之和：6.976135672087105第1700批次，该批次的数据之和：-5.35707792331438第1800批次，该批次的数据之和：15.930799536487907第1900批次，该批次的数据之和：-4.654408531448469'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="ufnc通用函数"><a href="#ufnc通用函数" class="headerlink" title="ufnc通用函数"></a>ufnc通用函数</h1><p>NumPy 中的函数可以是向量或矩阵，而利用向量或矩阵可以避免使用循环语句，通用函数如下：<br>| 函数                   | 使用方法                 |<br>| ———————- | ———————— |<br>| sqrt()                 | 计算序列化数据的平方根   |<br>| sin()、cos()           | 三角函数                 |<br>| abs()                  | 计算序列化数据的绝对值   |<br>| dot()                  | 矩阵运算                 |<br>| log()、logl()、log2()  | 对数函数                 |<br>| exp()                  | 指数函数                 |<br>| cumsum()、cumproduct() | 累计求和、求积           |<br>| sum()                  | 对一个序列化数据进行求和 |<br>| mean()                 | 计算均值                 |<br>| median()               | 计算中位数               |<br>| std()                  | 计算标准差               |<br>| var()                  | 计算方差                 |<br>| corrcoef()             | 计算相关系数             |</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># math与numpy函数性能比较</span><span class="token keyword">import</span> time<span class="token keyword">import</span> math<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npx <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">0.001</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">]</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> t <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    x<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> math<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"math.sin:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span>x <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">0.001</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">]</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>x<span class="token punctuation">)</span>start <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>sin<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"numpy.sin:"</span><span class="token punctuation">,</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''math.sin: 0.17639699999999991numpy.sin: 0.017746999999999957'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环与向量运算"><a href="#循环与向量运算" class="headerlink" title="循环与向量运算"></a>循环与向量运算</h2><p>实现计算的向量化，可大大地提高运行速度。NumPy 库中的内建函数使用了 SIMD 指令。如下使用的向量化要比使用循环计算速度快得多。如果使用GPU，其性能将更强大，不过Numpy不支持GPU。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npx1 <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>x2 <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">##使用循环计算向量点积</span>tic <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>dot <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    dot <span class="token operator">+=</span> x1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> x2<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    toc <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"dot = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>dot<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n for loop----- Computation time = "</span> <span class="token operator">+</span>      str<span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> <span class="token punctuation">(</span>toc <span class="token operator">-</span> tic<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用numpy函数求点积</span>tic <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span>dot <span class="token operator">=</span> <span class="token number">0</span>dot <span class="token operator">=</span> np<span class="token punctuation">.</span>dot<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span>toc <span class="token operator">=</span> time<span class="token punctuation">.</span>process_time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"dot = "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>dot<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"\n verctor version---- Computation time = "</span> <span class="token operator">+</span>      str<span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> <span class="token punctuation">(</span>toc <span class="token operator">-</span> tic<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''dot = 249965.34253404333 for loop----- Computation time = 1146.446813msdot = 249965.34253405244 verctor version---- Computation time = 2.297117999999987ms'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="广播机制"><a href="#广播机制" class="headerlink" title="广播机制"></a>广播机制</h1><p>调整数组使得 shape 一样，需要满足一定的规则，否则将出错。这些规则可归纳为以下 4 条。</p><ul><li>让所有输入数组都向其中 shape 最长的数组看齐，不足的部分则通过在前面加 1 补齐，如：<blockquote><p>a：2×3×2<br>b：3×2</p></blockquote></li></ul><p>则 b 向 a 看齐，在 b 的前面加 1，变为 1×3×2。</p><ul><li>输出数组的 shape 是输入数组 shape 的各个轴上的最大值。</li><li>如果输入数组的某个轴和输出数组的对应轴的长度相同或者某个轴的长度为 1 时，这个数组能被用来计算，否则出错。</li><li>当输入数组的某个轴的长度为1时，沿着此轴运算时都用（或复制）此轴上的第一组值。<blockquote><p>目的：计算A+B，其中A为 4×1 矩阵，B为一维向量 (3,)。</p></blockquote></li></ul><p>处理过程如下：</p><ul><li><p>根据规则 1，B 需要向看齐，把 B 变为 (1,3)</p></li><li><p>根据规则2，输出的结果为各个轴上的最大值，即输出结果应该为 (4,3) 矩阵，那么 A 如何由 (4,1) 变为 (4,3) 矩阵？B 又如何由 (1,3) 变为 (4,3) 矩阵？</p></li><li><p>根据规则4，用此轴上的第一组值（要主要区分是哪个轴），进行复制（但在实际处理中不是真正复制，否则太耗内存，而是采用其他对象如 ogrid 对象，进行网格处理）即可，详细处理过程如图1所示。</p><div align="center"><img src="/images/Numpy广播.png" width="400"></div><center>图1 NumPy广播规则</center><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> npA <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>B <span class="token operator">=</span> np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"A矩阵的形状:{},B矩阵的形状:{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>A<span class="token punctuation">.</span>shape<span class="token punctuation">,</span>B<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span>C<span class="token operator">=</span>A<span class="token operator">+</span>B<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"C矩阵的形状:{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>C<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''A矩阵的形状:(4, 1),B矩阵的形状:(3,)C矩阵的形状:(4, 3)[[ 0  1  2][10 11 12][20 21 22][30 31 32]]'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django框架笔记</title>
      <link href="/2020/05/04/bian-cheng-yu-yan/python/django-kuang-jia-bi-ji/"/>
      <url>/2020/05/04/bian-cheng-yu-yan/python/django-kuang-jia-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Django-MTV与MVC的区别"><a href="#Django-MTV与MVC的区别" class="headerlink" title="Django MTV与MVC的区别"></a>Django MTV与MVC的区别</h1><p>MVC是Model-View-Controller的缩写，其中每个单词都有其不同的含义：</p><ul><li>Modle 代表数据存储层，是对数据表的定义和数据的增删改查；</li><li>View 代表视图层，是系统前端显示部分，它负责显示什么和如何进行显示；</li><li>Controller 代表控制层，负责根据从 View 层输入的指令来检索 Model 层的数据，并在该层编写代码产生结果并输出。<div align="center"><img src="/images/MVC.png" width="400"></div><center>图1 MVC设计模式</center></li></ul><p>MVC 设计模式的请求与响应过程描述如下：</p><ul><li>用户通过浏览器向服务器发起request请求，Controller层接受请求后，同时向Model层和View发送指令；</li><li>Mole 层根据指令与数据库交互并选择相应业务数据，然后将数据发送给 Controller 层；</li><li>View 层接收到 Controller 的指令后，加载用户请求的页面，并将此页面发送给 Controller 层；</li><li>Controller 层接收到 Model 层和 View 层的数据后，将它们组织成响应格式发送给浏览器，浏览器通过解析后把页面展示出来。</li></ul><p>MVC的3层之间紧密相连，但又相互独立，每一层的修改都不会影响其它层，每一层都提供了各自独立的接口供其它层调用，MVC的设计模式降低了代码之间的耦合性（即关联性），增加了模块的可重用性，这就是MVC的设计模式。</p><p>Django借鉴了经典的MVC模式，它也将交互的过程分为了3个层次，也就是MTV设计模式；</p><ul><li>Model：数据存储层，处理所有数据相关的业务，和数据库进行交互，并提供数据的增删改查；</li><li>Template：模板层（也叫表现层）具体来处理页面的显示；</li><li>View：业务逻辑层，处理具体的业务逻辑，它的作用是连通Model 层和 Template 。<div align="center"><img src="/images/MTV.png" width="400"></div><center>图2 MTV设计模式</center></li></ul><p>对MTV设计模式的请求与响应过程进行描述：</p><ul><li>用户通过浏览器对服务器发起 request 请求，服务器接收请求后，通过 View 的业务逻辑层进行分析，同时向 Model 层和 Template 层发送指令；</li><li>Mole层与数据库进行交互，将数据返回给 View 层；</li><li>Template层接收到指令后，调用相应的模板，并返回给 View 层；</li><li>View层接收到模板与数据后，首先对模板进行渲染（即将相应的数据赋值给模板），然后组织成响应格式返回给浏览器，浏览器进行解析后并最终呈现给用户。</li></ul><p>通过以上两种设计模式的比较， 我们可以得出MTV是MVC的一种细化，将原来MVC中的 V层拿出来进行分离，视图的显示与如何显示交给Template层，而View层更专注于实现业务逻辑。</p><h1 id="ORM模块"><a href="#ORM模块" class="headerlink" title="ORM模块"></a>ORM模块</h1><p>ORM（Object Realtional Mapping）即对象关系映射，它是一种基于关系型数据库的程序技术。ORM允许你使用类和对象对数据库进行操作，这大大提高了对数据库的控制，避免了直接使用SQL语句对数据库进行操作。如图3是ORM与数据库的映射关系，ORM 把类映射成数据库中的表，把类的一个实例对象映射成数据库中的数据行，把类的属性映射成表中的字段，通过对象的操作对应到数据库表的操作，实现了对象到 SQL、SQL 到对象转换过程。</p><div align="center"><img src="/images/ORM与DB.png" width="400"></div><center>图3 ORM与DB映射关系</center><p>针对数据库中的字段类型，对应的”xxxField”表述如下表：</p><table>    <tr>        <td>字段</td>        <td>说明</td>        <td>字段属性</td>    </tr>    <tr>        <td>AutoFiled</td>        <td>默然自增主键（Primary_key=Ture），Django 默认建立id字段为主键。</td>        <td></td>    </tr>    <tr>        <td>CharFiled</td>        <td>字符类型</td>        <td>Max_length=32，字符长度需要明确</td>    </tr>    <tr>        <td>InterFiled</td>        <td>整型 int</td>        <td> </td>    </tr>    <tr>        <td>DateFiled</td>        <td>年月日时间类型</td>        <td>auto_now=True，数据被更新就会更新时间 ；auto_now_add=True，数据第一次参数时产生。</td>    </tr>    <tr>    <td>DateTimeFiled</td>        <td>年月日小时分钟秒时间类型</td>        <td>auto_now=True，数据被更新就会更新时间； auto_now_add=True，数据第一次参数时产生。</td>    </tr>    <tr>        <td>DecimalFiled</td>        <td>混合精度的小数类型</td>        <td>max_digits=3，限定数字的最大位数(包含小数位)；decimal_places=2，限制小数的最大位数。</td>    </tr>    <td>BooleanFiled</td>        <td>布尔字段，对应数据库 tinyint 类型数据长度只有1位。</td>        <td>值为True或False</td>        <tr>        <td>TextFiled</td>        <td>用于大文件</td>        <td></td>    </tr></table><h2 id="Filed的通用字段选项"><a href="#Filed的通用字段选项" class="headerlink" title="Filed的通用字段选项"></a>Filed的通用字段选项</h2><p>Model 中添加的字段都是 Field 类型的实例，不同的 Field 类型可能会支持不同的字段选项，但是也有很多字段选项是通用的，即可以用在任何一种 Field 类型中。</p><ul><li>blank：默认值是False，设置为True时，字段可以为空。设置为 False时，字段是必须填写的。如果是字符型字段CharField和TextField，它们是用空字符串来存储空值的</li><li>unique：默认值是 False，它是一个数据库级别的选项，规定该字段在表中必须是唯一的。<blockquote><p>数据库层面对待对待唯一性约束会创建唯一性索引，所以，如果一个字段设置了 unique=True，就不需要对这个字段加上索引选项了。</p></blockquote></li><li>null<br>默认为False，如果此选项为 False建议加入default选项来设置默认值。如果设置为True，表示该列值允许为空。日期型、时间型以及数字型字段不接受空字符串。所以当设置IntegerField，DateTimeField型字段可以为空时，需要将blank与null均设为True。<blockquote><p>对于 CharFiled 和 TextFiled 这样的字符串类型，null 字段应该设置为 False，如果为 Ture，对于空数据就会有两种概念。</p></blockquote></li><li>db_index：默认值是 False，如果设置为 True，Django 则会为该字段创建数据库索引，如果该字段经常作为查询的条件，那么就需要设置 db_index 选项，从而加快数据的检索速度。</li><li>db_column：这个选项用于设置数据库表字段的名称。如果没有指定，Django 默认使用 Model 中字段的名字。</li><li>default：用于给字段设置默认值，该选项可以设置为一个值或者是可以调用对象，但不能是可变对象，不同字段类型默认值也不同，比如 BooleanFiled 布尔类型 default 值为Ture 或者 False。主要的使用场景是当一个字段的值被用户省略时，后台服务器自动为该字段的设置默认值。</li><li>primary_key：默认值是 False，如果设置为 True，表示该字段为主键，在 Django 中 默认 id 为主键，也就是说即使你的数据表中没有创建 id 字段，Django 也会自动为你创建 id 字段并将其设置为主键。如果你在表中设置了其他字段为主键的时，那么 Django 将取消为 id 字段设置主键。</li><li>choices：这个选项用于给字段设置可以选择的值。它是一个可迭代对象，即列表或者元组，其中每一个元素都是一个二元组（a，b）的形式，a是用来选择的对象，b是对a的描述信息。</li><li>verbose_name：设置此字段在 admin后台管理系统界面上的显示名称，如果没有设置这个字段，Django将会直接展示字段名并且将字段中的下划线转变为空格。</li></ul><h1 id="视图函数"><a href="#视图函数" class="headerlink" title="视图函数"></a>视图函数</h1><p> 视图函数是一个 Python 函数或者类，开发者主要通过编写视图函数来实现业务逻辑。视图函数首先接受来自浏览器或者客户端的请求，并最终返回响应，视图函数返回的响应可以是HTML文件，也可以是HTTP协议中的303重定向，如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>http <span class="token keyword">import</span> HttpResponse<span class="token keyword">def</span> <span class="token function">Hello_my_django</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span><span class="token string">'&lt;html>&lt;body>Hello my Django&lt;/body>&lt;/html>'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>1.HttpResponse视图响应类型</strong></p><p>django.http 模块中导入 HttpResponse，从它简单的名字我们可以得知，它是一种视图的响应类型。</p><p><strong>2.视图函数参数request</strong></p><p>视图函数至少有一个参数，第一个参数必须是 request，request是HttpRequest请求类型的对象，它携带了浏览器的请求信息，所以视图函数的第一个参数必须为request。</p><p><strong>3.return视图响应</strong></p><p>视图函数要返回响应内容，这里的响应内容是我们用HTML标签编写的，把它作为HttpResponse的对象返回给浏览器。</p><h1 id="模板系统及应用"><a href="#模板系统及应用" class="headerlink" title="模板系统及应用"></a>模板系统及应用</h1><p>“模板”称之为Template，它的存在使得HTML和 View视图层实现了解耦，在 templates 文件中新建一个 HTML 文件，并且将此文件命名为 hello.html，然后在此文件中书写我们的 HTML 代码，如下所示：</p><p>写HTM代码：</p><pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>{{vaule}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>写视图函数：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>shortcuts <span class="token keyword">import</span> render      <span class="token keyword">def</span> <span class="token function">hello_my_django</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> render<span class="token punctuation">(</span>request<span class="token punctuation">,</span><span class="token string">"hello.html"</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">"vaule"</span><span class="token punctuation">:</span><span class="token string">"hello my Django"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>1.模板传参</strong></p><p>hello.html 文件中的  是一个模板的变量，视图函数必须把数据形成字典的形式才可以传递给模板，这就是“模板传参”。</p><p><strong>2.render方法</strong></p><p>render 是 View 层加载模板的一种方式，它封装在 django.shortcuts 模块中，render 方法使用起来非常方便，它首先加载模板，然后将加载完成的模板响应给浏览器。</p><h1 id="路由系统"><a href="#路由系统" class="headerlink" title="路由系统"></a>路由系统</h1><p>Django 中利用 ROOT_URLCONF 构建了 URL 与视图函数的映射关系。在 django.conf.urls 中封装了路由模块，新建的Django项目中提供了urls.py路由配置文件，urls.py文件中定义了一个 urlpatterns的列表，它是由url( )实例对象组成的列表，Django中url的定义就是在这个列表完成的。后台Admin管理系统的路由就定义在了列表第一个位置，下面我们对路由的语法格进行简单说明：</p><blockquote><p>url(regex,view,name=None)</p></blockquote><p>参数解析如下：</p><ul><li>regex，匹配请求路径，用正则表达式表示；</li><li>view，指定 regex 匹配路径所对应的视图函数的名称；</li><li>name，是给 url 地址起个别名，在模板反向解析的时候使用</li></ul><h2 id="配置URL实现页面访问"><a href="#配置URL实现页面访问" class="headerlink" title="配置URL实现页面访问"></a>配置URL实现页面访问</h2><p>在 urls.py 的同级目录下，新建 views.py 文件，把它作为编写视图函数的 View 层，然后在 views.py 中编写如下代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>http <span class="token keyword">import</span> HttpResponse<span class="token keyword">def</span> <span class="token function">page_view</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>    html<span class="token operator">=</span><span class="token string">'&lt;h1>欢迎来到，C语言中文网，网址是http://c.biancheng.net&lt;/h>'</span>    <span class="token keyword">return</span> HttpResponse<span class="token punctuation">(</span>html<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>目的是把 URL 与视图层进行绑定，然后在urls.py的 urlpatterns 中编写如下代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> django<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>urls <span class="token keyword">import</span> url<span class="token keyword">from</span> django<span class="token punctuation">.</span>contrib <span class="token keyword">import</span> admin<span class="token keyword">from</span> myject <span class="token keyword">import</span> viewsurlpatterns <span class="token operator">=</span> <span class="token punctuation">[</span>    url<span class="token punctuation">(</span>r<span class="token string">'admin/'</span><span class="token punctuation">,</span> admin<span class="token punctuation">.</span>site<span class="token punctuation">.</span>urls<span class="token punctuation">)</span><span class="token punctuation">,</span>    url<span class="token punctuation">(</span>r<span class="token string">'^page$/'</span><span class="token punctuation">,</span>views<span class="token punctuation">.</span>page_view<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web框架 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-并发编程(二)</title>
      <link href="/2020/05/02/bian-cheng-yu-yan/python/python-bing-fa-bian-cheng-2/"/>
      <url>/2020/05/02/bian-cheng-yu-yan/python/python-bing-fa-bian-cheng-2/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池及其原理"><a href="#线程池及其原理" class="headerlink" title="线程池及其原理"></a>线程池及其原理</h1><p>线程池在系统启动时即创建大量空闲的线程，程序只要将一个函数提交给线程池，线程池就会启动一个空闲的线程来执行它。当该函数执行结束后，该线程并不会死亡，而是再次返回到线程池中变成空闲状态，等待执行下一个函数。使用线程池可以有效地控制系统中并发线程的数量。</p><p>当系统中包含有大量的并发线程时，会导致系统性能急剧下降，甚至导致 Python 解释器崩溃，而线程池的最大线程数参数可以控制系统中并发线程的数量不超过此数。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><p>线程池的基类是concurrent.futures模块中的Executor，Executor提供了两个子类，即 ThreadPoolExecutor 和ProcessPoolExecutor，其中ThreadPoolExecutor用于创建线程池，而ProcessPoolExecutor用于创建进程池。使用线程池/进程池来管理并发编程，那么只要将相应的task函数提交给线程池/进程池，剩下的事情就由线程池/进程池来搞定。常用的方法如下：</p><ul><li>submit(fn, <em>args, *</em>kwargs)：将 fn 函数提交给线程池。<em>args 代表传给 fn 函数的参数，</em>kwargs 代表以关键字参数的形式为 fn 函数传入参数。</li><li>map(func, *iterables, timeout=None, chunksize=1)：该函数类似于全局函数 </li><li>map(func, *iterables)，只是该函数将会启动多个线程，以异步方式立即对 iterables 执行 map 处理。</li><li>shutdown(wait=True)：关闭线程池。</li></ul><p>程序将task函数提交（submit）给线程池后，submit方法会返回一个Future对象，Future类主要用于获取线程任务函数的返回值。由于线程任务会在新线程中以异步方式执行，因此，线程执行的函数相当于一个“将来完成”的任务，所以 Python使用Future来代表。提供的方法如下：</p><ul><li>cancel()：取消该 Future 代表的线程任务。如果该任务正在执行，不可取消，则该方法返回 False；否则，程序会取消该任务，并返回 True。</li><li>cancelled()：返回 Future 代表的线程任务是否被成功取消。</li><li>running()：如果该 Future 代表的线程任务正在执行、不可被取消，该方法返回 True。</li><li>done()：如果该 Funture 代表的线程任务被成功取消或执行完成，则该方法返回 True。</li><li>result(timeout=None)：获取该 Future代表的线程任务最后返回的结果。如果Future代表的线程任务还未完成，该方法将会阻塞当前线程，其中 timeout参数指定最多阻塞多少秒。</li><li>exception(timeout=None)：获取该 Future 代表的线程任务所引发的异常。如果该任务成功完成，没有异常，则该方法返回 None。</li><li>add_done_callback(fn)：为该 Future代表的线程任务注册一个“回调函数”，当该任务成功完成时，程序会自动触发该fn函数。</li></ul><p>在用完一个线程池后，应该调用该线程池的shutdown()方法，该方法将启动线程池的关闭序列。调用shutdown()方法后的线程池不再接收新任务，但会将以前所有的已提交任务执行完成。当线程池中的所有任务都执行完成后，该线程池中的所有线程都会死亡。执行线程任务的步骤如下：</p><ul><li>调用ThreadPoolExecutor类的构造器创建一个线程池</li><li>定义一个普通函数作为线程任务</li><li>调用ThreadPoolExecutor 对象的 submit() 方法来提交线程任务。</li><li>当不想提交任何任务时，调用 ThreadPoolExecutor对象的 shutdown() 方法来关闭线程池。</li></ul><p>使用线程池执行线程任务如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures <span class="token keyword">import</span> ThreadPoolExecutor<span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">action</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 准备作为线程任务的函数</span>    my_sum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        my_sum <span class="token operator">+=</span> i    <span class="token keyword">return</span> my_sumpool <span class="token operator">=</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 2条线程的线程池</span>future1 <span class="token operator">=</span> pool<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>action<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 提交一个task，50为action函数</span>future2 <span class="token operator">=</span> pool<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>action<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>future1<span class="token punctuation">.</span>done<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>future2<span class="token punctuation">.</span>done<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 查看结果</span><span class="token keyword">print</span><span class="token punctuation">(</span>future1<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> future2<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 关闭线程池</span>pool<span class="token punctuation">.</span>shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''...ThreadPoolExecutor-0_1 95ThreadPoolExecutor-0_1 96ThreadPoolExecutor-0_1 97ThreadPoolExecutor-0_1 98ThreadPoolExecutor-0_1 99True1225 4950'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="获取执行结果"><a href="#获取执行结果" class="headerlink" title="获取执行结果"></a>获取执行结果</h2><p>程序调用了Future的result()方法来获取线程任务的运回值，但该方法会阻塞当前主线程，只有等到钱程任务完成后，result()方法的阻塞才会被解除。如果程序不希望直接调用result()方法阻塞线程，则可通过Future的 add_done_callback()方法来添加回调函数，该回调函数形如fn(future)。当线程任务完成后，程序会自动触发该回调函数，并将对应的Future对象作为参数传给该回调函数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures <span class="token keyword">import</span> ThreadPoolExecutor<span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">def</span> <span class="token function">action</span><span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">:</span>    my_sum <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>max<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>currentThread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">' '</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>        my_sum <span class="token operator">+=</span> i    <span class="token keyword">return</span> my_sum<span class="token comment" spellcheck="true"># 创建2条线程的线程池</span><span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>    future1 <span class="token operator">=</span> pool<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>action<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span>    future2 <span class="token operator">=</span> pool<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>action<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">get_result</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 添加线程回调函数</span>    future1<span class="token punctuation">.</span>add_done_callback<span class="token punctuation">(</span>get_result<span class="token punctuation">)</span>    future2<span class="token punctuation">.</span>add_done_callback<span class="token punctuation">(</span>get_result<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'-----------'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分别为future1、future2添加回调函数，该回调函数在线程任务结束时获取其返回值。因此主线程不会被阻塞，可以立即看到输出主线程打印出的横线。接下来将会看到两个新线程并发执行，当线程任务执行完成后，get_result()函数被触发，输出线程任务的返回值。Exectuor提供了map(func, *iterables, timeout=None, chunksize=1)方法，会为iterables的每个元素启动一个线程，并发执行func函数。这种方式相当于启动len(iterables)个线程，井收集每个线程的执行结果。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 使用线程执行map计算</span>    <span class="token comment" spellcheck="true"># 后面元组有3个元素，因此程序启动3条线程来执行action函数</span>    results <span class="token operator">=</span> pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>action<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">150</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'--------------'</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> r <span class="token keyword">in</span> results<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序的线程池包含4个线程，如果继续使用只包含两个线程的线程池，此时将有一个任务处于等待状态，必须等其中一个任务完成，线程空闲出来才会获得执行的机会），map()方法的返回值将会收集每个线程任务的返回结果。虽然程序会以并发方式来执行action()函数，但最后收集的action()函数的执行结果，依然与传入参数的结果保持一致。也就是说，上面results的第一个元素是action(50)的结果，第二个元素是action(100) 的结果，第三个元素是action(150) 的结果。</p><h1 id="threading-Local-函数：返回线程局部变量"><a href="#threading-Local-函数：返回线程局部变量" class="headerlink" title="threading Local()函数：返回线程局部变量"></a>threading Local()函数：返回线程局部变量</h1><p>除非必须将多线程使用的资源设置为公共资源，Python threading 模块还提供了一种可彻底避免数据不同步问题的方法，即本节要介绍的 local() 函数。</p><p>使用local()函数创建的变量，可以被各个线程调用，但和公共资源不同，各个线程在使用local()函数创建的变量时，都会在该线程自己的内存空间中拷贝一份。这意味着，local()函数创建的变量看似全局变量（可以被各个线程调用），但各线程调用的都是该变量的副本（各调用各的，之间并无关系）。使用 threading模块中的local()函数，可以为各个线程创建完全属于它们自己的变量（又称线程局部变量）。正是由于各个线程操作的是属于自己的变量，该资源属于各个线程的私有资源，因此可以从根本上杜绝发生数据同步问题。用local()函数的好处，至少有以下2点：</p><ul><li>各个线程操作的都是自己的私有资源，不会涉及到数据同步问题；</li><li>由于local()函数的返回值位于全局作用域，无论在程序什么位置，都可以随时调用，很方便。<h2 id="与互斥锁的区别"><a href="#与互斥锁的区别" class="headerlink" title="与互斥锁的区别"></a>与互斥锁的区别</h2>无论是使用线程局部变量，还是使用互斥锁机制，其根本目的是为了解决多线程访问公共资源时可能发生的数据同步问题。互斥锁机制实现的出发点是，在各线程仍使用公共资源的前提下，想办法控制各个线程对该资源的同时访问；而线程局部变量则另辟蹊径，直接令多线程操作各自的私有资源，从根本上杜绝了同时访问所带来的数据同步问题。</li></ul><p>需要说明的一点是，线程局部变量的解决方案，并不能完全替代互斥锁同步机制。同步机制是为了同步多个线程对公共资源的并发访问，是多个线程之间进行通信的有效方式；而线程局部变量则从根本上避免了多个钱程之间对共享资源（变量）的竞争。如果多线程之间需要共享资源（如多人操作同一银行账户的例子），就使用互斥锁同步机制；反之，如果仅是为了解决多线程之间的共享资源冲突，则推荐使用线程局部变量。</p><h1 id="Timer定时器：控制函数在特定时间执行"><a href="#Timer定时器：控制函数在特定时间执行" class="headerlink" title="Timer定时器：控制函数在特定时间执行"></a>Timer定时器：控制函数在特定时间执行</h1><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 每1s输出一次当前时间</span><span class="token keyword">from</span> threading <span class="token keyword">import</span> Timer<span class="token keyword">import</span> time<span class="token comment" spellcheck="true"># 定义总共输出几次的计数器</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">print_time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"当前时间：%s"</span> <span class="token operator">%</span> time<span class="token punctuation">.</span>ctime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">global</span> t<span class="token punctuation">,</span> count    count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true"># 如果count小于10，开始下一次调度</span>    <span class="token keyword">if</span> count <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">:</span>        t <span class="token operator">=</span> Timer<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> print_time<span class="token punctuation">)</span>        t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 指定1秒后执行print_time函数</span>t <span class="token operator">=</span> Timer<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> print_time<span class="token punctuation">)</span>t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''当前时间：Sat May  2 20:32:07 2020当前时间：Sat May  2 20:32:08 2020当前时间：Sat May  2 20:32:09 2020当前时间：Sat May  2 20:32:10 2020当前时间：Sat May  2 20:32:11 2020当前时间：Sat May  2 20:32:12 2020当前时间：Sat May  2 20:32:13 2020当前时间：Sat May  2 20:32:14 2020当前时间：Sat May  2 20:32:15 2020当前时间：Sat May  2 20:32:16 2020'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="schedule任务调度及用法"><a href="#schedule任务调度及用法" class="headerlink" title="schedule任务调度及用法"></a>schedule任务调度及用法</h1><p>Python 还提供有一个更强大的、可用来定义执行任务调度的 sched 模块，该模块中含有一个 scheduler 类，可用来执行更复杂的任务调度。<br>scheduler类常用的构造方法如下：</p><blockquote><p>scheduler(timefunc=time.monotonic, delayfunc=time.sleep)</p></blockquote><p>可以向该构造方法中传入 2 个参数（当然也可以不提供，因为都有默认值），分别表示的含义如下：</p><ul><li>timefunc：指定生成时间戳的函数，默认使用time.monotonic来生成时间戳；</li><li>delayfunc：在未到达指定时间前，通过该参数可以指定阻塞任务执行的函数，默认采用time.sleep()函数来阻塞程序。</li></ul><p>scheduler类中提供常用的方法有：<br>| 方法格式                                                         | 功能                                                                                                                                                                                                                                                                  |<br>| —————————————————————- | ——————————————————————————————————————————————————————————————————————————————————————— |<br>| scheduler.enter(delay, priority, action, argument=(), kwargs={}) | 在 time 规定的时间后，执行 action 参数指定的函数，其中 argument 和 kwargs 负责为 action 指定的函数传参，priority 参数执行要执行任务的等级，当同一时间点有多个任务需要执行时，等级越高（ priority 值越小）的任务会优先执行。该函数会返回一个 event，可用来取消该任务。 |<br>| scheduler.cancel(event)                                          | 取消 event 任务。注意，如果 event 参数执行的任务不存在，则会引发 ValueError 错误。                                                                                                                                                                                    |<br>| scheduler.run(blocking=True)                                     | 运行所有需要调度的任务。如果调用该方法的 blocking 参数为 True，该方法将会阻塞线程，直到所有被调度的任务都执行完成。                                                                                                                                                   |<br>scheduler类的实例如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">from</span> sched <span class="token keyword">import</span> scheduler<span class="token keyword">def</span> <span class="token function">action</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#定义线程要调用的方法，*add可接收多个以非关键字方式传入的参数</span><span class="token keyword">def</span> <span class="token function">thread_action</span><span class="token punctuation">(</span><span class="token operator">*</span>add<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#创建任务调度对象</span>    sche <span class="token operator">=</span> scheduler<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#定义优先级</span>    i <span class="token operator">=</span> <span class="token number">3</span>    <span class="token keyword">for</span> arc <span class="token keyword">in</span> add<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 指定1秒后执行action函数</span>        sche<span class="token punctuation">.</span>enter<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> action<span class="token punctuation">,</span> argument<span class="token operator">=</span><span class="token punctuation">(</span>arc<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>        i <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span>    <span class="token comment" spellcheck="true">#执行所有调度的任务</span>    sche<span class="token punctuation">.</span>run<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#定义为线程方法传入的参数</span>my_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"http://c.biancheng.net/python/"</span><span class="token punctuation">,</span>\            <span class="token string">"http://c.biancheng.net/shell/"</span><span class="token punctuation">,</span>\            <span class="token string">"http://c.biancheng.net/java/"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#创建线程</span>thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>thread_action<span class="token punctuation">,</span> args<span class="token operator">=</span>my_tuple<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#启动线程</span>thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''http://c.biancheng.net/java/http://c.biancheng.net/shell/http://c.biancheng.net/python/'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="os-fork-方法：创建新进程"><a href="#os-fork-方法：创建新进程" class="headerlink" title="os.fork()方法：创建新进程"></a>os.fork()方法：创建新进程</h1><p>每个 Python 程序在执行时，系统都会生成一个新的进程，该进程又称父进程（或主进程）。在此基础上，Python os 模块还提供有 fork() 函数，该函数可以在当前程序中再创建出一个进程（又称子进程）。</p><p>也就是说，程序中通过引入 os 模块，并调用其提供的 fork() 函数，程序中会拥有 2 个进程，其中父进程负责执行整个程序代码，而通过 fork() 函数创建出的子进程，会从创建位置开始，执行后续所有的程序（包含创建子进程的代码）。语法格式：</p><blockquote><p>pid = os.fork()</p></blockquote><p>其中，pid作为函数的返回值，主进程和子进程都会执行该语句，但主进程执行 fork()函数得到的pid值为非 0 值（其实是子进程的进程ID），而子进程执行该语句得到的pid值为0。因此，pid常常作为区分父进程和子进程的标志。os模块提供了getpid()和getppid()函数，可分别用来获取当前进程的ID号和父进程的ID号。</p><blockquote><p>注意，os.fork() 函数在 Windows 系统上无效，只在 UNIX 及类 UNIX 系统上（包括UNIX、Linux 和 Mac OS X）效。</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'父进程 ID='</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 子进程</span>pid <span class="token operator">=</span> os<span class="token punctuation">.</span>fork<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'当前进程 ID ='</span><span class="token punctuation">,</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">" pid="</span><span class="token punctuation">,</span>pid<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#根据 pid 值，分别为子进程和父进程布置任务</span><span class="token keyword">if</span> pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'子进程, ID='</span><span class="token punctuation">,</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">" 父进程 ID="</span><span class="token punctuation">,</span>os<span class="token punctuation">.</span>getppid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'父进程, ID='</span><span class="token punctuation">,</span>os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">" pid="</span><span class="token punctuation">,</span>pid<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''父进程 ID= 23633当前进程 ID = 23633  pid= 23634父进程, ID= 23633  pid= 23634当前进程 ID = 23634  pid= 0子进程, ID= 23634  父进程 ID= 23633'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Process创建进程"><a href="#Process创建进程" class="headerlink" title="Process创建进程"></a>Process创建进程</h1><p>Python multiprocessing 模块提供了 Process 类，该类可用来在 Windows 平台上创建新进程。和使用 Thread 类创建多线程方法类似，使用 Process 类创建多进程也有以下 2 种方式：</p><ul><li>直接创建Process类的实例对象，由此就可以创建一个新的进程；</li><li>通过继承Process类的子类，创建实例对象，也可以创建新的进程。注意，继承Process类的子类需重写父类的 run()方法。</li></ul><table><thead><tr><th>属性名或方法名</th><th>功能</th></tr></thead><tbody><tr><td>run()</td><td>第2种创建进程的方式需要用到，继承类中需要对方法进行重写，该方法中包含的是新进程要执行的代码。</td></tr><tr><td>start()</td><td>和启动子线程一样，新创建的进程也需要手动启动，该方法的功能就是启动新创建的线程。</td></tr><tr><td>join([timeout])</td><td>和thread类 join() 方法的用法类似，其功能是在多进程执行过程，其他进程必须等到调用 join() 方法的进程执行完毕（或者执行规定的 timeout 时间）后，才能继续执行；</td></tr><tr><td>is_alive()</td><td>判断当前进程是否还活着。</td></tr><tr><td>terminate()</td><td>中断该进程。</td></tr><tr><td>name属性</td><td>可以为该进程重命名，也可以获得该进程的名称。</td></tr><tr><td>daemon</td><td>和守护线程类似，通过设置该属性为 True，可将新建进程设置为“守护进程”。</td></tr><tr><td>pid</td><td>返回进程的 ID 号。大多数操作系统都会为每个进程配备唯一的 ID 号。</td></tr><tr><td>## 通过Process类创建进程</td><td></td></tr><tr><td>使用 Process 类创建实例化对象，其本质是调用该类的构造方法创建新进程。Process 类的构造方法格式如下：</td><td></td></tr></tbody></table><blockquote><p>def <strong>init</strong>(self,group=None,target=None,name=None,args=(),kwargs={})</p></blockquote><p>其中，各个参数的含义为：</p><ul><li>group：该参数未进行实现，不需要传参；</li><li>target：为新建进程指定执行任务，也就是指定一个函数；</li><li>name：为新建进程设置名称；</li><li>args：为 target 参数指定的参数传递非关键字参数；</li><li>kwargs：为 target 参数指定的参数传递关键字参数。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token keyword">import</span> os<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"当前进程ID："</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义一个函数，准备作为新进程的 target 参数</span><span class="token keyword">def</span> <span class="token function">action</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token operator">*</span>add<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token keyword">for</span> arc <span class="token keyword">in</span> add<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s --当前进程%d"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>arc<span class="token punctuation">,</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#定义为进程方法传入的参数</span>    my_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"http://forwardpeng.club/python/"</span><span class="token punctuation">,</span>\                <span class="token string">"http://forwardpeng.club/shell/"</span><span class="token punctuation">,</span>\                <span class="token string">"http://forwardpeng.club/java/"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#创建子进程，执行 action() 函数</span>    my_process <span class="token operator">=</span> Process<span class="token punctuation">(</span>target<span class="token operator">=</span>action<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">"my_process进程"</span><span class="token punctuation">,</span> <span class="token operator">*</span>my_tuple<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#启动子进程</span>    my_process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#主进程执行该函数</span>    action<span class="token punctuation">(</span><span class="token string">"主进程"</span><span class="token punctuation">,</span> <span class="token operator">*</span>my_tuple<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''当前进程ID： 24176主进程http://forwardpeng.club/python/ --当前进程24176http://forwardpeng.club/shell/ --当前进程24176http://forwardpeng.club/java/ --当前进程24176my_process进程http://forwardpeng.club/python/ --当前进程24177http://forwardpeng.club/shell/ --当前进程24177http://forwardpeng.club/java/ --当前进程24177'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通过Process继承类创建进程"><a href="#通过Process继承类创建进程" class="headerlink" title="通过Process继承类创建进程"></a>通过Process继承类创建进程</h2><p>除了直接使用 Process 类创建进程，还可以通过创建 Process 的子类来创建进程。需要注意的是，在创建 Process 的子类时，需在子类内容重写run()方法。实际上，该方法所起到的作用，就如同第一种创建方式中target参数执行的函数。</p><p>另外，通过 Process 子类创建进程，和使用 Process 类一样，先创建该类的实例对象，然后调用 start() 方法启动该进程。下面程序演示如何通过 Process 子类创建一个进程。</p><h1 id="进程启动的3中方法"><a href="#进程启动的3中方法" class="headerlink" title="进程启动的3中方法"></a>进程启动的3中方法</h1><p>启动进程的方式大致可分为以下 3 种：</p><ul><li>spawn：使用此方式启动的进程，只会执行和 target 参数或者 run() 方法相关的代码。Windows 平台只能使用此方法，事实上该平台默认使用的也是该启动方式。相比其他两种方式，此方式启动进程的效率最低。</li><li>fork：使用此方式启动的进程，基本等同于主进程（即主进程拥有的资源，该子进程全都有）。因此，该子进程会从创建位置起，和主进程一样执行程序中的代码。注意，此启动方式仅适用于UNIX平台，os.fork()创建的进程就是采用此方式启动的。</li><li>forserver：使用此方式，程序将会启动一个服务器进程。即当程序每次请求启动新进程时，父进程都会连接到该服务器进程，请求由服务器进程来创建新进程。通过这种方式启动的进程不需要从父进程继承资源。注意，此启动方式只在 UNIX平台上有效。</li></ul><pre class="line-numbers language-python"><code class="language-python">multiprocessing<span class="token punctuation">.</span>set_start_method<span class="token punctuation">(</span><span class="token string">'spawn'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#创建子进程，执行 action() 函数</span>my_process <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target <span class="token operator">=</span> action<span class="token punctuation">,</span> args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"my_process进程"</span><span class="token punctuation">,</span><span class="token operator">*</span>my_tuple<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">###############</span>ctx <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>get_context<span class="token punctuation">(</span><span class="token string">'spawn'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#用 ctx 代替 multiprocessing 模块创建子进程，执行 action() 函数</span>my_process <span class="token operator">=</span> ctx<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target <span class="token operator">=</span> action<span class="token punctuation">,</span> args <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"my_process进程"</span><span class="token punctuation">,</span><span class="token operator">*</span>my_tuple<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>multiprocessing 模块提供的 get_context() 函数来设置进程启动的方法，调用该函数时可传入 “spawn”、”fork”、”forkserver” 作为参数，用来指定进程启动的方式，需用该函数的返回值，代替 multiprocessing模块调用Process()。 </p><h1 id="多进程编程和多线程编程优缺点"><a href="#多进程编程和多线程编程优缺点" class="headerlink" title="多进程编程和多线程编程优缺点"></a>多进程编程和多线程编程优缺点</h1><p>多进程编程和多钱程编程，都可以使用并行机制来提升系统的运行效率。二者的区别在于运行时所占的内存分布不同，多钱程是共用一套内存的代码块区间；而多进程是各用一套独立的内存区间。</p><p>多进程编程也有不足，即创建进程的代价非常大，因为操作系统要给每个进程分配固定的资源，并且操作系统对进程的总数会有一定的限制，若进程过多，操作系统调度都会存在问题，会造成假死状态。多线程编程的优点是效率较高一些，适用于批处理任务等功能；不足之处在于，任何一个线程崩溃都可能造成整个进程的崩溃，因为它们共享了进程的内存资源池。</p><p>既然多线程编程和多进程编程各有优缺点，因此它们分别适用于不同的场景。比如说，对于计算密集型的任务，多进程效率会更高一下；而对于IO密集型的任务（比如文件操作，网络爬虫），采用多线程编程效率更高。</p><p>对于任务数来说，无论是多进程编程或者多线程编程，其进程数或线程数都不能太多：</p><ul><li>对于多进程编程来说，操作系统在切换任务时，会有一系列的保护现场措施，这要花费相当多的系统资源，若任务过多，则大部分资源都被用做干这些了，结果就是所有任务都做不好；</li><li>多线程编程也不是线程个数越多效率越高，通过下面的公式可以计算出线程数量最优的一个参考值。<br>$$ 最佳线程数量 = \frac{线程等待时间+线程CPU时间}{线程CPU时间} * CPU数量$$</li></ul><h1 id="进程池管理进程"><a href="#进程池管理进程" class="headerlink" title="进程池管理进程"></a>进程池管理进程</h1><p>进程池可以提供指定数量的进程给用户使用，即当有新的请求提交到进程池中时，如果池未满，则会创建一个新的进程用来执行该请求；反之，如果池中的进程数已经达到规定最大值，那么该请求就会等待，只要池中有进程空闲下来，该请求就能得到执行。Python multiprocessing 模块提供了 Pool() 函数，专门用来创建一个进程池，该函数的语法格式如下：</p><blockquote><p>multiprocessing.Pool( processes )</p></blockquote><p>其中，processes 参数用于指定该进程池中包含的进程数。如果进程是 None，则默认使用 os.cpu_count() 返回的数字（根据本地的 cpu 个数决定，processes 小于等于本地的 cpu 个数）。注意，Pool() 函数只是用来创建进程池，而 multiprocessing 模块中表示进程池的类是 multiprocessing.pool.Pool 类。该类中提供了一些和操作进程池相关的方法，如下表所示。<br>| 方法名                                                                 | 功能                                                                                                                                         |<br>| ———————————————————————- | ——————————————————————————————————————————————– |<br>| apply( func[, args[, kwds]] )                                          | 将 func 函数提交给进程池处理。其中 args 代表传给 func 的位置参数，kwds 代表传给 func 的关键字参数。该方法会被阻塞直到 func 函数执行完成。    |<br>| apply_async( func[, args[, kwds[, callback[, error_callback]]]] )      | 这是 apply() 方法的异步版本，该方法不会被阻塞。其中 callback 指定 func 函数完成后的回调函数，error_callback 指定 func 函数出错后的回调函数。 |<br>| map( func, iterable[, chunksize] )                                     | 类似于 Python 的 map() 全局函数，只不过此处使用新进程对 iterable 的每一个元素执行 func 函数。                                                |<br>| map_async( func, iterable[, chunksize[, callback[, error_callback]]] ) | 这是 map() 方法的异步版本，该方法不会被阻塞。其中 callback 指定 func 函数完成后的回调函数，error_callback 指定 func 函数出错后的回调函数。   |<br>| imap( func, iterable[, chunksize] )                                    | 这是 map() 方法的延迟版本。                                                                                                                  |<br>| imap_unordered( func, iterable[, chunksize] )                          | 功能类似于 imap() 方法，但该方法不能保证所生成的结果（包含多个元素）与原 iterable 中的元素顺序一致。                                         |<br>| starmap( func, iterable[,chunksize] )                                  | 功能类似于 map() 方法，但该方法要求 iterable 的元素也是 iterable 对象，程序会将每一个元素解包之后作为 func 函数的参数。                      |<br>| close()                                                                | 关闭进程池。在调用该方法之后，该进程池不能再接收新任务，它会把当前进程池中的所有任务执行完成后再关闭自己。                                   |<br>| terminate()                                                            | 立即中止进程池。                                                                                                                             |<br>| join()                                                                 | 等待所有进程完成。                                                                                                                           |</p><h1 id="进程间通信的实现方法-Queue和Pipe"><a href="#进程间通信的实现方法-Queue和Pipe" class="headerlink" title="进程间通信的实现方法(Queue和Pipe)"></a>进程间通信的实现方法(Queue和Pipe)</h1><p>Python 也提供了多种实现进程间通信的机制，主要有以下 2 种：</p><ul><li>Python multiprocessing 模块下的 Queue 类，提供了多个进程之间实现通信的诸多方法；</li><li>Pipe，又被称为“管道”，常用于实现 2 个进程之间的通信，这 2 个进程分别位于管道的两端。</li></ul><h2 id="Queue实现进程间通信"><a href="#Queue实现进程间通信" class="headerlink" title="Queue实现进程间通信"></a>Queue实现进程间通信</h2><p>实现进程间通信，需要使用 multiprocessing 模块中的 Queue 类。原理是使用了操作系统给开辟的一个队列空间，各个进程可以把数据放到该队列中，当然也可以从队列中把自己需要的信息取走。Queue类常用方法有：<br>| 方法名                                      | 功能                                                                                                                                                                                                                                                                                                                                                             |<br>| ——————————————- | —————————————————————————————————————————————————————————————————————————————————————————————————————————————————————- |<br>| put( obj[ ,block=True [ ,timeout=None ] ] ) | 将 obj 放入队列，其中当 block 参数设为 True 时，一旦队列被写满，则代码就会被阻塞，直到有进程取走数据并腾出空间供 obj 使用。timeout 参数用来设置阻塞的时间，即程序最多在阻塞 timeout 秒之后，如果还是没有空闲空间，则程序会抛出 queue.Full 异常。                                                                                                                 |<br>| put_nowait(obj)                             | 该方法的功能等同于 put(obj, False)。                                                                                                                                                                                                                                                                                                                             |<br>| get([block=True , [timeout=None] ])         | 从队列中取数据并返回，当 block 为 True 且 timeout 为 None 时，该方法会阻塞当前进程，直到队列中有可用的数据。如果 block 设为 False，则进程会直接做取数据的操作，如果取数据失败，则抛出 queue.Empty 异常（这种情形下 timeout 参数将不起作用）。如果手动 timeout 秒数，则当前进程最多被阻塞 timeout 秒，如果到时依旧没有可用的数据取出，则会抛出 queue.Empty 异常。 |<br>| get_nowait()                                | 该方法的功能等同于 get(False)。                                                                                                                                                                                                                                                                                                                                  |<br>| empty()                                     | 判断当前队列空间是否为空，如果为空，则该方法返回 True；反之，返回 False。                                                                                                                                                                                                                                                                                        |</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing<span class="token keyword">def</span> <span class="token function">processFun</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>multiprocessing<span class="token punctuation">.</span>current_process<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>pid<span class="token punctuation">,</span> <span class="token string">"进程放数据："</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#将 name 放入队列</span>    queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 创建进程通信的Queue</span>    queue <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 创建子进程</span>    process <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>processFun<span class="token punctuation">,</span>                                      args<span class="token operator">=</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span>                                            <span class="token string">"http://forwardpeng.club/python/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 启动子进程</span>    process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#该子进程必须先执行完毕</span>    process<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>multiprocessing<span class="token punctuation">.</span>current_process<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>pid<span class="token punctuation">,</span> <span class="token string">"取数据："</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''25487 进程放数据： http://forwardpeng.club/python/25486 取数据：http://forwardpeng.club/python/'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Pipe实现进程通信"><a href="#Pipe实现进程通信" class="headerlink" title="Pipe实现进程通信"></a>Pipe实现进程通信</h2><p>Pipe 也常用来实现 2 个进程之间的通信，这 2 个进程分别位于管道的两端，一端用来发送数据，另一端用来接收数据。使用Pipe 实现进程通信，首先需要调用 multiprocessing.Pipe() 函数来创建一个管道。该函数的语法格式如下：</p><blockquote><p>conn1, conn2 = multiprocessing.Pipe( [duplex=True] )</p></blockquote><p>其中，conn1 和 conn2 分别用来接收 Pipe 函数返回的 2 个端口；duplex 参数默认为 True，表示该管道是双向的，即位于 2 个端口的进程既可以发送数据，也可以接受数据，而如果将 duplex 值设为 False，则表示管道是单向的，conn1 只能用来接收数据，而 conn2 只能用来发送数据。<br>conn1 和 conn2 都属于 PipeConnection 对象，它们还可以调用下表所示的这些方法。<br>| 方法名                               | 功能                                                                                                                                                                                                                                                        |<br>| ———————————— | ———————————————————————————————————————————————————————————————————————————————————– |<br>| send(obj)                            | 发送一个 obj 给管道的另一端，另一端使用 recv() 方法接收。需要说明的是，该 obj 必须是可序列化的，如果该对象序列化之后超过 32MB，则很可能会引发 ValueError 异常。                                                                                             |<br>| recv()                               | 接收另一端通过 send() 方法发送过来的数据。                                                                                                                                                                                                                  |<br>| close()                              | 关闭连接。                                                                                                                                                                                                                                                  |<br>| poll([timeout])                      | 返回连接中是否还有数据可以读取。                                                                                                                                                                                                                            |<br>| send_bytes(buffer[, offset[, size]]) | 发送字节数据。如果没有指定 offset、size 参数，则默认发送 buffer 字节串的全部数据；如果指定了 offset 和 size 参数，则只发送 buffer 字节串中从 offset 开始、长度为 size 的字节数据。通过该方法发送的数据，应该使用 recv_bytes() 或 recv_bytes_into 方法接收。 |<br>| recv_bytes([maxlength])              | 接收通过 send_bytes() 方法发送的数据，maxlength 指定最多接收的字节数。该方法返回接收到的字节数据。                                                                                                                                                          |<br>| recv_bytes_into(buffer[, offset])    | 功能与 recv_bytes() 方法类似，只是该方法将接收到的数据放在 buffer 中。                                                                                                                                                                                      |</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing<span class="token keyword">def</span> <span class="token function">processFun</span><span class="token punctuation">(</span>conn<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>multiprocessing<span class="token punctuation">.</span>current_process<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>pid<span class="token punctuation">,</span> <span class="token string">'进程发送数据：'</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>    conn<span class="token punctuation">.</span>send<span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 创建管道</span>    conn1<span class="token punctuation">,</span> conn2 <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Pipe<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 子进程</span>    process <span class="token operator">=</span> multiprocessing<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>target<span class="token operator">=</span>processFun<span class="token punctuation">,</span>                                      args<span class="token operator">=</span><span class="token punctuation">(</span>conn1<span class="token punctuation">,</span> <span class="token string">"http://forwardpeng/club/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 启动</span>    process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>    process<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>multiprocessing<span class="token punctuation">.</span>current_process<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>pid<span class="token punctuation">,</span> <span class="token string">"接收数据："</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>conn2<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''3852 进程发送数据： http://forwardpeng/club/3849 接收数据：http://forwardpeng/club/'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Futures并发编程"><a href="#Futures并发编程" class="headerlink" title="Futures并发编程"></a>Futures并发编程</h1><p>多线程与单线程主要区别如下代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">with</span> concurrent<span class="token punctuation">.</span>futures<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">as</span> executor<span class="token punctuation">:</span>    executor<span class="token punctuation">.</span>map<span class="token punctuation">(</span>download_one<span class="token punctuation">,</span> sites<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>函数ProcessPoolExecutor()表示创建进程池，使用多个进程并行的执行程序。不过，这里通常省略参数workers，因为系统会自动返回 CPU的数量作为可以调用的进程数。</p><p>但是，并行的方式一般用在CPU heavy的场景中，因为对于I/O heavy的操作，多数时间都会用于等待，相比于多线程，使用多进程并不会提升效率。反而很多时候，因为 CPU 数量的限制，会导致其执行效率不如多线程版本。</p><h2 id="什么是Futures"><a href="#什么是Futures" class="headerlink" title="什么是Futures"></a>什么是Futures</h2><p>Python Futures 模块，位于 concurrent.futures 和 asyncio 中，它们都表示带有延迟的操作。Futures 会将处于等待状态的操作包裹起来放到队列中，这些操作的状态随时可以查询，当然它们的结果（或是异常）也能够在操作完成后被获取。通常来说，用户不用考虑如何去创建 Futures，这些 Futures 底层都会帮我们处理好，唯一要做的只是去设定这些 Futures 的执行。比如，Futures 中的 Executor 类，当执行 executor.submit(func) 时，它便会安排里面的 func() 函数执行，并返回创建好的 future 实例，以便之后查询调用。</p><p>这里再介绍一些常用的函数。比如 Futures 中的方法 done()，表示相对应的操作是否完成，返回 True 表示完成；返回 False 表示没有完成。不过要注意的是，done() 是非阻塞的，会立即返回结果。相对应的 add_done_callback(fn)，则表示 Futures 完成后，相对应的参数函数 fn 会被通知并执行调用。Futures 中还有一个重要的函数 result()，它表示当future完成后，返回其对应的结果或异常。而 as_completed(fs)，则是针对给定的 future 迭代器 fs，在其完成后返回完成后的迭代器。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">download_all</span><span class="token punctuation">(</span>sites<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> concurrent<span class="token punctuation">.</span>futures<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">(</span>max_workers<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">as</span> executor<span class="token punctuation">:</span>        to_do <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> site <span class="token keyword">in</span> sites<span class="token punctuation">:</span>            future <span class="token operator">=</span> executor<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>download_one<span class="token punctuation">,</span> site<span class="token punctuation">)</span>            to_do<span class="token punctuation">.</span>append<span class="token punctuation">(</span>future<span class="token punctuation">)</span>        <span class="token keyword">for</span> future <span class="token keyword">in</span> concurrent<span class="token punctuation">.</span>futures<span class="token punctuation">.</span>as_completed<span class="token punctuation">(</span>to_do<span class="token punctuation">)</span><span class="token punctuation">:</span>            future<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>future 列表中每个 future 完成的顺序和它在列表中的顺序并不一定完全一致。到底哪个先完成、哪个后完成，取决于系统的调度和每个 future 的执行时间。</p><h1 id="Asyncio并发编程"><a href="#Asyncio并发编程" class="headerlink" title="Asyncio并发编程"></a>Asyncio并发编程</h1><p>同步，是指操作一个接一个地执行，下一个操作必须等上一个操作执行完成之后才能开始执行；而异步是指不同操作间可以相互交替执行，如果其中地某个操作被堵塞，程序并不会等待，而是会找出可执行的操作继续执行。同步和异步的方式完成的过程如下：</p><ul><li>如果按照同步的方式，应先向软件中输入各项数据，接下来等报表生成，再写邮件提交；</li><li>如果按照异步的方式，向软件中输出各项数据后，会先写邮件，等待报表生成后，暂停写邮件的工作去查看生成的报表，确认无误后在写邮件直到发送完毕。<h2 id="Asyncio的原理"><a href="#Asyncio的原理" class="headerlink" title="Asyncio的原理"></a>Asyncio的原理</h2>假设任务只有两个状态：，分别是预备状态和等待状态：</li><li>预备状态是指任务目前空闲，但随时待命准备运行；</li><li>等待状态是指任务已经运行，但正在等待外部的操作完成，比如 I/O 操作。</li></ul><p>事件循环会维护两个任务列表，分别对应这两种状态，并且选取预备状态的一个任务（具体选取哪个任务，和其等待的时间长短、占用的资源等等相关）使其运行，一直到这个任务把控制权交还给事件循环为止。</p><p>当任务把控制权交还给事件循环对象时，它会根据其是否完成把任务放到预备或等待状态的列表，然后遍历等待状态列表的任务，查看他们是否完成：如果完成，则将其放到预备状态的列表；反之，则继续放在等待状态的列表。而原先在预备状态列表的任务位置仍旧不变，因为它们还未运行。</p><p>这样，当所有任务被重新放置在合适的列表后，新一轮的循环又开始了，事件循环对象继续从预备状态的列表中选取一个任务使其执行…如此周而复始，直到所有任务完成。值得一提的是，对于 Asyncio 来说，它的任务在运行时不会被外部的一些因素打断，因此 Asyncio 内的操作不会出现竞争资源（多个线程同时使用同一资源）的情况，也就不需要担心线程安全的问题了。实现示例如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> aiohttp<span class="token keyword">import</span> time<span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">download_one</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">async</span> <span class="token keyword">with</span> aiohttp<span class="token punctuation">.</span>ClientSession<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> session<span class="token punctuation">:</span>        <span class="token keyword">async</span> <span class="token keyword">with</span> session<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token keyword">as</span> resp<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Read {} from {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>resp<span class="token punctuation">.</span>content_length<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">download_all</span><span class="token punctuation">(</span>sites<span class="token punctuation">)</span><span class="token punctuation">:</span>    tasks <span class="token operator">=</span> <span class="token punctuation">[</span>asyncio<span class="token punctuation">.</span>ensure_future<span class="token punctuation">(</span>download_one<span class="token punctuation">(</span>site<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> site <span class="token keyword">in</span> sites<span class="token punctuation">]</span>    <span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>gather<span class="token punctuation">(</span><span class="token operator">*</span>tasks<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    sites <span class="token operator">=</span> <span class="token punctuation">[</span>        <span class="token string">'http://c.biancheng.net'</span><span class="token punctuation">,</span> <span class="token string">'http://c.biancheng.net/c'</span><span class="token punctuation">,</span>        <span class="token string">'http://c.biancheng.net/python'</span>    <span class="token punctuation">]</span>    start_time <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span>    loop <span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>download_all<span class="token punctuation">(</span>sites<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">finally</span><span class="token punctuation">:</span>        loop<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    end_time <span class="token operator">=</span> time<span class="token punctuation">.</span>perf_counter<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Download {} sites in {} seconds'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>len<span class="token punctuation">(</span>sites<span class="token punctuation">)</span><span class="token punctuation">,</span>                                                   end_time <span class="token operator">-</span> start_time<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''Read None from http://c.biancheng.netRead None from http://c.biancheng.net/pythonRead None from http://c.biancheng.net/cDownload 3 sites in 0.16684959100166452 seconds'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Async 和 await 关键字是 Asyncio 的最新写法，表示这个语句（函数）是非阻塞的，正好对应前面所讲的事件循环的概念，即如果任务执行的过程需要等待，则将其放入等待状态的列表中，然后继续执行预备状态列表里的任务。另外在主函数中，第 22-26 行代码表示拿到事件循环对象，并运行 download_all() 函数，直到其结束，最后关闭这个事件循环对象。和之前多线程版本有很大的区别：</p><ul><li>这里的asyncio.ensure_future(coro) 表示对输入的协程 coro 创建一个任务，安排它的执行，并返回此任务对象。可以看到，这里对每一个网站的下载，都创建了一个对应的任务。</li><li>asyncio.gather()表示在事件循环对象中运行aws序列的所有任务。</li></ul><h1 id="GIL全局解释器锁分析"><a href="#GIL全局解释器锁分析" class="headerlink" title="GIL全局解释器锁分析"></a>GIL全局解释器锁分析</h1><p>实例如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> timestart <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">CountDown</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        n <span class="token operator">-=</span> <span class="token number">1</span>CountDown<span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Time used:"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''Time used: 0.004934000000000001'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将上面的程序改写成多个线程如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time <span class="token keyword">from</span> threading <span class="token keyword">import</span> Threadstart <span class="token operator">=</span> time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">CountDown</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        n <span class="token operator">-=</span> <span class="token number">1</span>t1 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>CountDown<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">100000</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>t2 <span class="token operator">=</span> Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>CountDown<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">100000</span> <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>t1<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>t2<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Time used:"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>clock<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''Time used: 0.005221000000000003'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行效率非但没有提高，反而降低了。因为 GIL 限制了 Python 多线程的性能不会像我们预期的那样。</p><p>GIL是最流程的CPython解释器（平常称为 Python）中的一个技术术语，中文译为全局解释器锁，其本质上类似操作系统的Mutex。GIL的功能是：在CPython解释器中执行的每一个Python线程，都会先锁住自己，以阻止别的线程执行。当然，CPython不可能容忍一个线程一直独占解释器，它会轮流执行 Python 线程。这样一来，用户看到的就是“伪”并行，即 Python 线程在交替执行，来模拟真正并行的线程。</p><p>其实，这和 CPython 的底层内存管理有关。CPython使用引用计数来管理内容，所有Python脚本中创建的实例，都会配备一个引用计数，来记录有多少个指针来指向它。当实例的引用计数的值为0时，会自动释放其所占的内存。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sys<span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> a<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token number">3</span><span class="token comment" spellcheck="true"># a的引用计数值为3，因为有 a、b 和作为参数传递的getrefcount都引用了一个空列表。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>假设有两个Python线程同时引用a，那么双方就都会尝试操作该数据，很有可能造成引用计数的条件竞争，导致引用计数只增加1（实际应增加 2），这造成的后果是，当第一个线程结束时，会把引用计数减少1，此时可能已经达到释放内存的条件（引用计数为 0），当第2个线程再次视图访问a时，就无法找到有效的内存了。</p><h2 id="GIL底层实现"><a href="#GIL底层实现" class="headerlink" title="GIL底层实现"></a>GIL底层实现</h2><div align="center"><img src="/images/GIL工作流.png" width="400"></div> 上图是GIL在Python程序的工作示例。其中，Thread 1、2、3 轮流执行，每一个线程在开始执行时，都会锁住GIL，以阻止别的线程执行；同样的，每一个线程执行完一段后，会释放GIL，以允许别的线程开始利用资源。<p> Python线程在开始执行时锁住 GIL，且永远不去释放 GIL，那别的线程就都没有运行的机会。其实，CPython 中还有另一个机制，叫做间隔式检查（check_interval），意思是 CPython 解释器会去轮询检查线程 GIL 的锁住情况，每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会。</p><pre class="line-numbers language-cpp"><code class="language-cpp"> <span class="token comment" spellcheck="true">//Python线程的循环封装</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>ticker <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ticker <span class="token operator">=</span> check_interval<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">/* Give another thread a chance */</span>        <span class="token function">PyThread_release_lock</span><span class="token punctuation">(</span>interpreter_lock<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/* Other threads may run now */</span>           <span class="token function">PyThread_acquire_lock</span><span class="token punctuation">(</span>interpreter_lock<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    bytecode <span class="token operator">=</span> <span class="token operator">*</span>next_instr<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>bytecode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/* execute the next instruction ... */</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 每个Python线程都会先检查ticker计数。只有在ticker大于0的情况下，线程才会去执行自己的代码。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="GIL不能绝对线程安全"><a href="#GIL不能绝对线程安全" class="headerlink" title="GIL不能绝对线程安全"></a>GIL不能绝对线程安全</h2><p>有了 GIL，并不意味着 Python 程序员就不用去考虑线程安全了，因为即便 GIL 仅允许一个 Python 线程执行，但别忘了 Python 还有 check interval 这样的抢占机制。实例代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threadingn <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> n    n <span class="token operator">+=</span> <span class="token number">1</span>threads <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>foo<span class="token punctuation">)</span>    threads<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token keyword">for</span> t <span class="token keyword">in</span> threads<span class="token punctuation">:</span>    t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> t <span class="token keyword">in</span> threads<span class="token punctuation">:</span>    t<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其大部分时候会打印100，但有时也会打印 99或者98，原因在于n+=1这一句代码让线程并不安全。</p><h1 id="Python垃圾回收机制"><a href="#Python垃圾回收机制" class="headerlink" title="Python垃圾回收机制"></a>Python垃圾回收机制</h1><p>Python程序在运行时，需要在内存中开辟出一块空间，用于存放运行时产生的临时变量，计算完成后，再将结果输出到永久性存储器中。但是当数据量过大，或者内存空间管理不善，就很容易出现内存溢出的情况，程序可能会被操作系统终止。</p><h2 id="引用计数机制"><a href="#引用计数机制" class="headerlink" title="引用计数机制"></a>引用计数机制</h2><p>当这个对象的引用计数值为 0 时，说明这个对象永不再用，自然它就变成了垃圾，需要被回收。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">import</span> psutil<span class="token comment" spellcheck="true"># 显示当前 python 程序占用的内存大小</span><span class="token keyword">def</span> <span class="token function">show_memory_info</span><span class="token punctuation">(</span>hint<span class="token punctuation">)</span><span class="token punctuation">:</span>    pid <span class="token operator">=</span> os<span class="token punctuation">.</span>getpid<span class="token punctuation">(</span><span class="token punctuation">)</span>    p <span class="token operator">=</span> psutil<span class="token punctuation">.</span>Process<span class="token punctuation">(</span>pid<span class="token punctuation">)</span>    info <span class="token operator">=</span> p<span class="token punctuation">.</span>memory_full_info<span class="token punctuation">(</span><span class="token punctuation">)</span>    memory <span class="token operator">=</span> info<span class="token punctuation">.</span>uss <span class="token operator">/</span> <span class="token number">1024</span><span class="token punctuation">.</span> <span class="token operator">/</span> <span class="token number">1024</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'{} memory used: {} MB'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>hint<span class="token punctuation">,</span> memory<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    show_memory_info<span class="token punctuation">(</span><span class="token string">'initial'</span><span class="token punctuation">)</span>    a <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    show_memory_info<span class="token punctuation">(</span><span class="token string">'after a created'</span><span class="token punctuation">)</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span>show_memory_info<span class="token punctuation">(</span><span class="token string">'finished'</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''initial memory used: 8.90234375 MBafter a created memory used: 395.296875 MBfinished memory used: 9.21484375 MB'''</span><span class="token comment" spellcheck="true"># 在函数返回后，局部变量的引用会注销掉，此时列表 a 所指代对象的引用计数为 0，Python 便会执行垃圾回收，因此之前占用的大量内存就又回来了。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>global a表示将a声明为全局变量，则即使函数返回后，列表的引用依然存在，于是a对象就不会被当做垃圾回收掉，依然占用大量内存。Python内部的引用计数机制实例2：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> sysa <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 两次引用，一次来自 a，一次来自 getrefcount</span><span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 四次引用，a，python 的函数调用栈，函数参数，和 getrefcount</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>func<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 两次引用，一次来自 a，一次来自 getrefcount，函数 func 调用已经不存在</span><span class="token keyword">print</span><span class="token punctuation">(</span>sys<span class="token punctuation">.</span>getrefcount<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''242'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>手动垃圾回收需要先调用del a删除一个对象，然后强制调用gc.collect()启动垃圾回收。</p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><p>如果有两个对象，之间互相引用，且不再被别的对象所引用，导致引用数都不为0。示例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    show_memory_info<span class="token punctuation">(</span><span class="token string">'initial'</span><span class="token punctuation">)</span>    a <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    b <span class="token operator">=</span> <span class="token punctuation">[</span>i <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    show_memory_info<span class="token punctuation">(</span><span class="token string">'after a, b created'</span><span class="token punctuation">)</span>    a<span class="token punctuation">.</span>append<span class="token punctuation">(</span>b<span class="token punctuation">)</span>    b<span class="token punctuation">.</span>append<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''initial memory used: 8.90234375 MBafter a, b created memory used: 781.78125 MBfinished memory used: 781.79296875 MB'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Python 使用标记清除（mark-sweep）算法和分代收集（generational），来启用针对循环引用的自动垃圾回收。</p><p>先来看标记清除算法。我们先用图论来理解不可达的概念。对于一个有向图，如果从一个节点出发进行遍历，并标记其经过的所有节点；那么，在遍历结束后，所有没有被标记的节点，我们就称之为不可达节点。显而易见，这些节点的存在是没有任何意义的，自然的，我们就需要对它们进行垃圾回收。当然，每次都遍历全图，对于 Python 而言是一种巨大的性能浪费。所以，在Python的垃圾回收实现中，标记清除算法使用双向链表维护了一个数据结构，并且只考虑容器类的对象（只有容器类对象才有可能产生循环引用）。</p><p>分代收集算法，则是将Python中的所有对象分为三代。刚刚创立的对象是第0代；经过一次垃圾回收后，依然存在的对象，便会依次从上一代挪到下一代。而每一代启动自动垃圾回收的阈值，则是可以单独指定的。当垃圾回收器中新增对象减去删除对象达到相应的阈值时，就会对这一代对象启动垃圾回收。事实上，分代收集基于的思想是，新生的对象更有可能被垃圾回收，而存活更久的对象也有更高的概率继续存活。因此，通过这种做法，可以节约不少计算量，从而提高Python的性能。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-并发编程(一)</title>
      <link href="/2020/04/30/bian-cheng-yu-yan/python/python-bing-fa-bian-cheng/"/>
      <url>/2020/04/30/bian-cheng-yu-yan/python/python-bing-fa-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p>几乎所有的操作系统都支持同时运行多个任务，每个任务通常是一个程序，每一个运行中的程序就是一个进程，即进程是应用程序的执行实例。现代的操作系统几乎都支持多进程并发执行。</p><blockquote><p>并发和并行是两个概念，并行指在同一时刻有多条指令在多个处理器上同时执行；并发是指在同一时刻只能有一条指令执行，但多个进程指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。</p></blockquote><p>线程是进程的组成部分，一个进程可以拥有多个线程。在多线程中，会有一个主线程来完成整个进程从开始到结束的全部操作，而其他的线程会在主线程的运行过程中被创建或退出。进程初始化后，要求有一个主线程，但也可以在进程内创建多个顺序执行流，这些顺序执行流就是线程。</p><blockquote><p>当一个进程里只有一个线程时，叫作单线程。超过一个线程就叫作多线程。</p></blockquote><p>每个线程必须有自己的父进程，且它可以拥有自己的堆栈、程序计数器和局部变量，但不拥有系统资源，因为它和父进程的其他线程共享该进程所拥有的全部资源。线程可以完成一定的任务，可以与其他线程共享父进程中的共享变量及部分环境，相互之间协同完成进程所要完成的任务。</p><blockquote><p>多个线程共享父进程里的全部资源，会使得编程更加方便，需要注意的是，要确保线程不会妨碍同一进程中的其他线程。</p></blockquote><p>线程是独立运行的，它并不知道进程中是否还有其他线程存在。线程的运行是抢占式的，也就是说，当前运行的线程在任何时候都可能被挂起，以便另外一个线程可以运行。多线程也是并发执行的，即同一时刻，Python主程序只允许有一个线程执行，这和全局解释器锁有关系，后续会做详细介绍。</p><p>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发运行。对多线程实现调度和管理以及资源分配，线程的调度和管理由进程本身负责完成。</p><h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>threading模块提供功能丰富的多线程支持，创建线程方式：</p><ul><li>使用threading模块中Thread类的构造器创建线程。即直接对类 threading.Thread进行实例化创建线程，并调用实例化对象的start()方法启动线程。</li><li>继承 threading 模块中的 Thread 类创建线程类。即用 threading.Thread派生出一个新的子类，将新建类实例化创建线程，并调用其start()方法启动线程。<h2 id="调用Thread类的构造器创建线程"><a href="#调用Thread类的构造器创建线程" class="headerlink" title="调用Thread类的构造器创建线程"></a>调用Thread类的构造器创建线程</h2>Thread 类提供了如下的 <strong>init</strong>() 构造器，可以用来创建线程：<blockquote><p>_<em>init_</em>(self, group=None, target=None, name=None, args=(), kwargs=None, *,daemon=None)</p></blockquote></li></ul><p>此构造方法中，以上所有参数都是可选参数，即可以使用，也可以忽略。其中各个参数的含义如下：</p><ul><li>group：指定所创建的线程隶属于哪个线程组（此参数尚未实现，无需调用）；</li><li>target：指定所创建的线程要调度的目标方法（最常用）；</li><li>args：以元组的方式，为target指定的方法传递参数；</li><li>kwargs：以字典的方式，为target指定的方法传递参数；</li><li>daemon：指定所创建的线程是否为后代线程。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Thread类的构造函数创建一个线程</span><span class="token keyword">import</span> threading<span class="token comment" spellcheck="true"># 定义线程要调用的方法，*add可接受多个非关键字方式传入的参数</span><span class="token keyword">def</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token operator">*</span>add<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> arc <span class="token keyword">in</span> add<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 调用getname()方法获取线程名</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>getName<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> arc<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义为线程方法传入的参数</span>my_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"the test1"</span><span class="token punctuation">,</span>\        <span class="token string">"the test2"</span><span class="token punctuation">,</span>\        <span class="token string">"the test3"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建线程</span>thread <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target <span class="token operator">=</span> action<span class="token punctuation">,</span> args<span class="token operator">=</span>my_tuple<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># threading模块提供start()方法启动线程</span>thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''Thread-1 the test1Thread-1 the test2Thread-1 the test3MainThreadMainThread'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>默认情况下，主线程的名字为 MainThread，用户启动的多个线程的名字依次为 Thread-1、Thread-2、Thread-3、…、Thread-n等。如果程序中不显式创建任何线程，则所有程序的执行，都将由主线程 MainThread 完成，程序就只能按照顺序依次执行。</p></blockquote><p>当前程序中有2个线程，分别为主线程 MainThread 和子线程 Thread-1，它们以并发方式执行，即 Thread-1 执行一段时间，然后 MainThread 执行一段时间。通过轮流获得CPU执行一段时间的方式，程序的执行在多个线程之间切换，从而给用户一种错觉，即多个线程似乎同时在执行。</p><h2 id="继承Thread类创建线程类"><a href="#继承Thread类创建线程类" class="headerlink" title="继承Thread类创建线程类"></a>继承Thread类创建线程类</h2><p>通过继承 Thread 类，我们可以自定义一个线程类，从而实例化该类对象，获得子线程。需要注意的是，在创建 Thread类的子类时，必须重写从父类继承得到的run()方法。因为该方法即为要创建的子线程执行的方法，其功能如同第一种创建方法中的action()自定义函数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token comment" spellcheck="true"># 创建子线程</span><span class="token keyword">class</span> <span class="token class-name">my_thread</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> add<span class="token punctuation">)</span><span class="token punctuation">:</span>        threading<span class="token punctuation">.</span>Thread<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>add <span class="token operator">=</span> add    <span class="token comment" spellcheck="true"># 重写run()方法</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> arc <span class="token keyword">in</span> self<span class="token punctuation">.</span>add<span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 调用getName()方法获取当前执行该程序的线程名</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>getName<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> arc<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义run()方法的参数</span>my_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"The test1"</span><span class="token punctuation">,</span> <span class="token string">"The test2"</span><span class="token punctuation">,</span> <span class="token string">"The test3"</span><span class="token punctuation">)</span>mythread <span class="token operator">=</span> my_thread<span class="token punctuation">(</span>my_tuple<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 启动</span>mythread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 主线程</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>getName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''Thread-1 The test1Thread-1 The test2Thread-1 The test3MainThreadMainThread'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="线程的生命周期-新建、就绪、运行、阻塞和死亡"><a href="#线程的生命周期-新建、就绪、运行、阻塞和死亡" class="headerlink" title="线程的生命周期(新建、就绪、运行、阻塞和死亡)"></a>线程的生命周期(新建、就绪、运行、阻塞和死亡)</h1><p>CPU 在轮换执行线程过程中，线程都经历了什么呢？线程从创建到消亡的整个过程，可能会历经 5 种状态，分别是新建、就绪、运行、阻塞和死亡，如图 1 所示。</p><div align="center"><img src="/images/xiancheng.png" width="400"></div> <center>图 1 线程状态转换图</center><h2 id="线程的新建和就绪状态"><a href="#线程的新建和就绪状态" class="headerlink" title="线程的新建和就绪状态"></a>线程的新建和就绪状态</h2><p> 所谓就绪，就是告诉 CPU，该线程已经可以执行了，但是具体什么时候执行，取决于 CPU 什么时候调度它。换句话说，如果一个线程处于就绪状态，只能说明此线程已经做好了准备，随时等待 CPU 调度执行，并不是说执行了 start() 方法此线程就会立即被执行。</p><blockquote><p>一方面 Python解释器会将它们看做是普通的函数调用和类方法调用。另一方面，由于新建的线程属于新建状态而不是就绪状态，因此不会得到 CPU 的调度。</p></blockquote><h2 id="线程的运行和阻塞状态"><a href="#线程的运行和阻塞状态" class="headerlink" title="线程的运行和阻塞状态"></a>线程的运行和阻塞状态</h2><p> 如果当前有多个线程处于就绪状态（等待 CPU 调度）时，处于运行状态的线程将无法一直霸占 CPU 资源，为了使其它线程也有执行的机会，CPU 会在一定时间内强制当前运行的线程让出 CPU 资源，以供其他线程使用。而对于获得 CPU 调度却没有执行完毕的线程，就会进入阻塞状态。</p><p>如果处于运行状态的线程发生如下几种情况，也将会由运行状态转到阻塞状态：</p><ul><li>线程调用了 sleep() 方法；</li><li>线程等待接收用户输入的数据；</li><li>线程试图获取某个对象的同步锁（后续章节会详细讲解）时，如果该锁被其他线程所持有，则当前线程进入阻塞状态；</li><li>线程调用 wait() 方法，等待特定条件的满足；</li></ul><p>该线程才会有阻塞状态转到就绪状态，继续等待 CPU 调度（如图 1 所示）。以上 4 种可能发生线程阻塞的情况，解决措施分别如下：</p><ul><li>sleep() 方法规定的时间已过；</li><li>线程接收到了用户输入的数据；</li><li>其他线程释放了该同步锁，并由该线程获得；</li><li>调用set()方法发出通知；</li></ul><h2 id="线程死亡状态"><a href="#线程死亡状态" class="headerlink" title="线程死亡状态"></a>线程死亡状态</h2><p>执行结束的线程将处于死亡状态。线程执行结束，除了正常执行结束外，如果程序执行过程发生异常（Exception）或者错误（Error），线程也会进入死亡状态。对于处于死亡状态的线程，有以下2点需要注意：</p><ul><li>主线程死亡，并不意味着所有线程全部死亡。也就是说，主线程的死亡，不会影响子线程继续执行；反之也是如此。</li><li>对于死亡的线程，无法再调用start()方法使其重新启动，否则Python解释器将抛出RuntimeError异常。</li></ul><h1 id="Thread-join-用法"><a href="#Thread-join-用法" class="headerlink" title="Thread join()用法"></a>Thread join()用法</h1><p>join() 方法的功能是在程序指定位置，优先让该方法的调用者使用 CPU 资源。该方法的语法格式如下：</p><blockquote><p>thread.join( [timeout] )</p></blockquote><p>其中，thread 为 Thread 类或其子类的实例化对象；timeout 参数作为可选参数，其功能是指定 thread 线程最多可以霸占 CPU 资源的时间（以秒为单位），如果省略，则默认直到 thread 执行结束（进入死亡状态）才释放 CPU 资源。</p><h1 id="daemon守护线程"><a href="#daemon守护线程" class="headerlink" title="daemon守护线程"></a>daemon守护线程</h1><p>当程序中拥有多个线程时，主线程执行结束并不会影响子线程继续执行。换句话说，只有程序中所有线程全部执行完毕后，程序才算真正结束。</p><p>除此之外，Python 还支持创建另一种线程，称为守护线程（或后台线程）。此类线程的特点是，当程序中主线程及所有非守护线程执行结束时，未执行完毕的守护线程也会随之消亡（进行死亡状态），程序将结束运行。</p><blockquote><p>Python 解释器的垃圾回收机制就是守护线程的典型代表，当程序中所有主线程及非守护线程执行完毕后，垃圾回收机制也就没有再继续执行的必要了。</p></blockquote><p>通过调用thread线程的daemon属性并赋值为True，则该 thread 线程就变成了守护线程。</p><blockquote><p>thread.daemon = True</p></blockquote><h1 id="sleep-函数：线程睡眠"><a href="#sleep-函数：线程睡眠" class="headerlink" title="sleep()函数：线程睡眠"></a>sleep()函数：线程睡眠</h1><p>位于 time 模块中的 sleep(secs) 函数，可以实现令当前执行的线程暂停 secs 秒后再继续执行。所谓暂停，即令当前线程进入阻塞状态，当达到 sleep() 函数规定的时间后，再由阻塞状态转为就绪状态，等待CPU调度。需要先引入time模块，语法规则如下：</p><blockquote><p>time.sleep(secs) # secs参数用于指定暂停秒数</p></blockquote><h1 id="互斥锁-Lock-：解决多线程安全问题"><a href="#互斥锁-Lock-：解决多线程安全问题" class="headerlink" title="互斥锁(Lock)：解决多线程安全问题"></a>互斥锁(Lock)：解决多线程安全问题</h1><p>多线程的优势在于并发性，即可以同时运行多个任务。但是当线程需要使用共享数据时，也可能会由于数据不同步产生“错误情况”，这是由系统的线程调度具有一定的随机性造成的。银行取钱的基本流程可以分为如下几个步骤：</p><ul><li>用户输入账户、密码，系统判断用户的账户、密码是否匹配。</li><li>用户输入取款金额。</li><li>系统判断账户余额是否大于取款金额。</li><li>如果余额大于取款金额，则取款成功；如果余额小于取款金额，则取款失败。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 模拟银行取钱</span><span class="token keyword">class</span> <span class="token class-name">Account</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 定义构造器</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> account_no<span class="token punctuation">,</span> balance<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>account_no <span class="token operator">=</span> account_no        self<span class="token punctuation">.</span>balance <span class="token operator">=</span> balance<span class="token comment" spellcheck="true"># 启动两个线程取钱</span><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">import</span> Account<span class="token comment" spellcheck="true"># 定义一个函数来模拟取钱操作</span><span class="token keyword">def</span> <span class="token function">draw</span><span class="token punctuation">(</span>account<span class="token punctuation">,</span> draw_amount<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 账户余额大于取钱数目</span>    <span class="token keyword">if</span> account<span class="token punctuation">.</span>balance <span class="token operator">>=</span> draw_amount<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 吐出钞票</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name\            <span class="token operator">+</span> <span class="token string">"取钱成功！吐出钞票:"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>draw_amount<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#        time.sleep(0.001)</span>        <span class="token comment" spellcheck="true"># 修改余额</span>        account<span class="token punctuation">.</span>balance <span class="token operator">-=</span> draw_amount        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\t余额为: "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>account<span class="token punctuation">.</span>balance<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name\            <span class="token operator">+</span> <span class="token string">"取钱失败！余额不足！"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个账户</span>acct <span class="token operator">=</span> Account<span class="token punctuation">.</span>Account<span class="token punctuation">(</span><span class="token string">"1234567"</span> <span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 模拟两个线程对同一个账户取钱</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'甲'</span><span class="token punctuation">,</span> target<span class="token operator">=</span>draw <span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>acct <span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'乙'</span><span class="token punctuation">,</span> target<span class="token operator">=</span>draw <span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>acct <span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''甲取钱成功！吐出钞票:800乙取钱成功！吐出钞票:800        余额为: 200        余额为: -600'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>账户余额只有1000元时取出了 1600 元，而且账户余额出现了负值，远不是银行所期望的结果。虽然上面程序是人为地使用 time.sleep(0.001) 来强制线程调度切换，但这种切换也是完全可能发生的（100000 次操作只要有 1 次出现了错误，那就是由编程错误引起的）。</p><h2 id="Python互斥锁同步线程"><a href="#Python互斥锁同步线程" class="headerlink" title="Python互斥锁同步线程"></a>Python互斥锁同步线程</h2><p>run()方法的方法体不具有线程安全性，程序中有两个并发线程在修改Account对象，而且系统恰好在注释代码处执行线程切换，切换到另一个修改Account对象的线程，所以就出现了问题。为了解决这个问题，Python 的threading模块引入了互斥锁（Lock）。threading 模块提供了Lock和RLoc 两个类，它们都提供了如下两个方法来加互斥锁和释放互斥锁：</p><ul><li>acquire(blocking=True, timeout=-1)：请求对 Lock或RLock加锁，其中timeout参数指定加锁多少秒。</li><li>release()：释放锁。</li></ul><p>Lock和RLock的区别如下：</p><ul><li>threading.Lock：它是一个基本的锁对象，每次只能锁定一次，其余的锁请求，需等待锁释放后才能获取。</li><li>threading.RLock：它代表可重入锁（Reentrant Lock）。对于可重入锁，在同一个线程中可以对它进行多次锁定，也可以多次释放。如果使用 RLock，那么 acquire()和release()方法必须成对出现。如果调用了n次acquire()加锁，则必须调用n次release()才能释放锁。</li></ul><p>RLock锁具有可重入性。也就是说，同一个线程可以对已被加锁的RLock锁再次加锁，RLock对象会维持一个计数器来追踪acquire()方法的嵌套调用，线程在每次调用acquire()加锁后，都必须显式调用release()方法来释放锁。所以，一段被锁保护的方法可以调用另一个被相同锁保护的方法。</p><p>Lock是控制多个线程对共享资源进行访问的工具。通常，锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程在开始访问共享资源之前应先请求获得Lock对象。当对共享资源访问完成后，程序释放对Lock对象的锁定。RLock代码格式如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">X</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 保证线程安全</span>    <span class="token keyword">def</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 加锁</span>        self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 需要保证线程安全的代码</span>            <span class="token comment" spellcheck="true">#...方法体</span>        <span class="token comment" spellcheck="true"># finally块保证释放锁</span>        <span class="token keyword">finally</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 修改完成，释放锁</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用RLock对象来控制线程安全，当加锁和释放锁出现在不同的作用范围内时，通常建议使用finally块来确保在必要时释放锁。通过使用 Lock 对象可以非常方便地实现线程安全的类，线程安全的类具有如下特征：</p><ul><li>该类的对象可以被多个线程安全地访问。</li><li>每个线程在调用该对象的任意方法之后，都将得到正确的结果。</li><li>每个线程在调用该对象的任意方法之后，该对象都依然保持合理的状态。</li></ul><p>总的来说，不可变类总是线程安全的，因为它的对象状态不可改变；但可变对象需要额外的方法来保证其线程安全。例如，上面的 Account 就是一个可变类，它的self.account_no和self._balance（为了更好地封装，将 balance改名为_balance）两个成员变量都可以被改变，当两个钱程同时修改Account对象的self._balance成员变量的值时，程序就出现了异常。下面将Account类对self.balance的访问设置成线程安全的，那么只需对修改self.balance的方法增加线程安全的控制即可。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 启动两个线程取钱</span><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">account</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 定义构造器</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> account_no<span class="token punctuation">,</span> balance<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>account_no <span class="token operator">=</span> account_no        self<span class="token punctuation">.</span>_balance <span class="token operator">=</span> balance        self<span class="token punctuation">.</span>lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>RLock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">getBalance</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_balance    <span class="token comment" spellcheck="true"># 定义一个函数来模拟取钱操作</span>    <span class="token keyword">def</span> <span class="token function">draw</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> draw_amount<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 加锁</span>        self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 账户余额大于取钱数目</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>_balance <span class="token operator">>=</span> draw_amount<span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 吐出钞票</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name\                    <span class="token operator">+</span> <span class="token string">"取钱成功！吐出钞票:"</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>draw_amount<span class="token punctuation">)</span><span class="token punctuation">)</span>                time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.001</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># 修改余额</span>                self<span class="token punctuation">.</span>_balance <span class="token operator">-=</span> draw_amount                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"\t余额为: "</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_balance<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name\                    <span class="token operator">+</span> <span class="token string">"取钱失败！余额不足！"</span><span class="token punctuation">)</span>        <span class="token keyword">finally</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 修改完成，释放锁</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">draw</span><span class="token punctuation">(</span>account<span class="token punctuation">,</span> draw_amount<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 直接调用account对象的draw()方法来执行取钱操作</span>    account<span class="token punctuation">.</span>draw<span class="token punctuation">(</span>draw_amount<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个账户</span>acct <span class="token operator">=</span> account<span class="token punctuation">(</span><span class="token string">"1234567"</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 模拟两个线程对同一个账户取钱</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'甲'</span><span class="token punctuation">,</span> target<span class="token operator">=</span>draw<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>acct<span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'乙'</span><span class="token punctuation">,</span> target<span class="token operator">=</span>draw<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>acct<span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''甲取钱成功！吐出钞票:800                            余额为: 200乙取钱失败！余额不足！'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可变类的线程安全是以降低程序的运行效率作为代价的，为了减少线程安全所带来的负面影响，程序可以采用如下策略：</p><ul><li>不要对线程安全类的所有方法都进行同步，只对那些会改变竞争资源（竞争资源也就是共享资源）的方法进行同步。例如，上面Account类中的account_no实例变量就无须同步，所以程序只对draw()方法进行了同步控制。</li><li>如果可变类有两种运行环境，单线程环境和多线程环境，则应该为该可变类提供两种版本，即线程不安全版本和线程安全版本。在单线程环境中使用钱程不安全版本以保证性能，在多线程环境中使用线程安全版本。</li></ul><h1 id="死锁，如何避免死锁"><a href="#死锁，如何避免死锁" class="headerlink" title="死锁，如何避免死锁"></a>死锁，如何避免死锁</h1><p>当两个线程相互等待对方释放资源时，就会发生死锁。Python 解释器没有监测，也不会主动采取措施来处理死锁情况，所以在进行多线程编程时应该采取措施避免出现死锁。</p><blockquote><p>一旦出现死锁，整个程序既不会发生任何异常，也不会给出任何提示，只是所有线程都处于阻塞状态，无法继续。</p></blockquote><p>在系统中出现多个同步监视器，容易出现死锁：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>RLock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"当前线程名: "</span> <span class="token operator">+</span> threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name\                <span class="token operator">+</span> <span class="token string">" 进入了A实例的foo()方法"</span> <span class="token punctuation">)</span>     <span class="token comment" spellcheck="true"># ①</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"当前线程名: "</span> <span class="token operator">+</span> threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name\                <span class="token operator">+</span> <span class="token string">" 企图调用B实例的last()方法"</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># ③</span>            b<span class="token punctuation">.</span>last<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">finally</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">last</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"进入了A类的last()方法内部"</span><span class="token punctuation">)</span>        <span class="token keyword">finally</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>RLock<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"当前线程名: "</span> <span class="token operator">+</span> threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name\                <span class="token operator">+</span> <span class="token string">" 进入了B实例的bar()方法"</span> <span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># ②</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"当前线程名: "</span> <span class="token operator">+</span> threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name\                <span class="token operator">+</span> <span class="token string">" 企图调用A实例的last()方法"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># ④</span>            a<span class="token punctuation">.</span>last<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">finally</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">last</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">try</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"进入了B类的last()方法内部"</span><span class="token punctuation">)</span>        <span class="token keyword">finally</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span>b <span class="token operator">=</span> B<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"主线程"</span>    <span class="token comment" spellcheck="true"># 调用a对象的foo()方法</span>    a<span class="token punctuation">.</span>foo<span class="token punctuation">(</span>b<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"进入了主线程之后"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"副线程"</span>    <span class="token comment" spellcheck="true"># 调用b对象的bar()方法</span>    b<span class="token punctuation">.</span>bar<span class="token punctuation">(</span>a<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"进入了副线程之后"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 以action为target启动新线程</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>action<span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 调用init()函数</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序中 A 对象和 B 对象的方法都是线程安全的方法。程序中有两个线程执行，副线程的线程执行体是 action() 函数，主线程的线程执行体是 init() 函数（主程序调用了 init() 函数）。其中在 action() 函数中让 B 对象调用 bar() 方法，而在 init() 函数中让 A 对象调用 foo() 方法。</p><p>图 1 显示 action() 函数先执行，调用了 B 对象的 bar() 方法，在进入 bar() 方法之前，该线程对 B 对象的 Lock 加锁（当程序执行到 ② 号代码时，副线程暂停 0.2s）；CPU 切换到执行另一个线程，让 A 对象执行 foo() 方法，所以看到主线程开始执行 A 实例的 foo() 方法，在进入 foo() 方法之前，该线程对 A 对象的 Lock 加锁（当程序执行到 ① 号代码时，主线程也暂停 0.2s）。</p><p>接下来副线程会先醒过来，继续向下执行，直到执行到 ④ 号代码处希望调用 A 对象的 last() 方法（在执行该方法之前，必须先对 A 对象的 Lock 加锁），但此时主线程正保持着 A 对象的 Lock 的锁定，所以副线程被阻塞。</p><p>接下来主线程应该也醒过来了，继续向下执行，直到执行到 ③ 号代码处希望调用 B 对象的 last() 方法（在执行该方法之前，必须先对 B 对象的 Lock 加锁），但此时副线程没有释放对 B 对象的 Lock 的锁定。</p><p>至此，就出现了主线程保持着 A 对象的锁，等待对 B 对象加锁，而副线程保持着 B对象的锁，等待对 A 对象加锁，两个线程互相等待对方先释放锁，所以就出现了死锁。</p><p>死锁是不应该在程序中出现的，在编写程序时应该尽量避免出现死锁。下面有几种常见的方式用来解决死锁问题：</p><ul><li>避免多次锁定。尽量避免同一个线程对多个 Lock 进行锁定。例如上面的死锁程序，主线程要对 A、B 两个对象的 Lock 进行锁定，副线程也要对 A、B 两个对象的 Lock 进行锁定，这就埋下了导致死锁的隐患。</li><li>具有相同的加锁顺序。如果多个线程需要对多个 Lock 进行锁定，则应该保证它们以相同的顺序请求加锁。比如上面的死锁程序，主线程先对 A 对象的 Lock 加锁，再对 B 对象的 Lock 加锁；而副线程则先对 B 对象的 Lock 加锁，再对 A 对象的 Lock 加锁。这种加锁顺序很容易形成嵌套锁定，进而导致死锁。如果让主线程、副线程按照相同的顺序加锁，就可以避免这个问题。</li><li>使用定时锁。程序在调用 acquire() 方法加锁时可指定 timeout 参数，该参数指定超过 timeout 秒后会自动释放对 Lock 的锁定，这样就可以解开死锁了。</li><li>死锁检测。死锁检测是一种依靠算法机制来实现的死锁预防机制，它主要是针对那些不可能实现按序加锁，也不能使用定时锁的场景的。</li></ul><h1 id="condition实现线程通信"><a href="#condition实现线程通信" class="headerlink" title="condition实现线程通信"></a>condition实现线程通信</h1><p>线程的调度具有一定的透明性，通常程序无法准确控制线程的轮换执行，如果有需要，Python可通过线程通信来保证线程协调运行。<br>假设系统中有两个线程，这两个线程分别代表存款者和取钱者，现在假设系统有一种特殊的要求，即要求存款者和取钱者不断地重复存款、取钱的动作，而且要求每当存款者将钱存入指定账户后，取钱者就立即取出该笔钱。不允许存款者连续两次存钱，也不允许取钱者连续两次取钱。</p><p><font color="red">为了实现这种功能，可以借助于 Condition 对象来保持协调。使用 Condition 可以让那些己经得到 Lock 对象却无法继续执行的线程释放 Lock 对象，Condition 对象也可以唤醒其他处于等待状态的线程。</font></p><p>将Condition对象与Lock对象组合使用，可以为每个对象提供多个等待集（wait-set）。因此，Condition对象总是需要有对应的Lock对象。从Condition的构造器 <strong>init</strong>(self, lock=None) 可以看出，程序在创建 Condition 时可通过 lock 参数传入要绑定的 Lock 对象；如果不指定 lock 参数，在创建 Condition 时它会自动创建一个与之绑定的 Lock 对象。Condition类提供了如下方法：</p><ul><li>acquire([timeout])/release()：调用 Condition 关联的 Lock 的 acquire() 或 release() 方法。</li><li>wait([timeout])：导致当前线程进入 Condition 的等待池等待通知并释放锁，直到其他线程调用该  Condition 的 notify() 或 notify_all() 方法来唤醒该线程。在调用该 wait() 方法时可传入一个 timeout 参数，指定该线程最多等待多少秒。</li><li>notify()：唤醒在该 Condition 等待池中的单个线程并通知它，收到通知的线程将自动调用 acquire() 方法尝试加锁。如果所有线程都在该 Condition 等待池中等待，则会选择唤醒其中一个线程，选择是任意性的。</li><li>notify_all()：唤醒在该 Condition 等待池中等待的所有线程并通知它们。</li></ul><h1 id="Queue-队列实现线程通信"><a href="#Queue-队列实现线程通信" class="headerlink" title="Queue 队列实现线程通信"></a>Queue 队列实现线程通信</h1><p>queue 模块下主要提供了三个类，分别代表三种队列，它们的主要区别就在于进队列、出队列的不同。关于这三个队列类的简单介绍如下：</p><ul><li>queue.Queue(maxsize=0)：代表 FIFO（先进先出）的常规队列，maxsize 可以限制队列的大小。如果队列的大小达到队列的上限，就会加锁，再次加入元素时就会被阻塞，直到队列中的元素被消费。如果将 maxsize 设置为 0 或负数，则该队列的大小就是无限制的。</li><li>queue.LifoQueue(maxsize=0)：代表 LIFO（后进先出）的队列，与 Queue 的区别就是出队列的顺序不同。</li><li>PriorityQueue(maxsize=0)：代表优先级队列，优先级最小的元素先出队列。</li></ul><p>三个队列类的属性和方法基本相同，提供了如下属性和方法：</p><ul><li>Queue.qsize()：返回队列的实际大小，也就是该队列中包含几个元素。</li><li>Queue.empty()：判断队列是否为空。</li><li>Queue.full()：判断队列是否已满。</li><li>Queue.put(item, block=True, timeout=None)：向队列中放入元素。如果队列己满，且 block 参数为 True（阻塞），当前线程被阻塞，timeout 指定阻塞时间，如果将 timeout 设置为 None，则代表一直阻塞，直到该队列的元素被消费；如果队列己满，且 block 参数为 False（不阻塞），则直接引发 queue.FULL 异常。</li><li>Queue.put_nowait(item)：向队列中放入元素，不阻塞。相当于在上一个方法中将 block 参数设置为 False。</li><li>Queue.get(item, block=True, timeout=None)：从队列中取出元素（消费元素）。如果队列已满，且 block 参数为 True（阻塞），当前线程被阻塞，timeout 指定阻塞时间，如果将 timeout 设置为 None，则代表一直阻塞，直到有元素被放入队列中； 如果队列己空，且 block 参数为 False（不阻塞），则直接引发 queue.EMPTY 异常。</li><li>Queue.get_nowait(item)：从队列中取出元素，不阻塞。相当于在上一个方法中将block参数设置为False。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> queuebq <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 长度为2的阻塞队列</span>bq<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"Python"</span><span class="token punctuation">)</span>bq<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"Python"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"1111111111"</span><span class="token punctuation">)</span>bq<span class="token punctuation">.</span>put<span class="token punctuation">(</span><span class="token string">"Python"</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># ① 阻塞线程</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"2222222222"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 当程序试图放入第三个元素时，如果使用 put() 方法尝试放入元素将会阻塞线程</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在下面程序中就可以利用Queue来实现线程通信了。如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> time<span class="token keyword">import</span> queue<span class="token keyword">def</span> <span class="token function">product</span><span class="token punctuation">(</span>bq<span class="token punctuation">)</span><span class="token punctuation">:</span>    str_tuple <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Python"</span><span class="token punctuation">,</span> <span class="token string">"Kotlin"</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">99999</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"生产者准备生产元组元素！"</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true"># 尝试放入元素，如果队列已满，则线程被阻塞</span>        bq<span class="token punctuation">.</span>put<span class="token punctuation">(</span>str_tuple<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name \            <span class="token operator">+</span> <span class="token string">"生产者生产元组元素完成！"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">consume</span><span class="token punctuation">(</span>bq<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">"消费者准备消费元组元素！"</span><span class="token punctuation">)</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 尝试取出元素，如果队列已空，则线程被阻塞</span>        t <span class="token operator">=</span> bq<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name \            <span class="token operator">+</span> <span class="token string">"消费者消费[ %s ]元素完成！"</span> <span class="token operator">%</span> t<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 创建一个容量为1的Queue</span>bq <span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span>maxsize<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 启动3个生产者线程</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>product<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>bq<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>product<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>bq<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>product<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>bq<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 启动一个消费者线程</span>threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>consume<span class="token punctuation">,</span> args<span class="token operator">=</span><span class="token punctuation">(</span>bq<span class="token punctuation">,</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''Thread-4消费者消费[ Kotlin ]元素完成！Thread-2生产者生产元组元素完成！Thread-2生产者准备生产元组元素！Thread-4消费者准备消费元组元素！Thread-4消费者消费[ Python ]元素完成！Thread-1生产者生产元组元素完成！'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Event实现线程通信"><a href="#Event实现线程通信" class="headerlink" title="Event实现线程通信"></a>Event实现线程通信</h1><p>Event 本身管理一个内部旗标，程序可以通过 Event 的 set() 方法将该旗标设置为 True，也可以调用 clear() 方法将该旗标设置为 False。程序可以调用 wait() 方法来阻塞当前线程，直到 Event 的内部旗标被设置为 True。Event提供了如下方法：</p><ul><li>is_set()：该方法返回 Event 的内部旗标是否为True。</li><li>set()：该方法将会把 Event 的内部旗标设置为 True，并唤醒所有处于等待状态的线程。</li><li>clear()：该方法将 Event 的内部旗标设置为 False，通常接下来会调用 wait() 方法来阻塞当前线程。</li><li>wait(timeout=None)：该方法会阻塞当前线程。</li></ul><p>结合Event的内部旗标，同样可实现前面的Account的生产者-消费者效果：存钱线程（生产者）存钱之后，必须等取钱线程（消费者）取钱之后才能继续向下执行。Event实际上优点类似于Condition和旗标的结合体，但Event本身并不带Lock对象，因此如果要实现线程同步，还需要额外的Lock对象。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 取钱存钱的Event实现</span><span class="token keyword">import</span> threading<span class="token keyword">class</span> <span class="token class-name">Account</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 定义构造器</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> account_no<span class="token punctuation">,</span> balance<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 封装账户编号、账户余额的两个成员变量</span>        self<span class="token punctuation">.</span>account_no <span class="token operator">=</span> account_no        self<span class="token punctuation">.</span>_balance <span class="token operator">=</span> balance        self<span class="token punctuation">.</span>lock <span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>event <span class="token operator">=</span> threading<span class="token punctuation">.</span>Event<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 因为账户余额不允许随便修改，所以只为self._balance提供getter方法</span>    <span class="token keyword">def</span> <span class="token function">getBalance</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>_balance    <span class="token comment" spellcheck="true"># 提供一个线程安全的draw()方法来完成取钱操作</span>    <span class="token keyword">def</span> <span class="token function">draw</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> draw_amount<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 加锁</span>        self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 如果Event内部旗标为True，表明账户中已有人存钱进去</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>event<span class="token punctuation">.</span>is_set<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 执行取钱操作</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name                <span class="token operator">+</span> <span class="token string">" 取钱:"</span> <span class="token operator">+</span>  str<span class="token punctuation">(</span>draw_amount<span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>_balance <span class="token operator">-=</span> draw_amount            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"账户余额为："</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_balance<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 将Event内部旗标设为False</span>            self<span class="token punctuation">.</span>event<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 释放加锁</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 阻塞当前线程阻塞</span>            self<span class="token punctuation">.</span>event<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 释放加锁</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 阻塞当前线程阻塞</span>            self<span class="token punctuation">.</span>event<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deposit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> deposit_amount<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 加锁</span>        self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 如果Event内部旗标为False，表明账户中还没有人存钱进去</span>        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>event<span class="token punctuation">.</span>is_set<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 执行存款操作</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name\                <span class="token operator">+</span> <span class="token string">" 存款:"</span> <span class="token operator">+</span>  str<span class="token punctuation">(</span>deposit_amount<span class="token punctuation">)</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>_balance <span class="token operator">+=</span> deposit_amount            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"账户余额为："</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>self<span class="token punctuation">.</span>_balance<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 将Event内部旗标设为True</span>            self<span class="token punctuation">.</span>event<span class="token punctuation">.</span>set<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 释放加锁</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 阻塞当前线程阻塞</span>            self<span class="token punctuation">.</span>event<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 释放加锁</span>            self<span class="token punctuation">.</span>lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 阻塞当前线程阻塞</span>            self<span class="token punctuation">.</span>event<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-文件操作</title>
      <link href="/2020/04/29/bian-cheng-yu-yan/python/python-wen-jian-cao-zuo/"/>
      <url>/2020/04/29/bian-cheng-yu-yan/python/python-wen-jian-cao-zuo/</url>
      
        <content type="html"><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>常见的操作包括创建、删除、修改权限、读取、写入等，这些操作可大致分为以下 2 类：</p><ul><li>删除、修改权限：作用于文件本身，属于系统级操作。</li><li>写入、读取：是文件最常用的操作，作用于文件的内容，属于应用级操作。</li></ul><p>文件的应用级操作可以分为以下3步，每一步都需要借助对应的函数实现：</p><ul><li>打开文件：使用 open()函数，该函数会返回一个文件对象；</li><li>对已打开文件做读/写操作：读取文件内容可使用read()、readline() 以及 readlines() 函数；向文件中写入内容，可以使用write()函数。</li><li>关闭文件：完成对文件的读/写操作之后，最后需要关闭文件，可以使用 close() 函数。</li></ul><h1 id="open-函数：打开指定文件"><a href="#open-函数：打开指定文件" class="headerlink" title="open()函数：打开指定文件"></a>open()函数：打开指定文件</h1><p>open()函数用于创建或打开指定文件，该函数的常用语法格式如下：</p><blockquote><p>file = open(file_name [, mode=’r’ [ , buffering=-1 [ , encoding = None ]]])</p></blockquote><p>此格式中，用[]括起来的部分为可选参数，即可以使用也可以省略。其中，各个参数所代表的含义如下：</p><ul><li>file：表示要创建的文件对象。</li><li>file_mode：要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。</li><li>mode：可选参数，用于指定文件的打开模式。可选的打开模式如表 1 所示。如果不写，则默认以只读（r）模式打开文件。<br>buffing：可选参数，用于指定对文件做读写操作时，是否使用缓冲区（本节后续会详细介绍）。</li><li>encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同，以 Windows 为例，其默认为 cp936（实际上就是 GBK 编码）</li></ul><p>open()函数支持的文件打开模式如下表：<br>| 模式 | 意义                                                                                                                                                   | 注意事项                                                       |<br>| —- | —————————————————————————————————————————————————— | ————————————————————– |<br>| r    | 只读模式打开文件，读文件内容的指针会放在文件的开头。                                                                                                   | 操作的文件必须存在。                                           |<br>| rb   | 以二进制格式、采用只读模式打开文件，读文件内容的指针位于文件的开头，一般用于非文本文件，如图片文件、音频文件等。                                       | 操作的文件必须存在。                                           |<br>| r+   | 打开文件后，既可以从头读取文件内容，也可以从开头向文件中写入新的内容，写入的新内容会覆盖文件中等长度的原有内容。                                       | 操作的文件必须存在。                                           |<br>| rb+  | 以二进制格式、采用读写模式打开文件，读写文件的指针会放在文件的开头，通常针对非文本文件（如音频文件）。                                                 | 操作的文件必须存在。                                           |<br>| w    | 以只写模式打开文件，若该文件存在，打开时会清空文件中原有的内容。    若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。                        | 若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。 |<br>| wb   | 以二进制格式、只写模式打开文件，一般用于非文本文件（如音频文件）                                                                                       | 若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。 |     | wb+                                                | 以二进制格式、读写模式打开文件，一般用于非文本文件             | 若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。 |<br>|      |<br>| w+   | 打开文件后，会对原有内容进行清空，并对该文件有读写权限。                                                                                               | 若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。 | wb+ | 以二进制格式、读写模式打开文件，一般用于非文本文件 | 若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。 |<br>|      |<br>| wb+  | 以二进制格式、读写模式打开文件，一般用于非文本文件                                                                                                     | 若文件存在，会清空其原有内容（覆盖文件）；反之，则创建新文件。 |<br>| a    | 以追加模式打开一个文件，对文件只有写入权限，如果文件已经存在，文件指针将放在文件的末尾（即新写入内容会位于已有内容之后）；反之，则会创建新文件。       |                                                                |<br>| ab   | 以二进制格式打开文件，并采用追加模式，对文件只有写权限。如果该文件已存在，文件指针位于文件末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。   |                                                                |<br>| a+   | 以读写模式打开文件；如果文件存在，文件指针放在文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。                                         |<br>| ab+  | 以二进制模式打开文件，并采用追加模式，对文件具有读写权限，如果文件存在，则文件指针位于文件的末尾（新写入文件会位于已有内容之后）；反之，则创建新文件。 |</p><blockquote><p>文件打开模式，直接决定了后续可以对文件做哪些操作。例如，使用 r 模式打开的文件，后续编写的代码只能读取文件，而无法修改文件内容。</p></blockquote> <div align="center"><img src="/images/module.png" width="400"></div> <center>图1 不同文件打开模式的功能</center><h2 id="open-是否需要缓冲区"><a href="#open-是否需要缓冲区" class="headerlink" title="open()是否需要缓冲区"></a>open()是否需要缓冲区</h2><p> 如果buffing参数的值为0（或者 False），则表示在打开指定文件时不使用缓冲区；如果buffing参数值为大于 1 的整数，该整数用于指定缓冲区的大小（单位是字节）；如果buffing参数的值为负数，则代表使用默认的缓冲区大小。</p><blockquote><p>使用缓冲区，则程序在执行输出操作时，会先将所有数据都输出到缓冲区中，然后继续执行其它操作，缓冲区中的数据会有外设自行读取处理；同样，当程序执行输入操作时，会先等外设将数据读入缓冲区中，无需同外设做同步读写操作。</p></blockquote><h2 id="open-文件对象常用的属性"><a href="#open-文件对象常用的属性" class="headerlink" title="open()文件对象常用的属性"></a>open()文件对象常用的属性</h2><p> 成功打开文件之后，可以调用文件对象本身拥有的属性获取当前文件的部分信息，其常见的属性为：</p><ul><li>file.name：返回文件的名称；</li><li>file.mode：返回打开文件时，采用的文件打开模式；</li><li>file.encoding：返回打开文件时使用的编码格式；</li><li>file.closed：判断文件是否己经关闭。</li></ul><h1 id="read-函数：按字节-字符-读取文件"><a href="#read-函数：按字节-字符-读取文件" class="headerlink" title="read()函数：按字节(字符)读取文件"></a>read()函数：按字节(字符)读取文件</h1><p>Python 提供了如下 3 种函数，它们都可以帮我们实现读取文件中数据的操作：</p><ul><li>read() 函数：逐个字节或者字符读取文件中的内容；</li><li>readline() 函数：逐行读取文件中的内容；</li><li>readlines() 函数：一次性读取文件中多行内容。<h2 id="read-函数"><a href="#read-函数" class="headerlink" title="read()函数"></a>read()函数</h2>如果文件是以文本模式（非二进制模式）打开的，则 read() 函数会逐个字符进行读取；反之，如果文件以二进制模式打开，则 read() 函数会逐个字节进行读取。read() 函数的基本语法格式如下：<blockquote><p>file.read([size])</p></blockquote></li></ul><p>其中，file表示已打开的文件对象；size 作为一个可选参数，用于指定一次最多可读取的字符（字节）个数，如果省略，则默认一次性读取所有内容。注意，当操作文件结束后，必须调用close() 函数手动将打开的文件进行关闭，这样可以避免程序发生不必要的错误。</p><h2 id="readline-函数"><a href="#readline-函数" class="headerlink" title="readline()函数"></a>readline()函数</h2><p>readline() 函数用于读取文件中的一行，包含最后的换行符“\n”。此函数的基本语法格式为：</p><blockquote><p>file.readline([size])</p></blockquote><p>其中，file 为打开的文件对象；size 为可选参数，用于指定读取每一行时，一次最多读取的字符（字节）数。和read()函数一样，此函数成功读取文件数据的前提是，使用 open() 函数指定打开文件的模式必须为可读模式（包括 r、rb、r+、rb+ 4 种）。</p><blockquote><p>由于 readline() 函数在读取文件中一行的内容时，会读取最后的换行符“\n”，再加上 print() 函数输出内容时默认会换行，所以输出结果中会看到多出了一个空行。</p></blockquote><h2 id="readlines-函数"><a href="#readlines-函数" class="headerlink" title="readlines()函数"></a>readlines()函数</h2><p>readlines() 函数用于读取文件中的所有行，它和调用不指定 size 参数的 read() 函数类似，只不过该函数返回是一个字符串列表，其中每个元素为文件中的一行内容。和readline()函数一样，readlines()函数在读取每一行时，会连同行尾的换行符一块读取。readlines()函数的基本语法格式如下：</p><blockquote><p>file.readlines()</p></blockquote><p>其中，file 为打开的文件对象。和 read()、readline() 函数一样，它要求打开文件的模式必须为可读模式（包括 r、rb、r+、rb+ 4 种）。</p><h1 id="write-和writelines-：向文件中写入数据"><a href="#write-和writelines-：向文件中写入数据" class="headerlink" title="write()和writelines()：向文件中写入数据"></a>write()和writelines()：向文件中写入数据</h1><p>Python 中的文件对象提供了 write() 函数，可以向文件中写入指定内容。该函数的语法格式如下：</p><blockquote><p>file.write(string)</p></blockquote><p>其中，file 表示已经打开的文件对象；string 表示要写入文件的字符串（或字节串，仅适用写入二进制文件中）。<br><font color="red">注意，在使用 write() 向文件中写入数据，需保证使用 open() 函数是以 r+、w、w+、a 或 a+ 的模式打开文件，否则执行 write() 函数会抛出 io.UnsupportedOperation 错误。</font></p><p>采用不同的文件打开模式，会直接影响 write() 函数向文件中写入数据的效果。<br>另外，在写入文件完成后，一定要调用 close() 函数将打开的文件关闭，否则写入的内容不会保存到文件中。例如，将上面程序中最后一行 f.close() 删掉，再次运行此程序并打开 a.txt，你会发现该文件是空的。这是因为，当我们在写入文件内容时，操作系统不会立刻把数据写入磁盘，而是先缓存起来，只有调用 close() 函数时，操作系统才会保证把没有写入的数据全部写入磁盘文件中。</p><h2 id="writelines-函数"><a href="#writelines-函数" class="headerlink" title="writelines()函数"></a>writelines()函数</h2><p>Python 的文件对象中，不仅提供了 write() 函数，还提供了 writelines() 函数，可以实现将字符串列表写入文件中。注意，写入函数只有 write() 和 writelines() 函数，而没有名为 writeline 的函数。</p><pre class="line-numbers language-python"><code class="language-python">f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'a.txt'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">)</span>n <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">'b.txt'</span><span class="token punctuation">,</span><span class="token string">'w+'</span><span class="token punctuation">)</span>n<span class="token punctuation">.</span>writelines<span class="token punctuation">(</span>f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>n<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 writelines()函数向文件中写入多行数据时，不会自动给各行添加换行符。上面例子中，之所以b.txt文件中会逐行显示数据，是因为readlines()函数在读取各行数据时，读入了行尾的换行符。</p><h1 id="colse-函数"><a href="#colse-函数" class="headerlink" title="colse()函数"></a>colse()函数</h1><p>Python 出于效率的考虑，会先将数据临时存储到缓冲区中，只有使用close()函数关闭文件时，才会将缓冲区中的数据真正写入文件中。语法格式：</p><blockquote><p>file.close()</p></blockquote><p>当然在某些实际场景中，我们可能需要在将数据成功写入到文件中，但并不想关闭文件。这也是可以实现的，调用 flush() 函数即可。</p><h1 id="tell-函数"><a href="#tell-函数" class="headerlink" title="tell()函数"></a>tell()函数</h1><p>当向文件中写入数据时，如果不是文件的尾部，写入位置的原有数据不会自行向后移动，新写入的数据会将文件中处于该位置的数据直接覆盖掉。基本语法为：</p><blockquote><p>file.tell()</p><pre class="line-numbers language-python"><code class="language-python"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><h1 id="a-txt-http-forwardpeng-club"><a href="#a-txt-http-forwardpeng-club" class="headerlink" title="a.txt: http://forwardpeng.club"></a>a.txt: <a href="http://forwardpeng.club" target="_blank" rel="noopener">http://forwardpeng.club</a></h1><p>f = open(“a.txt”, ‘r’)<br>print(f.tell())<br>print(f.read(3))<br>print(f.tell())<br>‘’’<br>0<br>htt<br>3<br>‘’’<br>```</p><h1 id="seek-函数"><a href="#seek-函数" class="headerlink" title="seek()函数"></a>seek()函数</h1><p>seek()函数用于将文件指针移动至指定位置，该函数的语法格式如下：<br>file.seek(offset[, whence])</p><p>其中，各个参数的含义如下：</p><ul><li>file：表示文件对象；</li><li>whence：作为可选参数，用于指定文件指针要放置的位置，该参数的参数值有 3 个选择：0 代表文件头（默认值）、1 代表当前位置、2 代表文件尾。</li><li>offset：表示相对于 whence 位置文件指针的偏移量，正数表示向后偏移，负数表示向前偏移。例如，当whence == 0 &amp;&amp;offset == 3（即 seek(3,0) ），表示文件指针移动至距离文件开头处 3 个字符的位置；当whence == 1 &amp;&amp;offset == 5（即 seek(5,1) ），表示文件指针向后移动，移动至距离当前位置 5 个字符处。<blockquote><p>注意，当 offset 值非 0 时，Python 要求文件必须要以二进制格式打开，否则会抛出 io.UnsupportedOperation 错误。</p></blockquote></li></ul><h1 id="pickle模块：实现对象持久化存储"><a href="#pickle模块：实现对象持久化存储" class="headerlink" title="pickle模块：实现对象持久化存储"></a>pickle模块：实现对象持久化存储</h1><p>pickle 模块提供了以下 4 个函数供我们使用：</p><ul><li>dumps()：将 Python 中的对象序列化成二进制对象，并返回；</li><li>loads()：读取给定的二进制对象数据，并将其转换为 Python 对象；</li><li>dump()：将 Python 中的对象序列化成二进制对象，并写入文件；</li><li>load()：读取指定的序列化数据文件，并返回对象。</li></ul><p>以上这4个函数可以分成两类，其中 dumps 和 loads 实现基于内存的 Python 对象与二进制互转；dump 和 load 实现基于文件的 Python 对象与二进制互转。</p><h2 id="pickle-dumps-函数"><a href="#pickle-dumps-函数" class="headerlink" title="pickle.dumps()函数"></a>pickle.dumps()函数</h2><p>用于将 Python 对象转为二进制对象，其语法格式如下：<br>dumps(obj, protocol=None, *, fix_imports=True)</p><p>此格式中各个参数的含义为：</p><ul><li>obj：要转换的 Python 对象；</li><li>protocol：pickle 的转码协议，取值为 0、1、2、3、4，其中 0、1、2 对应 Python 早期的版本，3 和 4 则对应 Python 3.x 版本及之后的版本。未指定情况下，默认为 3。</li><li>其它参数：为了兼容 Python 2.x 版本而保留的参数，Python 3.x 中可以忽略。<h2 id="pickle-loads-函数"><a href="#pickle-loads-函数" class="headerlink" title="pickle.loads()函数"></a>pickle.loads()函数</h2>用于将二进制对象转换成 Python 对象，其基本格式如下：<blockquote><p>loads(data, *, fix_imports=True, encoding=’ASCII’, errors=’strict’)</p></blockquote></li></ul><p>其中，data 参数表示要转换的二进制对象，其它参数只是为了兼容Python 2.x版本而保留的，可以忽略。</p><h2 id="pickle-dump"><a href="#pickle-dump" class="headerlink" title="pickle.dump()"></a>pickle.dump()</h2><p>用于将 Python 对象转换成二进制文件，其基本语法格式为：</p><blockquote><p>dump (obj, file,protocol=None, *, fix mports=True)</p></blockquote><p>其中各个参数的具体含义如下：</p><ul><li>obj：要转换的 Python 对象。</li><li>file：转换到指定的二进制文件中，要求该文件必须是以”wb”的打开方式进行操作。</li><li>protocol：和 dumps() 函数中 protocol 参数的含义完全相同，因此这里不再重复描述。</li></ul><h2 id="pickle-load-函数"><a href="#pickle-load-函数" class="headerlink" title="pickle.load()函数"></a>pickle.load()函数</h2><p>用于将二进制对象文件转换成 Python 对象。该函数的基本语法格式为：</p><blockquote><p>load(file, *, fix_imports=True, encoding=’ASCII’, errors=’strict’)</p></blockquote><p>其中，file参数表示要转换的二进制对象文件（必须以 “rb” 的打开方式操作文件）。</p><p>pickle 不支持并发地访问持久性对象，在复杂的系统环境下，尤其是读取海量数据时，使用 pickle 会使整个系统的I/O读取性能成为瓶颈。这种情况下，可以使用 ZODB。</p><h1 id="fileinput模块：逐行读取多个文件"><a href="#fileinput模块：逐行读取多个文件" class="headerlink" title="fileinput模块：逐行读取多个文件"></a>fileinput模块：逐行读取多个文件</h1><p>fileinput 模块中 input() 该函数的语法格式如下：</p><blockquote><p>fileinput.input（files=”filename1, filename2, …”, inplace=False, backup=’’, bufsize=0, mode=’r’, openhook=None）</p></blockquote><p>此函数会返回一个 FileInput 对象，它可以理解为是将多个指定文件合并之后的文件对象。其中，各个参数的含义如下：</p><ul><li>files：多个文件的路径列表；</li><li>inplace：用于指定是否将标准输出的结果写回到文件，此参数默认值为 False；</li><li>backup：用于指定备份文件的扩展名；</li><li>bufsize：指定缓冲区的大小，默认为 0；</li><li>mode：打开文件的格式，默认为 r（只读格式）；</li><li>openhook：控制文件的打开方式，例如编码格式等。</li></ul><p>fileinput模块常见函数如下表：<br>| 函数名                  | 功能描述                                        |<br>| ———————– | ———————————————– |<br>| fileinput.filename()    | 返回当前正在读取的文件名称。                    |<br>| fileinput.fileno()      | 返回当前正在读取文件的文件描述符。              |<br>| fileinput.lineno()      | 返回当前读取了多少行。                          |<br>| fileinput.filelineno()  | 返回当前正在读取的内容位于当前文件中的行号。    |<br>| fileinput.isfirstline() | 判断当前读取的内容在当前文件中是否位于第 1 行。 |<br>| fileinput.nextfile()    | 关闭当前正在读取的文件，并开始读取下一个文件。  |<br>| fileinput.close()       | 关闭 FileInput 对象。                           |</p><h1 id="linecache模块：读取指定行"><a href="#linecache模块：读取指定行" class="headerlink" title="linecache模块：读取指定行"></a>linecache模块：读取指定行</h1><p>linecache模块擅长读取指定文件中的指定行。换句话说，如果我们想读取某个文件中指定行包含的数据，就可以使用 linecache模块。inecache 模块中常用的函数及其功能如下表所示。<br>| 函数基本格式                                             | 功能                                                                                                                                                                                                                                                                        |<br>| ——————————————————– | ————————————————————————————————————————————————————————————————————————————————————————— |<br>| linecache.getline(filename, lineno, module_globals=None) | 读取指定模块中指定文件的指定行（仅读取指定文件时，无需指定模块）。其中，filename 参数用来指定文件名，lineno 用来指定行号，module_globals 参数用来指定要读取的具体模块名。注意，当指定文件以相对路径的方式传给 filename 参数时，该函数以按照 sys.path 规定的路径查找该文件。 |<br>| linecache.clearcache()                                   | 如果程序某处，不再需要之前使用 getline() 函数读取的数据，则可以使用该函数清空缓存。                                                                                                                                                                                         |<br>| linecache.checkcache                                     | (filename=None)    检查缓存的有效性，即如果使用 getline() 函数读取的数据，其实在本地已经被修改，而我们需要的是新的数据，此时就可以使用该函数检查缓存的是否为新的数据。注意，如果省略文件名，该函数将检车所有缓存数据的有效性。                                                 |</p><h1 id="os-path模块常见函数"><a href="#os-path模块常见函数" class="headerlink" title="os.path模块常见函数"></a>os.path模块常见函数</h1><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>os.path.abspath(path)</td><td>返回 path 的绝对路径。</td></tr><tr><td>os.path.basename(path)</td><td>获取 path 路径的基本名称，即 path 末尾到最后一个斜杠的位置之间的字符串。</td></tr><tr><td>os.path.commonprefix(list)</td><td>返回 list（多个路径）中，所有 path 共有的最长的路径。</td></tr><tr><td>os.path.dirname(path)</td><td>返回 path 路径中的目录部分。</td></tr><tr><td>os.path.exists(path)</td><td>判断 path 对应的文件是否存在，如果存在，返回 True；反之，返回 False。和 lexists() 的区别在于，exists()会自动判断失效的文件链接（类似 Windows 系统中文件的快捷方式），而 lexists() 却不会。</td></tr><tr><td>os.path.lexists(path)</td><td>判断路径是否存在，如果存在，则返回 True；反之，返回 False。</td></tr><tr><td>os.path.expanduser(path)</td><td>把 path 中包含的 “<del>“ 和 “</del>user” 转换成用户目录。</td></tr><tr><td>os.path.expandvars(path)</td><td>根据环境变量的值替换 path 中包含的 “$name” 和 “${name}”。</td></tr><tr><td>os.path.getatime(path)</td><td>返回 path 所指文件的最近访问时间（浮点型秒数）。</td></tr><tr><td>os.path.getmtime(path)</td><td>返回文件的最近修改时间（单位为秒）。</td></tr><tr><td>os.path.getctime(path)</td><td>返回文件的创建时间（单位为秒，自 1970 年 1 月 1 日起（又称 Unix 时间））。</td></tr><tr><td>os.path.getsize(path)</td><td>返回文件大小，如果文件不存在就返回错误。</td></tr><tr><td>os.path.isabs(path)</td><td>判断是否为绝对路径。</td></tr><tr><td>os.path.isfile(path)</td><td>判断路径是否为文件。</td></tr><tr><td>os.path.isdir(path)</td><td>判断路径是否为目录。</td></tr><tr><td>os.path.islink(path)</td><td>判断路径是否为链接文件（类似 Windows 系统中的快捷方式）。</td></tr><tr><td>os.path.ismount(path)</td><td>判断路径是否为挂载点。</td></tr><tr><td>os.path.join(path1[, path2[, …]])</td><td>把目录和文件名合成一个路径。</td></tr><tr><td>os.path.normcase(path)</td><td>转换 path 的大小写和斜杠。</td></tr><tr><td>os.path.normpath(path)</td><td>规范 path 字符串形式。</td></tr><tr><td>os.path.realpath(path)</td><td>返回 path 的真实路径。</td></tr><tr><td>os.path.relpath(path[, start])</td><td>从 start 开始计算相对路径。</td></tr><tr><td>os.path.samefile(path1, path2)</td><td>判断目录或文件是否相同。</td></tr><tr><td>os.path.sameopenfile(fp1, fp2)</td><td>判断 fp1 和 fp2 是否指向同一文件。</td></tr><tr><td>os.path.samestat(stat1, stat2)</td><td>判断 stat1 和 stat2 是否指向同一个文件。</td></tr><tr><td>os.path.split(path)</td><td>把路径分割成 dirname 和 basename，返回一个元组。</td></tr><tr><td>os.path.splitdrive(path)</td><td>一般用在 windows 下，返回驱动器名和路径组成的元组。</td></tr><tr><td>os.path.splitext(path)</td><td>分割路径，返回路径名和文件扩展名的元组。</td></tr><tr><td>os.path.splitunc(path)</td><td>把路径分割为加载点与文件。</td></tr><tr><td>os.path.walk(path, visit, arg)</td><td>遍历path，进入每个目录都调用 visit 函数，visit 函数必须有 3 个参数(arg, dirname, names)，dirname 表示当前目录的目录名，names 代表当前目录下的所有文件名，args 则为 walk 的第三个参数。</td></tr><tr><td>os.path.supports_unicode_filenames</td><td>设置是否可以将任意 Unicode 字符串用作文件名。</td></tr></tbody></table><h1 id="fnmatch模块：用于文件名匹配"><a href="#fnmatch模块：用于文件名匹配" class="headerlink" title="fnmatch模块：用于文件名匹配"></a>fnmatch模块：用于文件名匹配</h1><p>fnmatch模块中，常用的函数及功能如下表：<br>| 函数名                                 | 功能                                                                        |<br>| ————————————– | ————————————————————————— |<br>| fnmatch.filter(names, pattern)         | 对 names 列表进行过滤，返回 names 列表中匹配 pattern 的文件名组成的子集合。 |<br>| fnmatch.fnmatch(filename, pattern)     | 判断 filename 文件名，是否和指定 pattern 字符串匹配                         |<br>| fnmatch.fnmatchcase(filename, pattern) | 和 fnmatch() 函数功能大致相同，只是该函数区分大小写。                       |<br>| fnmatch.translate(pattern)             | 将一个UNIX shell风格的pattern字符串，转换为正则表达式                       |</p><p>fnmatch 模块匹配文件名的模式使用的就是 UNIX shell 风格，其支持使用如下几个通配符：</p><ul><li>*：可匹配任意个任意字符。</li><li>？：可匹配一个任意字符。</li><li>[字符序列]：可匹配中括号里字符序列中的任意字符。该字符序列也支持中画线表示法。比如 [a-c] 可代表 a、b 和 c 字符中任意一个。</li><li>[!字符序列]：可匹配不在中括号里字符序列中的任意字符。</li></ul><h1 id="tempfile模块：生成临时文件和临时目录"><a href="#tempfile模块：生成临时文件和临时目录" class="headerlink" title="tempfile模块：生成临时文件和临时目录"></a>tempfile模块：生成临时文件和临时目录</h1><table><thead><tr><th>tempfile 模块函数</th><th>功能描述</th></tr></thead><tbody><tr><td>tempfile.TemporaryFile(mode=’w+b’, buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None)</td><td>创建临时文件。该函数返回一个类文件对象，也就是支持文件 I/O。</td></tr><tr><td>tempfile.NamedTemporaryFile(mode=’w+b’, buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None, delete=True)</td><td>创建临时文件。该函数的功能与上一个函数的功能大致相同，只是它生成的临时文件在文件系统中有文件名。</td></tr><tr><td>tempfile.SpooledTemporaryFile(max_size=0, mode=’w+b’, buffering=None, encoding=None, newline=None, suffix=None, prefix=None, dir=None)</td><td>创建临时文件。与 TemporaryFile 函数相比，当程序向该临时文件输出数据时，会先输出到内存中，直到超过 max_size 才会真正输出到物理磁盘中。</td></tr><tr><td>tempfile.TemporaryDirectory(suffix=None, prefix=None, dir=None)</td><td>生成临时目录。</td></tr><tr><td>tempfile.gettempdir()</td><td>获取系统的临时目录。</td></tr><tr><td>tempfile.gettempdirb()</td><td>与 gettempdir() 相同，只是该函数返回字节串。</td></tr><tr><td>tempfile.gettempprefix()</td><td>返回用于生成临时文件的前缀名。</td></tr><tr><td>tempfile.gettempprefixb()</td><td>与 gettempprefix() 相同，只是该函数返回字节串。</td></tr><tr><td>创建临时文件的方法：</td><td></td></tr><tr><td>* 第一种方式是手动创建临时文件，读写临时文件后需要主动关闭它，当程序关闭该临时文件时，该文件会被自动删除。</td><td></td></tr><tr><td>* 第二种方式则是使用 with 语句创建临时文件，这样 with 语句会自动关闭临时文件。</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-异常处理机制</title>
      <link href="/2020/04/29/bian-cheng-yu-yan/python/python-yi-chang-chu-li-ji-zhi/"/>
      <url>/2020/04/29/bian-cheng-yu-yan/python/python-yi-chang-chu-li-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的异常类型"><a href="#常见的异常类型" class="headerlink" title="常见的异常类型"></a>常见的异常类型</h1><table><thead><tr><th>异常类型</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>AssertionError</td><td>当 assert 关键字后的条件为假时，程序运行会停止并抛出 AssertionError 异常</td><td>&gt;&gt;&gt; demo_list = [‘C语言中文网’]&gt;&gt;&gt; assert len(demo_list) &gt; 0&gt;&gt;&gt; demo_list.pop()’C语言中文网’&gt;&gt;&gt; assert len(demo_list) &gt; 0 Traceback (most recent call last):File “&lt;pyshell#6&gt;”, line 1, in <module>assert len(demo_list) &gt; 0 AssertionError</module></td></tr><tr><td>AttributeError</td><td>当试图访问的对象属性不存在时抛出的异常</td><td>&gt;&gt;&gt; demo_list = [‘C语言中文网’]&gt;&gt;&gt; demo_list.len Traceback (most recent call last): File “&lt;pyshell#10&gt;”, line 1, in <module> demo_list.len AttributeError: ‘list’ object has no attribute ‘len’</module></td></tr><tr><td>IndexError</td><td>索引超出序列范围会引发此异常</td><td>&gt;&gt;&gt; demo_list = [‘C语言中文网’] &gt;&gt;&gt; demo_list[3] Traceback (most recent call last): File “&lt;pyshell#8&gt;”, line 1, in <module> demo_list[3] IndexError: list index out of range</module></td></tr><tr><td>KeyError</td><td>字典中查找一个不存在的关键字时引发此异常</td><td>&gt;&gt;&gt; demo_dict={‘C语言中文网’:”c.biancheng.net”} &gt;&gt;&gt; demo_dict[“C语言”] Traceback (most recent call last):File “&lt;pyshell#12&gt;”, line 1, in <module> demo_dict[“C语言”] KeyError: ‘C语言’</module></td></tr><tr><td>NameError</td><td>尝试访问一个未声明的变量时，引发此异常</td><td>&gt;&gt;&gt; C语言中文网 Traceback (most recent call last): File “&lt;pyshell#15&gt;”, line 1, in <module> C语言中文网NameError: name ‘C语言中文网’ is not defined</module></td></tr><tr><td>TypeError</td><td>不同类型数据之间的无效操作</td><td>&gt;&gt;&gt; 1+’C语言中文网’                                                 Traceback (most recent call last): File “&lt;pyshell#17&gt;”, line 1, in <module> 1+’C语言中文网’ TypeError: unsupported operand type(s) for +: ‘int’ and ‘str’</module></td></tr><tr><td>ZeroDivisionError</td><td>除法运算中除数为 0 引发此异常</td><td>&gt;&gt;&gt; a = 1/0 Traceback (most recent call last): File “&lt;pyshell#2&gt;”, line 1, in <module> a = 1/0 ZeroDivisionError: division by zero</module></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><blockquote><p>使用 Python 异常处理机制，可以让程序中的异常处理代码和正常业务代码分离，使得程序代码更加优雅，并可以提高程序的健壮性。</p></blockquote><h1 id="try-except异常处理"><a href="#try-except异常处理" class="headerlink" title="try except异常处理"></a>try except异常处理</h1><p>Python 中，用try except语句块捕获并处理异常，其基本语法结构如下所示：</p><blockquote><p>try:<br>    可能产生异常的代码块<br>except [ (Error1, Error2, … ) [as e] ]:<br>    处理异常的代码块1<br>except [ (Error3, Error4, … ) [as e] ]:<br>    处理异常的代码块2<br>except  [Exception]:<br>    处理其它异常</p></blockquote><p>该格式中，[]括起来的部分可以使用，也可以省略。其中各部分的含义如下：</p><ul><li>(Error1, Error2,…) 、(Error3, Error4,…)：其中，Error1、Error2、Error3 和 Error4都是具体的异常类型。显然，一个except块可以同时处理多种异常。</li><li>[as e]：作为可选参数，表示给异常类型起一个别名 e，这样做的好处是方便在except块中调用异常类型（后续会用到）。</li><li>[Exception]：作为可选参数，可以代指程序可能发生的所有异常情况，其通常用在最后一个except块。<blockquote><p>当程序发生不同的意外情况时，会对应特定的异常类型，Python 解释器会根据该异常类型选择对应的 except 块来处理该异常。</p></blockquote><h2 id="获取特定异常"><a href="#获取特定异常" class="headerlink" title="获取特定异常"></a>获取特定异常</h2>每种异常类型都提供了如下几个属性和方法，通过调用它们，就可以获取当前处理异常类型的相关信息：</li><li>args：返回异常的错误编号和描述字符串；</li><li>str(e)：返回异常信息，但不包括异常信息的类型；</li><li>repr(e)：返回较全的异常信息，包括异常信息的类型。<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>  <span class="token number">1</span><span class="token operator">/</span><span class="token number">0</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 访问异常的错误编号和详细信息</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>args<span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>repr<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>Output：<span class="token punctuation">(</span><span class="token string">'division by zero'</span><span class="token punctuation">,</span><span class="token punctuation">)</span>division by zeroZeroDivisionError<span class="token punctuation">(</span><span class="token string">'division by zero'</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="异常处理的底层实现"><a href="#异常处理的底层实现" class="headerlink" title="异常处理的底层实现"></a>异常处理的底层实现</h1><p>对于可以接收任何异常的 except 来说，其后可以跟Exception，也可以不跟任何参数，但表示的含义都是一样的。 Python 的常见异常类之间的继承关系如图 1：<br> <div align="center"><img src="/images/Exception.png" width="400"></div><br> <center>图1 Python 的常见异常类之间的继承关系</center></p><blockquote><p>如果用户要实现自定义异常，不应该继承 BaseException ，而应该继承 Exception 类</p></blockquote><p>当一个try块配有多个except块时，这些except块应遵循这样一个排序规则，即可处理全部异常的except块（参数为Exception，也可以什么都不写）要放到所有except块的后面，且所有父类异常的except块要放到子类异常的except块的后面。</p><h1 id="try-except-else详解"><a href="#try-except-else详解" class="headerlink" title="try except else详解"></a>try except else详解</h1><p>在原本的try except结构的基础上，Python 异常处理机制还提供了一个 else块，也就是原有try except 语句的基础上再添加一个else块，即try except else结构。</p><p>使用else包裹的代码，只有当try块没有捕获到任何异常时，才会得到执行；反之，如果try块捕获到异常，即便调用对应的except处理完异常，else块中的代码也不会得到执行。</p><h1 id="try-except-finally：资源回收"><a href="#try-except-finally：资源回收" class="headerlink" title="try except finally：资源回收"></a>try except finally：资源回收</h1><p>在整个异常处理机制中，finally语句的功能是：无论try块是否发生异常，最终都要进入finally语句，并执行其中的代码块。基于finally语句的这种特性，在某些情况下，当try块中的程序打开了一些物理资源（文件、数据库连接等）时，由于这些资源必须手动回收，而回收工作通常就放在finally块中。</p><blockquote><p>Python垃圾回收机制，只能帮我们回收变量、类对象占用的内存，而无法自动完成类似关闭文件、数据库连接等这些的工作。</p></blockquote><h1 id="异常处理机制结构"><a href="#异常处理机制结构" class="headerlink" title="异常处理机制结构"></a>异常处理机制结构</h1><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 语法结构</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#业务实现代码</span><span class="token keyword">except</span> Exception1 <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#异常处理块1</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">except</span> Exception2 <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#异常处理块2</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">#可以有多个 except</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#正常处理块</span><span class="token keyword">finally</span> <span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#资源回收块</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个异常处理结构中，只有 try 块是必需的，也就是说：</p><ul><li><p>如果没有 try 块，则不能有后面的 except 块、else 块和 * finally 块。但是也不能只使用 try 块，要么使用 try except 结构，要么使用 try finally 结构；<br>except 块、else 块、finally 块都是可选的，当然也可以同时出现；</p></li><li><p>可以有多个 except 块，但捕获父类异常的 except 块应该位于捕获子类异常的 except 块的后面；</p></li><li><p>多个except块必须位于try块之后，finally块必须位于所有的 except 块之后。</p></li><li><p>要使用else块，其前面必须包含 try和except。<br>异常处理语句块的执行流程如下图2：</p><div align="center"><img src="/images/liucheng.png" width="400"></div><center>图2 异常处理语句块的执行流程</center><h1 id="raise用法"><a href="#raise用法" class="headerlink" title="raise用法"></a>raise用法</h1><p>raise 语句的基本语法格式为：<br>。raise [exceptionName [(reason)]]</p></li></ul><p>其中，用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述。如果可选参数全部省略，则 raise 会把当前错误原样抛出；如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息。也就是说，raise 语句有如下三种常用的用法：</p><ul><li><p>raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。</p></li><li><p>raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。</p></li><li><p>raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。</p><p>如果没有 finally 块，程序才会立即执行 return 或 raise 语句；反之，如果找到 finally 块，系统立即开始执行 finally 块，只有当 finally 块执行完成后，系统才会再次跳回来执行 try 块、except 块里的 return 或 raise 语句。尽量避免在 finally 块里使用 return 或 raise 等导致方法中止的语句，否则可能出现一些很奇怪的情况。<font color="red">但是，如果在 finally 块里也使用了 return 或 raise 等导致方法中止的语句，finally 块己经中止了方法，系统将不会跳回去执行 try 块、except 块里的任何代码。</font></p><h1 id="sys-exc-info-方法：获取异常信息"><a href="#sys-exc-info-方法：获取异常信息" class="headerlink" title="sys.exc_info()方法：获取异常信息"></a>sys.exc_info()方法：获取异常信息</h1><p>捕获异常时，有 2 种方式可获得更多的异常信息，分别是：</p></li><li><p>使用 sys 模块中的 exc_info 方法；</p></li><li><p>使用 traceback 模块中的相关函数。</p></li></ul><p>模块 sys 中，有两个方法可以返回异常的全部信息，分别是 exc_info() 和 last_traceback()，这两个函数有相同的功能和用法，<br>exc_info() 方法会将当前的异常信息以元组的形式返回，该元组中包含 3 个元素，分别为 type、value 和 traceback，它们的含义分别是：</p><ul><li>type：异常类型的名称，它是 BaseException 的子类（有关 Python 异常类，可阅读《Python常见异常类型》一节）</li><li>value：捕获到的异常实例。</li><li>traceback：是一个 traceback 对象。</li></ul><p>使用 traceback 的 print_exc() 方法输出异常传播信息，print_exc([limit[, file]]) 相当于如下形式：</p><blockquote><p>print_exception(sys.exc_etype, sys.exc_value, sys.exc_tb[, limit[, file]])</p></blockquote><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 捕捉异常，并将异常传播信息输出控制台</span>    traceback<span class="token punctuation">.</span>print_exc<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 捕捉异常，并将异常传播信息输出指定文件中</span>    traceback<span class="token punctuation">.</span>print_exc<span class="token punctuation">(</span>file<span class="token operator">=</span>open<span class="token punctuation">(</span><span class="token string">'log.txt'</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h1><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">InputError</span><span class="token punctuation">(</span>Exception<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''当输出有误时，抛出此异常'''</span>    <span class="token comment" spellcheck="true">#自定义异常类型的初始化</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>value <span class="token operator">=</span> value    <span class="token comment" spellcheck="true"># 返回异常类对象的说明信息</span>    <span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">"{} is invalid input"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>repr<span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token keyword">raise</span> InputError<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 抛出 MyInputError 这个异常</span><span class="token keyword">except</span> InputError <span class="token keyword">as</span> err<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'error: {}'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''运行结果：    error: 1 is invalid input'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意，只要自定义的类继承自 Exception，则该类就是一个异常类，至于此类中包含的内容，并没有做任何规定。</p><h1 id="异常使用规则"><a href="#异常使用规则" class="headerlink" title="异常使用规则"></a>异常使用规则</h1><p>成功的异常处理应该实现如下 4 个目标：</p><ul><li>使程序代码混乱最小化。</li><li>捕获并保留诊断信息。</li><li>通知合适的人员。</li><li>采用合适的方式结束异常活动。</li></ul><h2 id="不要过度使用异常"><a href="#不要过度使用异常" class="headerlink" title="不要过度使用异常"></a>不要过度使用异常</h2><p>过度使用异常主要表现在两个方面：</p><ul><li>把异常和普通错误混淆在一起，不再编写任何错误处理代码，而是以简单地引发异常来代苦所有的错误处理。</li><li>使用异常处理来代替流程控制。</li></ul><blockquote><p>异常处理机制的初衷是将不可预期异常的处理代码和正常的业务逻辑处理代码分离，因此绝不要使用异常处理来代替正常的业务逻辑判断。</p></blockquote><h2 id="不要使用过于庞大的-try-块"><a href="#不要使用过于庞大的-try-块" class="headerlink" title="不要使用过于庞大的 try 块"></a>不要使用过于庞大的 try 块</h2><p>因为 try 块里的代码过于庞大，业务过于复杂，就会造成 try 块中出现异常的可能性大大增加，从而导致分析异常原因的难度也大大增加。而且当时块过于庞大时，就难免在 try 块后紧跟大量的 except 块才可以针对不同的异常提供不同的处理逻辑。在同一个 try 块后紧跟大量的 except 块则需要分析它们之间的逻辑关系，反而增加了编程复杂度。</p><p>正确的做法是，把大块的 try 块分割成多个可能出现异常的程序段落，并把它们放在单独的 try 块中，从而分别捕获并处理异常。</p><h2 id="不要忽略捕获的异常"><a href="#不要忽略捕获的异常" class="headerlink" title="不要忽略捕获的异常"></a>不要忽略捕获的异常</h2><p>既然己捕获到异常，那么 except 块理应做些有用的事情，及处理并修复异常。except 块整个为空，或者仅仅打印简单的异常信息都是不妥的！常建议对异常采取适当措施，比如：</p><ul><li>处理异常。对异常进行合适的修复，然后绕过异常发生的地方继续运行；或者用别的数据进行计算，以代替期望的方法返回值；或者提示用户重新操作……总之，程序应该尽量修复异常，使程序能恢复运行。</li><li>重新引发新异常。把在当前运行环境下能做的事情尽量做完，然后进行异常转译，把异常包装成当前层的异常，重新传给上层调用者。</li><li>在合适的层处理异常。如果当前层不清楚如何处理异常，就不要在当前层使用 except 语句来捕获该异常，让上层调用者来负责处理该异常。</li></ul><h1 id="logging模块用法"><a href="#logging模块用法" class="headerlink" title="logging模块用法"></a>logging模块用法</h1><p>logging模块可以很容易地创建自定义的消息记录，这些日志消息将描述程序执行何时到达日志函数调用，并列出指定的任何变量当时的值。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 程序开头加上</span><span class="token keyword">import</span> logginglogging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>DEBUG<span class="token punctuation">,</span> format<span class="token operator">=</span><span class="token string">' %(asctime)s - %(levelname)s - %(message)s'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>工作原理：当Python记录一个事件的日志时，它会创建一个LogRecord对象，保存关于该事件的信息。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> logginglogging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>DEBUG<span class="token punctuation">,</span>                    format<span class="token operator">=</span><span class="token string">' %(asctime)s - %(levelname)s - %(message)s'</span><span class="token punctuation">)</span>logging<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">'Start of program'</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>    logging<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">'Start of factorial(%s%%)'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    total <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        total <span class="token operator">*=</span> i        logging<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">'i is '</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">', total is '</span> <span class="token operator">+</span> str<span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token punctuation">)</span>    logging<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">'End of factorial(%s%%)'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> total<span class="token keyword">print</span><span class="token punctuation">(</span>factorial<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>logging<span class="token punctuation">.</span>debug<span class="token punctuation">(</span><span class="token string">'End of program'</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''运行结果：2020-04-29 15:48:52,751 - DEBUG - Start of program 2020-04-29 15:48:52,751 - DEBUG - Start of factorial(5%) 2020-04-29 15:48:52,751 - DEBUG - i is 0, total is 0 2020-04-29 15:48:52,751 - DEBUG - i is 1, total is 0 2020-04-29 15:48:52,751 - DEBUG - i is 2, total is 0 2020-04-29 15:48:52,751 - DEBUG - i is 3, total is 0 2020-04-29 15:48:52,751 - DEBUG - i is 4, total is 0 2020-04-29 15:48:52,751 - DEBUG - i is 5, total is 0 2020-04-29 15:48:52,751 - DEBUG - End of factorial(5%) 2020-04-29 15:48:52,751 - DEBUG - End of program0'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="logging日志级别"><a href="#logging日志级别" class="headerlink" title="logging日志级别"></a>logging日志级别</h2><table><thead><tr><th>级别</th><th>对应的函数</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>logging.debug()</td><td>最低级别，用于小细节，通常只有在诊断问题时，才会关心这些消息。</td></tr><tr><td>INFO</td><td>logging.info()</td><td>用于记录程序中一般事件的信息，或确认一切工作正常。</td></tr><tr><td>WARNING</td><td>logging.warning()</td><td>用于表示可能的问题，它不会阻止程序的工作，但将来可能会。</td></tr><tr><td>ERROR</td><td>logging.error()</td><td>用于记录错误，它导致程序做某事失败。</td></tr><tr><td>CRITICAL</td><td>logging.critical()</td><td>最高级别，用于表示致命的错误，它导致或将要导致程序完全停止工作。</td></tr><tr><td>## logging禁用日志</td><td></td><td></td></tr><tr><td>在调试完程序后，可能并不希望所有这些日志消息出现在屏幕上，这时就可以使用 logging.disable() 函数禁用这些日志消息，从而不必进入到程序中，手工删除所有的日志调用。</td><td></td><td></td></tr></tbody></table><p>logging.disable() 函数的用法是，向其传入一个日志级别，它会禁止该级别以及更低级别的所有日志消息。因此，如果想要禁用所有日志，只要在程序中添加 logging.disable(logging.CRITICAL) 即可</p><h2 id="日志消息输出到文件中"><a href="#日志消息输出到文件中" class="headerlink" title="日志消息输出到文件中"></a>日志消息输出到文件中</h2><p>将日志消息输出到文件中的实现方法很简单，只需要设置 logging.basicConfig() 函数中的 filename 关键字参数即可，例如：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> logging<span class="token operator">>></span><span class="token operator">></span> logging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>filename<span class="token operator">=</span><span class="token string">'demo.txt'</span><span class="token punctuation">,</span> level<span class="token operator">=</span>logging<span class="token punctuation">.</span>DEBUG<span class="token punctuation">,</span> format<span class="token operator">=</span><span class="token string">'%(asctime)s - %(levelname)s - %(message)s'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此程序中，将日志消息存储到了 demo.txt 文件中，该文件就位于运行的程序文件所在的目录。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类特殊成员</title>
      <link href="/2020/04/28/bian-cheng-yu-yan/python/python-lei-te-shu-cheng-yuan/"/>
      <url>/2020/04/28/bian-cheng-yu-yan/python/python-lei-te-shu-cheng-yuan/</url>
      
        <content type="html"><![CDATA[<h1 id="new-方法"><a href="#new-方法" class="headerlink" title="new()方法"></a><strong>new</strong>()方法</h1><p><strong>new</strong>() 是一种负责创建类实例的静态方法，它无需使用 staticmethod 装饰器修饰，且该方法会优先<strong>init</strong>() 初始化方法被调用。一般情况下，覆写<strong>new</strong>()的实现将会使用合适的参数调用其超类的 super().<strong>new</strong>()，并在返回之前修改实例。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">demoClass</span><span class="token punctuation">:</span>    instances_created <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"__new__():"</span><span class="token punctuation">,</span>cls<span class="token punctuation">,</span>args<span class="token punctuation">,</span>kwargs<span class="token punctuation">)</span>        instance <span class="token operator">=</span> super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>        instance<span class="token punctuation">.</span>number <span class="token operator">=</span> cls<span class="token punctuation">.</span>instances_created        cls<span class="token punctuation">.</span>instances_created <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> instance    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>attribute<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"__init__():"</span><span class="token punctuation">,</span>self<span class="token punctuation">,</span>attribute<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>attribute <span class="token operator">=</span> attributetest1 <span class="token operator">=</span> demoClass<span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span>test2 <span class="token operator">=</span> demoClass<span class="token punctuation">(</span><span class="token string">"xyz"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test1<span class="token punctuation">.</span>number<span class="token punctuation">,</span>test1<span class="token punctuation">.</span>instances_created<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>test2<span class="token punctuation">.</span>number<span class="token punctuation">,</span>test2<span class="token punctuation">.</span>instances_created<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 输出结果</span><span class="token comment" spellcheck="true">#__new__(): &lt;class '__main__.demoClass'> ('abc',) {}</span><span class="token comment" spellcheck="true">#__init__(): &lt;__main__.demoClass object at 0x0000026FC0DF8080> abc</span><span class="token comment" spellcheck="true">#__new__(): &lt;class '__main__.demoClass'> ('xyz',) {}</span><span class="token comment" spellcheck="true">#__init__(): &lt;__main__.demoClass object at 0x0000026FC0DED358> xyz</span><span class="token comment" spellcheck="true">#0 2</span><span class="token comment" spellcheck="true">#1 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="repr-方法：显示属性"><a href="#repr-方法：显示属性" class="headerlink" title="repr()方法：显示属性"></a><strong>repr</strong>()方法：显示属性</h1><p><strong>repr</strong>() 会返回和调用者有关的 “类名+object at+内存地址”信息。当然，我们还可以通过在类中重写这个方法，从而实现当输出实例化对象时，输出我们想要的信息。实例：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CLanguage</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"C语言中文网"</span>        self<span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token string">"http://c.biancheng.net"</span>    <span class="token keyword">def</span> <span class="token function">__repr__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">"CLanguage[name="</span><span class="token operator">+</span> self<span class="token punctuation">.</span>name <span class="token operator">+</span><span class="token string">",add="</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>add <span class="token operator">+</span><span class="token string">"]"</span>clangs <span class="token operator">=</span> CLanguage<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>clangs<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># CLanguage[name=C语言中文网,add=http://c.biancheng.net]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>repr</strong>() 方法是类的实例化对象用来做“自我介绍”的方法，默认情况下，它会返回当前对象的“类名+object at+内存地址”，而如果对该方法进行重写，可以为其制作自定义的自我描述信息。</p><h1 id="dir-用法"><a href="#dir-用法" class="headerlink" title="dir()用法"></a><strong>dir</strong>()用法</h1><p>提到了dir() 函数，通过此函数可以某个对象拥有的所有的属性名和方法名，该函数会返回一个包含有所有属性名和方法名的有序列表。</p><h1 id="dict属性：查看对象内部所有属性名和属性值组成的字典"><a href="#dict属性：查看对象内部所有属性名和属性值组成的字典" class="headerlink" title="dict属性：查看对象内部所有属性名和属性值组成的字典"></a><strong>dict</strong>属性：查看对象内部所有属性名和属性值组成的字典</h1><p>便用户查看类中包含哪些属性，Python 类提供了<strong>dict</strong>属性。需要注意的一点是，该属性可以用类名或者类的实例对象来调用，用类名直接调用 <strong>dict</strong>，会输出该由类中所有类属性组成的字典；而使用类的实例对象调用 <strong>dict</strong>，会输出由类中所有实例属性组成的字典。对于具有继承关系的父类和子类来说，父类有自己的<strong>dict</strong>，同样子类也有自己的<strong>dict</strong>，它不会包含父类的<strong>dict</strong></p><h1 id="setattr-、getattr-、hasattr-函数用法"><a href="#setattr-、getattr-、hasattr-函数用法" class="headerlink" title="setattr()、getattr()、hasattr()函数用法"></a>setattr()、getattr()、hasattr()函数用法</h1><h2 id="hasattr-函数"><a href="#hasattr-函数" class="headerlink" title="hasattr()函数"></a>hasattr()函数</h2><p>hasattr() 函数用来判断某个类实例对象是否包含指定名称的属性或方法。该函数的语法格式如下：</p><blockquote><p>hasattr(obj, name)</p></blockquote><p>无论是属性名还是方法名，都在 hasattr() 函数的匹配范围内。因此，我们只能通过该函数判断实例对象是否包含该名称的属性或方法，但不能精确判断，该名称代表的是属性还是方法。</p><h2 id="getattr-函数"><a href="#getattr-函数" class="headerlink" title="getattr()函数"></a>getattr()函数</h2><p>getattr() 函数获取某个类实例对象中指定属性的值，该函数只会从类对象包含的所有属性中进行查找。<br>getattr() 函数的语法格式如下：</p><blockquote><p>getattr(obj, name[, default])</p></blockquote><p>其中，obj 表示指定的类实例对象，name 表示指定的属性名，而 default 是可选参数，用于设定该函数的默认返回值，即当函数查找失败时，如果不指定 default 参数，则程序将直接报 AttributeError 错误，反之该函数将返回 default 指定的值。</p><h2 id="setattr-函数"><a href="#setattr-函数" class="headerlink" title="setattr()函数"></a>setattr()函数</h2><p>setattr() 函数的功能相对比较复杂，它最基础的功能是修改类实例对象中的属性值。其次，它还可以实现为实例对象动态添加属性或者方法。setattr() 函数的语法格式如下：</p><blockquote><p>setattr(obj, name, value)</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我正在学Python"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">CLanguage</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> __init__ <span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"C语言中文网"</span>        self<span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token string">"http://c.biancheng.net"</span>clangs <span class="token operator">=</span> CLanguage<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>clangs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>clangs<span class="token punctuation">.</span>add<span class="token punctuation">)</span>setattr<span class="token punctuation">(</span>clangs<span class="token punctuation">,</span><span class="token string">"name"</span><span class="token punctuation">,</span>say<span class="token punctuation">)</span>clangs<span class="token punctuation">.</span>name<span class="token punctuation">(</span>clangs<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>#程序运行结果为：</p><p>#C语言中文网</p><p>#<a href="http://c.biancheng.net" target="_blank" rel="noopener">http://c.biancheng.net</a></p><p>#我正在学Python</p><pre><code># issubclass和isinstance函数：检查类型Python 提供了如下两个函数来检查类型：* issubclass(cls, class_or_tuple)：检查 cls 是否为后一个类或元组包含的多个类中任意类的子类。* isinstance(obj, class_or_tuple)：检查 obj 是否为后一个类或元组包含的多个类中任意类的对象。区别只是 issubclass() 的第一个参数是类名，而 isinstance() 的第一个参数是变量，这也与两个函数的意义对应：issubclass 用于判断是否为子类，而 isinstance() 用于判断是否为该类或子类的实例。Python为所有类都提供了一个 __bases__ 属性，通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组。# __call__()方法功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。&gt;Python 中，凡是可以将 () 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。hasattr()的功能是查找类的实例对象中是否包含指定名称的属性或者方法，但该函数有一个缺陷，即它无法判断该指定的名称，到底是类属性还是类方法。```pythonclass CLanguage:    def __init__ (self):        self.name = &quot;C语言中文网&quot;        self.add = &quot;http://c.biancheng.net&quot;    def say(self):        print(&quot;我正在学Python&quot;)clangs = CLanguage()if hasattr(clangs,&quot;name&quot;):    print(hasattr(clangs.name,&quot;__call__&quot;))print(&quot;**********&quot;)if hasattr(clangs,&quot;say&quot;):    print(hasattr(clangs.say,&quot;__call__&quot;))执行结果：    False      *********    True# 由于name是类属性，它没有以__call__为名的__call__()方法；而 say是类方法，它是可调用对象，因此它有__call__()方法。</code></pre><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h1><p>Python 类支持对哪些方法进行重载呢？，列出了 Python 中常用的可重载的运算符，以及各自的含义。<br>| 重载运算符                                     | 含义                                                                                                                                                                          |<br>| ———————————————- | —————————————————————————————————————————————————————————– |<br>| <strong>new</strong>                                        | 创建类，在 <strong>init</strong> 之前创建对象                                                                                                                                              |<br>| <strong>init</strong>                                       | 类的构造函数，其功能是创建类对象时做初始化工作。                                                                                                                              |<br>| <strong>del</strong>                                        | 析构函数，其功能是销毁对象时进行回收资源的操作                                                                                                                                |<br>| <strong>add</strong>                                        | 加法运算符 +，当类对象 X 做例如 X+Y 或者 X+=Y 等操作，内部会调用此方法。但如果类中对 <strong>iadd</strong> 方法进行了重载，则类对象 X 在做 X+=Y 类似操作时，会优先选择调用 <strong>iadd</strong> 方法。 |<br>| <strong>radd</strong>                                       | 当类对象 X 做类似 Y+X 的运算时，会调用此方法。                                                                                                                                |<br>| <strong>iadd</strong>                                       | 重载 += 运算符，也就是说，当类对象 X 做类似 X+=Y 的操作时，会调用此方法。                                                                                                     |<br>| <strong>or</strong>                                         | “或”运算符                                                                                                                                                                    | ，如果没有重载 <strong>ior</strong>，则在类似 X | Y、X     | =Y 这样的语句中，“或”符号生效        |<br>| <strong>repr</strong>，<strong>str</strong>                              | 格式转换方法，分别对应函数 repr(X)、str(X)                                                                                                                                    |<br>| <strong>call</strong>                                       | 函数调用，类似于 X(<em>args, *</em>kwargs) 语句                                                                                                                                      |<br>| <strong>getattr</strong>                                    | 点号运算，用来获取类属性                                                                                                                                                      |<br>| <strong>setattr</strong>                                    | 属性赋值语句，类似于 X.any=value                                                                                                                                              |<br>| <strong>delattr</strong>                                    | 删除属性，类似于 del X.any                                                                                                                                                    |<br>| <strong>getattribute</strong>                               | 获取属性，类似于 X.any                                                                                                                                                        |<br>| <strong>getitem</strong>                                    | 索引运算，类似于 X[key]，X[i:j]                                                                                                                                               |<br>| <strong>setitem</strong>                                    | 索引赋值语句，类似于 X[key], X[i:j]=sequence                                                                                                                                  |<br>| <strong>delitem</strong>                                    | 索引和分片删除                                                                                                                                                                |<br>| <strong>get</strong>, <strong>set</strong>, <strong>delete</strong>                   | 描述符属性，类似于 X.attr，X.attr=value，del X.attr                                                                                                                           |<br>| <strong>len</strong>                                        | 计算长度，类似于 len(X)                                                                                                                                                       |<br>| <strong>lt</strong>，<strong>gt</strong>，<strong>le</strong>，<strong>ge</strong>，<strong>eq</strong>，<strong>ne</strong> | 比较，分别对应于 &lt;、&gt;、&lt;=、&gt;=、=、!= 运算符。                                                                                                                                 |<br>| <strong>iter</strong>，<strong>next</strong>                             | 迭代环境下，生成迭代器与取下一条，类似于 I=iter(X) 和 next()                                                                                                                  |<br>| <strong>contains</strong>                                   | 成员关系测试，类似于 item in X                                                                                                                                                |<br>| <strong>index</strong>                                      | 整数值，类似于 hex(X)，bin(X)，oct(X)                                                                                                                                         |<br>| <strong>enter</strong>，<strong>exit</strong>                            | 在对类对象执行类似 with obj as var 的操作之前，会先调用 <strong>enter</strong> 方法，其结果会传给 var；在最终结束该操作之前，会调用                                                        |                                    | <strong>exit</strong> | 方法（常用于做一些清理、扫尾的工作） |</p><h1 id="Python迭代器"><a href="#Python迭代器" class="headerlink" title="Python迭代器"></a>Python迭代器</h1><p>迭代器指的就是支持迭代的容器，更确切的说，是支持迭代的容器类对象，这里的容器可以是列表、元组等这些 Python 提供的基础容器，也可以是自定义的容器类对象，只要该容器支持迭代即可。自定义实现一个迭代器，则类中必须实现如下2个方法：</p><ul><li><strong>next</strong>(self)：返回容器的下一个元素。</li><li><strong>iter</strong>(self)：该方法返回一个迭代器（iterator）。</li></ul><p>Python 内置的 iter() 函数也会返回一个迭代器，该函数的语法格式如下：</p><blockquote><p>iter(obj[, sentinel])</p></blockquote><p>其中，obj 必须是一个可迭代的容器对象，而 sentinel 作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象。</p><blockquote><p>可调用对象，指的是该类的实例对象可以像函数那样，直接以“对象名()”的形式被使用。通过在类中添加 <strong>call</strong>() 方法，就可以将该类的实例对象编程可调用对象。</p></blockquote><p> 1个参数的 iter()函数，通过传入一个可迭代的容器对象，我们可以获得一个迭代器，通过调用该迭代器中的<strong>next</strong>()方法即可实现迭代，使用next()内置函数来迭代，即next(myIter)，和<strong>next</strong>()方法是完全一样的。</p><p> iter()函数第2个参数的作用，如果使用该参数，则要求第一个obj参数必须传入可调用对象（可以不支持迭代），这样当使用返回的迭代器调用<strong>next</strong>()方法时，它会通过执行obj()调用 <strong>call</strong>()方法，如果该方法的返回值和第 2 个参数值相同，则输出 StopInteration 异常；反之，则输出 <strong>call</strong>() 方法的返回值。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 迭代器实现字符串逆序</span><span class="token keyword">class</span> <span class="token class-name">Reverse</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> string<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__string <span class="token operator">=</span> string        self<span class="token punctuation">.</span>__index <span class="token operator">=</span> len<span class="token punctuation">(</span>string<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__iter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self    <span class="token keyword">def</span> <span class="token function">__next__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>__index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span><span class="token punctuation">(</span>StopIteration<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>__index <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__string<span class="token punctuation">[</span>self<span class="token punctuation">.</span>__index<span class="token punctuation">]</span>revstr <span class="token operator">=</span> Reverse<span class="token punctuation">(</span><span class="token string">'Python'</span><span class="token punctuation">)</span><span class="token keyword">for</span> c <span class="token keyword">in</span> revstr<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器的创建方式也比迭代器简单很多，大体分为以下 2 步：</p><ul><li>定义一个以 yield 关键字标识返回值的函数；</li><li>调用刚刚创建的函数，即可创建一个生成器。</li></ul><p>和return相比，yield 除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。不仅如此，即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。</p><blockquote><p>相比迭代器，生成器最明显的优势就是节省内存空间，即它不会一次性生成所有的数据，而是什么时候需要，什么时候生成。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">intNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"开始执行"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">yield</span> i        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"继续执行"</span><span class="token punctuation">)</span>num <span class="token operator">=</span> intNum<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。想要生成器函数执行，或者想使执行完 yield 语句立即暂停的程序得以继续执行，可以通过：</p><ul><li>通过生成器调用next()内置函数或者<strong>next</strong>()方法</li><li>通过for循环遍历生成器</li></ul></blockquote><h2 id="生成器send-方法"><a href="#生成器send-方法" class="headerlink" title="生成器send()方法"></a>生成器send()方法</h2><p>通过 send() 方法，还可以向生成器中传值。</p><p>值得一提的是，send()方法可带一个参数，也可以不带任何参数（用 None 表示）。其中，当使用不带参数的send()方法时，它和next()函数的功能完全相同。例如：</p><pre class="line-numbers language-python"><code class="language-python">ddef foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    bar_a <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token string">"hello"</span>    bar_b <span class="token operator">=</span> <span class="token keyword">yield</span> bar_a    <span class="token keyword">yield</span> bar_bf <span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>send<span class="token punctuation">(</span>None<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"C语言中文网"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token string">"http://c.biancheng.net"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#hello</span><span class="token comment" spellcheck="true">#C语言中文网</span><span class="token comment" spellcheck="true">#http://c.biancheng.net</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h2><p>生成器函数中遇到yield语句暂停运行时，此时如果调用 close()方法，会阻止生成器函数继续执行，该函数会在程序停止运行的位置抛出 GeneratorExit 异常。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">yield</span> <span class="token number">1</span>    <span class="token keyword">except</span> GeneratorExit<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'捕获到 GeneratorExit'</span><span class="token punctuation">)</span>        <span class="token keyword">yield</span> <span class="token number">2</span> <span class="token comment" spellcheck="true">#抛出 RuntimeError 异常</span>f <span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''1捕获到 GeneratorExit Traceback (most recent call last):  File "D:\python3.6\1.py", line 10, in &lt;module>    f.close()RuntimeError: generator ignored GeneratorExit'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="生成器throw-方法"><a href="#生成器throw-方法" class="headerlink" title="生成器throw()方法"></a>生成器throw()方法</h2><p>生成器 throw() 方法的功能是，在生成器函数执行暂停处，抛出一个指定的异常，之后程序会继续执行生成器函数中后续的代码，直到遇到下一个yield语句。需要注意的是，如果到剩余代码执行完毕没有遇到下一个yield语句，则程序会抛出 StopIteration异常。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">yield</span> <span class="token number">1</span>    <span class="token keyword">except</span> ValueError<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'捕获到 ValueError'</span><span class="token punctuation">)</span>f <span class="token operator">=</span> foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>f<span class="token punctuation">.</span>throw<span class="token punctuation">(</span>ValueError<span class="token punctuation">)</span><span class="token triple-quoted-string string">'''运行结果：1捕获到 ValueErrorTraceback (most recent call last):  File "D:\python3.6\1.py", line 9, in &lt;module>    f.throw(ValueError)StopIteration'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一开始生成器函数在yield 1处暂停执行，当执行throw()方法时，它会先抛出 ValueError异常，然后继续执行后续代码找到下一个 yield语句，该程序中由于后续不再有yield语句，因此程序执行到最后，会抛出一个 StopIteration异常。</p><h1 id="函数装饰器及用法"><a href="#函数装饰器及用法" class="headerlink" title="函数装饰器及用法"></a>函数装饰器及用法</h1><p> Python 内置的 3 种函数装饰器，分别是 ＠staticmethod、＠classmethod 和 @property，其中 staticmethod()、classmethod()和 property()都是Python的内置函数。<br> 使用函数装饰器A()去装饰另一个函数B()，其底层执行了如下2步操作：</p><ul><li>将B作为参数传给A()函数；</li><li>将A()函数执行完成的返回值反馈回B。<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">funA</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"C语言中文网"</span><span class="token punctuation">)</span>  fn<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 执行传入的fn参数</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"http://c.biancheng.net"</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> <span class="token string">"装饰器函数的返回值"</span>@funA<span class="token keyword">def</span> <span class="token function">funB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"学习 Python"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''C语言中文网学习 Pythonhttp://c.biancheng.net在此基础上，如果在程序末尾添加如下语句：print(funB)其输出结果为：装饰器函数的返回值'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名；同样，如果装饰器返回的是一个函数的名称，怎么被修饰的函数名依然表示一个函数。<blockquote><p>函数装饰器，就是通过装饰器函数，在不修改原函数的前提下，来对函数的功能进行合理的扩充。</p></blockquote><h2 id="带参数的函数装饰器"><a href="#带参数的函数装饰器" class="headerlink" title="带参数的函数装饰器"></a>带参数的函数装饰器</h2>函数装饰器中嵌套一个函数，该函数带有的参数个数和被装饰器修饰的函数相同。例如：<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">funA</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 定义一个嵌套函数</span>  <span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>arc<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Python教程:"</span><span class="token punctuation">,</span>arc<span class="token punctuation">)</span>  <span class="token keyword">return</span> say@funA<span class="token keyword">def</span> <span class="token function">funB</span><span class="token punctuation">(</span>arc<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"funB():"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>funB<span class="token punctuation">(</span><span class="token string">"http://c.biancheng.net/python"</span><span class="token punctuation">)</span><span class="token triple-quoted-string string">'''程序执行结果为：Python教程: http://c.biancheng.net/python'''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数装饰器嵌套"><a href="#函数装饰器嵌套" class="headerlink" title="函数装饰器嵌套"></a>函数装饰器嵌套</h2>上面程序的执行顺序是里到外，所以它等效于下面这行代码：<blockquote><p>fun = funA( funB ( funC (fun) ) )</p></blockquote><h1 id="装饰器的应用场景"><a href="#装饰器的应用场景" class="headerlink" title="装饰器的应用场景"></a>装饰器的应用场景</h1><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">authenticate</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>  @functools<span class="token punctuation">.</span>wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span>  <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>      request <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>      <span class="token comment" spellcheck="true"># 如果用户处于登录状态</span>      <span class="token keyword">if</span> check_user_logged_in<span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token comment" spellcheck="true"># 执行函数 post_comment()</span>          <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>          <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'Authentication failed'</span><span class="token punctuation">)</span>  <span class="token keyword">return</span> wrapper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>@authenticate<br>def post_comment(request, …)<br>    …</p><pre><code>定义了装饰器 authenticate，函数 post_comment() 则表示发表用户对某篇文章的评论，每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。## 日志记录日志记录同样是很常见的一个案例。在实际工作中，如果你怀疑某些函数的耗时过长，导致整个系统的延迟增加，想在线上测试某些函数的执行时间，那么，装饰器就是一种很常用的手段。```pythonimport timeimport functoolsdef log_execution_time(func):    @functools.wraps(func)    def wrapper(*args, **kwargs):        start = time.perf_counter()        res = func(*args, **kwargs)        print(&#39;{} took {} ms&#39;.format(func.__name__, (end - start) * 1000))        return res    return wrapper@log_execution_timedef calculate_similarity(items):    ...</code></pre><p>装饰器 log_execution_time 记录某个函数的运行时间，并返回其执行结果。如果你想计算任何函数的执行时间，在这个函数上方加上@log_execution_time即可。</p><h2 id="装饰器用于输入合理性检查"><a href="#装饰器用于输入合理性检查" class="headerlink" title="装饰器用于输入合理性检查"></a>装饰器用于输入合理性检查</h2><p>在大型公司的机器学习框架中，调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检查。这样就可以大大避免输入不正确对机器造成的巨大开销。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">validation_check</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">:</span>    @functools<span class="token punctuation">.</span>wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>@validation_check<span class="token keyword">def</span> <span class="token function">neural_network_training</span><span class="token punctuation">(</span>param1<span class="token punctuation">,</span> param2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现。</p><h2 id="缓存装饰器"><a href="#缓存装饰器" class="headerlink" title="缓存装饰器"></a>缓存装饰器</h2><p>ython 中的表示形式是 @lru_cache。@lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除最近最久未使用的数据。正确使用缓存装饰器，往往能极大地提高程序运行效率。</p><pre class="line-numbers language-python"><code class="language-python">@lru_cache<span class="token keyword">def</span> <span class="token function">check</span><span class="token punctuation">(</span>param1<span class="token punctuation">,</span> param2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 检查用户设备类型、版本号</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-类和对象</title>
      <link href="/2020/04/28/bian-cheng-yu-yan/python/python-lei-he-dui-xiang/"/>
      <url>/2020/04/28/bian-cheng-yu-yan/python/python-lei-he-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="Python描述符详解"><a href="#Python描述符详解" class="headerlink" title="Python描述符详解"></a>Python描述符详解</h1><p>述符就是一个类，只不过它定义了另一个类中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。</p><blockquote><p>描述符是Python中复杂属性访问的基础，它在内部被用于实现property、方法、类方法、静态方法和super类型。</p></blockquote><p>描述符协议：</p><ul><li><strong>set</strong>(self, obj, type=None)：在设置属性时将调用这一方法（本节后续用 setter 表示）；</li><li><strong>get</strong>(self, obj, value)：在读取属性时将调用这一方法（本节后续用 getter 表示）；</li><li><strong>delete</strong>(self, obj)：对属性调用 del 时将调用这一方法。</li></ul><p>在每次查找属性时，描述符协议中的方法都由类对象的特殊方法 <strong>getattribute</strong>()调用（注意不要和<strong>getattr</strong>() 弄混）。也就是说，每次使用类对象.属性（或者 getattr(类对象，属性值)）的调用方式时，都会隐式地调用 <strong>getattribute</strong>()，它会按照下列顺序查找该属性：</p><ul><li>验证该属性是否为类实例对象的数据描述符；</li><li>如果不是，就查看该属性是否能在类实例对象的 <strong>dict</strong> 中找到；</li><li>最后，查看该属性是否为类实例对象的非数据描述符。<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">revealAccess</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> initval <span class="token operator">=</span> None<span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">'var'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      self<span class="token punctuation">.</span>val <span class="token operator">=</span> initval      self<span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token keyword">def</span> <span class="token function">__get__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> objtype<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Retrieving"</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>      <span class="token keyword">return</span> self<span class="token punctuation">.</span>val  <span class="token keyword">def</span> <span class="token function">__set__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> obj<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"updating"</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>      self<span class="token punctuation">.</span>val <span class="token operator">=</span> val<span class="token keyword">class</span> <span class="token class-name">myClass</span><span class="token punctuation">:</span>  x <span class="token operator">=</span> revealAccess<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'var "x"'</span><span class="token punctuation">)</span>  y <span class="token operator">=</span> <span class="token number">5</span>m <span class="token operator">=</span> myClass<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>x<span class="token punctuation">)</span>m<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">20</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>Retrieving var “x”<br>10<br>updating var “x”<br>Retrieving var “x”<br>20<br>5</p><pre><code>如果一个类的某个属性有数据描述符，那么每次查找这个属性时，都会调用描述符的__get__()方法，并返回它的值；同样，每次在对该属性赋值时，也会调用__set__()方法。&gt;除了使用描述符类自定义类属性被调用时做的操作外，还可以使用 property()函数或者@property装饰器## property()函数：定义属性Python 中提供了 property() 函数，可以实现在不破坏类封装原则的前提下，让开发者依旧使用“类对象.属性”的方式操作类中的属性。property()函数的基本使用格式如下：&gt;属性名=property(fget=None, fset=None, fdel=None, doc=None)其中，fget 参数用于指定获取该属性值的类方法，fset 参数用于指定设置该属性值的方法，fdel 参数用于指定删除该属性值的方法，最后的 doc 是一个文档字符串，用于说明此函数的作用。```pythonclass CLanguage:    #构造函数    def __init__(self,n):        self.__name = n    #设置 name 属性值的函数    def setname(self,n):        self.__name = n    #访问nema属性值的函数    def getname(self):        return self.__name    #删除name属性值的函数    def delname(self):        self.__name=&quot;xxx&quot;    #为name 属性配置 property() 函数    name = property(getname, setname, delname, &#39;指明出处&#39;)#调取说明文档的 2 种方式#print(CLanguage.name.__doc__)help(CLanguage.name)clang = CLanguage(&quot;C语言中文网&quot;)#调用 getname() 方法print(clang.name)#调用 setname() 方法clang.name=&quot;Python教程&quot;print(clang.name)#调用 delname() 方法del clang.nameprint(clang.name)</code></pre><p><font color="red">由于getname()方法中需要返回 name 属性，如果使用 self.name的话，其本身又被调用 getname()，这将会先入无限死循环。为了避免这种情况的出现，程序中的name属性必须设置为私有属性，即使用__name（前面有2个下划线）。</font></p><pre class="line-numbers language-python"><code class="language-python">name <span class="token operator">=</span> property<span class="token punctuation">(</span>getname<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># name 属性可读，不可写，也不能删除</span>name <span class="token operator">=</span> property<span class="token punctuation">(</span>getname<span class="token punctuation">,</span> setname<span class="token punctuation">,</span>delname<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#name属性可读、可写、也可删除，就是没有说明文档</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h1><p>保护类的封装特性，又要让开发者可以使用“对象.属性”的方式操作操作类属性，除了使用 property() 函数，Python 还提供了 @property 装饰器。通过 @property 装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对“（）”小括号。语法格式：</p><blockquote><p>@property<br>def 方法名(self)<br>    代码块</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Rect</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>area<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__area <span class="token operator">=</span> area    @property    <span class="token keyword">def</span> <span class="token function">area</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__arearect <span class="token operator">=</span> Rect<span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>#直接通过方法名来访问 area 方法<br>print(“矩形的面积是：”,rect.area)</p><pre><code>使用＠property 修饰了area()方法，这样就使得该方法变成了 area 属性的 getter 方法。需要注意的是，如果类中只包含该方法，那么area属性将是一个只读属性。添加setter方法，需要用到setter装饰器，语法格式：&gt;@方法名.setterdef 方法名(self, value):    代码块删除deleter装饰器指定属性，语法格式为：&gt;@方法名.deleterdef 方法名(self):    代码块```python@area.setterdef area(self, value):    self.__area = value@area.deleterdef area(self):    self.__area = 0</code></pre><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>Python并没有提供public、private这些修饰符。为了实现类的封装，Python采取了下面的方法：</p><ul><li>默认情况下，Python 类中的变量和方法都是公有（public）的，它们的名称前都没有下划线（_）；</li><li>如果类中的变量和函数，其名称以双下划线“__”开头，则该变量（函数）为私有变量（私有函数），其属性等同于 private。</li><li>定义以单下划线“_”开头的类属性或者类方法（例如 _name、_display(self)），这种类属性和类方法通常被视为私有属性和私有方法，虽然它们也能通过类对象正常访问，但这是一种约定俗称的用法<blockquote><p>Python 类中还有以双下划线开头和结尾的类方法（例如类的构造函数<strong>init</strong>(self)），这些都是 Python 内部定义的，用于 Python 内部调用。我们自己定义类属性或者类方法时，不要使用这种格式。</p></blockquote></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CLanguage</span> <span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">setname</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'名称长度必须大于3！'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>__name <span class="token operator">=</span> name    <span class="token keyword">def</span> <span class="token function">getname</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__name    <span class="token comment" spellcheck="true">#为 name 配置 setter 和 getter 方法</span>    name <span class="token operator">=</span> property<span class="token punctuation">(</span>getname<span class="token punctuation">,</span> setname<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">setadd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> add<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> add<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">"http://"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>__add <span class="token operator">=</span> add        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> ValueError<span class="token punctuation">(</span><span class="token string">'地址必须以 http:// 开头'</span><span class="token punctuation">)</span>     <span class="token keyword">def</span> <span class="token function">getadd</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>__add    <span class="token comment" spellcheck="true">#为 add 配置 setter 和 getter 方法</span>    add <span class="token operator">=</span> property<span class="token punctuation">(</span>getadd<span class="token punctuation">,</span> setadd<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#定义个私有方法</span>    <span class="token keyword">def</span> <span class="token function">__display</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>__name<span class="token punctuation">,</span>self<span class="token punctuation">.</span>__add<span class="token punctuation">)</span>clang <span class="token operator">=</span> CLanguage<span class="token punctuation">(</span><span class="token punctuation">)</span>clang<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"个人博客"</span>clang<span class="token punctuation">.</span>add <span class="token operator">=</span> <span class="token string">"http://forwardpeng.club"</span><span class="token keyword">print</span><span class="token punctuation">(</span>clang<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>clang<span class="token punctuation">.</span>add<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CLanguage 将 name 和 add 属性都隐藏了起来，但同时也提供了可操作它们的“窗口”，也就是各自的 setter 和 getter 方法，这些方法都是公有（public）的。</p><p>不仅如此，以add属性的 setadd() 方法为例，通过在该方法内部添加控制逻辑，即通过调用 startswith()方法，控制用户输入的地址必须以“http://”开头，否则程序将会执行 raise 语句抛出 ValueError 异常。</p><blockquote><p>raise 这里可简单理解成，如果用户输入不规范，程序将会报错。</p></blockquote><p><font color="red">以双下划线开头命名的类属性或类方法，Python 在底层实现时，将它们的名称都偷偷改成了 “_类名<strong>属性（方法）名” 的格式。私有的类属性（例如 __name 和 __add），其底层的名称也改成了“_类名</strong>属性名”的这种格式。可以通过修改 clang 对象的私有属性</font></p><h1 id="继承机制及其使用"><a href="#继承机制及其使用" class="headerlink" title="继承机制及其使用"></a>继承机制及其使用</h1><p>Python 类的封装、继承、多态 3 大特性，前面章节已经详细介绍了 Python 类的封装，本节继续讲解 Python 类的继承机制。</p><p>继承机制经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），但又不想直接将现有类代码复制给新类。也就是说，通过使用继承这种机制，可以轻松实现类的重复使用。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">draw</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"画"</span><span class="token punctuation">,</span>content<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Form</span><span class="token punctuation">(</span>Shape<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">area</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#....</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"此图形的面积为..."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>class From(Shape) 就表示 From 继承 Shape。Python中，实现继承的类称为子类，被继承的类称为父类（也可称为基类、超类）。因此在上面这个样例中，From 是子类，Shape 是父类。</p><p>子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。语法格式如下：</p><blockquote><p>class 类名(父类1, 父类2, …)：</p></blockquote><pre><code>#类定义部分</code></pre><p><font color="red">如果该类没有显式指定继承自哪个类，则默认继承 object 类（object 类是 Python 中所有类的父类，即要么是直接父类，要么是间接父类）。另外，Python 的继承是多继承机制（和 C++ 一样），即一个子类可以同时拥有多个直接父类。</font></p><p>继承是相对子类来说的，即子类继承自父类；而派生是相对于父类来说的，即父类派生出子类。子类拥有父类所有的属性和方法，即便该属性或方法是私有（private）的</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>使用多继承经常需要面临的问题是，多个父类中包含同名的类方法。对于这种情况，Python 的处置措施是：根据子类继承多个父类时这些父类的前后次序决定，即排在前面父类中的类方法会覆盖排在后面父类中的同名类方法。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> People    <span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"People类"</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> Animal    <span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Animal类"</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#People中的 name 属性和 say() 会遮蔽 Animal 类中的</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>People<span class="token punctuation">,</span> Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>zhangsan <span class="token operator">=</span> Person<span class="token punctuation">(</span><span class="token punctuation">)</span>zhangsan<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"张三"</span>zhangsan<span class="token punctuation">.</span>say<span class="token punctuation">(</span><span class="token punctuation">)</span>OutPut：People类 张三<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="父类方法重写"><a href="#父类方法重写" class="headerlink" title="父类方法重写"></a>父类方法重写</h1><p>类继承了父类，那么子类就拥有了父类所有的类属性和类方法。通常情况下，子类会在此基础上，扩展一些新的类属性和类方法。</p><blockquote><p>重写，有时又称覆盖，是一个意思，指的是对类中已有方法的内部实现进行修改。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Bird</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><pre><code>#鸟有翅膀def isWing(self):    print(&quot;鸟有翅膀&quot;)#鸟会飞def fly(self):    print(&quot;鸟会飞&quot;)</code></pre><p>class Ostrich(Bird):<br>    # 重写Bird类的fly()方法<br>    def fly(self):<br>        print(“鸵鸟不会飞”)</p><h1 id="创建Ostrich对象"><a href="#创建Ostrich对象" class="headerlink" title="创建Ostrich对象"></a>创建Ostrich对象</h1><p>ostrich = Ostrich()</p><p>#调用 Ostrich 类中重写的 fly() 类方法<br>ostrich.fly()<br>结果：鸵鸟不会飞</p><pre><code>## 如何调用被重写的方法通过类名调用实例方法的这种方式，又被称为未绑定方法。```python# 创建Ostrich对象ostrich = Ostrich()#调用 Bird 类中的 fly() 方法Bird.fly(ostrich)鸟会飞</code></pre><h1 id="使用Python继承机制-子类化内置类型"><a href="#使用Python继承机制-子类化内置类型" class="headerlink" title="使用Python继承机制(子类化内置类型)"></a>使用Python继承机制(子类化内置类型)</h1><p>内置类型子类化，其实就是自定义一个新类，使其继承有类似行为的内置类，通过重定义这个新类实现指定的功能。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">newDictError</span><span class="token punctuation">(</span>ValueError<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">"""如果向newDict 添加重复值，则引发此异常"""</span><span class="token keyword">class</span> <span class="token class-name">newDict</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token triple-quoted-string string">"""不接受重复值的字典"""</span>  <span class="token keyword">def</span> <span class="token function">__setitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> value <span class="token keyword">in</span> self<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> self <span class="token operator">and</span> self<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">!=</span>value<span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key <span class="token operator">not</span> <span class="token keyword">in</span> self<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> newDictError<span class="token punctuation">(</span><span class="token string">"这个值已经存在，并对应不同的键"</span><span class="token punctuation">)</span>    super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__setitem__<span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span>demoDict <span class="token operator">=</span> newDict<span class="token punctuation">(</span><span class="token punctuation">)</span>demoDict<span class="token punctuation">[</span><span class="token string">'key'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'value'</span>demoDict<span class="token punctuation">[</span><span class="token string">'other_key'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'value2'</span><span class="token keyword">print</span><span class="token punctuation">(</span>demoDict<span class="token punctuation">)</span>demoDict<span class="token punctuation">[</span><span class="token string">'other_key'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'value'</span><span class="token keyword">print</span><span class="token punctuation">(</span>demoDict<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>newDict是Python中 dict 类型的子类，所以其大部分行为都和dict内置类相同，唯一不同之处在于，newDict不允许字典中多个键对应相同的值。如果用户试图添加具有相同值的新元素，则会引发 newDictError 异常，并给出提示信息。</p><h1 id="super-函数：调用父类构造方法"><a href="#super-函数：调用父类构造方法" class="headerlink" title="super()函数：调用父类构造方法"></a>super()函数：调用父类构造方法</h1><p>Python 中子类会继承父类所有的类属性和类方法。严格来说，类的构造方法其实就是实例方法，因此毫无疑问，父类的构造方法，子类同样会继承。在子类中的构造方法中，调用父类构造方法的方式有 2 种，分别是：</p><ul><li>类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要额外备注类名（此方式又称为未绑定方法）；</li><li>使用 super() 函数。但如果涉及多继承，该函数只能调用第一个直接父类的构造方法。<blockquote><p>也就是说，涉及到多继承时，在子类构造函数中，调用第一个父类构造方法的方式有以上 2 种，而调用其它父类构造方法的方式只能使用未绑定方法。</p></blockquote></li></ul><p>语法格式如下：</p><blockquote><p>super().<strong>init</strong>(self,…)</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我是人，名字为："</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>food<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>food <span class="token operator">=</span> food    <span class="token keyword">def</span> <span class="token function">display</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我是动物,我吃"</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>food<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>People<span class="token punctuation">,</span> Animal<span class="token punctuation">)</span><span class="token punctuation">:</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><pre><code>#自定义构造方法def __init__(self,name,food):    #调用 People 类的构造方法    super().__init__(name)    #super(Person,self).__init__(name) #执行效果和上一行相同    #People.__init__(self,name)#使用未绑定方法调用 People 类构造方法    #调用其它父类的构造方法，需手动给 self 传值    Animal.__init__(self,food)    </code></pre><p>per = Person(“zhangsan”,”熟食”)<br>per.say()<br>per.display()</p><h1 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h1><pre><code>我是人，名字为： zhangsan我是动物,我吃 熟食</code></pre><pre><code>Person类自定义的构造方法中，调用People类构造方法，可以使用super() 函数，也可以使用未绑定方法。但是调用Animal类的构造方法，只能使用未绑定方法。# super()使用注意事项（包含新式类和旧式类的区别）Python 2.x 版本中，为了向后兼容保留了旧式类。该版本中的新式类必须显式继承 object 或者其他新式类：```pythonclass newStyleClass(object):  passclass newStyleClass(newStyleClass):  pass</code></pre><p>Python3.x中，显式声明某个类继承自object似乎是冗余的。但如果考虑跨版本兼容，那么就必须将 object 作为所有基类的祖先，因为如果不这么做的话，这些类将被解释为旧式类，最终会导致难以诊断的问题。</p><h1 id="super-使用注意事项"><a href="#super-使用注意事项" class="headerlink" title="super()使用注意事项"></a>super()使用注意事项</h1><p>由于基类不会在<strong>init</strong>() 中被隐式地调用，需要程序员显式调用它们。这种情况下，当程序中包含多重继承的类层次结构时，使用super是非常危险的，往往会在类的初始化过程中出现问题。</p><h2 id="混用super与显式类调用"><a href="#混用super与显式类调用" class="headerlink" title="混用super与显式类调用"></a>混用super与显式类调用</h2><p>C类使用了 <strong>init</strong>() 方法调用它的基类，会造成B类被调用了2次：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span>B<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">)</span>        A<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        B<span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"MRO:"</span><span class="token punctuation">,</span><span class="token punctuation">[</span>x<span class="token punctuation">.</span>__name__ <span class="token keyword">for</span> x <span class="token keyword">in</span> C<span class="token punctuation">.</span>__mro__<span class="token punctuation">]</span><span class="token punctuation">)</span>C<span class="token punctuation">(</span><span class="token punctuation">)</span>运行结果为：MRO<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'object'</span><span class="token punctuation">]</span>C A B B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> C的实例调用A.<strong>init</strong>(self)，使得super(A,self).<strong>init</strong>() 调用了B.<strong>init</strong>()方法。换句话说，super应该被用到整个类的层次结构中。</p><h2 id="不同种类的参数"><a href="#不同种类的参数" class="headerlink" title="不同种类的参数"></a>不同种类的参数</h2><pre class="line-numbers language-python"><code class="language-python"> <span class="token keyword">class</span> <span class="token class-name">commonBase</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"commonBase"</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">base1</span><span class="token punctuation">(</span>commonBase<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"base1"</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">base2</span><span class="token punctuation">(</span>commonBase<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"base2"</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">myClass</span><span class="token punctuation">(</span>base1<span class="token punctuation">,</span>base2<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>arg<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"my base"</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>arg<span class="token punctuation">)</span>myClass<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<em>args和*</em>kwargs包装的参数和关键字参数，但是由于任何参数都可以传入，所有构造函数都可以接受任何类型的参数，这会导致代码变得脆弱。另一种解决方法是在 MyClass 中显式地使用特定类的 <strong>init</strong>() 调用，但这无疑会导致第一种错误。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>尽可能避免使用多继承，可以使用一些设计模式来替代它；</li><li>super的使用必须一致，即在类的层次结构中，要么全部使用super，要么全不用。混用super和传统调用是一种混乱的写法；</li><li>如果代码需要兼容 Python 2.x，在 Python 3.x中应该显式地继承自 object。在 Python 2.x 中，没有指定任何祖先地类都被认定为旧式类。</li><li>调用父类时应提前查看类的层次结构，也就是使用类的<strong>mro</strong>属性或者mro()方法查看有关类的MRO。</li></ul><h1 id="slots-限制类实例动态添加属性和方法"><a href="#slots-限制类实例动态添加属性和方法" class="headerlink" title="slots:限制类实例动态添加属性和方法"></a><strong>slots</strong>:限制类实例动态添加属性和方法</h1><p>Python 提供了 <strong>slots</strong> 属性，通过它可以避免用户频繁的给实例对象动态地添加属性或方法。再次声明，<strong>slots</strong> 只能限制为实例对象动态添加属性和方法，而无法限制动态地为类添加属性和方法。</p><p><strong>slots</strong>属性值其实就是一个元组，只有其中指定的元素，才可以作为动态添加的属性或者方法的名称。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CLanguage</span><span class="token punctuation">:</span>    __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span><span class="token string">'add'</span><span class="token punctuation">,</span><span class="token string">'info'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>对于动态添加的方法，<strong>slots</strong>限制的是其方法名，并不限制参数的个数。只对当前所在的类起限制作用，如果为子类也设置有 <strong>slots</strong> 属性，那么子类实例对象允许动态添加的属性和方法，是子类中 <strong>slots</strong> 属性和父类 <strong>slots</strong> 属性的和。</p></blockquote><h1 id="type-函数：动态创建类"><a href="#type-函数：动态创建类" class="headerlink" title="type()函数：动态创建类"></a>type()函数：动态创建类</h1><p>type() 函数属于 Python 内置函数，通常用来查看某个变量的具体类型。其实，type() 函数还有一个更高级的用法，即创建一个自定义类型（也就是创建一个类）。type() 函数的语法格式有 2 种，分别如下：</p><ul><li>type(obj) </li><li>type(name, bases, dict)</li></ul><p>以上这 2 种语法格式，各参数的含义及功能分别是：</p><ul><li>第一种语法格式用来查看某个变量（类对象）的具体类型，obj 表示某个变量或者类对象。</li><li>第二种语法格式用来创建类，其中 name 表示类的名称；bases 表示一个元组，其中存储的是该类的父类；dict 表示一个字典，用于表示类内定义的属性或者方法。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我要学 Python！"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#使用 type() 函数创建类</span>CLanguage <span class="token operator">=</span> type<span class="token punctuation">(</span><span class="token string">"CLanguage"</span><span class="token punctuation">,</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dict<span class="token punctuation">(</span>say <span class="token operator">=</span> say<span class="token punctuation">,</span> name <span class="token operator">=</span> <span class="token string">"个人博客"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#创建一个 CLanguage 实例对象</span>clangs <span class="token operator">=</span> CLanguage<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#调用 say() 方法和 name 属性</span>clangs<span class="token punctuation">.</span>say<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>clangs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Python 元组语法规定，当 (object,) 元组中只有一个元素时，最后的逗号（,）不能省略。</p></blockquote><h1 id="MetaClass元类"><a href="#MetaClass元类" class="headerlink" title="MetaClass元类"></a>MetaClass元类</h1><p>使用元类的主要目的就是为了实现在创建类时，能够动态地改变类中定义的属性或者方法。把一个类设计成MetaClass 元类，其必须符合以下条件：</p><ul><li>必须显式继承自type类；</li><li>类中需要定义并实现<strong>new</strong>()方法，该方法一定要返回该类的一个实例对象，因为在使用元类创建类时，该<strong>new</strong>()方法会自动被执行，用来修改新建的类。<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#定义一个元类</span><span class="token keyword">class</span> <span class="token class-name">FirstMetaClass</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># cls代表动态修改的类</span>  <span class="token comment" spellcheck="true"># name代表动态修改的类名</span>  <span class="token comment" spellcheck="true"># bases代表被动态修改的类的所有父类</span>  <span class="token comment" spellcheck="true"># attr代表被动态修改的类的所有属性、方法组成的字典</span>  <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> name<span class="token punctuation">,</span> bases<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 动态为该类添加一个name属性</span>      attrs<span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"个人博客"</span>      attrs<span class="token punctuation">[</span><span class="token string">'say'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">lambda</span> self<span class="token punctuation">:</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用say()实例方法"</span><span class="token punctuation">)</span>      <span class="token keyword">return</span> super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span>name<span class="token punctuation">,</span>bases<span class="token punctuation">,</span>attrs<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#定义类时，指定元类</span><span class="token keyword">class</span> <span class="token class-name">CLanguage</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span>metaclass<span class="token operator">=</span>FirstMetaClass<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python多态及用法"><a href="#Python多态及用法" class="headerlink" title="Python多态及用法"></a>Python多态及用法</h1>Python是弱类型语言，其最明显的特征是在使用变量时，无需为其指定具体的数据类型。这会导致一种情况，即同一变量可能会被先后赋值不同的类对象，类的多态特性，还要满足以下 2 个前提条件：</li><li>继承：多态一定是发生在子类和父类之间；</li><li>重写：子类重写了父类的方法。<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">WhoSay</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>who<span class="token punctuation">)</span><span class="token punctuation">:</span>      who<span class="token punctuation">.</span>say<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">CLanguage</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用的是 Clanguage 类的say方法"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">CPython</span><span class="token punctuation">(</span>CLanguage<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用的是 CPython 类的say方法"</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">CLinux</span><span class="token punctuation">(</span>CLanguage<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">say</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用的是 CLinux 类的say方法"</span><span class="token punctuation">)</span>a <span class="token operator">=</span> WhoSay<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#调用 CLanguage 类的 say() 方法</span>a<span class="token punctuation">.</span>say<span class="token punctuation">(</span>CLanguage<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#调用 CPython 类的 say() 方法</span>a<span class="token punctuation">.</span>say<span class="token punctuation">(</span>CPython<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#调用 CLinux 类的 say() 方法</span>a<span class="token punctuation">.</span>say<span class="token punctuation">(</span>CLinux<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>通过给WhoSay类中的say()函数添加一个who参数，其内部利用传入的who调用 say() 方法。这意味着，当调用 WhoSay 类中的 say() 方法时，我们传给 who 参数的是哪个类的实例对象，它就会调用那个类中的 say()方法。<h1 id="枚举类定义及使用"><a href="#枚举类定义及使用" class="headerlink" title="枚举类定义及使用"></a>枚举类定义及使用</h1>实例：<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum<span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 为序列值指定value值</span>  red <span class="token operator">=</span> <span class="token number">1</span>  green <span class="token operator">=</span> <span class="token number">2</span>  blue <span class="token operator">=</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>Color 枚举类中，red、green、blue 都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为 name 和 value，其中 name 属性值为该枚举值的变量名（如 red），value 代表该枚举值的序号（序号通常从 1 开始）。<pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 访问枚举类成员</span><span class="token keyword">print</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>red<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Color<span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Color<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#调取枚举成员中的 value 和 name</span><span class="token keyword">print</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>red<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Color<span class="token punctuation">.</span>red<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>枚举类成员之间可以用 == 或者 is 进行比较是否相等，但各个成员的值，不能在类的外部做任何修改。Python枚举类中各个成员必须保证 name 互不相同，但value可以相同。可以借助@unique装饰器，这样当枚举类中出现相同值的成员时，程序会报 ValueError错误。实例如下：<pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum<span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 为序列值指定value值</span>  red <span class="token operator">=</span> <span class="token number">1</span>  green <span class="token operator">=</span> <span class="token number">1</span>  blue <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">print</span><span class="token punctuation">(</span>Color<span class="token punctuation">[</span><span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Output Color：red<span class="token keyword">from</span> enum <span class="token keyword">import</span> Enum<span class="token punctuation">,</span>unique<span class="token comment" spellcheck="true">#添加 unique 装饰器</span>@unique<span class="token keyword">class</span> <span class="token class-name">Color</span><span class="token punctuation">(</span>Enum<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 为序列值指定value值</span>  red <span class="token operator">=</span> <span class="token number">1</span>  green <span class="token operator">=</span> <span class="token number">1</span>  blue <span class="token operator">=</span> <span class="token number">3</span><span class="token keyword">print</span><span class="token punctuation">(</span>Color<span class="token punctuation">[</span><span class="token string">'green'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>ValueError错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>除了通过继承 Enum 类的方法创建枚举类，还可以使用Enum()函数创建枚举类。可接受2个参数，第一个用于指定枚举类的类名，第二个参数用于指定枚举类中的多个成员。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-代码质量</title>
      <link href="/2020/04/27/bian-cheng-yu-yan/python/python-dai-ma-zhi-liang/"/>
      <url>/2020/04/27/bian-cheng-yu-yan/python/python-dai-ma-zhi-liang/</url>
      
        <content type="html"><![CDATA[<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://www.zhihu.com/question/21408921/answer/129036707" target="_blank" rel="noopener">怎样才能写出 Pythonic 的代码？</a></li><li><a href="https://www.zhihu.com/question/37751951/answer/73425339" target="_blank" rel="noopener">Python优美代码的一些方法</a><h1 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h1><h2 id="enumerate类"><a href="#enumerate类" class="headerlink" title="enumerate类"></a>enumerate类</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> __future__ <span class="token keyword">import</span> print_function<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>L = [i*i for i in range(5)]</p><h1 id="普通写法"><a href="#普通写法" class="headerlink" title="普通写法"></a>普通写法</h1><p>index = 0<br>for data in L:<br>    index += 1<br>    print(index, ‘:’, data)</p><h1 id="enumerate类的使用"><a href="#enumerate类的使用" class="headerlink" title="enumerate类的使用"></a>enumerate类的使用</h1><p>for index, data in enumerate(L, 1):<br>    print(index, ‘:’, data)</p><pre><code>在保证代码可读性的前提下，代码越少越好。显然，使用enumerate效果就好很多。## reversedPython中的列表支持切片操作，可以像L[::-1]这样取reverse列表。## any遍历一个二维的元组，判断是否存在Non_unique为0,Null列不为YES的记录```python# 普通def has_primary_key():    for row in rows:        if row[1] == 0 and row[9] != &#39;YES&#39;:            return True        return False# 使用anydef has_prmary_key1():    return any(row[1] == 0 and row[9] != &#39;YES&#39; for row in rows)</code></pre><h1 id="Python中的小细节"><a href="#Python中的小细节" class="headerlink" title="Python中的小细节"></a>Python中的小细节</h1><h2 id="raise-SystemExit"><a href="#raise-SystemExit" class="headerlink" title="raise SystemExit"></a>raise SystemExit</h2><p>在程序检测某种错误时，打印错误信息，并退出程序</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">raise</span> SystemExit<span class="token punctuation">(</span><span class="token string">'It failed!'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="文件的x模式"><a href="#文件的x模式" class="headerlink" title="文件的x模式"></a>文件的x模式</h2><p>需求：写一个文件，如果该文件已经存在，则不写，否则以w模式打开文件并写入：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> os<span class="token keyword">if</span> <span class="token operator">not</span> os<span class="token punctuation">.</span>paht<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">'filename'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'Hello\n'</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'File already exists!'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用x模式</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'filename'</span><span class="token punctuation">,</span> <span class="token string">'xt'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    f<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token string">'Hello\n'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ConfigParser"><a href="#ConfigParser" class="headerlink" title="ConfigParser"></a>ConfigParser</h2><p>提供生成连接字符串的功能，用于读取配置参数。如下：</p><pre class="line-numbers language-txt"><code class="language-txt">$cat db.conf[DEFAULT]conn_str=%(dbn)s://(%user)s:%(pw)s@%(host)s:%(port)s/%(db)sdbn=mysqluser=rootpw=roothost=localhostport=3306db=test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="合理的使用数据结构"><a href="#合理的使用数据结构" class="headerlink" title="合理的使用数据结构"></a>合理的使用数据结构</h1><h2 id="字典的get传递默认值"><a href="#字典的get传递默认值" class="headerlink" title="字典的get传递默认值"></a>字典的get传递默认值</h2><pre class="line-numbers language-python"><code class="language-python">port <span class="token operator">=</span> kwargs<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'port'</span><span class="token punctuation">)</span><span class="token keyword">if</span> port <span class="token keyword">is</span> None<span class="token punctuation">:</span>    port <span class="token operator">=</span> <span class="token number">3306</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>字典的get方法支持提供默认参数，在字典没有值的情况下，将返回用户提供的默认参数，高质量的写法：</p><pre class="line-numbers language-python"><code class="language-python">port <span class="token operator">=</span> kwargs<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'port'</span><span class="token punctuation">,</span> <span class="token number">3306</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在调用pop()函数是，需要返回最后一个元素：</p><pre class="line-numbers language-python"><code class="language-python">L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>last <span class="token operator">=</span> L<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>L<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 优化</span>last <span class="token operator">=</span> L<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="dfaultdict-amp-Counter"><a href="#dfaultdict-amp-Counter" class="headerlink" title="dfaultdict &amp; Counter"></a>dfaultdict &amp; Counter</h2><p>需求1：假设字典的value是list，先判断key是否已经存在，如果不存在，新建一个list并赋值给key，如果已经存在，则调用list的append()方法，将值添加进去。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 普通</span>d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> pairs<span class="token punctuation">:</span>    <span class="token keyword">if</span> key <span class="token operator">not</span> <span class="token keyword">in</span> d<span class="token punctuation">:</span>        d<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    d<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 使用defaultdict</span>d <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> pairs<span class="token punctuation">:</span>    d<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需求2：统计一个文件中，每个单词出现的次数，使用字典的写法如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 普通写法</span>d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">with</span> open<span class="token punctuation">(</span>'<span class="token operator">/</span>etc<span class="token operator">/</span>passwd<span class="token operator">/</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>        <span class="token keyword">for</span> word <span class="token keyword">in</span> line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> word <span class="token operator">not</span> <span class="token keyword">in</span> d<span class="token punctuation">:</span>                d<span class="token punctuation">[</span>word<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>            d<span class="token punctuation">[</span>word<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># 使用collections中的Counter</span>word_counts <span class="token operator">=</span> Counter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'/etc/passwd'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>        word_counts<span class="token punctuation">.</span>update<span class="token punctuation">(</span>line<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">':'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需求3：打印出现次数最多的三个单词，使用字典如下：</p><pre class="line-numbers language-python"><code class="language-python">result <span class="token operator">=</span> sorted<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>d<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Couter直接提供</span><span class="token keyword">for</span> key<span class="token punctuation">,</span> val <span class="token keyword">in</span> <span class="token punctuation">(</span>word_counts<span class="token punctuation">.</span>most_common<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span><span class="token string">':'</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="nametuple"><a href="#nametuple" class="headerlink" title="nametuple"></a>nametuple</h2><p>监控系统，可以从/proc/diskstats中获取磁盘的详细信息</p><pre class="line-numbers language-shell"><code class="language-shell">$ cat /proc/diskstats    7       0 loop0 59 0 2116 3486 0 0 0 0 0 120 3420 0 0 0 0   7       1 loop1 132 0 2288 3816 0 0 0 0 0 164 3752 0 0 0 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果使用下标访问，计算较复杂，可以使用Python中的命名元组，即collections中的namedtuple，如下：</p><pre class="line-numbers language-python"><code class="language-python">DiskDevice <span class="token operator">=</span> collections<span class="token punctuation">.</span>namedtuple<span class="token punctuation">(</span><span class="token string">'DiskDevice'</span><span class="token punctuation">,</span> <span class="token string">'major_number minor_number device_name read_count read_merged_count'</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 有了命名空间，通过命名元组，能够通过属性访问各个字段，获取磁盘监控的代码如下：</span><span class="token keyword">def</span> <span class="token function">get_disk_info</span><span class="token punctuation">(</span>disk_name<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"/proc/diskstats"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>        <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">:</span>            <span class="token keyword">if</span> line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> disk_name<span class="token punctuation">:</span>                <span class="token keyword">return</span> DiskDevice<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="使用高级并发工具"><a href="#使用高级并发工具" class="headerlink" title="使用高级并发工具"></a>使用高级并发工具</h1><p>实例：生产者消费者模型，生产者向队列中放东西，消费者从队列中取东西。创建一个锁来保证线程间操作的互斥性，当队列满时，生产者进入等待状态，当队列空的时候，消费者进入等待状态。如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token punctuation">,</span> Condition<span class="token keyword">import</span> time<span class="token keyword">import</span> randomqueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>MAX_NUM <span class="token operator">=</span> <span class="token number">10</span>Condition <span class="token operator">=</span> Condition<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ProducerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        nums <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>        <span class="token keyword">global</span> queue        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            Condition<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span> <span class="token operator">==</span> MAX_NUM<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Queue full, producer is waiting"</span><span class="token punctuation">)</span>                Condition<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Space in queue, Consumer notified the producer"</span><span class="token punctuation">)</span>            num <span class="token operator">=</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>            queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Produced"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>            Condition<span class="token punctuation">.</span>notify<span class="token punctuation">(</span><span class="token punctuation">)</span>            Condition<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ConsumerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> queue        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            Condition<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> queue<span class="token punctuation">:</span>                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Nothing in queue, consumer is waiting"</span><span class="token punctuation">)</span>                Condition<span class="token punctuation">.</span>wait<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">print</span><span class="token punctuation">(</span>                    <span class="token string">"producer added something queue and notified the consumer"</span><span class="token punctuation">)</span>            num <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Consumed"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>            Condition<span class="token punctuation">.</span>notify<span class="token punctuation">(</span><span class="token punctuation">)</span>            Condition<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ProducerThread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>ConsumerThread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于同步问题，可以直接使用Queue，Queue提供线程安全的队列，适用解决生产者和消费者问题，支持阻塞读、阻塞写，写法如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread<span class="token keyword">import</span> time<span class="token keyword">import</span> random<span class="token keyword">from</span> queue <span class="token keyword">import</span> Queuequeue <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ProducThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        nums <span class="token operator">=</span> range<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>        <span class="token keyword">global</span> queue        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            num <span class="token operator">=</span> random<span class="token punctuation">.</span>choice<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>            queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>num<span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Produced"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">ConsumerThread</span><span class="token punctuation">(</span>Thread<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">run</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">global</span> queue        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            num <span class="token operator">=</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>            queue<span class="token punctuation">.</span>task_done<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Consumed"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span>            time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>ProducThread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>ConsumerThread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用Queue后，代码量减少。同时，在并发编程，不需要手动启动一个线程或进程，可以使用并发工具，内置的map是单线程运行的，如果涉及到网络请求或大量CPU计算，速度相对会慢很多，需要使用并发的map，如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Pool<span class="token keyword">def</span> <span class="token function">get_website_data</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    r <span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token keyword">return</span> r<span class="token punctuation">.</span>url<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    urls <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'http://www.google.com'</span><span class="token punctuation">.</span>    <span class="token string">'https://www.baidu.com'</span><span class="token punctuation">,</span>    <span class="token string">'http://www.163.com'</span><span class="token punctuation">]</span>    pool <span class="token operator">=</span> Pool<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>get_website_data<span class="token punctuation">,</span> urls<span class="token punctuation">)</span><span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了保证线程兼容，模型提供了dummy，用以提供线程池的实现，如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">from</span> multiprocessing<span class="token punctuation">.</span>dummy <span class="token keyword">import</span> Pool<span class="token comment" spellcheck="true"># 可以快速的在线程池和进程池之间切换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="使用装饰器"><a href="#使用装饰器" class="headerlink" title="使用装饰器"></a>使用装饰器</h1><p>实例：有两个模块，A模块需要给B模块发消息，B模块检查A模块发送过来的参数，没有问题则进行处理，对于检查参数的操作，使用装饰器的代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> inspect<span class="token keyword">import</span> functools<span class="token keyword">def</span> <span class="token function">check_args</span><span class="token punctuation">(</span>parameters<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    check paramenters of action    """</span>    <span class="token keyword">def</span> <span class="token function">decorated</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        decorator        """</span>        @functools<span class="token punctuation">.</span>wraps        <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>            func_args <span class="token operator">=</span> inspect<span class="token punctuation">.</span>getcallargs<span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>            msg <span class="token operator">=</span> func_args<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'msg'</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> item <span class="token keyword">in</span> parameters<span class="token punctuation">:</span>                <span class="token keyword">if</span> msg<span class="token punctuation">.</span>body_dict<span class="token punctuation">.</span>get<span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token keyword">is</span> None<span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token string">"check faild, %s is not found"</span> <span class="token operator">%</span> item            <span class="token keyword">return</span> f<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>        <span class="token keyword">return</span> wrapper    <span class="token keyword">return</span> decorated<span class="token comment" spellcheck="true">#使用装饰器</span><span class="token keyword">class</span> <span class="token class-name">AsyncMsgHandle</span><span class="token punctuation">(</span>MsgHandler<span class="token punctuation">)</span><span class="token punctuation">:</span>    @check<span class="token punctuation">.</span>check_args<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Containerldentifier'</span><span class="token punctuation">,</span> <span class="token string">'MonitorSecretKey'</span><span class="token punctuation">,</span> <span class="token string">"InstanceID"</span><span class="token punctuation">,</span> <span class="token string">"UUID"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">init_container</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python中的设计模式"><a href="#Python中的设计模式" class="headerlink" title="Python中的设计模式"></a>Python中的设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Borg</span><span class="token punctuation">:</span>    _shared_state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__dict__ <span class="token operator">=</span> self<span class="token punctuation">.</span>_shared_state<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>只要所有的实例共享状态、行为一直，就达到单例的目的，通过Borg可以创建任意数量的实例。在Python中，模块初始化一次，import机制是线程安全的，因此模块本身就是单例的实现。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// CPP的工厂模式实现</span><span class="token keyword">class</span> <span class="token class-name">Shape</span>    <span class="token keyword">class</span> <span class="token class-name">Circle</span><span class="token operator">:</span> <span class="token keyword">public</span> Shape    <span class="token keyword">class</span> <span class="token class-name">Square</span><span class="token operator">:</span> <span class="token keyword">public</span> Shape    Shape <span class="token operator">*</span>Shape<span class="token operator">::</span><span class="token function">factory</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>type<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token string">"Circle"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> Circle<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token string">"Square"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> Square<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述单例的Python实现如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span>Shape<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">Square</span><span class="token punctuation">(</span>Shape<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">for</span> name <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">"Circle"</span><span class="token punctuation">,</span> <span class="token string">"Square"</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    cls <span class="token operator">=</span> globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>name<span class="token punctuation">]</span>    obj <span class="token operator">=</span> cls<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理解：Python中的类是可调用的对象，在import后，存在于当前命名空间中。可以先通过名字获取类，再用类构造出对象，Python比C++少一个需要维护的函数。</p><h1 id="优美代码注意事项"><a href="#优美代码注意事项" class="headerlink" title="优美代码注意事项"></a>优美代码注意事项</h1><ul><li>写代码跟写作文一样，条理要清晰</li><li>准确无歧义，完整且清晰</li><li>排版清楚，添加必要的空行</li><li>添加必要的注释、注意标点符号</li><li>保证可读性且代码尽可能短小</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-流程控制</title>
      <link href="/2020/04/27/bian-cheng-yu-yan/python/python-liu-cheng-kong-zhi/"/>
      <url>/2020/04/27/bian-cheng-yu-yan/python/python-liu-cheng-kong-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="assert断言"><a href="#assert断言" class="headerlink" title="assert断言"></a>assert断言</h1><p>assert 语句的语法结构为：</p><blockquote><p>assert 表达式</p></blockquote><p>assert 语句的执行流程可以用 if 判断语句表示，如下所示：</p><blockquote><p>if 表达式==True:<br>    程序继续执行<br>else:<br>    程序报 AssertionError 错误</p><pre class="line-numbers language-python"><code class="language-python"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></blockquote><p>#price 为原价，discount 为折扣力度<br>def apply_discount(price, discount):<br>    updated_price = price * (1 - discount)<br>    assert 0 &lt;= updated_price &lt;= price, ‘折扣价应在 0 和原价之间’<br>    return updated_price</p><h1 id="添加了一个-assert-语句，用来检查折后价格，这里要求新折扣价格必须大于等于-0、小于等于原来的价格，否则就抛出异常。"><a href="#添加了一个-assert-语句，用来检查折后价格，这里要求新折扣价格必须大于等于-0、小于等于原来的价格，否则就抛出异常。" class="headerlink" title="添加了一个 assert 语句，用来检查折后价格，这里要求新折扣价格必须大于等于 0、小于等于原来的价格，否则就抛出异常。"></a>添加了一个 assert 语句，用来检查折后价格，这里要求新折扣价格必须大于等于 0、小于等于原来的价格，否则就抛出异常。</h1><pre><code>assert 的加入可以有效预防程序漏洞，提高程序的健壮性。循环嵌套结构的代码，Python解释器执行的流程为：* 当外层循环条件为 True 时，则执行外层循环结构中的循环体；* 外层循环体中包含了普通程序和内循环，当内层循环的循环条件为 True 时会执行此循环中的循环体，直到内层循环条件为 False，跳出内循环；* 如果此时外层循环的条件仍为 True，则返回第 2 步，继续执行外层循环体，直到外层循环的循环条件为False；* 当内层循环的循环条件为False，且外层循环的循环条件也为False，则整个嵌套循环才算执行完毕。# zip函数及其用法zip() 函数是 Python 内置函数之一，它可以将多个序列（列表、元组、字典、集合、字符串以及 range() 区间构成的列表）“压缩”成一个 zip 对象。所谓“压缩”，其实就是将这些序列中对应位置的元素重新组合，生成一个个新的元组。&gt;语法格式：zip(iterable, ...)其中iterable,... 表示多个列表、元组、字典、集合、字符串，甚至还可以为range()区间。```python&gt;&gt;&gt; my_list = [11,12,13]&gt;&gt;&gt; my_tuple = (21,22,23)&gt;&gt;&gt; print([x for x in zip(my_list,my_tuple)])[(11, 21), (12, 22), (13, 23)]</code></pre><h1 id="reversed函数及用法"><a href="#reversed函数及用法" class="headerlink" title="reversed函数及用法"></a>reversed函数及用法</h1><p>对于给定的序列（包括列表、元组、字符串以及 range(n) 区间），该函数可以返回一个逆序序列的迭代器（用于遍历该逆序序列）reserved()函数的语法格式如下：</p><blockquote><p>reversed(seq)</p></blockquote><p>其中，seq可以是列表，元素，字符串以及range()生成的区间列表。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token punctuation">[</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> reversed<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="sorted函数及用法"><a href="#sorted函数及用法" class="headerlink" title="sorted函数及用法"></a>sorted函数及用法</h1><p>sorted() 作为 Python 内置函数之一，其功能是对序列（列表、元组、字典、集合、还包括字符串）进行排序。sorted()函数的基本语法格式如下：</p><blockquote><p>list = sorted(iterable, key=None, reverse=False)  </p></blockquote><p>其中，iterable表示指定的序列，key 参数可以自定义排序规则；reverse参数指定以升序（False，默认）还是降序（True）进行排序。sorted()函数会返回一个排好序的列表。</p><p><font color="red">注意，key 参数和 reverse 参数是可选参数，即可以使用，也可以忽略。</font></p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>\<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token number">5</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">,</span>\<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token number">3</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">,</span>\<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token number">2</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">,</span>\<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token number">1</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>a<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>a<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 函数默认对序列中元素进行升序排序，通过手动将其reverse参数值改为True，可实现降序排序。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sorted()函数时，还可传入一个 key参数，它可以接受一个函数，该函数的功能是指定sorted()函数按照什么标准进行排序，实例如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> chars <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'sss'</span><span class="token punctuation">,</span> <span class="token string">'ss'</span><span class="token punctuation">,</span> <span class="token string">'sssss'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'ss'</span><span class="token punctuation">,</span> <span class="token string">'sss'</span><span class="token punctuation">,</span> <span class="token string">'sssss'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>sorted<span class="token punctuation">(</span>chars<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span>len<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'ss'</span><span class="token punctuation">,</span> <span class="token string">'sss'</span><span class="token punctuation">,</span> <span class="token string">'sssss'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="函数可变参数args及-kwargs"><a href="#函数可变参数args及-kwargs" class="headerlink" title="函数可变参数args及*kwargs"></a>函数可变参数<em>args及*</em>kwargs</h1><p>Python函数可变参数<em>args及*</em>kwargs，先给出标准答案：</p><ul><li><p>*args是arguments单词缩写，表示任意多个无名参数，是一个tuple，如 (1,2,3,’a’,’b’,’c’)</p></li><li><p>*<em>kwargs是keyword arguments单词缩写,表示关键字参数，是一个dict，如{‘a’:1,’b’:2,’c’:3}，</em>args参数必须在**kwargs前</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">print</span> <span class="token string">'args='</span><span class="token punctuation">,</span>args  <span class="token keyword">print</span> <span class="token string">'kwargs='</span><span class="token punctuation">,</span>kwargs  <span class="token keyword">print</span> <span class="token string">'*'</span><span class="token operator">*</span><span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>if <strong>name</strong>==’<strong>main</strong>‘:<br>    #只传参数<em>args=(1,2,3)<br>    foo(1,2,3)<br><br>    #只传参数*</em>kwargs=dict(a=1,b=2,c=3)<br>    foo(a=1,b=2,c=3)<br><br>    #传入参数<em>args=(1,2,3)<br>    #传入参数*</em>kwargs=dict(a=1,b=2,c=3)<br>    foo(1,2,3,a=1,b=2,c=3)<br><br>    #传入参数<em>args=(1,’b’,’c’)<br>    #传入参数*</em>kwargs=dict(a=1,b=’b’,c=’c’)<br>    foo(1,’b’,’c’,a=1,b=’b’,c=’c’)</p><p>输出：<br>args= (1, 2, 3)<br>kwargs= {}</p><hr><p>args= ()<br>kwargs= {‘a’: 1, ‘c’: 3, ‘b’: 2}</p><hr><p>args= (1, 2, 3)<br>kwargs= {‘a’: 1, ‘c’: 3, ‘b’: 2}</p><hr><p>args= (1, ‘b’, ‘c’)<br>kwargs= {‘a’: 1, ‘c’: ‘c’, ‘b’: ‘b’}</p><hr><pre><code>## 逆向参数收集在列表、元组前添加 *，在字典前添加 **。```python&gt;&gt;&gt; def test(a, b):...     print(a)...     print(b)... &gt;&gt;&gt; vals_1 = [10,20]&gt;&gt;&gt; test(*vals_1)1020&gt;&gt;&gt; vals_2 = {&#39;a&#39;:10, &#39;b&#39;:20}&gt;&gt;&gt; test(*vals_2)ab&gt;&gt;&gt; test(**vals_2)1020</code></pre><h1 id="None-空值-及其用法"><a href="#None-空值-及其用法" class="headerlink" title="None(空值)及其用法"></a>None(空值)及其用法</h1><p>有一个特殊的常量None（N 必须大写）。和False不同，它不表示0，也不表示空字符串，而表示没有值，也就是空值。</p><p>这里的空值并不代表空对象，即None和[]、“” 不同：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> None <span class="token keyword">is</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token boolean">False</span><span class="token operator">>></span><span class="token operator">></span> None <span class="token keyword">is</span> <span class="token string">""</span><span class="token boolean">False</span><span class="token operator">>></span><span class="token operator">></span> type<span class="token punctuation">(</span>None<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'NoneType'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">None 是 NoneType 数据类型的唯一值（其他编程语言可能称这个值为 null、nil 或 undefined），也就是说，我们不能再创建其它 NoneType 类型的变量，但是可以将 None 赋值给任何变量。如果希望变量中存储的东西不与任何其它值混淆，就可以使用 None。</font></p><h1 id="partial偏函数及其用法"><a href="#partial偏函数及其用法" class="headerlink" title="partial偏函数及其用法"></a>partial偏函数及其用法</h1><p>简单的理解偏函数，它是对原始函数的二次封装，是将现有函数的部分参数预先绑定为指定值，从而得到一个新的函数，该函数就称为偏函数。相比原函数，偏函数具有较少的可变参数，从而降低了函数调用的难度。</p><p>定义偏函数，需使用 partial 关键字（位于 functools 模块中），其语法格式如下：</p><ul><li>偏函数名 = partial(func, <em>args, *</em>kwargs)</li></ul><p>其中，func 指的是要封装的原函数，<em>args 和 *</em>kwargs 分别用于接收无关键字实参和关键字实参。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">mod</span><span class="token punctuation">(</span> n<span class="token punctuation">,</span> m <span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>   <span class="token keyword">return</span> n <span class="token operator">%</span> m<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">>></span><span class="token operator">></span> mod_by_100 <span class="token operator">=</span> partial<span class="token punctuation">(</span> mod<span class="token punctuation">,</span> <span class="token number">100</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>mod<span class="token punctuation">(</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">7</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">2</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>mod_by_100<span class="token punctuation">(</span> <span class="token number">7</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="变量作用域-全局变量和局部变量"><a href="#变量作用域-全局变量和局部变量" class="headerlink" title="变量作用域(全局变量和局部变量)"></a>变量作用域(全局变量和局部变量)</h1><p>作用域（Scope），就是变量的有效范围，就是变量可以在哪个范围以内使用。有些变量可以在整段代码的任意位置使用，有些变量只能在函数内部使用，有些变量只能在 for 循环内部使用。变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。本节我们只讲解两种变量，局部变量和全局变量。</p><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量（Local Variable）。</p><p>要知道，当函数被执行时，Python 会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     add <span class="token operator">=</span> <span class="token string">"http://c.biancheng.net/python/"</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数内部 add ="</span><span class="token punctuation">,</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">>></span><span class="token operator">></span> demo<span class="token punctuation">(</span><span class="token punctuation">)</span>函数内部 add <span class="token operator">=</span> http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>python<span class="token operator">/</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数外部 add ="</span><span class="token punctuation">,</span>add<span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>NameError<span class="token punctuation">:</span> name <span class="token string">'add'</span> <span class="token keyword">is</span> <span class="token operator">not</span> defined<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>在函数内部定义变量，Python 还允许在所有函数的外部定义变量，这样的变量称为全局变量（Global Variable）。和局部变量不同，全局变量的默认作用域是整个程序，即全局变量既可以在各个函数的外部使用，也可以在各函数内部使用。</p><p>定义全局变量的方式有以下2种：</p><ul><li>在函数体外定义的变量，一定是全局变量，如：<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> add <span class="token operator">=</span> <span class="token string">"http://c.biancheng.net/shell/"</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数体内访问："</span><span class="token punctuation">,</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">>></span><span class="token operator">></span> text<span class="token punctuation">(</span><span class="token punctuation">)</span>函数体内访问： http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>shell<span class="token operator">/</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'函数体外访问：'</span><span class="token punctuation">,</span>add<span class="token punctuation">)</span>函数体外访问： http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>shell<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>在函数体内定义全局变量。即使用 global关键字对变量进行修饰后，该变量就会变为全局变量<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">global</span> add<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     add<span class="token operator">=</span> <span class="token string">"http://c.biancheng.net/java/"</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数体内访问："</span><span class="token punctuation">,</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">>></span><span class="token operator">></span> text<span class="token punctuation">(</span><span class="token punctuation">)</span>函数体内访问： http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>java<span class="token operator">/</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span>http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>java<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><font color="red">注意，在使用 global 关键字修饰变量名时，不能直接给变量赋初值，否则会引发语法错误。</font><h2 id="获取指定作用域范围中的变量"><a href="#获取指定作用域范围中的变量" class="headerlink" title="获取指定作用域范围中的变量"></a>获取指定作用域范围中的变量</h2></li></ul><p><strong>1.globals()函数</strong> </p><p>globals()函数为Python的内置函数，它可以返回一个包含全局范围内所有变量的字典，该字典中的每个键值对，键为变量名，值为该变量的值。globals()函数返回的字典中，会默认包含有很多变量。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> globals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'Pyname'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Python入门教程"</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>Pyname<span class="token punctuation">)</span>Python入门教程<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2.locals()函数</strong></p><p>locals()函数也是Python内置函数之一，通过调用该函数，我们可以得到一个包含当前作用域内所有变量的字典。这里所谓的“当前作用域”指的是，在函数内部调用 locals() 函数，会获得包含所有局部变量的字典；而在全局范文内调用 locals() 函数，其功能和 globals() 函数相同。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> Pyname <span class="token operator">=</span> <span class="token string">"Python教程"</span><span class="token operator">>></span><span class="token operator">></span> Pyadd <span class="token operator">=</span> <span class="token string">"http://c.biancheng.net/python/"</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">def</span> <span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment" spellcheck="true">#局部变量</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     Shename <span class="token operator">=</span> <span class="token string">"shell教程"</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     Sheadd<span class="token operator">=</span> <span class="token string">"http://c.biancheng.net/shell/"</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数内部的 locals:"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">>></span><span class="token operator">></span> text<span class="token punctuation">(</span><span class="token punctuation">)</span>函数内部的 locals<span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token string">'Sheadd'</span><span class="token punctuation">:</span> <span class="token string">'http://c.biancheng.net/shell/'</span><span class="token punctuation">,</span> <span class="token string">'Shename'</span><span class="token punctuation">:</span> <span class="token string">'shell教程'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"函数外部的 locals:"</span><span class="token punctuation">)</span>函数外部的 locals<span class="token punctuation">:</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>locals<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.vars(object)</strong></p><p>vars() 函数也是 Python 内置函数，其功能是返回一个指定 object 对象范围内所有变量组成的字典。如果不传入object 参数，vars() 和 locals() 的作用完全相同。</p><h1 id="同名的全局变量"><a href="#同名的全局变量" class="headerlink" title="同名的全局变量"></a>同名的全局变量</h1><p>解决方式：</p><p>方式1：在函数中要定义局部变量时不要与全局变量同名， 即在numCheck( )中定义的局部变量换个名。</p><p>方式2：进入函数时先定义与全局变量同名的局部变量，就不会报错了，但是这样就没有达到引用全局变量a之后再定义与全局变量同名的局部变量a 的目的，所以引入方式3。</p><p>方式3：这里涉及到全局变量和局部变量的区分，如果想使用全局变量a之后再使用同名的局部变量a，就应该是把方法和变量定义在类里。通过类的成员变量去引用全局变量。</p><h1 id="局部函数及用法（包含nonlocal关键字）"><a href="#局部函数及用法（包含nonlocal关键字）" class="headerlink" title="局部函数及用法（包含nonlocal关键字）"></a>局部函数及用法（包含nonlocal关键字）</h1><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#全局函数</span><span class="token keyword">def</span> outdef <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    name <span class="token operator">=</span> <span class="token string">"所在函数中定义的 name 变量"</span>    <span class="token comment" spellcheck="true">#局部函数</span>    <span class="token keyword">def</span> <span class="token function">indef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        nonlocal name        <span class="token keyword">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#修改name变量的值</span>        name <span class="token operator">=</span> <span class="token string">"局部函数中定义的 name 变量"</span>    indef<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#调用全局函数</span>outdef<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于这里的name变量也是局部变量，因此前面章节讲解的globals() 函数或者 globals关键字，并不适用于解决此问题。这里可以使用Python提供的 nonlocal关键字</p><h1 id="函数的高级用法"><a href="#函数的高级用法" class="headerlink" title="函数的高级用法"></a>函数的高级用法</h1><p>Python 函数还支持赋值、作为其他函数的参数以及作为其他函数的返回值。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">my_def</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"正在执行 my_def 函数"</span><span class="token punctuation">)</span>other <span class="token operator">=</span> my_defother<span class="token punctuation">(</span><span class="token punctuation">)</span>正在执行 my_def 函数<span class="token comment" spellcheck="true"># Python 还支持函数的返回值也为函数</span><span class="token keyword">def</span> my_def <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#局部函数</span>    <span class="token keyword">def</span> <span class="token function">indef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"调用局部函数"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#调用局部函数</span>    <span class="token keyword">return</span> indefother_def <span class="token operator">=</span> my_def<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#调用局部的 indef() 函数</span>other_def<span class="token punctuation">(</span><span class="token punctuation">)</span>调用局部函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python的闭包"><a href="#Python的闭包" class="headerlink" title="Python的闭包"></a>Python的闭包</h1><p>闭包，又称闭包函数或者闭合函数，其实和前面讲的嵌套函数类似，不同之处在于，闭包中外部函数返回的不是一个具体的值，而是一个函数。一般情况下，返回的函数会赋值给一个变量，这个变量可以在后面被继续执行调用。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#闭包函数，其中 exponent 称为自由变量</span><span class="token keyword">def</span> <span class="token function">nth_power</span><span class="token punctuation">(</span>exponent<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exponent_of</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> base <span class="token operator">**</span> exponent    <span class="token keyword">return</span> exponent_of <span class="token comment" spellcheck="true"># 返回值是 exponent_of 函数</span>square <span class="token operator">=</span> nth_power<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 计算一个数的平方</span>cube <span class="token operator">=</span> nth_power<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 计算一个数的立方</span><span class="token keyword">print</span><span class="token punctuation">(</span>square<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 计算 2 的平方</span><span class="token keyword">print</span><span class="token punctuation">(</span>cube<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 计算 2 的立方</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">函数开头需要做一些额外工作，当需要多次调用该函数时，如果将那些额外工作的代码放在外部函数，就可以减少多次调用导致的不必要开销，提高程序的运行效率。</font></p><h2 id="闭包的closure属性"><a href="#闭包的closure属性" class="headerlink" title="闭包的closure属性"></a>闭包的<strong>closure</strong>属性</h2><p>记录着自由变量的地址。当闭包被调用时，系统就会根据该地址找到对应的自由变量，完成整体的函数调用。类型是一个元组，这表明闭包可以支持多个自由变量的形式。</p><h1 id="lambda表达式-匿名函数-及其用法"><a href="#lambda表达式-匿名函数-及其用法" class="headerlink" title="lambda表达式(匿名函数)及其用法"></a>lambda表达式(匿名函数)及其用法</h1><p>lambda 表达式，又称匿名函数，常用来表示内部仅包含 1 行表达式的函数。如果一个函数的函数体仅有 1 行表达式，则该函数就可以用 lambda 表达式来代替。lambda 表达式的语法格式如下：</p><blockquote><p>name = lambda [list] : 表达式</p></blockquote><p>其中，定义 lambda 表达式，必须使用 lambda 关键字；[list] 作为可选参数，等同于定义函数是指定的参数列表；value 为该表达式的名称。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> add <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token punctuation">:</span> x <span class="token operator">+</span> y<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>add<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>lamba 表达式具有以下  2 个优势：</p><ul><li>对于单行函数，使用 lambda 表达式可以省去定义函数的过程，让代码更加简洁；</li><li>对于不需要多次复用的函数，使用 lambda 表达式可以在用完之后立即释放，提高程序执行的性能。<h1 id="eval-和exec-函数"><a href="#eval-和exec-函数" class="headerlink" title="eval()和exec()函数"></a>eval()和exec()函数</h1>eval() 和 exec() 函数的功能是相似的，都可以执行一个字符串形式的 Python 代码（代码以字符串的形式提供），相当于一个 Python 的解释器。二者不同之处在于，eval() 执行完要返回结果，而 exec() 执行完不返回结果。<br>eval() 函数的语法格式为：<blockquote><p>eval(source, globals=None, locals=None, /)</p></blockquote></li></ul><p>而 exec() 函数的语法格式如下：</p><blockquote><p>exec(source, globals=None, locals=None, /)</p></blockquote><p>二者的语法格式除了函数名，其他都相同，其中各个参数的具体含义如下：</p><ul><li>expression：这个参数是一个字符串，代表要执行的语句 。该语句受后面两个字典类型参数 globals 和 locals 的限制，只有在 globals 字典和 locals 字典作用域内的函数和变量才能被执行。</li><li>globals：这个参数管控的是一个全局的命名空间，即 expression 可以使用全局命名空间中的函数。如果只是提供了 globals 参数，而没有提供自定义的 <strong>builtins</strong>，则系统会将当前环境中的 * <strong>builtins</strong> 复制到自己提供的 globals 中，然后才会进行计算；如果连 globals 这个参数都没有被提供，则使用 Python 的全局命名空间。</li><li>locals：这个参数管控的是一个局部的命名空间，和 globals 类似，当它和 globals 中有重复或冲突时，以 locals 的为准。如果 locals 没有被提供，则默认为 globals。</li></ul><p><font color="red">注意，<strong>builtins</strong> 是 Python 的内建模块，平时使用的 int、str、abs 都在这个模块中。通过<br>print(dic[“<strong>builtins</strong>“]) 语句可以查看 <strong>builtins</strong> 所对应的 value。</font></p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a<span class="token operator">=</span><span class="token number">10</span><span class="token operator">>></span><span class="token operator">></span> b<span class="token operator">=</span><span class="token number">20</span><span class="token operator">>></span><span class="token operator">></span> c<span class="token operator">=</span><span class="token number">30</span><span class="token operator">>></span><span class="token operator">></span> g<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">8</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#定义一个字典</span><span class="token operator">>></span><span class="token operator">></span> t<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#定义一个字典</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>eval<span class="token punctuation">(</span><span class="token string">'a+b+c'</span><span class="token punctuation">,</span> g<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#定义一个字典 116</span><span class="token number">116</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="exec-和eval-区别"><a href="#exec-和eval-区别" class="headerlink" title="exec()和eval()区别"></a>exec()和eval()区别</h2><pre class="line-numbers language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">exec</span><span class="token punctuation">(</span><span class="token string">"a = 2"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#相当于直接执行 a=2</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token number">2</span>a <span class="token operator">=</span> <span class="token keyword">exec</span><span class="token punctuation">(</span><span class="token string">"2+3"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#相当于直接执行 2+3，但是并没有返回值，a 应为 None</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>Nonea <span class="token operator">=</span> eval<span class="token punctuation">(</span><span class="token string">'2+3'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#执行 2+3，并把结果返回给 a</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token number">5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>exec() 中最适合放置运行后没有结果的语句，而 eval() 中适合放置有结果返回的语句。</p><h2 id="eval-和-exec-函数的应用场景"><a href="#eval-和-exec-函数的应用场景" class="headerlink" title="eval() 和 exec() 函数的应用场景"></a>eval() 和 exec() 函数的应用场景</h2><p>客户端向服务端发送一段字符串代码，服务端无需关心具体的内容，直接跳过 eval() 或 exec() 来执行，这样的设计会使服务端与客户端的耦合度更低，系统更易扩展。<br><font color="red">注意的是，在使用 eval() 或是 exec() 来处理请求代码时，函数 eval() 和 exec() 常常会被黑客利用，成为可以执行系统级命令的入口点，进而来攻击网站。解决方法是：通过设置其命名空间里的可执行函数，来限制 eval() 和 exec() 的执行范围。</font></p><p>第一个参数是字符串，而字符串的内容一定要是可执行的代码。在编写代码时，一般会使 repr() 数来生成动态的字符串，再传入到 eval() 或 exec() 函数内，实现动态执行代码的功能。</p><h1 id="函数式编程（map-、filter-和reduce-）详解"><a href="#函数式编程（map-、filter-和reduce-）详解" class="headerlink" title="函数式编程（map()、filter()和reduce()）详解"></a>函数式编程（map()、filter()和reduce()）详解</h1><p>函数式编程的优点，主要在于其纯函数和不可变的特性使程序更加健壮，易于调试和测试；缺点主要在于限制多，难写。<br>注意，纯粹的函数式编程语言（比如 Scala），其编写的函数中是没有变量的，因此可以保证，只要输入是确定的，输出就是确定的；而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出。</p><p>Python 允许使用变量，所以它并不是一门纯函数式编程语言。Python 仅对函数式编程提供了部分支持，主要包括 map()、filter() 和 reduce() 这 3 个函数，它们通常都结合 lambda 匿名函数一起使用。接下来就对这 3 个函数的用法做逐一介绍。</p><h2 id="map-函数"><a href="#map-函数" class="headerlink" title="map()函数"></a>map()函数</h2><p>map()函数的基本语法格式如下：</p><blockquote><p>map(function, iterable)</p></blockquote><p>其中，function参数表示要传入一个函数，其可以是内置函数、自定义函数或者 lambda 匿名函数；iterable 表示一个或多个可迭代对象，可以是列表、字符串等。map()函数的功能是对可迭代对象中的每个元素，都调用指定的函数，并返回一个map对象。</p><blockquote><p>注意，该函数返回的是一个map对象，不能直接输出，可以通过for循环或者 list() 函数来显示。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span> listDemo1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">>></span> listDemo2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">>></span> new_list <span class="token operator">=</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token punctuation">:</span> x <span class="token operator">+</span> y<span class="token punctuation">,</span> listDemo1<span class="token punctuation">,</span>listDemo2<span class="token punctuation">)</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>new_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">注意，由于 map() 函数是直接由用 C 语言写的，运行时不需要通过 Python 解释器间接调用，并且内部做了诸多优化，所以相比其他方法，此方法的运行效率最高。</font></p></blockquote><h2 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter()函数"></a>filter()函数</h2><p>filter()函数的基本语法格式如下：</p><blockquote><p>filter(function, iterable)</p></blockquote><p>此格式中，funcition参数表示要传入一个函数，iterable表示一个可迭代对象。filter()函数的功能是对 iterable中的每个元素，都使用 function函数判断，并返回 True 或者 False，最后将返回 True 的元素组成一个新的可遍历的集合。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> new_list <span class="token operator">=</span> map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token punctuation">:</span> x<span class="token operator">-</span>y<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>list<span class="token punctuation">(</span>new_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="reduce-函数"><a href="#reduce-函数" class="headerlink" title="reduce()函数"></a>reduce()函数</h2><p>reduce()函数通常用来对一个集合做一些累积操作，其基本语法格式为：</p><blockquote><p>reduce(function, iterable)</p></blockquote><p>其中，function规定必须是一个包含2个参数的函数；iterable 表示可迭代对象。注意，由于 reduce()函数在 Python 3.x中已经被移除，放入了 functools模块，因此在使用该函数之前，需先导入functools模块。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> listDemo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> product <span class="token operator">=</span> functools<span class="token punctuation">.</span>reduce<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">*</span> y<span class="token punctuation">,</span> listDemo<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>product<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 叠乘</span><span class="token number">120</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="函数注解（Function-Annotations）"><a href="#函数注解（Function-Annotations）" class="headerlink" title="函数注解（Function Annotations）"></a>函数注解（Function Annotations）</h1><p>函数注解语法 可以让你在定义函数的时候对参数和返回值添加注解：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foobar</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token string">"it's b"</span><span class="token punctuation">,</span> c<span class="token punctuation">:</span> str <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> tuple<span class="token punctuation">:</span>    <span class="token keyword">return</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token comment" spellcheck="true"># foobar.__annotations__获取参数注解</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>a: int 这种是注解参数</li><li>c: str = 5 是注解有默认值的参数</li><li>-&gt; tuple 是注解返回值。</li></ul><p>基于注解可以实现参数类型检查的装饰器</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># coding: utf8</span><span class="token keyword">import</span> collections<span class="token keyword">import</span> functools<span class="token keyword">import</span> inspect<span class="token keyword">def</span> <span class="token function">check</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    msg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'Expected type {expected!r} for argument {argument}, '</span>           <span class="token string">'but got type {got!r} with value {value!r}'</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 获取函数定义的参数</span>    sig <span class="token operator">=</span> inspect<span class="token punctuation">.</span>signature<span class="token punctuation">(</span>func<span class="token punctuation">)</span>    parameters <span class="token operator">=</span> sig<span class="token punctuation">.</span>parameters          <span class="token comment" spellcheck="true"># 参数有序字典</span>    arg_keys <span class="token operator">=</span> tuple<span class="token punctuation">(</span>parameters<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 参数名称</span>    @functools<span class="token punctuation">.</span>wraps<span class="token punctuation">(</span>func<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        CheckItem <span class="token operator">=</span> collections<span class="token punctuation">.</span>namedtuple<span class="token punctuation">(</span><span class="token string">'CheckItem'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'anno'</span><span class="token punctuation">,</span> <span class="token string">'arg_name'</span><span class="token punctuation">,</span> <span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        check_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># collect args   *args 传入的参数以及对应的函数参数注解</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> value <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>            arg_name <span class="token operator">=</span> arg_keys<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            anno <span class="token operator">=</span> parameters<span class="token punctuation">[</span>arg_name<span class="token punctuation">]</span><span class="token punctuation">.</span>annotation            check_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>CheckItem<span class="token punctuation">(</span>anno<span class="token punctuation">,</span> arg_name<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># collect kwargs  **kwargs 传入的参数以及对应的函数参数注解</span>        <span class="token keyword">for</span> arg_name<span class="token punctuation">,</span> value <span class="token keyword">in</span> kwargs<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>           anno <span class="token operator">=</span> parameters<span class="token punctuation">[</span>arg_name<span class="token punctuation">]</span><span class="token punctuation">.</span>annotation           check_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>CheckItem<span class="token punctuation">(</span>anno<span class="token punctuation">,</span> arg_name<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># check type</span>        <span class="token keyword">for</span> item <span class="token keyword">in</span> check_list<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> isinstance<span class="token punctuation">(</span>item<span class="token punctuation">.</span>value<span class="token punctuation">,</span> item<span class="token punctuation">.</span>anno<span class="token punctuation">)</span><span class="token punctuation">:</span>                error <span class="token operator">=</span> msg<span class="token punctuation">.</span>format<span class="token punctuation">(</span>expected<span class="token operator">=</span>item<span class="token punctuation">.</span>anno<span class="token punctuation">,</span> argument<span class="token operator">=</span>item<span class="token punctuation">.</span>arg_name<span class="token punctuation">,</span>                                   got<span class="token operator">=</span>type<span class="token punctuation">(</span>item<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token operator">=</span>item<span class="token punctuation">.</span>value<span class="token punctuation">)</span>                <span class="token keyword">raise</span> TypeError<span class="token punctuation">(</span>error<span class="token punctuation">)</span>        <span class="token keyword">return</span> func<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span>    <span class="token keyword">return</span> wrapper@check<span class="token keyword">def</span> <span class="token function">foobar</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> int<span class="token punctuation">,</span> b<span class="token punctuation">:</span>str<span class="token punctuation">,</span> c<span class="token punctuation">:</span> float<span class="token operator">=</span><span class="token number">3.2</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> tuple<span class="token punctuation">:</span>    <span class="token keyword">return</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token operator">>></span><span class="token operator">></span> foobar<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token number">3.2</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> foobar<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>TypeError<span class="token punctuation">:</span> Expected type <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'int'</span><span class="token operator">></span> <span class="token keyword">for</span> argument a<span class="token punctuation">,</span> but got type <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'str'</span><span class="token operator">></span> <span class="token keyword">with</span> value 'a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-字符串</title>
      <link href="/2020/04/27/bian-cheng-yu-yan/python/python-zi-fu-chuan/"/>
      <url>/2020/04/27/bian-cheng-yu-yan/python/python-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="split-分割字符串"><a href="#split-分割字符串" class="headerlink" title="split()分割字符串"></a>split()分割字符串</h1><p>split() 方法可以实现将一个字符串按照指定的分隔符切分成多个子串，这些子串会被保存到列表中（不包含分隔符），作为方法的返回值反馈回来。该方法的基本语法格式如下：</p><blockquote><p>str.split(sep,maxsplit)</p></blockquote><p>此方法中各部分参数的含义分别是：</p><ul><li>str：表示要进行分割的字符串；</li><li>sep：用于指定分隔符，可以包含多个字符。此参数默认为 None，表示所有空字符，包括空格、换行符“\n”、制表符“\t”等。</li><li>maxsplit：可选参数，用于指定分割的次数，最后列表中子串的个数最多为 maxsplit+1。如果不指定或者指定为 -1，则表示分割次数没有限制。’</li></ul><h1 id="join-方法，合并字符串"><a href="#join-方法，合并字符串" class="headerlink" title="join()方法，合并字符串"></a>join()方法，合并字符串</h1><p>join() 方法的语法格式如下：</p><blockquote><p>newstr = str.join(iterable)</p></blockquote><p>此方法中各参数的含义如下：</p><ul><li>newstr：表示合并后生成的新字符串；</li><li>str：用于指定合并时的分隔符；</li><li>iterable：做合并操作的源字符串数据，允许以列表、元组等形式提供。</li></ul><h1 id="统计字符串出现的次数"><a href="#统计字符串出现的次数" class="headerlink" title="统计字符串出现的次数"></a>统计字符串出现的次数</h1><p>count 方法用于检索指定字符串在另一字符串中出现的次数，如果检索的字符串不存在，则返回 0，否则返回出现的次数。count方法的语法格式如下：</p><blockquote><p>str.count(sub[,start[,end]])</p></blockquote><p>此方法中，各参数的具体含义如下：</p><ul><li>str：表示原字符串；</li><li>sub：表示要检索的字符串；</li><li>start：指定检索的起始位置，也就是从什么位置开始检测。如果不指定，默认从头开始检索；</li><li>end：指定检索的终止位置，如果不指定，则表示一直检索到结尾。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str <span class="token operator">=</span> <span class="token string">"c.biancheng.net"</span><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="find-方法，检测字符串中是否包含某子串"><a href="#find-方法，检测字符串中是否包含某子串" class="headerlink" title="find()方法，检测字符串中是否包含某子串"></a>find()方法，检测字符串中是否包含某子串</h1><p>find() 方法的语法格式如下：</p><blockquote><p>str.find(sub[,start[,end]])</p></blockquote><p>此格式中各参数的含义如下：</p><ul><li>str：表示原字符串；</li><li>sub：表示要检索的目标字符串；</li><li>start：表示开始检索的起始位置。如果不指定，则默认从头开始检索；</li><li>end：表示结束检索的结束位置。如果不指定，则默认一直检索到结尾。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 首次出现</span><span class="token number">1</span><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 起始索引位置</span><span class="token number">11</span><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>find<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 区间</span><span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">注意，Python 还提供了 rfind() 方法，与 find() 方法最大的不同在于，rfind()是从字符串右边开始检索。</font></p><h1 id="index-方法：检测字符串中是否包含某子串"><a href="#index-方法：检测字符串中是否包含某子串" class="headerlink" title="index()方法：检测字符串中是否包含某子串"></a>index()方法：检测字符串中是否包含某子串</h1><p>index() 方法也可以用于检索是否包含指定的字符串，不同之处在于，当指定的字符串不存在时，index() 方法会抛出异常。index()方法的语法格式如下：</p><blockquote><p>str.index(sub[,start[,end]])</p></blockquote><p>此格式中各参数的含义分别是：</p><ul><li>str：表示原字符串；</li><li>sub：表示要检索的子字符串；</li><li>start：表示检索开始的起始位置，如果不指定，默认从头开始检索；</li><li>end：表示检索的结束位置，如果不指定，默认一直检索到结尾。</li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'z'</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;pyshell#49>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>    str<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token string">'z'</span><span class="token punctuation">)</span>ValueError<span class="token punctuation">:</span> substring <span class="token operator">not</span> found<span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>rindex<span class="token punctuation">(</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token number">11</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="字符串对齐方法-ljust-、rjust-和center"><a href="#字符串对齐方法-ljust-、rjust-和center" class="headerlink" title="字符串对齐方法(ljust()、rjust()和center())"></a>字符串对齐方法(ljust()、rjust()和center())</h1><h2 id="ljust-方法"><a href="#ljust-方法" class="headerlink" title="ljust()方法"></a>ljust()方法</h2><p>ljust() 方法的功能是向指定字符串的右侧填充指定字符，从而达到左对齐文本的目的。ljust() 方法的基本格式如下：</p><blockquote><p>S.ljust(width[, fillchar])</p></blockquote><p>其中各个参数的含义如下：</p><ul><li>S：表示要进行填充的字符串；</li><li>width：表示包括 S 本身长度在内，字符串要占的总长度；</li><li>fillchar：作为可选参数，用来指定填充字符串时所用的字符，默认情况使用空格。<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> S <span class="token operator">=</span> <span class="token string">'http://c.biancheng.net/python/'</span><span class="token operator">>></span><span class="token operator">></span> addr <span class="token operator">=</span> <span class="token string">'http://c.biancheng.net'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">)</span>http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>python<span class="token operator">/</span>      <span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>addr<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">)</span>http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net <span class="token comment" spellcheck="true"># 该输出结果中除了明显可见的网址字符串外，其后还有空格字符存在，每行一共 35 个字符长度。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="rjust-方法"><a href="#rjust-方法" class="headerlink" title="rjust()方法"></a>rjust()方法</h2>rjust() 和 ljust() 方法类似，唯一的不同在于，rjust() 方法是向字符串的左侧填充指定字符，从而达到右对齐文本的目的。rjust() 方法的基本格式如下：<blockquote><p>S.rjust(width[, fillchar])</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span class="token operator">/</span>python<span class="token operator">/</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>addr<span class="token punctuation">.</span>rjust<span class="token punctuation">(</span><span class="token number">35</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           http<span class="token punctuation">:</span><span class="token operator">//</span>c<span class="token punctuation">.</span>biancheng<span class="token punctuation">.</span>net<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="center-方法"><a href="#center-方法" class="headerlink" title="center()方法"></a>center()方法</h2>center() 字符串方法与 ljust() 和 rjust() 的用法类似，但它让文本居中，而不是左对齐或右对齐。center() 方法的基本格式如下：<blockquote><p>S.center(width[, fillchar])</p></blockquote></li></ul><p>其中各个参数的含义和 ljust()、rjust()方法相同。</p><h1 id="startswith-和endswith-方法"><a href="#startswith-和endswith-方法" class="headerlink" title="startswith()和endswith()方法"></a>startswith()和endswith()方法</h1><h2 id="startswith-方法"><a href="#startswith-方法" class="headerlink" title="startswith()方法"></a>startswith()方法</h2><p>startswith() 方法用于检索字符串是否以指定字符串开头，如果是返回 True；反之返回 False。此方法的语法格式如下：</p><blockquote><p>str.startswith(sub[,start[,end]])</p></blockquote><p>此格式中各个参数的具体含义如下：</p><ul><li>str：表示原字符串；</li><li>sub：要检索的子串；</li><li>start：指定检索开始的起始位置索引，如果不指定，则默认从头开始检索；</li><li>end：指定检索的结束位置索引，如果不指定，则默认一直检索在结束。<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str <span class="token operator">=</span> <span class="token string">"c.biancheng.net"</span><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="endswith-方法"><a href="#endswith-方法" class="headerlink" title="endswith()方法"></a>endswith()方法</h2>endswith() 方法用于检索字符串是否以指定字符串结尾，如果是则返回 True；反之则返回 False。该方法的语法格式如下：<blockquote><p>str.endswith(sub[,start[,end]])</p></blockquote></li></ul><p>此格式中各参数的含义如下：</p><ul><li>str：表示原字符串；</li><li>sub：表示要检索的字符串；</li><li>start：指定检索开始时的起始位置索引（字符串第一个字符对应的索引值为 0），如果不指定，默认从头开始检索。</li><li>end：指定检索的结束位置索引，如果不指定，默认一直检索到结束。</li></ul><h1 id="字符串大小写转换（3种）函数及用法"><a href="#字符串大小写转换（3种）函数及用法" class="headerlink" title="字符串大小写转换（3种）函数及用法"></a>字符串大小写转换（3种）函数及用法</h1><h2 id="title-方法"><a href="#title-方法" class="headerlink" title="title()方法"></a>title()方法</h2><p>title() 方法用于将字符串中每个单词的首字母转为大写，其他字母全部转为小写，转换完成后，此方法会返回转换得到的字符串。如果字符串中没有需要被转换的字符，此方法会将字符串原封不动地返回。title()方法的语法格式如下：</p><blockquote><p>str.title()</p></blockquote><p>其中，str 表示要进行转换的字符串。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str <span class="token operator">=</span> <span class="token string">"c.biancheng.net"</span><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'C.Biancheng.Net'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="lower-方法"><a href="#lower-方法" class="headerlink" title="lower()方法"></a>lower()方法</h2><p>lower() 方法用于将字符串中的所有大写字母转换为小写字母，转换完成后，该方法会返回新得到的字符串。如果字符串中原本就都是小写字母，则该方法会返回原字符串。lower() 方法的语法格式如下：</p><blockquote><p>str.lower()</p></blockquote><h2 id="upper-方法"><a href="#upper-方法" class="headerlink" title="upper()方法"></a>upper()方法</h2><p>upper() 的功能和 lower()方法恰好相反，它用于将字符串中的所有小写字母转换为大写字母，和以上两种方法的返回方式相同，即如果转换成功，则返回新字符串；反之，则返回原字符串。upper()方法的语法格式如下：</p><blockquote><p>str.upper()</p></blockquote><h1 id="去除字符串中空格（删除指定字符）的3种方法"><a href="#去除字符串中空格（删除指定字符）的3种方法" class="headerlink" title="去除字符串中空格（删除指定字符）的3种方法"></a>去除字符串中空格（删除指定字符）的3种方法</h1><p>特殊字符，指的是制表符（\t）、回车符（\r）、换行符（\n）等<br>字符串变量提供了 3 种方法来删除字符串中多余的空格和特殊字符，它们分别是：</p><ul><li>strip()：删除字符串前后（左右两侧）的空格或特殊字符。</li><li>lstrip()：删除字符串前面（左边）的空格或特殊字符。</li><li>rstrip()：删除字符串后面（右边）的空格或特殊字符。</li></ul><h2 id="strip-方法"><a href="#strip-方法" class="headerlink" title="strip()方法"></a>strip()方法</h2><p>strip() 方法用于删除字符串左右两个的空格和特殊字符，该方法的语法格式为：</p><blockquote><p>str.strip([chars])</p></blockquote><p>其中，str 表示原字符串，[chars] 用来指定要删除的字符，可以同时指定多个，如果不手动指定，则默认会删除空格以及制表符、回车符、换行符等特殊字符。</p><h2 id="lstrip-方法"><a href="#lstrip-方法" class="headerlink" title="lstrip()方法"></a>lstrip()方法</h2><p>lstrip() 方法用于去掉字符串左右的空格和特殊字符。该方法的语法格式如下：</p><blockquote><p>str.lstrip([chars])</p></blockquote><p>其中，str和chars参数的含义，分别同 strip()语法格式中的str和chars完全相同。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str <span class="token operator">=</span> <span class="token string">"  c.biancheng.net \t\n\r"</span><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>lstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'c.biancheng.net \t\n\r'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="rstrip-方法"><a href="#rstrip-方法" class="headerlink" title="rstrip()方法"></a>rstrip()方法</h2><p>rstrip() 方法用于删除字符串右侧的空格和特殊字符，其语法格式为：</p><blockquote><p>str.rstrip([chars])</p></blockquote><p>str和chars参数的含义和前面2种方法语法格式中的参数完全相同。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str <span class="token operator">=</span> <span class="token string">"  c.biancheng.net \t\n\r"</span><span class="token operator">>></span><span class="token operator">></span> str<span class="token punctuation">.</span>rstrip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'  c.biancheng.net'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="format-格式化输出方法详解"><a href="#format-格式化输出方法详解" class="headerlink" title="format()格式化输出方法详解"></a>format()格式化输出方法详解</h1><p>format()方法的语法格式如下：</p><blockquote><p>str.format(args)</p></blockquote><p>此方法中，str用于指定字符串的显示样式；args用于指定要进行格式转换的项，如果有多项，之间有逗号进行分割。使用{}和：来指定占位符，其完整的语法格式为：</p><blockquote><p>{ [index][ : [ [fill] align] [sign] [#] [width] [.precision] [type] ] }</p></blockquote><p>格式中用[]括起来的参数都是可选参数，即可以使用，也可以不使用。各个参数的含义如下：</p><ul><li>index：指定：后边设置的格式要作用到 args 中第几个数据，数据的索引值从 0 开始。如果省略此选项，则会根据 args 中数据的先后顺序自动分配。</li><li>fill：指定空白处填充的字符。注意，当填充字符为逗号(,)且作用于整数或浮点数时，该整数（或浮点数）会以逗号分隔的形式输出，例如（1000000会输出 1,000,000）。</li><li>align：指定数据的对齐方式，具体的对齐方式如下表所示。</li></ul><table><thead><tr><th>align</th><th>含义</th></tr></thead><tbody><tr><td>&lt;</td><td>数据左对齐</td></tr><tr><td>&gt;</td><td>数据右对齐</td></tr><tr><td>=</td><td>数据右对齐，同时将符号放置在填充内容的最左侧，该选项只对数字类型有效。</td></tr><tr><td>^</td><td>数据居中，此选项需和 width 参数一起使用。</td></tr></tbody></table><ul><li>sign：指定有无符号数，此参数的值以及对应的含义如下表：</li></ul><table><thead><tr><th>sign参数</th><th>含义</th></tr></thead><tbody><tr><td>+</td><td>正数前加正号，负数前加负号。</td></tr><tr><td>-</td><td>正数前不加正号，负数前加负号。</td></tr><tr><td>空格</td><td>正数前加空格，负数前加负号。</td></tr><tr><td>#</td><td>对于二进制数、八进制数和十六进制数，使用此参数，各进制数前会分别显示 0b、0o、0x前缀；反之则不显示前缀。</td></tr></tbody></table><ul><li>width：指定输出数据时所占的宽度。</li><li>.precision：指定保留的小数位数。</li><li>type：指定输出数据的具体类型，如下表：</li><li><table><thead><tr><th>type类型值</th><th>含义</th></tr></thead><tbody><tr><td>s</td><td>对字符串类型格式化。</td></tr><tr><td>d</td><td>十进制整数。</td></tr><tr><td>c</td><td>将十进制整数自动转换成对应的 Unicode 字符。</td></tr><tr><td>e 或者 E</td><td>转换成科学计数法后，再格式化输出。</td></tr><tr><td>g 或 G</td><td>自动在 e 和 f（或 E 和 F）中切换。</td></tr><tr><td>b</td><td>将十进制数自动转换成二进制表示，再格式化输出。</td></tr><tr><td>o</td><td>将十进制数自动转换成八进制表示，再格式化输出。</td></tr><tr><td>x 或者 X</td><td>将十进制数自动转换成十六进制表示，再格式化输出。</td></tr><tr><td>f 或者 F</td><td>转换为浮点数（默认小数点后保留 6 位），再格式化输出。</td></tr><tr><td>%</td><td>显示百分比（默认显示小数点后 6 位）。</td></tr><tr><td>```python</td><td></td></tr></tbody></table><blockquote><blockquote><blockquote><p>print(“货币形式：{:,d}”.format(1000000))<br>货币形式：1,000,000<br>#科学计数法表示<br>… print(“科学计数法：{:E}”.format(1200.12))<br>科学计数法：1.200120E+03<br>#以十六进制表示<br>… print(“100的十六进制：{:#x}”.format(100))<br>100的十六进制：0x64<br>#输出百分比形式<br>… print(“0.01的百分比表示：{:.0%}”.format(0.01))</p></blockquote></blockquote></blockquote></li></ul><p>0.01的百分比表示：1%</p><pre><code># encode()和decode()方法：字符串编码转换Python 中，有2种常用的字符串类型，分别为str和 bytes 类型，其中 str 用来表示 Unicode 字符，bytes 用来表示二进制数据。str 类型和 bytes 类型之间就需要使用 encode() 和 decode() 方法进行转换。&gt;Python 3.x 默认采用 UTF-8 编码格式，有效地解决了中文乱码的问题。## encode()方法encode() 方法为字符串类型（str）提供的方法，用于将 str 类型转换成 bytes 类型，这个过程也称为“编码”。encode()方法的语法格式如下：&gt;str.encode([encoding=&quot;utf-8&quot;][,errors=&quot;strict&quot;])&lt;font color=red&gt;注意，格式中用 [] 括起来的参数为可选参数，也就是说，在使用此方法时，可以使用 [] 中的参数，也可以不使用。&lt;/font&gt;errors = &quot;strict&quot;指定错误处理方式，其可选择值可以是：* strict：遇到非法字符就抛出异常。* ignore：忽略非法字符。* replace：用“？”替换非法字符。* xmlcharrefreplace：使用 xml的字符引用。该参数的默认值为 strict。## decode()方法和 encode() 方法正好相反，decode() 方法用于将 bytes 类型的二进制数据转换为 str 类型，这个过程也称为“解码”。decode()方法的语法格式如下：&gt;bytes.decode([encoding=&quot;utf-8&quot;][,errors=&quot;strict&quot;])# dir()和help()帮助函数dir() 函数用来列出某个类或者某个模块中的全部内容，包括变量、方法、函数和类等，它的用法为：&gt;dir(obj)obj表示要查看的对象。obj 可以不写，此时 dir() 会列出当前范围内的变量、方法和定义的类型。Python help() 函数用来查看某个函数或者模块的帮助文档，它的用法为：&gt;help(obj)obj表示要查看的对象。obj可以不写，此时help()会进入帮助子程序。```python &gt;&gt;&gt; help(str.lower)Help on method_descriptor:lower(self, /)    Return a copy of the string converted to lowercase.</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-列表元组字典集合</title>
      <link href="/2020/04/25/bian-cheng-yu-yan/python/python-lie-biao-yuan-zu-zi-dian-ji-he/"/>
      <url>/2020/04/25/bian-cheng-yu-yan/python/python-lie-biao-yuan-zu-zi-dian-ji-he/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Python 序列（Sequence）是指按特定顺序依次排列的一组数据，它们可以占用一块连续的内存，也可以分散到多块内存中。Python 中的序列类型包括列表（list）、元组（tuple）、字典（dict）和集合（set）。</p><p>在Python编程中，我们既需要独立的变量来保存一份数据，也需要序列来保存大量数据。列表（list）和元组（tuple）比较相似，它们都按顺序保存元素，所有的元素占用一块连续的内存，每个元素都有自己的索引，因此列表和元组的元素都可以通过索引（index）来访问。它们的区别在于：列表是可以修改的，而元组是不可修改的。</p><p>字典（dict）和集合（set）存储的数据都是无序的，每份元素占用不同的内存，其中字典元素以 key-value的形式保存</p><h1 id="Python序列详解（包括序列类型和常用操作）"><a href="#Python序列详解（包括序列类型和常用操作）" class="headerlink" title="Python序列详解（包括序列类型和常用操作）"></a>Python序列详解（包括序列类型和常用操作）</h1><p>所谓序列，指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可通过每个值所在位置的编号（称为索引）访问它们。集合和字典不支持索引、切片、相加和相乘操作。</p><blockquote><p>字符串也是一种常见的序列，它也可以直接通过索引访问字符串内的字符。</p></blockquote><h2 id="序列索引"><a href="#序列索引" class="headerlink" title="序列索引"></a>序列索引</h2><p>序列中，每个元素都有属于自己的编号（索引）。从起始元素开始，索引值从 0 开始递增，如图1所示。</p><div align="center"><img src="/images/序列索引.png" width="400"></div><center>图1 序列索引值示意图</center><p>Python还支持索引值是负数，此类索引是从右向左计数，换句话说，从最后一个元素开始计数，从索引值 -1 开始，如图 2 所示。</p><div align="center"><img src="/images/负值索引.png" width="400"></div><center>图2 负值索引示意图</center><blockquote><p>注意，在使用负值作为列序中各元素的索引值时，是从 -1 开始，而不是从 0 开始。</p></blockquote><h2 id="序列切片"><a href="#序列切片" class="headerlink" title="序列切片"></a>序列切片</h2><p>切片操作是访问序列中元素的另一种方法，它可以访问一定范围内的元素，通过切片操作，可以生成一个新的序列。</p><blockquote><p>语法格式：sname[start : end : step]</p></blockquote><p>其中，各个参数的含义如下：</p><ul><li>sname：表示序列的名称；</li><li>start：表示切片的开始索引位置（包括该位置），此参数也可以不指定，会默认为 0，也就是从序列的开头进行切片；</li><li>end：表示切片的结束索引位置（不包括该位置），如果不指定，则默认为序列的长度；</li><li>step：表示在切片过程中，隔几个存储位置（包含当前位置）取一次元素，也就是说，如果step的值大于1，则在进行切片去序列元素时，会“跳跃式”的取元素。如果省略设置step的值，则最后一个冒号就可以省略。<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>He<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>HloWrd<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>Hello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="序列相加"><a href="#序列相加" class="headerlink" title="序列相加"></a>序列相加</h2>Python 中，支持两种类型相同的序列使用“+”运算符做相加操作，它会将两个序列进行连接，但不会去除重复的元素。<blockquote><p>这里所说的“类型相同”，指的是“+”运算符的两侧序列要么都是序列类型，要么都是元组类型，要么都是字符串。</p></blockquote><h2 id="序列相乘"><a href="#序列相乘" class="headerlink" title="序列相乘"></a>序列相乘</h2>Python 中，使用数字 n 乘以一个序列会生成新的序列，其内容为原来序列被重复n次的结果。<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span>Hello WorldHello WorldHello World<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="检查元素是否包含在序列中"><a href="#检查元素是否包含在序列中" class="headerlink" title="检查元素是否包含在序列中"></a>检查元素是否包含在序列中</h2>Python 中，可以使用 in 关键字检查某元素是否为序列的成员，其语法格式为：<blockquote><p>value in sequence 其中，value 表示要检查的元素，sequence 表示指定的序列。</p></blockquote></li></ul><p>与in关键字用法相同，但功能恰好相反的，还有not in关键字，它用法检查某个元素是否不包含在指定的序列中</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'W'</span> <span class="token keyword">in</span> str<span class="token punctuation">)</span><span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'W'</span> <span class="token operator">not</span> <span class="token keyword">in</span> str<span class="token punctuation">)</span><span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="序列相关的内置函数"><a href="#序列相关的内置函数" class="headerlink" title="序列相关的内置函数"></a>序列相关的内置函数</h2><p>Python提供了几个内置函数，可用于实现与序列相关的一些常用操作，如下表：<br>| 函数        | 功能                                                                                                                                                                                                    |<br>| ———– | ——————————————————————————————————————————————————————————————————- |<br>| len()       | 计算序列的长度，即返回序列中包含多少个元素。                                                                                                                                                            |<br>| max()       | 找出序列中的最大元素。注意，对序列使用 sum() 函数时，做加和操作的必须都是数字，不能是字符或字符串，否则该函数将抛出异常，因为解释器无法判定是要做连接操作（+ 运算符可以连接两个序列），还是做加和操作。 |<br>| min()       | 找出序列中的最小元素                                                                                                                                                                                    |<br>| list()      | 将序列转换为列表                                                                                                                                                                                        |<br>| str()       | 将序列转换为字符串。                                                                                                                                                                                    |<br>| sum()       | 计算元素和。                                                                                                                                                                                            |<br>| sorted()    | 对元素进行排序。                                                                                                                                                                                        |<br>| reversed()  | 反向序列中的元素。                                                                                                                                                                                      |<br>| enumerate() | 将序列组合为一个索引序列，多用在 for 循环中。                                                                                                                                                           |</p><h1 id="Python-list列表详解"><a href="#Python-list列表详解" class="headerlink" title="Python list列表详解"></a>Python list列表详解</h1><p>列表可以存储整数、小数、字符串、列表、元组等任何类型的数据，并且同一个列表中元素的类型也可以不同</p><p><font color="red">在使用列表时，虽然可以将不同类型的数据放入到同一个列表中，但通常情况下不这么做，同一列表中只放入同一类型的数据，这样可以提高程序的可读性。</font></p><h2 id="Python创建列表"><a href="#Python创建列表" class="headerlink" title="Python创建列表"></a>Python创建列表</h2><p>在 Python 中，创建列表的方法可分为两种：</p><p><strong>1.使用[]直接创建列表</strong><br>使用[ ]创建列表后，一般使用=将它赋值给某个变量，具体格式如下：</p><blockquote><p>listname = [element1 , element2 , element3 , … , elementn]</p></blockquote><p>其中，listname 表示变量名，element1 ~ elementn 表示列表元素。</p><p><strong>2.使用list()函数创建列表</strong></p><p>Python 还提供了一个内置的函数 list()，使用它可以将其它数据类型转换为列表类型。例如：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> list1 <span class="token operator">=</span> list<span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>list1<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> dict1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">:</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">:</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> list2 <span class="token operator">=</span> list<span class="token punctuation">(</span>dict1<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>list2<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h2><p>列表是 Python 序列的一种，我们可以使用索引（Index）访问列表中的某个元素（得到的是一个元素的值），也可以使用切片访问列表中的一组元素（得到的是一个新的子列表）。</p><blockquote><p>listname[i] #索引访问<br>listname[start:end:step] # 切片访问</p></blockquote><h2 id="删除列表"><a href="#删除列表" class="headerlink" title="删除列表"></a>删除列表</h2><p>对于已经创建的列表，如果不再使用，可以使用del关键字将其删除。Python自带的垃圾回收机制会自动销毁无用的列表，即使不手动删除，Python也会自动将其回收。</p><blockquote><p>语法格式：del listname</p></blockquote><h1 id="Python-list列表添加元素"><a href="#Python-list列表添加元素" class="headerlink" title="Python list列表添加元素"></a>Python list列表添加元素</h1><h2 id="append-添加元素"><a href="#append-添加元素" class="headerlink" title="append()添加元素"></a>append()添加元素</h2><p>append() 方法用于在列表的末尾追加元素，该方法的语法格式如下：</p><blockquote><p>listname.append(obj)</p></blockquote><p>其中，listname 表示要添加元素的列表；obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组等。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'python'</span><span class="token punctuation">,</span><span class="token string">'c++'</span><span class="token punctuation">,</span><span class="token string">'java'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'php'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">[</span><span class="token string">'python'</span><span class="token punctuation">,</span> <span class="token string">'c++'</span><span class="token punctuation">,</span> <span class="token string">'java'</span><span class="token punctuation">,</span> <span class="token string">'php'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Ruby'</span><span class="token punctuation">,</span><span class="token string">'SQL'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">[</span><span class="token string">'python'</span><span class="token punctuation">,</span> <span class="token string">'c++'</span><span class="token punctuation">,</span> <span class="token string">'java'</span><span class="token punctuation">,</span> <span class="token string">'php'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Ruby'</span><span class="token punctuation">,</span> <span class="token string">'SQL'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="extend-方法添加元素"><a href="#extend-方法添加元素" class="headerlink" title="extend()方法添加元素"></a>extend()方法添加元素</h2><p>extend() 和 append() 的不同之处在于：extend() 不会把列表或者元祖视为一个整体，而是把它们包含的元素逐个添加到列表中。语法格式如下：</p><blockquote><p>listname.extend(obj)</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'JS'</span><span class="token punctuation">,</span> <span class="token string">'C#'</span><span class="token punctuation">,</span> <span class="token string">'Go'</span><span class="token punctuation">)</span><span class="token operator">>></span> l<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'python'</span><span class="token punctuation">,</span> <span class="token string">'c++'</span><span class="token punctuation">,</span> <span class="token string">'java'</span><span class="token punctuation">,</span> <span class="token string">'php'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Ruby'</span><span class="token punctuation">,</span> <span class="token string">'SQL'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'JS'</span><span class="token punctuation">,</span> <span class="token string">'C#'</span><span class="token punctuation">,</span> <span class="token string">'Go'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="insert-方法插入元素"><a href="#insert-方法插入元素" class="headerlink" title="insert()方法插入元素"></a>insert()方法插入元素</h2><p>append()和extend()方法只能在列表末尾插入元素，如果希望在列表中间某个位置插入元素，那么可以使用 insert()方法。语法格式：</p><blockquote><p>listname.insert(index, obj)</p></blockquote><p>其中，index 表示指定位置的索引值。insert() 会将 obj 插入到 listname 列表第 index 个元素的位置。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Python'</span><span class="token punctuation">,</span> <span class="token string">'C++'</span><span class="token punctuation">,</span> <span class="token string">'Java'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">[</span><span class="token string">'Python'</span><span class="token punctuation">,</span> <span class="token string">'C++'</span><span class="token punctuation">,</span> <span class="token string">'Java'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">[</span><span class="token string">'Python'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'C++'</span><span class="token punctuation">,</span> <span class="token string">'Java'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Ruby'</span><span class="token punctuation">,</span> <span class="token string">'SQL'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> l<span class="token punctuation">[</span><span class="token string">'Python'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'C++'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Ruby'</span><span class="token punctuation">,</span> <span class="token string">'SQL'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'Java'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="list列表删除元素-4种方法"><a href="#list列表删除元素-4种方法" class="headerlink" title="list列表删除元素(4种方法)"></a>list列表删除元素(4种方法)</h1><p>在 Python 列表中删除元素主要分为以下 3 种场景：</p><ul><li>根据目标元素所在位置的索引进行删除，可以使用 del 关键字或者 pop() 方法；</li><li>根据元素本身的值进行删除，可使用列表（list类型）提供的 remove() 方法；</li><li>将列表中所有元素全部删除，可使用列表（list类型）提供的clear()方法。<h2 id="del-根据索引值删除元素"><a href="#del-根据索引值删除元素" class="headerlink" title="del:根据索引值删除元素"></a>del:根据索引值删除元素</h2>del 是 Python 中的关键字，专门用来执行删除操作，它不仅可以删除整个列表，还可以删除列表中的某些元素。语法格式如下：<blockquote><p>del listname[index] # index表示索引<br>del listname[start:end] # 中间一段连续的元素</p></blockquote><h2 id="pop-根据索引值删除元素"><a href="#pop-根据索引值删除元素" class="headerlink" title="pop():根据索引值删除元素"></a>pop():根据索引值删除元素</h2>用于删除列表中指定索引处的元素，语法格式：<blockquote><p>listname.pop(index)  #类似于数据结构中的“出栈”操作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">89</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">>></span> nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token number">2</span><span class="token operator">>></span> nums<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">7</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h2 id="remove-根据元素值进行删除"><a href="#remove-根据元素值进行删除" class="headerlink" title="remove():根据元素值进行删除"></a>remove():根据元素值进行删除</h2>remove()方法只会删除第一个和指定值相同的元素，而且必须保证该元素是存在的，否则会引发ValueError错误。<font color="red">使用 remove() 删除元素时最好提前判断一下。</font></li></ul><h2 id="clear-删除列表所有元素"><a href="#clear-删除列表所有元素" class="headerlink" title="clear():删除列表所有元素"></a>clear():删除列表所有元素</h2><p>用来删除列表的所有元素，也即清空列表。</p><h1 id="list列表修改元素"><a href="#list列表修改元素" class="headerlink" title="list列表修改元素"></a>list列表修改元素</h1><p>Python提供了两种修改列表（list）元素的方法，你可以每次修改单个元素，也可以每次修改一组元素（多个）。</p><h2 id="修改单个元素"><a href="#修改单个元素" class="headerlink" title="修改单个元素"></a>修改单个元素</h2><p>修改单个元素非常简单，直接对元素赋值即可。实例如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">89</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">26</span><span class="token operator">>></span><span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">66.22</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">66.22</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="修改一组元素"><a href="#修改一组元素" class="headerlink" title="修改一组元素"></a>修改一组元素</h2><p>Python支持通过切片语法给一组元素赋值。在进行这种操作时，如果不指定步长（step 参数），Python就不要求新赋值的元素个数与原来的元素个数相同；这意味，该操作既可以为列表添加元素，也可以为列表删除元素。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">89</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">52.5</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">52.5</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 对空切片(slice)赋值，相当于插入一组新元素</span><span class="token operator">>></span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">89</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> nums<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">52.5</span><span class="token punctuation">,</span> <span class="token number">999</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">52.5</span><span class="token punctuation">,</span> <span class="token number">999</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 使用切片语法赋值时，Python 不支持单个值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="list列表查找元素"><a href="#list列表查找元素" class="headerlink" title="list列表查找元素"></a>list列表查找元素</h1><p>Python 列表（list）提供了index()和count()方法，它们都可以用来查找元素。</p><h2 id="index-方法"><a href="#index-方法" class="headerlink" title="index()方法"></a>index()方法</h2><p>index()方法用来查找某个元素在列表中出现的位置（也就是索引），如果该元素不存在，则会导致ValueError错误，所以在查找之前最好使用count()方法判断一下。语法格式：</p><blockquote><p>listname.index(obj, start, end)</p></blockquote><p>其中，listname表示列表名称，obj 表示要查找的元素，start表示起始位置，end表示结束位置。start和end参数用来指定检索范围：</p><ul><li>start和end可以都不写，此时会检索整个列表；</li><li>如果只写start不写end，那么表示检索从start到末尾的元素；</li><li>如果start和end都写，那么表示检索 start 和 end 之间的元素。</li></ul><p>index()方法会返回元素所在列表中的索引值。示例如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">77</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">52.5</span><span class="token punctuation">,</span> <span class="token number">999</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">8</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>ValueError<span class="token punctuation">:</span> <span class="token number">55</span> <span class="token keyword">is</span> <span class="token operator">not</span> <span class="token keyword">in</span> list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="count-方法"><a href="#count-方法" class="headerlink" title="count()方法"></a>count()方法</h2><p>count() 方法用来统计某个元素在列表中出现的次数，基本语法格式为：</p><blockquote><p>listname.count(obj)</p></blockquote><p>如果count()返回 0，就表示列表中不存在该元素，所以count()也可以用来判断列表中的某个元素是否存在。</p><h1 id="Python-tuple元组"><a href="#Python-tuple元组" class="headerlink" title="Python tuple元组"></a>Python tuple元组</h1><p>元组和列表（list）的不同之处在于：</p><ul><li>列表的元素是可以更改的，包括修改元素值，删除和插入元素，所以列表是可变序列；</li><li>而元组一旦被创建，它的元素就不可更改了，所以元组是不可变序列。<blockquote><p>语法格式：(element1, element2, … , elementn)</p></blockquote><h2 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h2></li><li><em>1.使用()直接创建*</em></li></ul><p>通过( )创建元组后，一般使用=将它赋值给某个变量，具体格式为：</p><blockquote><p>tuplename = (element1, element2, …, elementn)</p></blockquote><p><font color="red"> 需要注意的一点是，当创建的元组中只有一个字符串类型的元素时，该元素后面必须要加一个逗号,，否则 Python 解释器会将它视为字符串。</font></p><p><strong>2.使用tuple()函数创建</strong><br>tuple() 的语法格式如下：</p><blockquote><p>tuple(data)</p></blockquote><h2 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h2><p>元素使用索引访问元组元素的格式为：</p><blockquote><p>tuplename[i]</p></blockquote><p>其中，tuplename 表示元组名字，i 表示索引值。元组的索引可以是正数，也可以是负数。</p><p>使用切片访问元组元素的格式为：</p><blockquote><p>tuplename[start : end : step]</p></blockquote><p>其中，start 表示起始索引，end 表示结束索引，step 表示步长。</p><h2 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h2><p>组是不可变序列，元组中的元素不能被修改，所以我们只能创建一个新的元组去替代旧的元组。</p><h2 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h2><p>使用del关键字删除元组</p><h1 id="Python元组和列表的区别"><a href="#Python元组和列表的区别" class="headerlink" title="Python元组和列表的区别"></a>Python元组和列表的区别</h1><p>元组和列表最大的区别就是，列表中的元素可以进行任意修改；而元组中的元素无法修改，除非将元组整体替换掉。tuple元组是只读版本的list。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> listdemo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> listdemo<span class="token punctuation">.</span>__sizeof__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">40</span><span class="token operator">>></span><span class="token operator">></span> tupleDemo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> tupleDemo<span class="token punctuation">.</span>__sizeof__<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token number">24</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">由于列表是动态的，它需要存储指针来指向对应的元素（占用 8 个字节）。另外，由于列表中元素可变，所以需要额外存储已经分配的长度大小（占用 8 个字节）。但是对于元组，情况就不同了，元组长度大小固定，且存储元素不可变，所以存储空间也是固定的。</font></p><p>元组要比列表更加轻量级，所以从总体上来说，元组的性能速度要由于列表。另外，Python 会在后台，对静态数据做一些资源缓存。通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python 就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。</p><p>但是对于一些静态变量（比如元组），如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样的话，当下次再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。元组的不可替代性体现在以下这些场景中：</p><ul><li>元组作为很多内置函数和序列类型方法的返回值存在，也就是说，在使用某些函数或者方法时，它的返回值会元组类型，因此你必须对元组进行处理。</li><li>元组比列表的访问和处理速度更快，因此，当需要对指定元素进行访问，且不涉及修改元素的操作时，建议使用元组。</li><li>元组可以在映射（和集合的成员）中当做“键”使用，而列表不行<h1 id="Python-dict字典详解"><a href="#Python-dict字典详解" class="headerlink" title="Python dict字典详解"></a>Python dict字典详解</h1>Python字典（dict）是一种无序的、可变的序列，它的元素以“键值对（key-value）”的形式存储。相对地，列表（list）和元组（tuple）都是有序的序列，它们的元素在底层是挨着存放的。将各元素对应的索引称为键（key），各个键对应的元素称为值（value），键及其关联的值称为“键值对”。字典的主要特征如下表：<table><thead><tr><th>主要特征</th><th>解释</th></tr></thead><tbody><tr><td>通过键而不是通过索引来读取元素</td><td>字典类型有时也称为关联数组或者散列表  （hash）。它是通过键将一系列的值联系起来的，这样就可以通过键从字典中获取指定项，但不能通过索引来获取。</td></tr><tr><td>字典是任意数据类型的无序集合</td><td>和列表、元组不同，通常会将索引值 0 对应的元素称为第一个元素，而字典中的元素是无序的。</td></tr><tr><td>字典是可变的，并且可以任意嵌套</td><td>字典可以在原处增长或者缩短（无需生成一个副本），并且它支持任意深度的嵌套，即字典存储的值也可以是列表或其它的字典。</td></tr><tr><td>字典中的键必须唯一</td><td>字典中，不支持同一个键出现多次，否则只会保留最后一个键值对。</td></tr><tr><td>字典中的键必须不可变</td><td>字典中的值是不可变的，只能使用数字、字符串或者元组，不能使用列表。</td></tr><tr><td>## Python创建字典</td><td></td></tr></tbody></table></li><li><em>1.使用{}创建字典*</em></li></ul><p>由于字典中每个元素都包含两部分，分别是键（key）和值（value），因此在创建字典时，键和值之间使用冒号:分隔，相邻元素之间使用逗号,分隔，所有元素放在大括号{ }中。语法格式如下：</p><blockquote><p>dictname = {‘key’:’value1’, ‘key2’:’value2’,…,’keyn’:’vakyen’}</p></blockquote><p>其中dictname表示字典变量名，keyn :valuen表示各个元素的键值对。需要注意的是，同一字典中的各个键必须唯一，不能重复。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> scores <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">92</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">84</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">92</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">84</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> dict1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token string">'great'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>dict1<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token string">'great'</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.通过fromkeys()方法创建字典</strong></p><p>使用dict字典类型提供的fromkeys()方法创建带有默认值的字典，具体格式为：</p><blockquote><p>dictname = dict.fromkeys(list，value=None)</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span> knowledge <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'语文'</span><span class="token punctuation">,</span> <span class="token string">'数学'</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">}</span><span class="token operator">>></span> scores <span class="token operator">=</span> dict<span class="token punctuation">.</span>fromkeys<span class="token punctuation">(</span>knowledge<span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token operator">>></span> scores<span class="token punctuation">{</span><span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">60</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>3.通过dict()映射函数创建字典</strong></p></blockquote><table><thead><tr><th>创建格式</th><th>注意事项</th></tr></thead><tbody><tr><td>a = dict(str1=value1, str2=value2, str3=value3)</td><td>str 表示字符串类型的键，value 表示键对应的值。使用此方式创建字典时，字符串不能带引号。</td></tr><tr><td>#方式1                                     demo = [(‘two’,2), (‘one’,1), (‘three’,3)]#方式2 demo = [[‘two’,2], [‘one’,1], [‘three’,3]]#方式3 demo = ((‘two’,2), (‘one’,1), (‘three’,3)) #方式4 demo = ([‘two’,2], [‘one’,1], [‘three’,3])</td><td>a = dict(demo)    向 dict() 函数传入列表或元组，而它们中的元素又各自是包含 2 个元素的列表或元组，其中第一个元素作为键，第二个元素作为值。</td></tr><tr><td>keys = [‘one’, ‘two’, ‘three’] #还可以是字符串或元组values = [1, 2, 3] #还可以是字符串或元组a = dict( zip(keys, values))</td><td>通过应用 dict() 函数和 zip() 函数，可将前两个列表转换为对应的字典。</td></tr></tbody></table><blockquote><p>无论采用以上哪种方式创建字典，字典中各元素的键都只能是字符串、元组或数字，不能是列表。列表是可变的，不能作为键。</p></blockquote><h2 id="访问字典"><a href="#访问字典" class="headerlink" title="访问字典"></a>访问字典</h2><p>列表和元组是通过下标来访问元素的，而字典不同，它通过键来访问对应的值。因为字典中的元素是无序的，每个元素的位置都不固定，所以字典也不能像列表和元组那样，采用切片的方式一次性访问多个元素。Python访问字典元素的具体格式为：</p><blockquote><p>dictname[key]</p></blockquote><p>其中，dictname 表示字典变量的名字，key 表示键名。注意，键必须是存在的，否则会抛出异常。</p><p>除了上面这种方式外，Python更推荐使用dict类型提供的get()方法来获取指定键对应的值。当指定的键不存在时，get()方法不会抛出异常。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> tup <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'two'</span><span class="token punctuation">,</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">,</span><span class="token number">88</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'three'</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'four'</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">59</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> dic <span class="token operator">=</span> dict<span class="token punctuation">(</span>tup<span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>dic<span class="token punctuation">[</span><span class="token string">'one'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#键存在</span><span class="token number">88</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>dic<span class="token punctuation">[</span><span class="token string">'five'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#键不存在</span>Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>  File <span class="token string">"&lt;stdin>"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">></span>KeyError<span class="token punctuation">:</span> <span class="token string">'five'</span><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> dict<span class="token punctuation">(</span>two<span class="token operator">=</span><span class="token number">0.65</span><span class="token punctuation">,</span> one<span class="token operator">=</span><span class="token number">88</span><span class="token punctuation">,</span> three<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> four<span class="token operator">=</span><span class="token operator">-</span><span class="token number">59</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span> a<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'one'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token number">88</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span> a<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token string">'five'</span><span class="token punctuation">,</span> <span class="token string">'该键不存在'</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>该键不存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python-dict字典基本操作（包括添加、修改、删除键值对）"><a href="#Python-dict字典基本操作（包括添加、修改、删除键值对）" class="headerlink" title="Python dict字典基本操作（包括添加、修改、删除键值对）"></a>Python dict字典基本操作（包括添加、修改、删除键值对）</h1><p>由于字典属于可变序列，所以我们可以任意操作字典中的键值对（key-value）。Python 中，常见的字典操作有以下几种：</p><ul><li>向现有字典中添加新的键值对。</li><li>修改现有字典中的键值对。</li><li>从现有字典中删除指定的键值对。</li><li>判断现有字典中是否存在指定的键值对。<blockquote><p>字典是由一个一个的key-value构成的，key是找到数据的关键，Python对字典的操作都是通过key来完成的。</p></blockquote><h2 id="Python字典添加键值对"><a href="#Python字典添加键值对" class="headerlink" title="Python字典添加键值对"></a>Python字典添加键值对</h2>字典添加新的键值对很简单，直接给不存在的 key 赋值即可，具体语法格式如下：<blockquote><p>dictname[key] = value</p></blockquote></li></ul><p>对各个部分的说明：</p><ul><li>dictname表示字典名称。</li><li>key表示新的键。</li><li>value表示新的值，只要是Python支持的数据类型都可以。<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span><span class="token number">95</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true">#添加新键值对</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">[</span><span class="token string">'语文'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">89</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true">#再次添加新键值对</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">[</span><span class="token string">'英语'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">90</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python字典修改键值对"><a href="#Python字典修改键值对" class="headerlink" title="Python字典修改键值对"></a>Python字典修改键值对</h2>Python 字典中键（key）的名字不能被修改，只能修改值（value）。字典中各元素的键必须是唯一的，因此，如果新添加元素的键与已存在元素的键相同，那么键所对应的值就会被新的值替换掉，以此达到修改元素值的目的。<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token string">'语文'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="Python字典删除键值对"><a href="#Python字典删除键值对" class="headerlink" title="Python字典删除键值对"></a>Python字典删除键值对</h2>删除字典中的键值对，使用del语句，如下：<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">del</span> a<span class="token punctuation">[</span><span class="token string">'语文'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="判断字典中是否存在指定键值对"><a href="#判断字典中是否存在指定键值对" class="headerlink" title="判断字典中是否存在指定键值对"></a>判断字典中是否存在指定键值对</h2>先应判断字典中是否有对应的键。判断字典是否包含指定键值对的键，可以使用 in 或 not in 运算符。<blockquote><p>需要指出的是，对于 dict 而言，in 或 not in 运算符都是基于 key 来判断的。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'物理'</span> <span class="token keyword">in</span> a<span class="token punctuation">)</span><span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h2 id="keys、values-和items-方法"><a href="#keys、values-和items-方法" class="headerlink" title="keys、values()和items()方法"></a>keys、values()和items()方法</h2>它们都用来获取字典中的特定数据：</li><li>keys() 方法用于返回字典中的所有键（key）；</li><li>values()方法用于返回字典中所有键对应的值（value）；</li><li>items()用于返回字典中所有的键值对（key-value）。<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> res <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>dict_keys<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'数学'</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>dict_values<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">95</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>dict_items<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'数学'</span><span class="token punctuation">,</span> <span class="token number">95</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'语文'</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'英语'</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">for</span> k<span class="token punctuation">,</span>v <span class="token keyword">in</span> res<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"key:"</span><span class="token punctuation">,</span>k<span class="token punctuation">,</span><span class="token string">" value:"</span><span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> key<span class="token punctuation">:</span> 数学  value<span class="token punctuation">:</span> <span class="token number">95</span>key<span class="token punctuation">:</span> 语文  value<span class="token punctuation">:</span> <span class="token number">89</span>key<span class="token punctuation">:</span> 英语  value<span class="token punctuation">:</span> <span class="token number">90</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="copy-方法"><a href="#copy-方法" class="headerlink" title="copy()方法"></a>copy()方法</h2>copy()方法返回一个字典的拷贝，也即返回一个具有相同键值对的新字典<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><font color="red">注意，copy() 方法所遵循的拷贝原理，既有深拷贝，也有浅拷贝。拿拷贝字典a为例，copy()方法只会对最表层的键值对进行深拷贝，也就是说，它会再申请一块内存用来存放 {‘one’: 1, ‘two’: 2, ‘three’: []}；而对于某些列表类型的值来说，此方法对其做的是浅拷贝，也就是说，b 中的 [1,2,3] 的值不是自己独有，而是和a共有。</font><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token string">'four'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">100</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">[</span><span class="token string">'three'</span><span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="update-方法"><a href="#update-方法" class="headerlink" title="update()方法"></a>update()方法</h2>update() 方法可以使用一个字典所包含的键值对来更新己有的字典。</li></ul><p>在执行 update() 方法时，如果被更新的字典中己包含对应的键值对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的键值对，则该键值对被添加进去。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span><span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span><span class="token number">9.3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> a<span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">:</span> <span class="token number">4.5</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'four'</span><span class="token punctuation">:</span> <span class="token number">9.3</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="pop-hepopitem-方法"><a href="#pop-hepopitem-方法" class="headerlink" title="pop()hepopitem()方法"></a>pop()hepopitem()方法</h2><p>pop() 和 popitem() 都用来删除字典中的键值对，不同的是，pop() 用来删除指定的键值对，而 popitem() 用来随机删除一个键值对，它们的语法格式如下：</p><blockquote><p>dictname.pop(key) <br>dictname.popitem()</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token string">'化学'</span><span class="token punctuation">:</span> <span class="token number">83</span><span class="token punctuation">,</span> <span class="token string">'生物'</span><span class="token punctuation">:</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token string">'物理'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token string">'化学'</span><span class="token punctuation">:</span> <span class="token number">83</span><span class="token punctuation">,</span> <span class="token string">'生物'</span><span class="token punctuation">:</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token string">'物理'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">}</span><span class="token operator">>></span> a<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token string">'化学'</span><span class="token punctuation">)</span><span class="token number">83</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token string">'生物'</span><span class="token punctuation">:</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token string">'物理'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">}</span><span class="token operator">>></span> a<span class="token punctuation">.</span>popitem<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token string">'物理'</span><span class="token punctuation">,</span> <span class="token number">89</span><span class="token punctuation">)</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token string">'生物'</span><span class="token punctuation">:</span> <span class="token number">98</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">键值对在底层也是有存储顺序的，popitem() 总是弹出底层中的最后一个 key-value</font></p></blockquote><h2 id="setdefault-方法"><a href="#setdefault-方法" class="headerlink" title="setdefault()方法"></a>setdefault()方法</h2><p>setdefault()方法用来返回某个key对应的value，其语法格式如下：</p><blockquote><p>dictname.setdefault(key, defaultvalue)</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span><span class="token operator">>></span> <span class="token comment" spellcheck="true">#key不存在，指定默认值</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">'物理'</span><span class="token punctuation">,</span> <span class="token number">94</span><span class="token punctuation">)</span><span class="token number">94</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token string">'物理'</span><span class="token punctuation">:</span> <span class="token number">94</span><span class="token punctuation">}</span><span class="token operator">>></span> <span class="token comment" spellcheck="true">#key不存在，不指定默认值</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">'化学'</span><span class="token punctuation">)</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token string">'物理'</span><span class="token punctuation">:</span> <span class="token number">94</span><span class="token punctuation">,</span> <span class="token string">'化学'</span><span class="token punctuation">:</span> None<span class="token punctuation">}</span><span class="token operator">>></span> <span class="token comment" spellcheck="true">#key存在，指定默认值</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> a<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span><span class="token string">'数学'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token number">95</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token string">'数学'</span><span class="token punctuation">:</span> <span class="token number">95</span><span class="token punctuation">,</span> <span class="token string">'语文'</span><span class="token punctuation">:</span> <span class="token number">89</span><span class="token punctuation">,</span> <span class="token string">'英语'</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token string">'物理'</span><span class="token punctuation">:</span> <span class="token number">94</span><span class="token punctuation">,</span> <span class="token string">'化学'</span><span class="token punctuation">:</span> None<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h1 id="使用字典格式化字符串"><a href="#使用字典格式化字符串" class="headerlink" title="使用字典格式化字符串"></a>使用字典格式化字符串</h1><p>在字符串模板中按 key 指定变量，然后通过字典为字符串模板中的 key 设置值。举例如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> temp <span class="token operator">=</span> <span class="token string">'教程是:%(name)s, 价格是:%(price)010.2f, 出版社是:%(publish)s'</span><span class="token operator">>></span><span class="token operator">></span> book <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'name'</span><span class="token punctuation">:</span><span class="token string">'Python基础教程'</span><span class="token punctuation">,</span> <span class="token string">'price'</span><span class="token punctuation">:</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token string">'publish'</span><span class="token punctuation">:</span> <span class="token string">'C语言中文网'</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>temp <span class="token operator">%</span> book<span class="token punctuation">)</span>教程是<span class="token punctuation">:</span>Python基础教程<span class="token punctuation">,</span> 价格是<span class="token punctuation">:</span><span class="token number">0000099.00</span><span class="token punctuation">,</span> 出版社是<span class="token punctuation">:</span>C语言中文网<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python-set集合详解"><a href="#Python-set集合详解" class="headerlink" title="Python set集合详解"></a>Python set集合详解</h1><p>Python 中的集合，和数学中的集合概念一样，用来保存不重复的元素，即集合中的元素都是唯一的，互不相同。Python 集合会将所有元素放在一对大括号 {} 中，相邻元素之间用“,”分隔，如下所示：</p><blockquote><p>{element1,element2,…,elementn}</p></blockquote><p>同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型。数据必须保证是唯一的，因为集合对于每种数据元素，只会保留一份。 Python 中的 set 集合是无序的，所以每次输出时元素的排序顺序可能都不相同。</p><blockquote><p>其实，Python 中有两种集合类型，一种是set类型的集合，另一种是 frozenset类型的集合，它们唯一的区别是，set类型集合可以做添加、删除元素的操作，而forzenset类型集合不行。</p></blockquote><h2 id="创建set集合"><a href="#创建set集合" class="headerlink" title="创建set集合"></a>创建set集合</h2><p>Python 提供了 2 种创建 set 集合的方法，分别是使用 {} 创建和使用 set() 函数将列表、元组等类型数据转换为集合。</p><p><strong>1.使用 {} 创建</strong></p><p>在 Python 中，创建 set 集合可以像列表、元素和字典一样，直接将集合赋值给变量，从而实现创建集合的目的，其语法格式如下：</p><blockquote><p>setname = {element1,element2,…,elementn}</p></blockquote><p>其中，setname 表示集合的名称，起名时既要符合 Python 命名规范，也要避免与 Python 内置函数重名。</p><p><strong>2.set()函数创建集合</strong></p><p>set() 函数为 Python 的内置函数，其功能是将字符串、列表、元组、range 对象等可迭代对象转换成集合。该函数的语法格式如下：</p><blockquote><p>setname = set(iteration)</p></blockquote><p><font color="red">如果要创建空集合，只能使用 set() 函数实现。因为直接使用一对 {}，Python 解释器会将其视为一个空字典。</font></p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> set2 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> set3 <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"set2:"</span><span class="token punctuation">,</span>set2<span class="token punctuation">)</span>set2<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"set3:"</span><span class="token punctuation">,</span>set3<span class="token punctuation">)</span>set3<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="访问set集合元素"><a href="#访问set集合元素" class="headerlink" title="访问set集合元素"></a>访问set集合元素</h2><p>由于集合中的元素是无序的，因此无法向列表那样使用下标访问元素。Python 中，访问集合元素最常用的方法是使用循环结构，将集合中的数据逐一读取出来。</p><h2 id="删除set集合"><a href="#删除set集合" class="headerlink" title="删除set集合"></a>删除set集合</h2><p>手动函数集合类型，使用del()语句删除。</p><h1 id="Python-set集合基本操作（添加、删除、交集、并集、差集）"><a href="#Python-set集合基本操作（添加、删除、交集、并集、差集）" class="headerlink" title="Python set集合基本操作（添加、删除、交集、并集、差集）"></a>Python set集合基本操作（添加、删除、交集、并集、差集）</h1><p>常用的操作是向集合中添加、删除元素，以及集合之间做交集、并集、差集等运算。</p><h2 id="向set集合中添加元素"><a href="#向set集合中添加元素" class="headerlink" title="向set集合中添加元素"></a>向set集合中添加元素</h2><p>set集合添加元素，使用set类型提供的add()方法实现，语法格式：</p><blockquote><p>setname.add(element)</p></blockquote><p>其中，setname表示添加元素的集合，element表示要添加的元素内容。<br><font color="red">使用 add() 方法添加的元素，只能是数字、字符串、元组或者布尔类型（True 和 False）值，不能添加列表、字典、集合这类可变的数据，否则 Python 解释器会报 TypeError 错误。</font></p><h2 id="set集合中删除元素"><a href="#set集合中删除元素" class="headerlink" title="set集合中删除元素"></a>set集合中删除元素</h2><p>删除现有 set 集合中的指定元素，可以使用 remove() 方法，该方法的语法格式如下：</p><blockquote><p>setname.remove(element)</p></blockquote><h2 id="set集合做交集、并集、差集运算"><a href="#set集合做交集、并集、差集运算" class="headerlink" title="set集合做交集、并集、差集运算"></a>set集合做交集、并集、差集运算</h2><p>集合最常做的操作就是进行交集、并集、差集以及对称差集运算。</p><table><thead><tr><th>运算操作</th><th>Python运算符</th><th>含义</th><th>例子</th></tr></thead><tbody><tr><td>交集</td><td>&amp;</td><td>取两集合公共的元素</td><td>&gt;&gt;&gt; set1 &amp; set2</td></tr><tr><td>{3}</td><td></td><td></td><td></td></tr><tr><td>并集</td><td>|</td><td>取两集合全部的元素</td><td>&gt;&gt;&gt; set1</td></tr><tr><td>{1,2,3,4,5}</td><td></td><td></td><td></td></tr><tr><td>差集</td><td>-</td><td>取一个集合中另一集合没有的元素</td><td>&gt;&gt;&gt; set1 - set2 {1,2} &gt;&gt;&gt; set2 - set1</td></tr><tr><td>对称差集</td><td>^</td><td>取集合 A 和 B 中不属于 A&amp;B 的元素</td><td>&gt;&gt;&gt; set1 ^ set2                        {1,2,4,5}</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-变量类型和运算符</title>
      <link href="/2020/04/24/bian-cheng-yu-yan/python/python-bian-liang-lei-xing-he-yun-suan-fu/"/>
      <url>/2020/04/24/bian-cheng-yu-yan/python/python-bian-liang-lei-xing-he-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="Python变量的定义和使用"><a href="#Python变量的定义和使用" class="headerlink" title="Python变量的定义和使用"></a>Python变量的定义和使用</h1><p>变量保存的数据可以被多次修改，而常量一旦保存某个数据之后就不能修改了。</p><h2 id="Python变量的赋值"><a href="#Python变量的赋值" class="headerlink" title="Python变量的赋值"></a>Python变量的赋值</h2><p>将数据放入变量的过程叫做赋值（Assignment）。Python使用等号=作为赋值运算符，具体格式为：</p><blockquote><p>name = value</p></blockquote><p>name表示变量名；value表示值，也就是要存储的数据。注意，变量是标识符的一种，它的名字不能随便起，要遵守Python标识符命名规范，还要避免和Python内置函数以及Python保留字重名。</p><h2 id="Python变量的使用"><a href="#Python变量的使用" class="headerlink" title="Python变量的使用"></a>Python变量的使用</h2><p>使用 Python 变量时，只要知道变量的名字即可。几乎在Python代码的任何地方都能使用变量。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#将变量传递给函数</span><span class="token number">10</span><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">5</span>  <span class="token comment" spellcheck="true">#将变量作为四则运算的一部分</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token number">105</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token number">-30</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#将由变量构成的表达式作为参数传递给函数</span><span class="token number">75</span><span class="token operator">>></span><span class="token operator">></span> m <span class="token operator">=</span> m <span class="token operator">*</span> <span class="token number">2</span>  <span class="token comment" spellcheck="true">#将变量本身的值翻倍</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token number">210</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python是弱类型的语言"><a href="#Python是弱类型的语言" class="headerlink" title="Python是弱类型的语言"></a>Python是弱类型的语言</h2><p>C语言、C++、Java 是强类型语言的代表。和强类型语言相对应的是弱类型语言，Python、JavaScript、PHP 等脚本语言一般都是弱类型的。</p><p>弱类型语言有两个特点：</p><ul><li>变量无须声明就可以直接赋值，对一个不存在的变量赋值就相当于定义了一个新变量。</li><li>变量的数据类型可以随时改变，比如，同一个变量可以一会儿被赋值为整数，一会儿被赋值为字符串。<h1 id="Python整数类型-int-详解"><a href="#Python整数类型-int-详解" class="headerlink" title="Python整数类型(int)详解"></a>Python整数类型(int)详解</h1>整数就是没有小数部分的数字，Python中的整数包括正整数、0和负整数。</li></ul><p>有些强类型的编程语言会提供多种整数类型，每种类型的长度都不同，能容纳的整数的大小也不同，开发者要根据实际数字的大小选用不同的类型。例如C语言提供了short、int、long、long long四种类型的整数，它们的长度依次递增，初学者在选择整数类型时往往比较迷惑，有时候还会导致数值溢出。</p><p>而Python则不同，它的整数不分类型，或者说它只有一种类型的整数。Python整数的取值范围是无限的，不管多大或者多小的数字，Python 都能轻松处理。</p><blockquote><p>当所用数值超过计算机自身的计算能力时，Python 会自动转用高精度计算（大数计算）。</p></blockquote><h2 id="整数的不同进制"><a href="#整数的不同进制" class="headerlink" title="整数的不同进制"></a>整数的不同进制</h2><ul><li>十进制形式：使用十进制形式的整数不能以 0 作为开头，除非这个数值本身就是 0。</li><li>二进制形式：由0和1两个数字组成，书写时以0b或0B开头。例如，101对应十进制数是5。</li><li>八进制：八进制整数由0~7共八个数字组成，以0o或0O开头。注意，第一个符号是数字 0，第二个符号是大写或小写的字母 O。</li><li>十六进制形式：由 0<del>9 十个数字以及 A</del>F（或 a~f）六个字母组成，书写时以0x或0X开头。<h2 id="数字分隔符"><a href="#数字分隔符" class="headerlink" title="数字分隔符"></a>数字分隔符</h2>Python 3.x 允许使用下划线_作为数字（包括整数和小数）的分隔符。通常每隔三个数字添加一个下划线，类似于英文数字中的逗号。下划线不会影响数字本身的值。</li></ul><h1 id="Python小数／浮点数-float-类型详解"><a href="#Python小数／浮点数-float-类型详解" class="headerlink" title="Python小数／浮点数(float)类型详解"></a>Python小数／浮点数(float)类型详解</h1><p>小数通常以浮点数的形式存储。浮点数和定点数是相对的：小数在存储过程中如果小数点发生移动，就称为浮点数；如果小数点不动，就称为定点数。Python中的小数有两种书写形式：</p><ul><li>十进制形式：平时看到的小数形式，例如 34.6、346.0、0.346。书写小数时必须包含一个小数点，否则会被Python当作整数处理。</li><li>指数形式：小数的指数形式为aEn或aen，a为尾数部分，是一个十进制数；n为指数部分，是一个十进制整数；E或e是固定的字符，用于分割尾数部分和指数部分。整个表达式等价于$a×10^{n}$。举例：2.1E5=2.1×105，其中2.1是尾数，5是指数。3.7E-2 = 3.7×10-2，其中3.7是尾数，-2是指数。0.5E7=0.5×107，其中 0.5是尾数，7是指数。</li></ul><blockquote><p>Python 只有一种小数类型，就是 float。C语言有两种小数类型，分别是 float 和 double：float 能容纳的小数范围比较小，double 能容纳的小数范围比较大。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span> f1 <span class="token operator">=</span> <span class="token number">12.5</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'f1Value:'</span><span class="token punctuation">,</span> f1<span class="token punctuation">)</span>f1Value<span class="token punctuation">:</span> <span class="token number">12.5</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'f1Type:'</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>f1<span class="token punctuation">)</span><span class="token punctuation">)</span>f1Type<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'float'</span><span class="token operator">></span><span class="token operator">>></span> f5 <span class="token operator">=</span> <span class="token number">12e4</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"f5Value: "</span><span class="token punctuation">,</span> f5<span class="token punctuation">)</span>f5Value<span class="token punctuation">:</span>  <span class="token number">120000.0</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"f5Type: "</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>f5<span class="token punctuation">)</span><span class="token punctuation">)</span>f5Type<span class="token punctuation">:</span>  <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'float'</span><span class="token operator">></span><span class="token operator">>></span> f6 <span class="token operator">=</span> <span class="token number">12.3</span> <span class="token operator">*</span> <span class="token number">0.1</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"f6Value: "</span><span class="token punctuation">,</span> f6<span class="token punctuation">)</span>f6Value<span class="token punctuation">:</span>  <span class="token number">1.2300000000000002</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"f6Type: "</span><span class="token punctuation">,</span> type<span class="token punctuation">(</span>f6<span class="token punctuation">)</span><span class="token punctuation">)</span>f6Type<span class="token punctuation">:</span>  <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'float'</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></blockquote><h1 id="为什么Python浮点类型存在误差"><a href="#为什么Python浮点类型存在误差" class="headerlink" title="为什么Python浮点类型存在误差"></a>为什么Python浮点类型存在误差</h1><p>主要还是因浮点数在计算机中实际是以二进制保存的，有些数不精确。<br>比如说: 0.1是十进制，转化为二进制后它是个无限循环的数：<br>0.00011001100110011001100110011001100110011001100110011001100<br>而python是以双精度(64)位来保存浮点数，多余的位会被截掉，所以看到的是0.1，但在电脑上实际保存的已不是精确的0.1，参与运算后，也就有可能点误差。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 解决方法 </span><span class="token keyword">from</span> decimal <span class="token keyword">import</span> <span class="token operator">*</span>a <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token string">'4.2'</span><span class="token punctuation">)</span>b <span class="token operator">=</span> Decimal<span class="token punctuation">(</span><span class="token string">'2.1'</span><span class="token punctuation">)</span>c <span class="token operator">=</span> a <span class="token operator">*</span> b <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python复数类型-complex-详解"><a href="#Python复数类型-complex-详解" class="headerlink" title="Python复数类型(complex)详解"></a>Python复数类型(complex)详解</h1><p>复数由实部（real）和虚部（imag）构成，在Python中，复数的虚部以j或者J作为后缀，具体格式为：</p><blockquote><p>a + bj # a表示实部，b表示虚部。</p></blockquote><h1 id="Python字符串详解（包含长字符串和原始字符串）"><a href="#Python字符串详解（包含长字符串和原始字符串）" class="headerlink" title="Python字符串详解（包含长字符串和原始字符串）"></a>Python字符串详解（包含长字符串和原始字符串）</h1><p>字符串必须由双引号” “或者单引号’ ‘包围，具体格式为：</p><blockquote><p>“字符串内容”<br>‘字符串内容’</p></blockquote><p>字符串的内容可以包含字母、标点、特殊符号、中文、日文等全世界的所有文字。字符串中的双引号和单引号没有任何区别，而有些编程语言的双引号字符串可以解析变量，单引号字符串一律原样输出。</p><h2 id="处理字符串中的引号"><a href="#处理字符串中的引号" class="headerlink" title="处理字符串中的引号"></a>处理字符串中的引号</h2><p>当字符串内容中出现引号时，我们需要进行特殊处理，否则Python会解析出错，处理方案如下：</p><p><strong>1.对引号进行转义</strong></p><p>在引号前面添加反斜杠\就可以对引号进行转义，让 Python 把它作为普通文本对待，例如：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str1 <span class="token operator">=</span> <span class="token string">'I\'m a great Person'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span>I'm a great Person<span class="token operator">>></span><span class="token operator">></span> str2 <span class="token operator">=</span> <span class="token string">"引文双引号是\",中文双引号是"</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span>引文双引号是"<span class="token punctuation">,</span>中文双引号是<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2.使用不同的引号包围字符串</strong></p><p>字符串内容中出现了单引号，那么我们可以使用双引号包围字符串，反之亦然。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str1 <span class="token operator">=</span> <span class="token string">"I'm a great coder!"</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span>I'm a great coder!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="字符串的换行"><a href="#字符串的换行" class="headerlink" title="字符串的换行"></a>字符串的换行</h2><p>Python 不是格式自由的语言，它对程序的换行、缩进都有严格的语法要求。要想换行书写一个比较长的字符串，必须在行尾添加反斜杠\，ｐｙｔｈｏｎ也支持表达式的换行。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> s2 <span class="token operator">=</span> "It took six months to writer \<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Please give me more support<span class="token punctuation">.</span> \<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> I will keep !"<span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span>It took six months to writer Please give me more support<span class="token punctuation">.</span> I will keep !<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Python原始字符串"><a href="#Python原始字符串" class="headerlink" title="Python原始字符串"></a>Python原始字符串</h2><p>为了解决转义字符的问题，Python 支持原始字符串。在原始字符串中，\不会被当作转义字符，所有的内容都保持“原汁原味”的样子。在普通字符串或者长字符串的开头加上r前缀，就变成了原始字符串，具体格式为：</p><blockquote><p>str1 = r’原始字符串内容’<br>str2 = r”””原始字符串内容”””</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span> str1 <span class="token operator">=</span> r<span class="token string">'I\'m a great coder!'</span><span class="token operator">>></span> <span class="token keyword">print</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span>I\'m a great coder!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Python 原始字符串中的反斜杠仍然会对引号进行转义，因此原始字符串的结尾处不能是反斜杠，否则字符串结尾处的引号会被转义，导致字符串不能正确结束。</p></blockquote><p>在 Python 中有两种方式解决这个问题：一种方式是改用长字符串的写法，不要使用原始字符串；另一种方式是单独书写反斜杠。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> str1 <span class="token operator">=</span> r<span class="token string">'D:\Program Files\Python 3.8'</span> <span class="token string">'\\'</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span>D<span class="token punctuation">:</span>\Program Files\Python <span class="token number">3.8</span>\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h1><p>ASCII码，全称为美国信息交换标准代码，是基于拉丁字母的一套字符编码，主要用于显示现代英语，因为万维网的出现，使得 ASCII码广为使用，其直到2007年12月才逐渐被Unicode取代。nicode字符集可以使用的编码方案有三种，分别是：</p><ul><li>UTF-8：一种变长的编码方案，使用1~6个字节来存储；</li><li>UTF-32：一种固定长度的编码方案，不管字符编号大小，始终使用4个字节来存储；</li><li>UTF-16：介于UTF-8和UTF-32之间，使用2个或者4个字节来存储，长度既固定又可变。<h2 id="Python使用的字符编码"><a href="#Python使用的字符编码" class="headerlink" title="Python使用的字符编码"></a>Python使用的字符编码</h2>Ｐython3.x中，字符串采用的是Unicode字符集，可以用如下代码来查看当前环境的编码格式：<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> sys<span class="token operator">>></span><span class="token operator">></span> sys<span class="token punctuation">.</span>getdefaultencoding<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">'utf-8'</span><span class="token comment" spellcheck="true"># 使用ord()和chr()函数实现字符和编码数字之间的转换</span><span class="token operator">>></span><span class="token operator">></span> ord<span class="token punctuation">(</span><span class="token string">'Q'</span><span class="token punctuation">)</span><span class="token number">81</span><span class="token operator">>></span><span class="token operator">></span> chr<span class="token punctuation">(</span><span class="token number">81</span><span class="token punctuation">)</span><span class="token string">'Q'</span><span class="token operator">>></span><span class="token operator">></span> ord<span class="token punctuation">(</span><span class="token string">"网"</span><span class="token punctuation">)</span><span class="token number">32593</span><span class="token operator">>></span><span class="token operator">></span> chr<span class="token punctuation">(</span><span class="token number">32593</span><span class="token punctuation">)</span><span class="token string">'网'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>虽然Python默认采用UTF-8编码，但它也提供了encode()方法，可以轻松实现将Unicode编码格式的字符串转化为其它编码格式。<h1 id="Bytes类型及其用法"><a href="#Bytes类型及其用法" class="headerlink" title="Bytes类型及其用法"></a>Bytes类型及其用法</h1>字节串（bytes）和字符串（string）的对比：</li><li>字符串由若干个字符组成，以字符为单位进行操作；字节串由若干个字节组成，以字节为单位进行操作。</li><li>字节串和字符串除了操作的数据单元不同之外，它们支持的所有方法都基本相同。</li><li>字节串和字符串都是不可变序列，不能随意增加和删除数据。</li></ul><p>bytes只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。</p><ul><li>如果字符串的内容都是ASCII字符，那么直接在字符串前面添加b前缀就可以转换成 bytes。</li><li>bytes是一个类，调用它的构造方法，也就是bytes()，可以将字符串按照指定的字符集转换成bytes；如果不指定字符集，那么默认采用UTF-8。</li><li>字符串本身有一个encode()方法，该方法专门用来将字符串按照指定的字符集转换成对应的字节串；如果不指定字符集，那么默认采用 UTF-8。<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> b5 <span class="token operator">=</span> <span class="token string">"个人博客"</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'UTF-8'</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span>b5<span class="token punctuation">)</span>b<span class="token string">'\xe4\xb8\xaa\xe4\xba\xba\xe5\x8d\x9a\xe5\xae\xa2'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="Python-bool布尔类型"><a href="#Python-bool布尔类型" class="headerlink" title="Python bool布尔类型"></a>Python bool布尔类型</h1>Python提供了bool 类型来表示真（对）或假（错），比如常见的5&gt;3比较算式，这个是正确的，在程序世界里称之为真（对），Python 使用 True 来代表；再比如4 &gt; 20比较算式，这个是错误的，在程序世界里称之为假（错），Python 使用 False 来代表。<h1 id="Python的缓存重用机制"><a href="#Python的缓存重用机制" class="headerlink" title="Python的缓存重用机制"></a>Python的缓存重用机制</h1>Python 缓冲机制是为提高程序执行的效率服务的，实际上就是在 Python 解释器启动时从内存空间中开辟出一小部分，用来存储高频使用的数据，这样可以大大减少高频使用的数据创建时申请内存和销毁时撤销内存的开销。Python 在存储数据时，会根据数据的读取频繁程度以及内存占用情况来考虑，是否按照一定的规则将数据存储缓存中。那么问题来了，内存重用机制适用于哪些基本数据类型呢？<table>  <tr>      <td>数据类型</td>      <td>是否可以重用</td>      <td>生效范围</td>  </tr>  <tr>      <td>范围在[-5,256]之间的小整数</td>      <td rowspan="3">如果之前在程序中创建过，就直接存入缓存，后续不再创建。</td>      <td rowspan="3">全局</td>  </tr>  <tr>      <td>bool类型</td>  </tr>  <tr>      <td>字符串类型数据</td>  </tr>  <tr>  <td>大于 256 的整数</td>      <td rowspan="2">只要在本代码块内创建过，就直接缓存，后续不再创建。</td>      <td rowspan="2">本代码块</td>  </tr>  <tr>      <td>大于0的浮点型小数</td>  </tr>  <td>小于0的浮点型小数</td>      <td rowspan="2">不进行缓存，每次都需要额外创建。</td>      <td rowspan="2"></td>    <tr>      <td>小于 -5 的整数</td>  </tr></table></li></ul><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true">#范围在 [-5, 256] 之间的小整数</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> int1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span><span class="token operator">>></span><span class="token operator">></span> int2 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"[-5, 256] 情况下的两个变量："</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>int1<span class="token punctuation">)</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>int2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">]</span> 情况下的两个变量： <span class="token number">10914304</span> <span class="token number">10914304</span><span class="token operator">>></span><span class="token operator">></span> <span class="token comment" spellcheck="true">#bool类型</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> bool1 <span class="token operator">=</span> <span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> bool2 <span class="token operator">=</span> <span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"bool类型情况下的两个变量："</span><span class="token punctuation">,</span>id<span class="token punctuation">(</span>bool1<span class="token punctuation">)</span><span class="token punctuation">,</span>id<span class="token punctuation">(</span>bool2<span class="token punctuation">)</span><span class="token punctuation">)</span>bool类型情况下的两个变量： <span class="token number">10302848</span> <span class="token number">10302848</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python-input-函数：获取用户输入的字符串"><a href="#Python-input-函数：获取用户输入的字符串" class="headerlink" title="Python input()函数：获取用户输入的字符串"></a>Python input()函数：获取用户输入的字符串</h1><p>input() 函数的用法为：</p><blockquote><p>str = input(tipmsg)</p></blockquote><p>说明：</p><ul><li>str 表示一个字符串类型的变量，input 会将读取到的字符串放入 str 中。</li><li>tipmsg 表示提示信息，它会显示在控制台上，告诉用户应该输入什么样的内容；如果不写 tipmsg，就不会有任何提示信息。</li></ul><p>可以使用 Python 内置函数将字符串转换成想要的类型，比如：</p><ul><li>int(string) 将字符串转换成 int 类型；</li><li>float(string) 将字符串转换成 float 类型；</li><li>bool(string) 将字符串转换成 bool 类型。<h1 id="Print-函数的高级用法"><a href="#Print-函数的高级用法" class="headerlink" title="Print()函数的高级用法"></a>Print()函数的高级用法</h1>使用 print() 函数时，都只输出了一个变量，但实际上 print() 函数完全可以同时输出多个变量，而且它具有更多丰富的功能。详细语法格式如下：<blockquote><p>print (value,…,sep=’’,end=’\n’,file=sys.stdout,flush=False)</p></blockquote></li></ul><p>value 参数可以接受任意多个变量或值，因此 print() 函数完全可以输出多个值。例如如下代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> user_name<span class="token operator">=</span><span class="token string">'Charlie'</span><span class="token operator">>></span><span class="token operator">></span> user_age <span class="token operator">=</span> <span class="token number">8</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"读者名："</span><span class="token punctuation">,</span>user_name<span class="token punctuation">,</span><span class="token string">"年龄："</span><span class="token punctuation">,</span>user_age<span class="token punctuation">)</span>读者名： Charlie 年龄： <span class="token number">8</span><span class="token comment" spellcheck="true"># 指定分隔符</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"读者名："</span><span class="token punctuation">,</span>user_name<span class="token punctuation">,</span><span class="token string">"年龄："</span><span class="token punctuation">,</span>user_age<span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">'|'</span><span class="token punctuation">)</span>读者名：<span class="token operator">|</span>Charlie<span class="token operator">|</span>年龄：<span class="token operator">|</span><span class="token number">8</span><span class="token comment" spellcheck="true">#设置end 参数，指定输出之后不再换行</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token string">'\t'</span><span class="token punctuation">,</span>end<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token number">40</span>     <span class="token operator">>></span><span class="token operator">></span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>file 参数指定 print() 函数的输出目标，file 参数的默认值为 sys.stdout，该默认值代表了系统标准输出，也就是屏幕，因此 print() 函数默认输出到屏幕。</p><pre class="line-numbers language-python"><code class="language-python">f <span class="token operator">=</span> open<span class="token punctuation">(</span><span class="token string">"./demo.txt"</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'沧海月明珠有泪'</span><span class="token punctuation">,</span> file<span class="token operator">=</span>f<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'蓝回日暖玉生烟'</span><span class="token punctuation">,</span> file<span class="token operator">=</span>f<span class="token punctuation">)</span>f<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python格式化字符串"><a href="#Python格式化字符串" class="headerlink" title="Python格式化字符串"></a>Python格式化字符串</h1><p>print() 函数使用以%开头的转换说明符对各种类型的数据进行格式化输出。<br>| 转换说明符 | 解释                                   |<br>| ———- | ————————————– |<br>| %d、%i     | 转换为带符号的十进制整数               |<br>| %o         | 转换为带符号的八进制整数               |<br>| %x、%X     | 转换为带符号的十六进制整数             |<br>| %e         | 转化为科学计数法表示的浮点数（e 小写） |<br>| %E         | 转化为科学计数法表示的浮点数（E 大写） |<br>| %f、%F     | 转化为十进制浮点数                     |<br>| %g         | 智能选择使用 %f 或 %e 格式             |<br>| %G         | 智能选择使用 %F 或 %E 格式             |<br>| %c         | 格式化字符及其 ASCII 码                |<br>| %r         | 使用 repr() 函数将表达式转换为字符串   |<br>| %s         | 使用 str() 函数将表达式转换为字符串    |</p><h2 id="指定最小输出宽度"><a href="#指定最小输出宽度" class="headerlink" title="指定最小输出宽度"></a>指定最小输出宽度</h2><p>当使用表1中的转换说明符时，可以使用下面的格式指定最小输出宽度（至少占用多少个字符的位置）：</p><ul><li>%10d 表示输出的整数宽度至少为 10；</li><li>%20s 表示输出的字符串宽度至少为 20。<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> <span class="token number">1234567</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"n(10):%10d."</span> <span class="token operator">%</span> n<span class="token punctuation">)</span>n<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token number">1234567</span><span class="token punctuation">.</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"n(5):%5d."</span> <span class="token operator">%</span> n<span class="token punctuation">)</span>n<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">1234567</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指定对齐方式"><a href="#指定对齐方式" class="headerlink" title="指定对齐方式"></a>指定对齐方式</h2>默认情况下，print()输出的数据总是右对齐的。也就是说，当数据不够宽时，数据总是靠右边输出，而在左边补充空格以达到指定的宽度。Python 允许在最小宽度之前增加一个标志来改变对齐方式，Python 支持的标志如下：<table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>-</td><td>指定左对齐</td></tr><tr><td>+</td><td>表示输出的数字总要带着符号；整数带+，负数带-。</td></tr><tr><td>0</td><td>表示宽度不足时补充 0，而不是补充空格。</td></tr><tr><td>说明：</td><td></td></tr></tbody></table></li><li>对于整数，指定左对齐时，在右边补0是没有效果的，因为这样会改变整数的值。</li><li>对于小数，以上三个标志可以同时存在。</li><li>对于字符串，只能使用-标志，因为符号对于字符串没有意义，而补0会改变字符串的值。<pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> n <span class="token operator">=</span> <span class="token number">123456</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"n(09):%09d"</span> <span class="token operator">%</span> n<span class="token punctuation">)</span>n<span class="token punctuation">(</span><span class="token number">09</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token number">000123456</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"n(+9):%+9d"</span> <span class="token operator">%</span> n<span class="token punctuation">)</span>n<span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token operator">+</span><span class="token number">123456</span><span class="token operator">>></span><span class="token operator">></span> f <span class="token operator">=</span> <span class="token number">140.5</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"f(-+0):%-+010f"</span> <span class="token operator">%</span> f<span class="token punctuation">)</span>f<span class="token punctuation">(</span><span class="token operator">-</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token operator">+</span><span class="token number">140.500000</span><span class="token operator">>></span><span class="token operator">></span> s <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"s(-10):%-10s."</span> <span class="token operator">%</span> s<span class="token punctuation">)</span>s<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>Hello     <span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="指定小数精度"><a href="#指定小数精度" class="headerlink" title="指定小数精度"></a>指定小数精度</h2>对于小数（浮点数），print() 还允许指定小数点后的数字位数，也即指定小数的输出精度。精度值需要放在最小宽度之后，中间用点号.隔开；也可以不写最小宽度，只写精度。具体格式如下：<blockquote><p>%m.nf %.nf  # m表示最小宽度，n表示输出精度，.是必须存在的。<br>```python</p><blockquote><blockquote><p>f = 3.141592653<br>print(“%8.3f” % f)<br> 3.142<br>print(“%08.3f” % f)</p></blockquote></blockquote></blockquote></li></ul><p>0003.142</p><blockquote><blockquote><blockquote><p>print(“%+08.3f” % f)<br>+003.142</p><pre><code></code></pre></blockquote></blockquote></blockquote><h1 id="转义字符及用法"><a href="#转义字符及用法" class="headerlink" title="转义字符及用法"></a>转义字符及用法</h1><p>ASCII 编码，0~31（十进制）范围内的字符为控制字符，它们都是看不见的，不能在显示器上显示，甚至无法从键盘输入，只能用转义字符的形式来表示。不过，直接使用ASCII 码记忆不方便，也不容易理解，所以，针对常用的控制字符，C语言又定义了简写方式，完整的列表如下。<br>| 转义字符 | 说明                                                 |<br>| ——– | —————————————————- |<br>| \n       | 换行符，将光标位置移到下一行开头                     |<br>| \r       | 回车符，将光标位置移到本行开头                       |<br>| \t       | 水平制表符，Tab键，相当于四个空格                    |<br>| \b       | 退格（Backspace），将光标位置移到前一列              |<br>| \       | 反斜线                                               |<br>| &#39;       | 单引号                                               |<br>| &quot;       | 双引号                                               |<br>| \        | 在字符串行尾的续行符，即一行未完，转到下一行继续写。 |</p><h1 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h1><p>Python 已经为我们提供了多种可实现数据类型转换的函数，如下表：<br>| 函数                    | 作用                                               |<br>| ———————– | ————————————————– |<br>| int(x)                  | 将x转换成整数类型                                  |<br>| float(x)                | 将x转换成浮点数类型                                |<br>| complex(real, [,image]) | 创建一个复数                                       |<br>| str(x)                  | 将x转换成字符串                                    |<br>| repr(x)                 | 将x转换为表达式字符串                              |<br>| eval(str)               | 计算在字符串中的有效 Python 表达式，并返回一个对象 |<br>| chr(x)                  | 将整数x转换为一个字符                              |<br>| ord(x)                  | 将一个字符x转换为它对应的整数值                    |<br>| hex(x)                  | 将一个整数x转换为一个十六进制字符串                |<br>| oct(x)                  | 将一个整数 x 转换为一个八进制的字符串              |</p><h1 id="Python算术运算符及用法详解"><a href="#Python算术运算符及用法详解" class="headerlink" title="Python算术运算符及用法详解"></a>Python算术运算符及用法详解</h1><p>算术运算符也即数学运算符，用来对数字进行数学运算，比如加减乘除。下表列出了 Python 支持所有基本算术运算符。<br>| 运算符 | 说明                                | 实例      | 结果          |<br>| —— | ———————————– | ——— | ————- |<br>| +      | 加                                  | 12.45+15  | 27.45         |<br>| -      | 减                                  | 4.56-0.26 | 4.3           |<br>| *      | 乘                                  | 5<em>3.6     | 18.0          |<br>| /      | 除法                                | 7/2       | 3.5           |<br>| //     | 整除                                | 7//2      | 3             |<br>| %      | 取余                                | 7%2       | 1             |<br>| *</em>     | 幂运算/次方运算，即返回 x 的 y 次方 | 2**4      | 16，即$2^{4}$ |</p><h1 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h1><p>赋值运算符用来把右侧的值传递给左侧的变量（或者常量）；可以直接将右侧的值交给左侧的变量，也可以进行某些运算后再交给左侧的变量，比如加减乘除、函数调用、逻辑运算等。</p><p><font color="red">= 和 == 是两个不同的运算符，= 用来赋值，而 == 用来判断两边的值是否相等，千万不要混淆。</font></p><p>Python扩展赋值运算符如下表：</p><div align="center"><img src="/images/运算符.png" width="400"></div><h1 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h1><p>Python 位运算按照数据在内存中的二进制位（Bit）进行操作，它一般用于底层开发（算法设计、驱动、图像处理、单片机等），在应用层开发（Web 开发、Linux 运维等）中并不常见。Python 支持的位运算符如下表所示。<br>| 位运算符 | 说明     | 使用形式 | 举例                             |<br>| ——– | ——– | ——– | ——————————– |<br>| &amp;        | 按位与   | a&amp;b      | 4&amp;5                              |<br>| |       | 按位或   | a|b     | 4|5                             |<br>| ^        | 按位异或 | a^b      | 4^5                              |<br>| ~        | 按位取反 | ~a       | ~4                               |<br>| &lt;&lt;       | 按位左移 | a&lt;&lt;b     | 4&lt;&lt;2表示整数4按位左移2位         |<br>| &gt;&gt;       | 按位右移 | a&gt;&gt;b     | 4 &gt;&gt; 2，表示整数 4 按位右移 2 位 |</p><h1 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h1><p>比较运算符，也称关系运算符，用于对常量、变量或表达式的结果进行大小比较。如果这种比较是成立的，则返回True（真），反之则返回False（假）。支持的比较运算符如表所示：<br>比较运算符    说明<br>| &gt;      | 大于，如果&gt;前面的值大于后面的值，则返回 True，否则返回 False。                                  |<br>| —— | ———————————————————————————————– |<br>| &lt;      | 小于，如果&lt;前面的值小于后面的值，则返回 True，否则返回 False。                                  |<br>| ==     | 等于，如果==两边的值相等，则返回 True，否则返回 False。                                         |<br>| &gt;=     | 大于等于（等价于数学中的 ≥），如果&gt;=前面的值大于或者等于后面的值，则返回 True，否则返回 False。 |<br>| &lt;=     | 小于等于（等价于数学中的 ≤），如果&lt;=前面的值小于或者等于后面的值，则返回 True，否则返回 False。 |<br>| !=     | 不等于（等价于数学中的 ≠），如果!=两边的值不相等，则返回 True，否则返回 False。                 |<br>| is     | 判断两个变量所引用的对象是否相同，如果相同则返回 True，否则返回 False。                         |<br>| is not | 判断两个变量所引用的对象是否不相同，如果不相同则返回 True，否则返回 False。                     |</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> time  <span class="token comment" spellcheck="true">#引入time模块</span>t1 <span class="token operator">=</span> time<span class="token punctuation">.</span>gmtime<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># gmtime()用来获取当前时间</span>t2 <span class="token operator">=</span>  time<span class="token punctuation">.</span>gmtime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>t1 <span class="token operator">==</span> t2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#输出True</span><span class="token keyword">print</span><span class="token punctuation">(</span>t1 <span class="token keyword">is</span> t2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#输出False</span><span class="token comment" spellcheck="true"># t1与t2值相等，但是两个不同的对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Python的逻辑运算符及其用法"><a href="#Python的逻辑运算符及其用法" class="headerlink" title="Python的逻辑运算符及其用法"></a>Python的逻辑运算符及其用法</h1><p>常用逻辑运算符及功能如下：<br>| 逻辑运算符 | 含义                           | 基本格式 | 说明                                                                                      |<br>| ———- | —————————— | ——– | —————————————————————————————– |<br>| and        | 逻辑与运算，等价于数学中的“且” | a and b  | 当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。                             |<br>| or         | 逻辑或运算，等价于数学中的“或” | a or b   | 当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。                             |<br>| not        | 逻辑非运算，等价于数学中的“非” | not a    | 如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。 |<br>Python 逻辑运算符用于操作 bool 类型的表达式，执行结果也是 bool 类型，这两点其实都是错误的！实例如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">and</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token number">200</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">45</span> <span class="token operator">and</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">or</span> <span class="token string">"http://forwardpeng.club/"</span><span class="token punctuation">)</span>http<span class="token punctuation">:</span><span class="token operator">//</span>forwardpeng<span class="token punctuation">.</span>club<span class="token operator">/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="逻辑运算符本质"><a href="#逻辑运算符本质" class="headerlink" title="逻辑运算符本质"></a>逻辑运算符本质</h2><p><font color="red">在Python中，and 和or不一定会计算右边表达式的值，有时候只计算左边表达式的值就能得到最终结果。另外，and和or运算符会将其中一个表达式的值作为最终结果，而不是将 True 或者 False 作为最终结果。<br></font><br>对于 and 运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 Python 按照下面的规则执行 and 运算：</p><ul><li>如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时 and 会把左边表达式的值作为最终结果。</li><li>如果左边表达式的值为真，那么最终值是不能确定的，and 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。</li></ul><p>对于 or 运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以 Python 按照下面的规则执行 or 运算：</p><ul><li>如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时 or 会把左边表达式的值作为最终结果。</li><li>如果左边表达式的值为假，那么最终值是不能确定的，or 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。<h1 id="Python-三目运算符用法详解"><a href="#Python-三目运算符用法详解" class="headerlink" title="Python 三目运算符用法详解"></a>Python 三目运算符用法详解</h1>if else 实现三目运算符（条件运算符）的格式如下：<blockquote><p>exp1 if contion else exp2</p></blockquote></li></ul><p>Python三目运算符支持嵌套，如此可以构成更加复杂的表达式。在嵌套时需要注意 if和else的配对，如下：</p><blockquote><p>a if a&gt;b else c if c&gt;d else d</p></blockquote><h1 id="Python运算符优先级和结合性"><a href="#Python运算符优先级和结合性" class="headerlink" title="Python运算符优先级和结合性"></a>Python运算符优先级和结合性</h1><p>Python 支持几十种运算符，被划分成将近二十个优先级，有的运算符优先级不同，有的运算符优先级相同，请看下表。</p><div align="center"><img src="/images/运算符优先级.png" width="400"></div><p>虽然 Python 运算符存在优先级的关系，但不推荐过度依赖运算符的优先级，建议：</p><ul><li>不要把一个表达式写得过于复杂，如果一个表达式过于复杂，可以尝试把它拆分来书写。</li><li>不要过多地依赖运算符的优先级来控制表达式的执行顺序，这样可读性太差，应尽量使用( )来控制表达式的执行顺序。<h2 id="运算符结合性"><a href="#运算符结合性" class="headerlink" title="运算符结合性"></a>运算符结合性</h2>结合性，就是当一个表达式中出现多个优先级相同的运算符时，先执行哪个运算符：先执行左边的叫左结合性，先执行右边的叫右结合性。如：100 / 25 * 16，/和*都具有左结合性，因此先执行左边的除法，再执行右边的乘法，最终结果是64。</li></ul><p>Python中大部分运算符都具有左结合性，也就是从左到右执行；只有单目运算符（例如 not 逻辑非运算符）、赋值运算符和三目运算符例外，它们具有右结合性，也就是从右向左执行。表 1 中列出了所有 Python 运算符的结合性。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-基础</title>
      <link href="/2020/04/24/bian-cheng-yu-yan/python/python-ji-chu/"/>
      <url>/2020/04/24/bian-cheng-yu-yan/python/python-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Python注释"><a href="#Python注释" class="headerlink" title="Python注释"></a>Python注释</h1><p>Python 支持两种类型的注释，分别是单行注释和多行注释。</p><h2 id="Python单行注释"><a href="#Python单行注释" class="headerlink" title="Python单行注释"></a>Python单行注释</h2><p>Python使用井号#作为单行注释的符号，语法格式为：</p><blockquote><p>#注释内容</p></blockquote><p>从井号#开始，直到这行结束为止的所有内容都是注释。Python 解释器遇到#时，会忽略它后面的整行内容。</p><h2 id="Python多行注释"><a href="#Python多行注释" class="headerlink" title="Python多行注释"></a>Python多行注释</h2><p>多行注释指的是一次性注释程序中多行的内容（包含一行）。Python 使用三个连续的单引号’’’或者三个连续的双引号”””注释多行内容，具体格式如下：</p><blockquote><p>‘’’<br>使用 3 个单引号分别作为注释的开头和结尾<br>可以一次性注释多行内容<br>这里面的内容全部是注释内容<br>‘’’</p></blockquote><h1 id="Python缩进规则-包含快捷键"><a href="#Python缩进规则-包含快捷键" class="headerlink" title="Python缩进规则(包含快捷键)"></a>Python缩进规则(包含快捷键)</h1><p>在 Python 中，对于类定义、函数定义、流程控制语句、异常处理语句等，行尾的冒号和下一行的缩进，表示下一个代码块的开始，而缩进的结束则表示此代码块的结束。</p><p>注意，Python 中实现对代码的缩进，可以使用空格或者 Tab 键实现。但无论是手动敲空格，还是使用 Tab 键，通常情况下都是采用 4 个空格长度作为一个缩进量（默认情况下，一个 Tab 键就表示 4 个空格）。</p><h1 id="Python编码规范（PEP-8）"><a href="#Python编码规范（PEP-8）" class="headerlink" title="Python编码规范（PEP 8）"></a>Python编码规范（PEP 8）</h1><p>Python 采用 PEP 8 作为编码规范，其中 PEP 是 Python Enhancement Proposal（Python 增强建议书）的缩写，8 代表的是 Python 代码的样式指南。</p><ul><li>每个 import 语句只导入一个模块，尽量避免一次导入多个模块</li><li>不要在行尾添加分号，也不要用分号将两条命令放在同一行</li><li>建议每行不超过80个字符，如果超过，建议使用小括号将多行内容隐式的连接起来，而不推荐使用反斜杠\进行连接。</li><li>使用必要的空行可以增加代码的可读性，通常在顶级定义（如函数或类的定义）之间空两行，而方法定义之间空一行，另外在用于分隔某些功能的位置也可以空一行。</li><li>通常情况下，在运算符两侧、函数参数之间以及逗号两侧，都建议使用空格进行分隔。<h1 id="Python标识符命名规范"><a href="#Python标识符命名规范" class="headerlink" title="Python标识符命名规范"></a>Python标识符命名规范</h1>Python 中标识符的命名不是随意的，而是要遵守一定的命令规则，比如说：</li><li>标识符是由字符（A<del>Z 和 a</del>z）、下划线和数字组成，但第一个字符不能是数字。</li><li>标识符不能和 Python 中的保留字相同。有关保留字，后续章节会详细介绍。</li><li>Python中的标识符中，不能包含空格、@、% 以及 $ 等特殊字符。</li><li>在 Python 中，标识符中的字母是严格区分大小写的，也就是说，两个同样的单词，如果大小格式不一样，多代表的意义也是完全不同的。</li><li>Python 语言中，以下划线开头的标识符有特殊含义，例如：以单下划线开头的标识符（如 _width），表示不能直接访问的类属性，其无法通过 from…import* 的方式导入；以双下划线开头的标识符（如<strong>add）表示类的私有成员；以双下划线作为开头和结尾的标识符（如 __init</strong>），是专用标识符。</li><li>标识符的命名，除了要遵守以上这几条规则外，不同场景中的标识符，其名称也有一定的规范可循，例如：当标识符用作模块名时，应尽量短小，并且全部使用小写字母，可以使用下划线分割多个字母，例如 game_mian、game_register等。当标识符用作包的名称时，应尽量短小，也全部使用小写字母，不推荐使用下划线，例如 com.mr、com.mr.book 等。当标识符用作类名时，应采用单词首字母大写的形式。例如，定义一个图书类，可以命名为 Book。模块内部的类名，可以采用 “下划线+首字母大写” 的形式，如 _Book;函数名、类中的属性名和方法名，应全部使用小写字母，多个单词之间可以用下划线分割；常量命名应全部使用大写字母，单词之间可以用下划线分割；</li></ul><h1 id="Python关键字-保留字"><a href="#Python关键字-保留字" class="headerlink" title="Python关键字(保留字)"></a>Python关键字(保留字)</h1><p>保留字是 Python 语言中一些已经被赋予特定意义的单词，这就要求开发者在开发程序时，不能用这些保留字作为标识符给变量、函数、类、模板以及其他对象命名。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> keyword<span class="token operator">>></span><span class="token operator">></span> keyword<span class="token punctuation">.</span>kwlist<span class="token punctuation">[</span><span class="token string">'False'</span><span class="token punctuation">,</span> <span class="token string">'None'</span><span class="token punctuation">,</span> <span class="token string">'True'</span><span class="token punctuation">,</span> <span class="token string">'and'</span><span class="token punctuation">,</span> <span class="token string">'as'</span><span class="token punctuation">,</span> <span class="token string">'assert'</span><span class="token punctuation">,</span> <span class="token string">'break'</span><span class="token punctuation">,</span> <span class="token string">'class'</span><span class="token punctuation">,</span> <span class="token string">'continue'</span><span class="token punctuation">,</span> <span class="token string">'def'</span><span class="token punctuation">,</span> <span class="token string">'del'</span><span class="token punctuation">,</span> <span class="token string">'elif'</span><span class="token punctuation">,</span> <span class="token string">'else'</span><span class="token punctuation">,</span> <span class="token string">'except'</span><span class="token punctuation">,</span> <span class="token string">'finally'</span><span class="token punctuation">,</span> <span class="token string">'for'</span><span class="token punctuation">,</span> <span class="token string">'from'</span><span class="token punctuation">,</span> <span class="token string">'global'</span><span class="token punctuation">,</span> <span class="token string">'if'</span><span class="token punctuation">,</span> <span class="token string">'import'</span><span class="token punctuation">,</span> <span class="token string">'in'</span><span class="token punctuation">,</span> <span class="token string">'is'</span><span class="token punctuation">,</span> <span class="token string">'lambda'</span><span class="token punctuation">,</span> <span class="token string">'nonlocal'</span><span class="token punctuation">,</span> <span class="token string">'not'</span><span class="token punctuation">,</span> <span class="token string">'or'</span><span class="token punctuation">,</span> <span class="token string">'pass'</span><span class="token punctuation">,</span> <span class="token string">'raise'</span><span class="token punctuation">,</span> <span class="token string">'return'</span><span class="token punctuation">,</span> <span class="token string">'try'</span><span class="token punctuation">,</span> <span class="token string">'while'</span><span class="token punctuation">,</span> <span class="token string">'with'</span><span class="token punctuation">,</span> <span class="token string">'yield'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="Python内置函数"><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h1><h2 id="abs-x"><a href="#abs-x" class="headerlink" title="abs(x)"></a>abs(x)</h2><p>返回一个数的绝对值。实参可以是整数或浮点数。如果实参是一个复数，返回它的模。</p><h2 id="all-iterable"><a href="#all-iterable" class="headerlink" title="all(iterable)"></a>all(iterable)</h2><p>如果 iterable 的所有元素为真（或迭代器为空），返回 True 。等价于:</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">all</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> element<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">return</span> <span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="any-iterable"><a href="#any-iterable" class="headerlink" title="any(iterable)"></a>any(iterable)</h2><p>如果 iterable 的任一元素为真则返回 True。 如果迭代器为空，返回 False。 等价于:</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">any</span><span class="token punctuation">(</span>iterable<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> element <span class="token keyword">in</span> iterable<span class="token punctuation">:</span>        <span class="token keyword">if</span> element<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">return</span> <span class="token boolean">False</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ascii-object"><a href="#ascii-object" class="headerlink" title="ascii(object)"></a>ascii(object)</h2><p>像函数repr()，返回一个对象可打印的字符串，但是repr()返回的字符串中非ASCII编码的字符，会使用 \x、\u 和 \U 来转义。生成的字符串和Python2的repr()返回的结果相似。</p><h2 id="bin-x"><a href="#bin-x" class="headerlink" title="bin(x)"></a>bin(x)</h2><p>将一个整数转变为一个前缀为“0b”的二进制字符串。结果是一个合法的 Python 表达式。如果x不是 Python的int对象，那它需要定义 <strong>index</strong>()方法返回一个整数。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> bin<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token string">'0b11'</span><span class="token operator">>></span><span class="token operator">></span> bin<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token string">'-0b1010'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="class-bool-x"><a href="#class-bool-x" class="headerlink" title="class bool([x])"></a>class bool([x])</h2><p>返回一个布尔值，True 或者 False。 x使用标准的 真值测试过程 来转换。如果x是假的或者被省略，返回 False；其他情况返回True。bool类是int的子类（参见 数字类型 — int, float, complex）。其他类不能继承自它。它只有False和True两个实例。</p><h2 id="breakpoint-args-kws"><a href="#breakpoint-args-kws" class="headerlink" title="breakpoint(args, *kws)"></a>breakpoint(<em>args, *</em>kws)</h2><p>此函数会在调用时将你陷入调试器中。具体来说，它调用sys.breakpointhook() ，直接传递args和kws 。默认情况下， sys.breakpointhook()调用 pdb.set_trace()且没有参数。在这种情况下，它纯粹是一个便利函数，因此您不必显式导入 pdb 且键入尽可能少的代码即可进入调试器。但是，sys.breakpointhook() 可以设置为其他一些函数并被breakpoint()自动调用，以允许进入你想用的调试器。</p><h2 id="class-bytearray-source-encoding-errors"><a href="#class-bytearray-source-encoding-errors" class="headerlink" title="class bytearray([source[, encoding[, errors]]])"></a>class bytearray([source[, encoding[, errors]]])</h2><p>返回一个新的bytes数组。 bytearray类是一个可变序列，包含范围为0 &lt;= x &lt; 256的整数。它有可变序列大部分常见的方法，见 可变序列类型的描述；同时有 bytes类型的大部分方法，参见 bytes和bytearray操作。</p><h2 id="enumerate-iterable-start-0"><a href="#enumerate-iterable-start-0" class="headerlink" title="enumerate(iterable, start=0)"></a>enumerate(iterable, start=0)</h2><p>返回一个枚举对象。iterable 必须是一个序列，或 iterator，或其他支持迭代的对象。 enumerate() 返回的迭代器的 <strong>next</strong>() 方法返回一个元组，里面包含一个计数值（从 start 开始，默认为 0）和通过迭代 iterable 获得的值。</p><p>##　divmod(a, b)<br>它将两个（非复数）数字作为实参，并在执行整数除法时返回一对商和余数。对于混合操作数类型，适用双目算术运算符的规则。对于整数，结果和 (a // b, a % b) 一致。对于浮点数，结果是(q, a % b) ，q通常是 math.floor(a / b) 但可能会比 1 小。在任何情况下， q * b + a % b和a基本相等；如果a % b非零，它的符号和 b 一样，并且 0 &lt;= abs(a % b) &lt; abs(b)。</p><h2 id="eval-expression-globals-locals"><a href="#eval-expression-globals-locals" class="headerlink" title="eval(expression[, globals[, locals]])"></a>eval(expression[, globals[, locals]])</h2><p>实参是一个字符串，以及可选的 globals 和 locals。globals 实参必须是一个字典。locals 可以是任何映射对象。</p><p>expression参数会作为一个 Python表达式（从技术上说是一个条件列表）被解析并求值，使用 globals 和 locals 字典作为全局和局部命名空间。如果 globals 字典存在且不包含以 <strong>builtins</strong>为键的值，则会在解析expression之前插入以此为键的对内置模块builtins的字典的引用。这意味着expression通常具有对标准builtins模块的完全访问权限且受限的环境会被传播。如果省略locals字典则其默认值为 globals字典。如果两个字典同时省略，表达式会在eval()被调用的环境中执行。返回值为表达式求值的结果。语法错误将作为异常被报告。</p><h2 id="getattr-object-name-default"><a href="#getattr-object-name-default" class="headerlink" title="getattr(object, name[, default])"></a>getattr(object, name[, default])</h2><p>返回对象命名属性的值。name必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。例如， getattr(x, ‘foobar’) 等同于 x.foobar。如果指定的属性不存在，且提供了default值，则返回它，否则触发 AttributeError。</p><h2 id="globals"><a href="#globals" class="headerlink" title="globals()"></a>globals()</h2><p>返回表示当前全局符号表的字典。这总是当前模块的字典（在函数或方法中，不是调用它的模块，而是定义它的模块）。</p><h2 id="hasattr-object-name"><a href="#hasattr-object-name" class="headerlink" title="hasattr(object, name)"></a>hasattr(object, name)</h2><p>该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回True，否则返回False。（此功能是通过调用getattr(object, name) 看是否有 AttributeError异常来实现的）。</p><h2 id="hash-object"><a href="#hash-object" class="headerlink" title="hash(object)"></a>hash(object)</h2><p>返回该对象的哈希值（如果它有的话）。哈希值是整数。它们在字典查找元素时用来快速比较字典的键。相同大小的数字变量有相同的哈希值（即使它们类型不同，如 1 和 1.0）。</p><h2 id="repr-object"><a href="#repr-object" class="headerlink" title="repr(object)"></a>repr(object)</h2><p>返回包含一个对象的可打印表示形式的字符串。 对于许多类型来说，该函数会尝试返回的字符串将会与该对象被传递给 eval() 时所生成的对象具有相同的值，在其他情况下表示形式会是一个括在尖括号中的字符串，其中包含对象类型的名称与通常包括对象名称和地址的附加信息。 类可以通过定义 <strong>repr</strong>() 方法来控制此函数为它的实例所返回的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2020/04/22/shu-ju-jie-gou/algo-table/"/>
      <url>/2020/04/22/shu-ju-jie-gou/algo-table/</url>
      
        <content type="html"><![CDATA[<p>将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。</p><h2 id="顺序存储结构和链式存储结构"><a href="#顺序存储结构和链式存储结构" class="headerlink" title="顺序存储结构和链式存储结构"></a>顺序存储结构和链式存储结构</h2><ul><li>将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构(顺序表)</li><li>数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构(链表)</li></ul><h3 id="前驱和后继"><a href="#前驱和后继" class="headerlink" title="前驱和后继"></a>前驱和后继</h3><p>数据结构中，一组数据中的每个个体被称为“数据元素”。</p><ul><li><p>某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；</p></li><li><p>某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；</p><div align="center"><img src="/images/prev.png" width="400"></div><center>图1 前驱和后继</center><h1 id="顺序表-顺序存储结构-及初始化"><a href="#顺序表-顺序存储结构-及初始化" class="headerlink" title="顺序表(顺序存储结构)及初始化"></a>顺序表(顺序存储结构)及初始化</h1><p>顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙。顺序表存储数据使用的是数组。</p></li></ul><h2 id="顺序表的初始化"><a href="#顺序表的初始化" class="headerlink" title="顺序表的初始化"></a>顺序表的初始化</h2><p>使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：</p><ul><li>顺序表申请的存储容量</li><li>顺序表的长度，元素的个数</li></ul><p><font color="red">正常状态下，顺序表申请的存储容量要大于顺序表的长度。</font></p><p>自定义顺序表的结构体：C语言实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Table<span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token operator">*</span> head<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//动态数组</span>    <span class="token keyword">int</span> length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//顺序表的长度</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//顺序表分配的存储容量</span><span class="token punctuation">}</span>table<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>建立顺序表需要做如下工作：</p><ul><li>给head动态数据申请足够大小的物理空间；</li><li>给size和length赋初值；<pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> Size 5</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Table<span class="token punctuation">{</span>  <span class="token keyword">int</span> <span class="token operator">*</span> head<span class="token punctuation">;</span>  <span class="token keyword">int</span> length<span class="token punctuation">;</span>  <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token punctuation">}</span>table<span class="token punctuation">;</span>table <span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  table t<span class="token punctuation">;</span>  t<span class="token punctuation">.</span>head<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>Size<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//构造一个空的顺序表，动态申请存储空间</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span>head<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//如果申请失败，作出提示并直接退出程序</span>  <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"初始化失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  t<span class="token punctuation">.</span>length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//长度为0</span>  t<span class="token punctuation">.</span>size<span class="token operator">=</span>Size<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//存储空间为Size</span>  <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//输出顺序表中元素的函数</span><span class="token keyword">void</span> <span class="token function">displayTable</span><span class="token punctuation">(</span>table t<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  table t<span class="token operator">=</span><span class="token function">initTable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//向顺序表中添加元素</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>Size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>      t<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"顺序表中存储的元素分别是：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">displayTable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表插入元素"><a href="#顺序表插入元素" class="headerlink" title="顺序表插入元素"></a>顺序表插入元素</h2>虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：</li><li>将要插入位置元素以及后续的元素整体向后移动一个位置；</li><li>将元素放到腾出来的位置上；<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置</span>table <span class="token function">addTable</span><span class="token punctuation">(</span>table t<span class="token punctuation">,</span> <span class="token keyword">int</span> elem<span class="token punctuation">,</span> <span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>add <span class="token operator">></span> t<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">||</span> add <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"插入位置有问题\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> t<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>length <span class="token operator">==</span> t<span class="token punctuation">.</span>size<span class="token punctuation">)</span>  <span class="token punctuation">{</span>      t<span class="token punctuation">.</span>head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>head<span class="token punctuation">,</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>t<span class="token punctuation">.</span>head<span class="token punctuation">)</span>      <span class="token punctuation">{</span>          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"存储分配失败\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> t<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      t<span class="token punctuation">.</span>size <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//插入操作，需要将从插入位置开始的后续元素，逐个后移</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> t<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> add <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//后移完成后，直接将所需插入元素，添加到顺序表的相应位置</span>  t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>add <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> elem<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//由于添加了元素，所以长度+1</span>  t<span class="token punctuation">.</span>length<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><font color="red">注意，动态数组额外申请更多物理空间使用的是 realloc 函数。并且，在实现后续元素整体后移的过程，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。</font></li></ul><h2 id="顺序表删除元素"><a href="#顺序表删除元素" class="headerlink" title="顺序表删除元素"></a>顺序表删除元素</h2><p>从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。</p><pre class="line-numbers language-c"><code class="language-c">table <span class="token function">delTable</span><span class="token punctuation">(</span>table t<span class="token punctuation">,</span> <span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"被删除元素的位置有误\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//删除操作</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>add<span class="token punctuation">;</span> i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    t<span class="token punctuation">.</span>length<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="顺序表查找元素"><a href="#顺序表查找元素" class="headerlink" title="顺序表查找元素"></a>顺序表查找元素</h2><p>顺序表中查找目标元素，可以使用多种查找算法实现，比如说二分查找算法、顺序查找等</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//顺序查找</span><span class="token keyword">int</span> <span class="token function">selectTable</span><span class="token punctuation">(</span>table t<span class="token punctuation">,</span><span class="token keyword">int</span> elem<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果查找失败，返回-1</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="更改元素"><a href="#更改元素" class="headerlink" title="更改元素"></a>更改元素</h2><p>顺序表更改元素的实现过程是：</p><ul><li><p>找到目标元素；</p></li><li><p>直接修改该元素的值；</p><pre class="line-numbers language-c"><code class="language-c">table <span class="token function">amendTable</span><span class="token punctuation">(</span>table t<span class="token punctuation">,</span><span class="token keyword">int</span> elem<span class="token punctuation">,</span><span class="token keyword">int</span> newElem<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> add<span class="token operator">=</span><span class="token function">selectTable</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> elem<span class="token punctuation">)</span><span class="token punctuation">;</span>  t<span class="token punctuation">.</span>head<span class="token punctuation">[</span>add<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span>newElem<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标</span>  <span class="token keyword">return</span> t<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。<font color="red">通过指针表示数据之间逻辑关系的存储结构就是链式存储结构。</font></p><h2 id="链表的节点"><a href="#链表的节点" class="headerlink" title="链表的节点"></a>链表的节点</h2><p>链表中每个数据的存储都由以下两部分组成：</p></li><li><p>数据元素本身，其所在的区域称为数据域；</p></li><li><p>指向直接后继元素的指针，所在的区域称为指针域；</p><div align="center"><img src="/images/节点结构.png" width="400"></div><center>图2 节点结构</center><p>链表中每个节点的结构体实现c代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> Link<span class="token punctuation">{</span>  <span class="token keyword">char</span> elem<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//代表数据域</span>  <span class="token keyword">struct</span> Link <span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//代表指针域，指向直接后继元素</span><span class="token punctuation">}</span>link<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//link为节点名，每个节点都是一个 link 结构体</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="头节点、头指针和首元节点"><a href="#头节点、头指针和首元节点" class="headerlink" title="头节点、头指针和首元节点"></a>头节点、头指针和首元节点</h2><p>一个完整的链表需要由以下几部分构成：</p><ul><li>头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；</li><li>头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；</li></ul></li><li><p>首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</p></li><li><p>其他节点：链表中其他的节点；</p></li></ul><p><font color="red">注意：链表中有头节点时，头指针指向头节点；反之，若链表中没有头节点，则头指针指向首元节点。</font></p><h2 id="链表的创建-初始化"><a href="#链表的创建-初始化" class="headerlink" title="链表的创建(初始化)"></a>链表的创建(初始化)</h2><p>创建一个链表步骤如下：</p><ul><li>声明一个头指针（如果有必要，可以声明一个头节点）；</li><li>创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//创建一个存储 {1,2,3,4} 且含头节点的链表</span>link <span class="token operator">*</span> <span class="token function">initLink</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  link <span class="token operator">*</span> p<span class="token operator">=</span><span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建一个头结点</span>  link <span class="token operator">*</span> temp<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//声明一个指针指向头结点，</span>  <span class="token comment" spellcheck="true">//生成链表</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      link <span class="token operator">*</span>a<span class="token operator">=</span><span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      a<span class="token operator">-></span>elem<span class="token operator">=</span>i<span class="token punctuation">;</span>      a<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>      temp<span class="token operator">-></span>next<span class="token operator">=</span>a<span class="token punctuation">;</span>      temp<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表插入元素"><a href="#链表插入元素" class="headerlink" title="链表插入元素"></a>链表插入元素</h2>虽然新元素的插入位置不固定，但是链表插入元素的思想是固定的，只需做以下两步操作，即可将新元素插入到指定的位置：</li><li>将新结点的 next 指针指向插入位置后的结点；</li><li>将插入位置前结点的 next 指针指向插入结点；</li></ul><p><font color="red">注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，除非再添加一个指针，作为插入位置后续链表的头指针，否则会导致插入位置后的这部分链表丢失，无法再实现步骤 1。</font></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//p为原链表，elem表示新数据元素，add表示新元素要插入的位置</span>link <span class="token operator">*</span> <span class="token function">insertElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> elem<span class="token punctuation">,</span> <span class="token keyword">int</span> add<span class="token punctuation">)</span> <span class="token punctuation">{</span>    link <span class="token operator">*</span> temp <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建临时结点temp</span>    <span class="token comment" spellcheck="true">//首先找到要插入位置的上一个结点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> add<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"插入位置无效\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//创建插入结点c</span>    link <span class="token operator">*</span> c <span class="token operator">=</span> <span class="token punctuation">(</span>link<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    c<span class="token operator">-></span>elem <span class="token operator">=</span> elem<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//向链表中插入结点</span>    c<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    temp<span class="token operator">-></span>next <span class="token operator">=</span> c<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表删除元素"><a href="#链表删除元素" class="headerlink" title="链表删除元素"></a>链表删除元素</h2><p>从链表中删除数据元素需要进行以下 2步操作：</p><ul><li>将结点从链表中摘下来;</li><li>手动释放掉结点，回收被结点占用的存储空间;<blockquote><p>temp-&gt;next=temp-&gt;next-&gt;next;</p></blockquote></li></ul><p>执行效果如图3所示：<br> <div align="center"><img src="/images/链表删除元素.png" width="400"></div><br> <center>图3 链表删除元素</center></p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//p为原链表，add为要删除元素的值</span>link <span class="token operator">*</span> <span class="token function">delElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span> p<span class="token punctuation">,</span> <span class="token keyword">int</span> add<span class="token punctuation">)</span> <span class="token punctuation">{</span>    link <span class="token operator">*</span> temp <span class="token operator">=</span> p<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//遍历到被删除结点的上一个结点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> add<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"没有该结点\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    link <span class="token operator">*</span> del <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//单独设置一个指针指向被删除结点，以防丢失</span>    temp<span class="token operator">-></span>next <span class="token operator">=</span> temp<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//删除某个结点的方法就是更改前一个结点的指针域</span>    <span class="token function">free</span><span class="token punctuation">(</span>del<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//手动释放该结点，防止内存泄漏</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表查找元素"><a href="#链表查找元素" class="headerlink" title="链表查找元素"></a>链表查找元素</h2><p>从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的 NULL（比对失败的标志）。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//p为原链表，elem表示被查找元素、</span><span class="token keyword">int</span> <span class="token function">selectElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> elem<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//新建一个指针t，初始化为头指针 p</span>    link <span class="token operator">*</span> t<span class="token operator">=</span>p<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//由于头节点的存在，因此while中的判断为t->next</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token operator">=</span>t<span class="token operator">-></span>next<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-></span>elem<span class="token operator">==</span>elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//程序执行至此处，表示查找失败</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="链表更新元素"><a href="#链表更新元素" class="headerlink" title="链表更新元素"></a>链表更新元素</h2><p>更新链表中的元素，只需通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值</span>link <span class="token operator">*</span><span class="token function">amendElem</span><span class="token punctuation">(</span>link <span class="token operator">*</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">,</span><span class="token keyword">int</span> newElem<span class="token punctuation">)</span><span class="token punctuation">{</span>    link <span class="token operator">*</span> temp<span class="token operator">=</span>p<span class="token punctuation">;</span>    temp<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在遍历之前，temp指向首元结点</span>    <span class="token comment" spellcheck="true">//遍历到待更新结点</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>add<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    temp<span class="token operator">-></span>elem<span class="token operator">=</span>newElem<span class="token punctuation">;</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="顺序表和链表的优缺点-区别、特点"><a href="#顺序表和链表的优缺点-区别、特点" class="headerlink" title="顺序表和链表的优缺点(区别、特点)"></a>顺序表和链表的优缺点(区别、特点)</h1><ul><li>顺序表存储数据，需预先申请一整块足够大的存储空间，然后将数据按照次序逐一存储，数据之间紧密贴合，不留一丝空隙，如图4a)所示；</li><li>链表的存储方式与顺序表截然相反，什么时候存储数据，什么时候才申请存储空间，数据之间的逻辑关系依靠每个数据元素携带的指针维持，如图4b)所示；</li></ul><div align="center"><img src="/images/区别.png" width="400"></div><h2 id="开辟空间的方式"><a href="#开辟空间的方式" class="headerlink" title="开辟空间的方式"></a>开辟空间的方式</h2><p>顺序表存储数据实行的是 “一次开辟，永久使用”，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小链表则不同，链表存储数据时一次只开辟存储一个节点的物理空间，如果后期需要还可以再申请。</p><p>因此，若只从开辟空间方式的角度去考虑，当存储数据的个数无法提前确定，又或是物理空间使用紧张以致无法一次性申请到足够大小的空间时，使用链表更有助于问题的解决。</p><h2 id="空间利用率"><a href="#空间利用率" class="headerlink" title="空间利用率"></a>空间利用率</h2><p>空间利用率的角度上看，顺序表的空间利用率显然要比链表高。链表在存储数据时，每次只申请一个节点的空间，且空间的位置是随机的</p><p>这种申请存储空间的方式会产生很多空间碎片，一定程序上造成了空间浪费。不仅如此，由于链表中每个数据元素都必须携带至少一个指针，因此，链表对所申请空间的利用率也没有顺序表高。空间碎片，指的是某些容量很小（1KB 甚至更小）以致无法得到有效利用的物理空间。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>根据顺序表和链表在存储结构上的差异，问题类型主要分为以下 2 类：</p><ul><li>问题中主要涉及访问元素的操作，元素的插入、删除和移动操作极少；</li><li>问题中主要涉及元素的插入、删除和移动，访问元素的需求很少；</li></ul><p>第 1 类问题适合使用顺序表。这是因为，顺序表中存储的元素可以使用数组下标直接访问，无需遍历整个表，因此使用顺序表访问元素的时间复杂度为 O(1)；而在链表中访问数据元素，需要从表头依次遍历，直到找到指定节点，花费的时间复杂度为 O(n);</p><p>第 2 类问题则适合使用链表。链表中数据元素之间的逻辑关系靠的是节点之间的指针，当需要在链表中某处插入或删除节点时，只需改变相应节点的指针指向即可，无需大量移动元素，因此链表中插入、删除或移动数据所耗费的时间复杂度为 O(1)；而顺序表中，插入、删除和移动数据可能会牵涉到大量元素的整体移动，因此时间复杂度至少为 O(n);</p><h1 id="静态链表及其创建"><a href="#静态链表及其创建" class="headerlink" title="静态链表及其创建"></a>静态链表及其创建</h1><p>使用静态链表存储数据，数据全部存储在数组中（和顺序表一样），但存储位置是随机的，数据之间”一对一”的逻辑关系通过一个整形变量（称为”游标”，和指针功能类似）维持（和链表类似）。<br> <div align="center"><img src="/images/静态链表.png" width="400"></div><br> <center>图4 静态链表存储数据</center></p><p> 静态链表会将第一个数据元素放到数组下标为 1 的位置（a[1]）中。从 a[1] 存储的数据元素 1 开始，通过存储的游标变量 3，就可以在 a[3] 中找到元素 1 的直接后继元素 2；同样，通过元素 a[3] 存储的游标变量 5，可以在 a[5] 中找到元素 2 的直接后继元素 3，这样的循环过程直到某元素的游标变量为 0 截止（因为 a[0] 默认不存储数据元素）。</p><h2 id="静态链表中的节点"><a href="#静态链表中的节点" class="headerlink" title="静态链表中的节点"></a>静态链表中的节点</h2><p>静态链表存储数据元素也需要自定义数据类型，至少需要包含以下 2 部分信息：</p><ul><li>数据域：用于存储数据元素的值；</li><li>游标：其实就是数组下标，表示直接后继元素所在数组中的位置</li></ul><p>静态链表中节点构成的C语言实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数据域</span>    <span class="token keyword">int</span> cur<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//游标</span><span class="token punctuation">}</span>component<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="备用链表"><a href="#备用链表" class="headerlink" title="备用链表"></a>备用链表</h2><p>备用链表的作用是回收数组中未使用或之前使用过（目前未使用）的存储空间，留待后期使用。也就是说，静态链表使用数组申请的物理空间中，存有两个链表，一条连接数据，另一条连接数组中未使用的空间</p><blockquote><p>通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。</p></blockquote><h2 id="静态链表的创建"><a href="#静态链表的创建" class="headerlink" title="静态链表的创建"></a>静态链表的创建</h2><ul><li>在数据链表未初始化之前，数组中所有位置都处于空闲状态，都被链接到备用链表上。</li><li>向静态链表添加数据时，需提前从备用链表中摘除节点，供新数据使用。</li></ul><p><font color="red">备用链表摘除节点最简单的方法是摘除 a[0] 的直接后继节点；同样，向备用链表中添加空闲节点也是添加作为 a[0] 新的直接后继节点。因为 a[0] 是备用链表的第一个节点，我们知道它的位置，操作它的直接后继节点相对容易，无需遍历备用链表，耗费的时间复杂度为 O(1)。</font></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">define</span> maxSize 6</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* data */</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">int</span> cur<span class="token punctuation">;</span><span class="token punctuation">}</span> component<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将结构体数组中所有分量链接到备用链表</span><span class="token keyword">void</span> <span class="token function">reserveArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化静态链表</span><span class="token keyword">int</span> <span class="token function">initArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输出函数</span><span class="token keyword">void</span> <span class="token function">displayArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token keyword">int</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从备用链表上摘下空闲节点</span><span class="token keyword">int</span> <span class="token function">mallocArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    component array<span class="token punctuation">[</span>maxSize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> body <span class="token operator">=</span> <span class="token function">initArr</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"静态链表：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">displayArr</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建备用链表</span><span class="token keyword">void</span> <span class="token function">reserveArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span>array<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将每个数组分量链接到一起</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    array<span class="token punctuation">[</span>maxSize <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//链表最后一个节点的游标为0</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//提前分配空间</span><span class="token keyword">int</span> <span class="token function">mallocArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span>array<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//初始化静态链表</span><span class="token keyword">int</span> <span class="token function">initArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span>array<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">reserveArr</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> body <span class="token operator">=</span> <span class="token function">mallocArr</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//声明一个变量，把它当指针使，指向链表的最后的一个结点，因为链表为空，所以和头结点重合</span>    <span class="token keyword">int</span> tempBody <span class="token operator">=</span> body<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token function">mallocArr</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从备用链表中拿出空闲的分量</span>        array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> j<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将申请的空闲分量链接在链表的最后一个结点后面</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//给新申请的分量的数据域初始化</span>        tempBody <span class="token operator">=</span> j<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//将指向链表最后一个结点的指针后移</span>    <span class="token punctuation">}</span>    array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//新的链表最后一个结点的指针设置为0</span>    <span class="token keyword">return</span> body<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">displayArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token keyword">int</span> body<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> tempBody <span class="token operator">=</span> body<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//tempBody准备做遍历使用</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,%d "</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span>        tempBody <span class="token operator">=</span> array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d,%d\n"</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="静态链表的基本操作"><a href="#静态链表的基本操作" class="headerlink" title="静态链表的基本操作"></a>静态链表的基本操作</h2><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>将元素4添加到静态链表中的第3个位置上，实现过程如下：</p><ul><li>从备用链表中摘除一个节点，用于存储元素 4；</li><li>找到表中第 2 个节点（添加位置的前一个节点，这里是数据元素 2），将元素 2 的游标赋值给新元素 4；</li><li>将元素 4 所在数组中的下标赋值给元素 2 的游标；<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">insertArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> body<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">,</span><span class="token keyword">char</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> tempBody<span class="token operator">=</span>body<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//tempBody做遍历结构体数组使用</span>  <span class="token comment" spellcheck="true">//找到要插入位置的上一个结点在数组中的位置</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>add<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      tempBody<span class="token operator">=</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">int</span> insert<span class="token operator">=</span><span class="token function">mallocArr</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//申请空间，准备插入</span>  array<span class="token punctuation">[</span>insert<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">=</span>a<span class="token punctuation">;</span>  array<span class="token punctuation">[</span>insert<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token operator">=</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新插入结点的游标等于其直接前驱结点的游标</span>  array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token operator">=</span>insert<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接前驱结点的游标等于新插入结点所在数组中的下标</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3>静态链表中删除指定元素，只需实现以下 2 步操作：</li><li>将存有目标元素的节点从数据链表中摘除；</li><li>将摘除节点添加到备用链表，以便下次再用；<pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//备用链表回收空间的函数，其中array为存储数据的数组，k表示未使用节点所在数组的下标</span><span class="token keyword">void</span> <span class="token function">freeArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>  array<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token operator">=</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>  array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token operator">=</span>k<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//删除结点函数，a 表示被删除结点中数据域存放的数据</span><span class="token keyword">void</span> <span class="token function">deletArr</span><span class="token punctuation">(</span>component <span class="token operator">*</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> body<span class="token punctuation">,</span><span class="token keyword">char</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> tempBody<span class="token operator">=</span>body<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//找到被删除结点的位置</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">!=</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>      tempBody<span class="token operator">=</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//当tempBody为0时，表示链表遍历结束，说明链表中没有存储该数据的结点</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>tempBody<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"链表中没有此数据"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//运行到此，证明有该结点</span>  <span class="token keyword">int</span> del<span class="token operator">=</span>tempBody<span class="token punctuation">;</span>  tempBody<span class="token operator">=</span>body<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//找到该结点的上一个结点，做删除操作</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token operator">!=</span>del<span class="token punctuation">)</span> <span class="token punctuation">{</span>      tempBody<span class="token operator">=</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//将被删除结点的游标直接给被删除结点的上一个结点</span>  array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token operator">=</span>array<span class="token punctuation">[</span>del<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//回收被摘除节点的空间</span>  <span class="token function">freeArr</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> del<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h3>静态链表查找指定元素，由于我们只知道静态链表第一个元素所在数组中的位置，因此只能通过逐个遍历静态链表的方式，查找存有指定数据元素的节点。<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">selectElem</span><span class="token punctuation">(</span>component <span class="token operator">*</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> body<span class="token punctuation">,</span><span class="token keyword">char</span> elem<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> tempBody<span class="token operator">=</span>body<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//当游标值为0时，表示链表结束</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">==</span>elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> tempBody<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      tempBody<span class="token operator">=</span>array<span class="token punctuation">[</span>tempBody<span class="token punctuation">]</span><span class="token punctuation">.</span>cur<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回-1，表示在链表中没有找到该元素</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="更改数据"><a href="#更改数据" class="headerlink" title="更改数据"></a>更改数据</h3>找到目标元素所在的节点，直接更改节点中的数据域即可。<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">amendElem</span><span class="token punctuation">(</span>component <span class="token operator">*</span> array<span class="token punctuation">,</span><span class="token keyword">int</span> body<span class="token punctuation">,</span><span class="token keyword">char</span> oldElem<span class="token punctuation">,</span><span class="token keyword">char</span> newElem<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">int</span> add<span class="token operator">=</span><span class="token function">selectElem</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> body<span class="token punctuation">,</span> oldElem<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>add<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"无更改元素"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  array<span class="token punctuation">[</span>add<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token operator">=</span>newElem<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="静态链表和动态链表区别"><a href="#静态链表和动态链表区别" class="headerlink" title="静态链表和动态链表区别"></a>静态链表和动态链表区别</h1><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2>使用静态链表存储数据，需要预先申请足够大的一整块内存空间，也就是说，静态链表存储数据元素的个数从其创建的那一刻就已经确定，后期无法更改。</li></ul><p>比如，如果创建静态链表时只申请存储10个数据元素的空间，那么在使用静态链表时，数据的存储个数就不能超过10个，否则程序就会发生错误。</p><p>不仅如此，静态链表是在固定大小的存储空间内随机存储各个数据元素，这就造成了静态链表中需要使用另一条链表（通常称为”备用链表”）来记录空间存储空间的位置，以便后期分配给新添加元素使用，如图 2 所示。</p><p>这意味着，如果你选择使用静态链表存储数据，你需要通过操控两条链表，一条是存储数据，另一条是记录空闲空间的位置。</p><h2 id="动态链表"><a href="#动态链表" class="headerlink" title="动态链表"></a>动态链表</h2><p>使用动态链表存储数据，不需要预先申请内存空间，而是在需要的时候才向内存申请。也就是说，动态链表存储数据元素的个数是不限的，想存多少就存多少。</p><p>同时，使用动态链表的整个过程，你也只需操控一条存储数据的链表。当表中添加或删除数据元素时，你只需要通过 malloc 或 free 函数来申请或释放空间即可，实现起来比较简单。</p><h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><p><font color="red">双向，指的是各节点之间的逻辑关系是双向的，但通常头指针只设置一个，除非实际情况需要</font></p><p>双向链表中各节点包含以下3部分信息：</p><ul><li>指针域：用于指向当前节点的直接前驱节点；</li><li>数据域：用于存储数据元素。</li><li>指针域：用于指向当前节点的直接后继节点；</li></ul><p>双链表的节点结构的Ｃ语言实现：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> line<span class="token punctuation">{</span>    <span class="token keyword">struct</span> line <span class="token operator">*</span> prior<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指向直接前趋</span>    <span class="token keyword">int</span> data<span class="token punctuation">;</span>    <span class="token keyword">struct</span> line <span class="token operator">*</span> next<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//指向直接后继</span><span class="token punctuation">}</span>line<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向链表的创建"><a href="#双向链表的创建" class="headerlink" title="双向链表的创建"></a>双向链表的创建</h2><p>与单链表不同，双链表创建过程中，每创建一个新节点，都要与其前驱节点建立两次联系，分别是：</p><ul><li><p>将新节点的 prior 指针指向直接前驱节点；</p></li><li><p>将直接前驱节点的 next 指针指向新节点；</p><pre class="line-numbers language-c"><code class="language-c">line<span class="token operator">*</span> <span class="token function">initLine</span><span class="token punctuation">(</span>line <span class="token operator">*</span> head<span class="token punctuation">)</span><span class="token punctuation">{</span>  head<span class="token operator">=</span><span class="token punctuation">(</span>line<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建链表第一个结点（首元结点）</span>  head<span class="token operator">-></span>prior<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  head<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  head<span class="token operator">-></span>data<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  line <span class="token operator">*</span> list<span class="token operator">=</span>head<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span><span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//创建并初始化一个新结点</span>      line <span class="token operator">*</span> body<span class="token operator">=</span><span class="token punctuation">(</span>line<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      body<span class="token operator">-></span>prior<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>      body<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>      body<span class="token operator">-></span>data<span class="token operator">=</span>i<span class="token punctuation">;</span>      list<span class="token operator">-></span>next<span class="token operator">=</span>body<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接前趋结点的next指针指向新结点</span>      body<span class="token operator">-></span>prior<span class="token operator">=</span>list<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//新结点指向直接前趋结点</span>      list<span class="token operator">=</span>list<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><pre class="line-numbers language-c"><code class="language-c">line <span class="token operator">*</span> <span class="token function">insertLine</span><span class="token punctuation">(</span>line <span class="token operator">*</span> head<span class="token punctuation">,</span><span class="token keyword">int</span> data<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//新建数据域为data的结点</span>  line <span class="token operator">*</span> temp<span class="token operator">=</span><span class="token punctuation">(</span>line<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  temp<span class="token operator">-></span>data<span class="token operator">=</span>data<span class="token punctuation">;</span>  temp<span class="token operator">-></span>prior<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  temp<span class="token operator">-></span>next<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//插入到链表头，要特殊考虑</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>add<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      temp<span class="token operator">-></span>next<span class="token operator">=</span>head<span class="token punctuation">;</span>      head<span class="token operator">-></span>prior<span class="token operator">=</span>temp<span class="token punctuation">;</span>      head<span class="token operator">=</span>temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>      line <span class="token operator">*</span> body<span class="token operator">=</span>head<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//找到要插入位置的前一个结点</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>add<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          body<span class="token operator">=</span>body<span class="token operator">-></span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//判断条件为真，说明插入位置为链表尾</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>body<span class="token operator">-></span>next<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          body<span class="token operator">-></span>next<span class="token operator">=</span>temp<span class="token punctuation">;</span>          temp<span class="token operator">-></span>prior<span class="token operator">=</span>body<span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>          body<span class="token operator">-></span>next<span class="token operator">-></span>prior<span class="token operator">=</span>temp<span class="token punctuation">;</span>          temp<span class="token operator">-></span>next<span class="token operator">=</span>body<span class="token operator">-></span>next<span class="token punctuation">;</span>          body<span class="token operator">-></span>next<span class="token operator">=</span>temp<span class="token punctuation">;</span>          temp<span class="token operator">-></span>prior<span class="token operator">=</span>body<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//删除结点的函数，data为要删除结点的数据域的值</span>line <span class="token operator">*</span> <span class="token function">delLine</span><span class="token punctuation">(</span>line <span class="token operator">*</span> head<span class="token punctuation">,</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>  line <span class="token operator">*</span> temp<span class="token operator">=</span>head<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//遍历链表</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//判断当前结点中数据域和data是否相等，若相等，摘除该结点</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">-></span>data<span class="token operator">==</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>          temp<span class="token operator">-></span>prior<span class="token operator">-></span>next<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>          temp<span class="token operator">-></span>next<span class="token operator">-></span>prior<span class="token operator">=</span>temp<span class="token operator">-></span>prior<span class="token punctuation">;</span>          <span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> head<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      temp<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"链表中无该数据元素"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//双链表查找指定元素的实现同单链表类似，都是从表头依次遍历表中元素。</span><span class="token comment" spellcheck="true">//head为原双链表，elem表示被查找元素</span><span class="token keyword">int</span> <span class="token function">selectElem</span><span class="token punctuation">(</span>line <span class="token operator">*</span> head<span class="token punctuation">,</span><span class="token keyword">int</span> elem<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//新建一个指针t，初始化为头指针 head</span>  line <span class="token operator">*</span> t<span class="token operator">=</span>head<span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token operator">-></span>data<span class="token operator">==</span>elem<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> i<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      i<span class="token operator">++</span><span class="token punctuation">;</span>      t<span class="token operator">=</span>t<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//程序执行至此处，表示查找失败</span>  <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="更改节点"><a href="#更改节点" class="headerlink" title="更改节点"></a>更改节点</h2><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//更新函数，其中，add 表示更改结点在双链表中的位置，newElem 为新数据的值</span>line <span class="token operator">*</span><span class="token function">amendElem</span><span class="token punctuation">(</span>line <span class="token operator">*</span> p<span class="token punctuation">,</span><span class="token keyword">int</span> add<span class="token punctuation">,</span><span class="token keyword">int</span> newElem<span class="token punctuation">)</span><span class="token punctuation">{</span>  line <span class="token operator">*</span> temp<span class="token operator">=</span>p<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//遍历到被删除结点</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>add<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      temp<span class="token operator">=</span>temp<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  temp<span class="token operator">-></span>data<span class="token operator">=</span>newElem<span class="token punctuation">;</span>  <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><p>将表中最后一个结点的指针指向头结点，虽然循环链表成环状，但本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等。循环链表和普通链表相比，唯一的不同就是循环链表首尾相连，其他都完全一样。</p><h2 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><p>已知 n 个人（分别用编号 1，2，3，…，n 表示）围坐在一张圆桌周围，从编号为 k 的人开始顺时针报数，数到 m 的那个人出列；他的下一个人又从 1 开始，还是顺时针开始报数，数到 m 的那个人又出列；依次重复下去，直到圆桌上剩余一个人。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> node<span class="token punctuation">{</span>  <span class="token keyword">int</span> number<span class="token punctuation">;</span>  <span class="token keyword">struct</span> node <span class="token operator">*</span>next<span class="token punctuation">;</span><span class="token punctuation">}</span> person<span class="token punctuation">;</span>person <span class="token operator">*</span><span class="token function">initLink</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>  person <span class="token operator">*</span>head <span class="token operator">=</span> <span class="token punctuation">(</span>person <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  head<span class="token operator">-></span>number <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  person <span class="token operator">*</span>cyclic <span class="token operator">=</span> head<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>  <span class="token punctuation">{</span>      person <span class="token operator">*</span>body <span class="token operator">=</span> <span class="token punctuation">(</span>person <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      body<span class="token operator">-></span>number <span class="token operator">=</span> i<span class="token punctuation">;</span>      body<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>      cyclic<span class="token operator">-></span>next <span class="token operator">=</span> body<span class="token punctuation">;</span>      cyclic <span class="token operator">=</span> cyclic<span class="token operator">-></span>next<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  cyclic<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//首尾相连</span>  <span class="token keyword">return</span> head<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>void findAndKillK(person *head, int k, int m)<br>{</p><pre><code>person *tail = head;//找到链表第一个结点的上一个结点，为删除操作做准备while (tail-&gt;next != head){    tail = tail-&gt;next;}person *p = head;//找到编号为k的人while (p-&gt;number != k){    tail = p;    p = p-&gt;next;}//从编号为k的人开始，只有符合p-&gt;next==p时，说明链表中除了p结点，所有编号都出列了，while (p-&gt;next != p){    //找到从p报数1开始，报m的人，并且还要知道数m-1de人的位置tail，方便做删除操作。    for (int i = 1; i &lt; m; i++)    {        tail = p;        p = p-&gt;next;    }    tail-&gt;next = p-&gt;next; //从链表上将p结点摘下来    printf(&quot;出列人的编号为:%d\n&quot;, p-&gt;number);    free(p);    p = tail-&gt;next; //继续使用p指针指向出列编号的下一个编号，游戏继续}printf(&quot;出列人的编号为:%d\n&quot;, p-&gt;number);free(p);</code></pre><p>}</p><p>int main()<br>{<br>    printf(“输入圆桌上的人数n:”);<br>    int n;<br>    scanf(“%d”, &amp;n);<br>    person *head = initLink(n);<br>    printf(“从第k人开始报数(k&gt;1且k&lt;%d)：”, n);<br>    int k;<br>    scanf(“%d”, &amp;k);<br>    printf(“数到m的人出列：”);<br>    int m;<br>    scanf(“%d”, &amp;m);<br>    findAndKillK(head, k, m);<br>    return 0;<br>}<br>```</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法导论 </tag>
            
            <tag> 线性表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
