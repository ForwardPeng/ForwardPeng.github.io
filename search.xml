<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态内存管理机制</title>
      <link href="/2022/12/04/cao-zuo-xi-tong/dong-tai-nei-cun-guan-li/"/>
      <url>/2022/12/04/cao-zuo-xi-tong/dong-tai-nei-cun-guan-li/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="占用块和空闲块"><a href="#占用块和空闲块" class="headerlink" title="占用块和空闲块"></a>占用块和空闲块</h1><p>对于计算机中的内存来说，称已经分配给用户的的内存区统称为“占用块”；还未分配出去的内存区统称为“空闲块”或者“可利用空间块”。</p><h1 id="系统的内存管理"><a href="#系统的内存管理" class="headerlink" title="系统的内存管理"></a>系统的内存管理</h1><p>对于初始状态下的内存来说，整个空间都是一个空闲块（在编译程序中称为“堆”）。但是随着不同的用户不断地提出存储请求，系统依次分配。</p><p>整个内存区就会分割成两个大部分：低地址区域会产生很多占用块；高地址区域还是空闲块。<br> <div align="center"><img src="/images/动态分配.png" width="800"></div><br> <center>图1 动态分配过程中的内存状态</center></p><p> 当某些用户运行结束，所占用的内存区域就变成了空闲块，如图2：<br>  <div align="center"><img src="/images/内存变化.png" width="800"></div><br> <center>图2 动态分配过程中的内存变化</center></p><p> 时，就形成了占用块和空闲块犬牙交错的状态。当后续用户请求分配内存时，系统有两种分配方式：</p><ul><li>系统继续利用高地址区域的连续空闲块分配给用户，不去理会之前分配给用户的内存区域的状态。直到分配无法进行，也就是高地址的空闲块不能满足用户的需求时，系统才会去回收之前的空闲块，重新组织继续分配；</li><li>当用户运行一结束，系统马上将其所占空间进行回收。当有新的用户请求分配内存时，系统遍历所有的空闲块，从中找出一个合适的空闲块分配给用户。<h1 id="可利用空间表"><a href="#可利用空间表" class="headerlink" title="可利用空间表"></a>可利用空间表</h1>系统需要建立一张记录所有空闲块信息的表。表的形式有两种：目录表和链表。各自的结构如图3所示：<div align="center"><img src="/images/目录表和链表.png" width="800"></div><center>图3 目录表和链表</center></li></ul><p>目录表：表中每一行代表一个空闲块，由三部分组成：</p><ul><li>初始地址：记录每个空闲块的起始地址。</li><li>空闲块大小：记录每个空闲块的内存大小。</li><li>使用情况：记录每个空闲块是否存储被占用的状态。</li></ul><p>链表：表中每个结点代表一个空闲块，每个结点中需要记录空闲块的使用情况、大小和连接下一个空闲块的指针域。</p><blockquote><p>由于链表中有指针的存在，所以结点中不需要记录各内存块的起始地址。</p></blockquote><p>存储空闲块的可利用空间表有以下不同的结构：</p><ul><li>如果每次用户请求的存储空间大小相同，对于此类系统中的内存来说，在用户运行初期就将整个内存存储块按照所需大小进行分割，然后通过链表链接。当用户申请空间时，从链表中摘除一个结点归其使用；用完后再链接到可利用空间表上。</li><li>每次如果用户申请的都是若干种大小规格的存储空间，针对这种情况可以建立若干个可利用空间表，每一个链表中的结点大小相同。当用户申请某一规格大小的存储空间时，就从对应的链表中摘除一个结点供其使用；用完后链接到相同规格大小的链表中。</li><li>用户申请的内存的大小不固定，所以造成系统分配的内存块的大小也不确定，回收时，链接到可利用空间表中每个结点的大小也各不一样。<blockquote><p>第 2 种情况下容易面临的问题是：如果同用户申请空间大小相同的链表中没有结点时，就需要找结点更大的链表，从中取出一个结点，一部分给用户使用，剩余部分插入到相应大小的链表中；回收时，将释放的空闲块插入到大小相同的链表中去。如果没有比用户申请的内存空间相等甚至更大的结点时，就需要系统重新组织一些小的连续空间，然后给用户使用。</p></blockquote></li></ul><h1 id="分配存储空间的方式"><a href="#分配存储空间的方式" class="headerlink" title="分配存储空间的方式"></a>分配存储空间的方式</h1><p>通常情况下系统中的可利用空间表是第 3 种情况。如图 3(C) 所示。由于链表中各结点的大小不一，在用户申请内存空间时，就需要从可利用空间表中找出一个合适的结点，有三种查找的方法：</p><ul><li>首次拟合法：在可利用空间表中从头开始依次遍历，将找到的第一个内存不小于用户申请空间的结点分配给用户，剩余空间仍留在链表中；回收时只要将释放的空闲块插入在链表的表头即可。</li><li>最佳拟合法：和首次拟合法不同，最佳拟合法是选择一块内存空间不小于用户申请空间，但是却最接近的一个结点分配给用户。为了实现这个方法，首先要将链表中的各个结点按照存储空间的大小进行从小到大排序，由此，在遍历的过程中只需要找到第一块大于用户申请空间的结点即可进行分配；用户运行完成后，需要将空闲块根据其自身的大小插入到链表的相应位置。</li><li>最差拟合法：和最佳拟合法正好相反，该方法是在不小于用户申请空间的所有结点中，筛选出存储空间最大的结点，从该结点的内存空间中提取出相应的空间给用户使用。为了实现这一方法，可以在开始前先将可利用空间表中的结点按照存储空间大小从大到小进行排序，第一个结点自然就是最大的结点。回收空间时，同样将释放的空闲块插入到相应的位置上。</li></ul><p>以上三种方法各有所长：</p><ul><li>最佳拟合法由于每次分配相差不大的结点给用户使用，所以会生成很多存储空间特别小的结点，以至于根本无法使用，使用过程中，链表中的结点存储大小发生两极分化，大的很大，小的很小。该方法适用于申请内存大小范围较广的系统</li><li>最差拟合法，由于每次都是从存储空间最大的结点中分配给用户空间，所以链表中的结点大小不会起伏太大。依次适用于申请分配内存空间较窄的系统。</li><li>首次拟合法每次都是随机分配。在不清楚用户申请空间大小的情况下，使用该方法分配空间。<h1 id="边界标识法管理动态内存"><a href="#边界标识法管理动态内存" class="headerlink" title="边界标识法管理动态内存"></a>边界标识法管理动态内存</h1>使用边界标识法的系统管理内存时，可利用空间表中的结点的构成如图 4：<div align="center"><img src="/images/结构构成.png" width="800"></div><center>图4 结构构成</center></li></ul><p>每个结点中包含3个区域，head域、foot域和space域：</p><ul><li>space域表示为该内存块的大小，它的大小通过head域中的size值表示。</li><li>head域中包含有4部分：llink 和rlink分别表示指向当前内存块结点的直接前驱和直接后继。tag值用于标记当前内存块的状态，是占用块（用 1 表示）还是空闲块（用 0 表示）。size用于记录该内存块的存储大小。</li><li>foot域中包含有2部分：uplink 是指针域，用于指向内存块本身，通过uplink就可以获取该内存块所在内存的首地址。tag同head域中的tag相同，都是记录内存块状态的。<blockquote><p>注意：head域和foot域在本节中都假设只占用当前存储块的1个存储单位的空间，对于该结点整个存储空间来说，可以忽略不计。也就是说，在可利用空间表中，知道下一个结点的首地址，该值减1就可以找到当前结点的foot域。</p></blockquote></li></ul><p>边界标识法管理的内存块结点代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> WORD<span class="token punctuation">{</span>    <span class="token keyword">union</span><span class="token punctuation">{</span>        <span class="token keyword">struct</span> WORD <span class="token operator">*</span>llink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向直接前驱</span>        <span class="token keyword">struct</span> WORD <span class="token operator">*</span>uplink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向结点本身</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tag<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//标记域,0表示为空闲块；1表示为占用块</span>    <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录内存块的存储大小</span>    <span class="token keyword">struct</span> WORD <span class="token operator">*</span>rlink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向直接后继</span>    OtherType other<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//内存块可能包含的其它的部分</span><span class="token punctuation">}</span>WORD<span class="token punctuation">,</span>head<span class="token punctuation">,</span>foot<span class="token punctuation">,</span><span class="token operator">*</span>Space<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h1><blockquote><p>3 种分配方法分别为：首部拟合法、最佳拟合法和最差拟合法。</p><ul><li>选定一个常量e，每次分配空间时，判断当前内存块向用户分配空间后，如果剩余部分的容量比e小，则将整个内存块全部分配给用户。</li><li>采用头部拟合法进行分配时，如果每次都从pav指向的结点开始遍历，在若干次后，会出现存储量小的结点密集地分布在pav结点附近的情况，严重影响遍历的时间。解决办法就是：在每次分配空间后，让pav指针指向该分配空间结点的后继结点，然后从新的pav指向的结点开始下一次的分配。</li></ul></blockquote><p>首部拟合法具体实现：</p><pre class="line-numbers language-c"><code class="language-c">Space <span class="token function">AllocBoundTag</span><span class="token punctuation">(</span>Space <span class="token operator">*</span>pav<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>    Space p<span class="token punctuation">,</span> f<span class="token punctuation">;</span>    <span class="token keyword">int</span> e <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//设定常亮 e 的值</span>    <span class="token comment" spellcheck="true">//如果在遍历过程，当前空闲块的在存储容量比用户申请空间 n 值小，在该空闲块有右孩子的情况下直接跳过</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>size <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> p<span class="token operator">-></span>rlink <span class="token operator">!=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">=</span> p<span class="token operator">-></span>rlink<span class="token punctuation">)</span>        <span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//跳出循环，首先排除p为空和p指向的空闲块容量小于 n 的情况</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p <span class="token operator">||</span> p<span class="token operator">-></span>size <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//指针f指向p空闲块的foot域</span>        f <span class="token operator">=</span> <span class="token function">FootLoc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//调整pav指针的位置，为下次分配做准备</span>        <span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span> <span class="token operator">=</span> p<span class="token operator">-></span>rlink<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果该空闲块的存储大小比 n 大，比 n+e 小，负责第一种情况，将 p 指向的空闲块全部分配给用户</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>size <span class="token operator">-</span> n <span class="token operator">&lt;=</span> e<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span> <span class="token operator">==</span> p<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                pav <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//全部分配用户，即从可利用空间表中删除 p 空闲块</span>                <span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span><span class="token operator">-></span>llink <span class="token operator">=</span> p<span class="token operator">-></span>llink<span class="token punctuation">;</span>                p<span class="token operator">-></span>llink<span class="token operator">-></span>rlink <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>pav<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//同时调整head域和foot域中的tag值</span>            p<span class="token operator">-></span>tag <span class="token operator">=</span> f<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//否则，从p空闲块中拿出 大小为 n 的连续空间分配给用户，同时更新p剩余存储块中的信息。</span>        <span class="token keyword">else</span>        <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//更改分配块foot域的信息</span>            f<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            p<span class="token operator">-></span>size <span class="token operator">-</span><span class="token operator">=</span> n<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//f指针指向剩余空闲块 p 的底部</span>            f <span class="token operator">=</span> <span class="token function">FootLoc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>            f<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            f<span class="token operator">-></span>uplink <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> f <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//p指向的是分配给用户的块的head域，也就是该块的首地址</span>            p<span class="token operator">-></span>tag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            p<span class="token operator">-></span>size <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h1><p>系统需要立即回收被用户占用的存储空间，以备新的用户使用。回收算法中需要解决的问题是：在若干次分配操作后，可利用空间块中会产生很多存储空间很小以致无法使用的空闲块。但是经过回收用户释放的空间后，可利用空间表中可能含有地址相邻的空闲块，回收算法需要将这些地址相邻的空闲块合并为大的空闲块供新的用户使用。合并空闲块有3种情况：</p><ul><li>该空闲块的左边有相邻的空闲块可以进行合并；</li><li>该空闲块的右边用相邻的空闲块可以进行合并；</li><li>该空闲块的左右两侧都有相邻的空闲块可以进行合并；<blockquote><p>判断当前空闲块左右两侧是否为空闲块的方法是：对于当前空闲块p ，p-1 就是相邻的低地址处的空闲块的foot域，如果foot域中的tag值为0 ，表明其为空闲块； p+p-&gt;size 表示的是高地址处的块的head域，如果head域中的tag值为 0，表明其为空闲块。</p></blockquote></li></ul><p>如果当前空闲块的左右两侧都不是空闲块，而是占用块，此种情况下只需要将新的空闲块按照相应的规则（头部拟合法随意插入，其它两种方法在对应位置插入）插入到可利用空间表中即可。实现代码为：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//设定p指针指向的为用户释放的空闲块</span>p<span class="token operator">-></span>tag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//f指针指向p空闲块的foot域</span>Space f<span class="token operator">=</span><span class="token function">FootLoc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token operator">-></span>uplink<span class="token operator">=</span>p<span class="token punctuation">;</span>f<span class="token operator">-></span>tag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//如果pav指针不存在，证明可利用空间表为空，此时设置p为头指针，并重新建立双向循环链表</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pav<span class="token punctuation">)</span> <span class="token punctuation">{</span>    pav<span class="token operator">=</span>p<span class="token operator">-></span>llink<span class="token operator">=</span>p<span class="token operator">-></span>rlink<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//否则，在p空闲块插入到pav指向的空闲块的左侧</span>    Space q<span class="token operator">=</span>pav<span class="token operator">-></span>llink<span class="token punctuation">;</span>    p<span class="token operator">-></span>rlink<span class="token operator">=</span>pav<span class="token punctuation">;</span>    p<span class="token operator">-></span>llink<span class="token operator">=</span>q<span class="token punctuation">;</span>    q<span class="token operator">-></span>rlink<span class="token operator">=</span>pav<span class="token operator">-></span>llink<span class="token operator">=</span>p<span class="token punctuation">;</span>    pav<span class="token operator">=</span>p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该空闲块的左侧相邻的块为空闲块，右侧为占用块，处理的方法是：只需要更改左侧空闲块中的size的大小，并重新设置左侧空闲块的foot 域即可（如图2）。</p><div align="center"><img src="/images/空闲块合并.png" width="800"></div> <center>图5 空闲块合并（当前块，左侧内存块）</center><p> 实现代码：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//常量 n 表示当前空闲块的存储大小</span><span class="token keyword">int</span> n<span class="token operator">=</span>p<span class="token operator">-></span>size<span class="token punctuation">;</span>Space s<span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">-></span>uplink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//p-1 为当前块的左侧块的foot域，foot域中的uplink指向的就是左侧块的首地址，s指针代表的是当前块的左侧存储块</span>s<span class="token operator">-></span>size<span class="token operator">+</span><span class="token operator">=</span>n<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置左侧存储块的存储容量</span>Space f<span class="token operator">=</span>p<span class="token operator">+</span>n<span class="token number">-1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//f指针指向的是空闲块 p 的foot域</span>f<span class="token operator">-></span>uplink<span class="token operator">=</span>s<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这是foot域的uplink指针重新指向合并后的存储空间的首地址</span>f<span class="token operator">-></span>tag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//设置foot域的tag标记为空闲块</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 如果当前用户释放掉的空闲块，物理位置上相邻的左右两侧的内存块全部为空闲块，需要将 3 个空闲块合并为一个更大的块，操作的过程为：更新左侧空闲块的 size 的值，同时在可利用空间表中摘除右侧空闲块，最后更新合并后的大的空闲块的 foot域</p><pre class="line-numbers language-c"><code class="language-c"> <span class="token keyword">int</span> n<span class="token operator">=</span>p<span class="token operator">-></span>size<span class="token punctuation">;</span>Space s<span class="token operator">=</span><span class="token punctuation">(</span>p<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">-></span>uplink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//找到释放内存块物理位置相邻的低地址的空闲块</span>Space t<span class="token operator">=</span>p<span class="token operator">+</span>p<span class="token operator">-></span>size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//找到物理位置相邻的高地址处的空闲块</span>s<span class="token operator">-></span>size<span class="token operator">+</span><span class="token operator">=</span>n<span class="token operator">+</span>t<span class="token operator">-></span>size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更新左侧空闲块的size的值</span><span class="token comment" spellcheck="true">//从可利用空间表中摘除右侧空闲块</span>Space q<span class="token operator">=</span>t<span class="token operator">-></span>llink<span class="token punctuation">;</span>Space q1<span class="token operator">=</span>t<span class="token operator">-></span>rlink<span class="token punctuation">;</span>q<span class="token operator">-></span>rlink<span class="token operator">=</span>q1<span class="token punctuation">;</span>q1<span class="token operator">-></span>llink<span class="token operator">=</span>q<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//更新合并后的空闲块的uplink指针的指向</span>Space f<span class="token operator">=</span><span class="token function">FootLoc</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token operator">-></span>uplink<span class="token operator">=</span>s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="伙伴系统管理动态内存"><a href="#伙伴系统管理动态内存" class="headerlink" title="伙伴系统管理动态内存"></a>伙伴系统管理动态内存</h1><p>伙伴系统本身是一种动态管理内存的方法，和边界标识法的区别是：使用伙伴系统管理的存储空间，无论是空闲块还是占用块，大小都是 2 的 n 次幂（n 为正整数）。</p><p>例如，系统中整个存储空间为 2m 个字。那么在进行若干次分配与回收后，可利用空间表中只可能包含空间大小为：20、21、22、…、2m 的空闲块。</p><blockquote><p>字是一种计量单位，由若干个字节构成，不同位数的机器，字所包含的字节数不同。例如，8 位机中一个字由 1 个字节组成；16 位机器一个字由 2 个字节组成。</p></blockquote><h2 id="可利用空间表中结点构成"><a href="#可利用空间表中结点构成" class="headerlink" title="可利用空间表中结点构成"></a>可利用空间表中结点构成</h2><div align="center"><img src="/images/结点构成.png" width="800"></div> <center>图6 结点构成</center><p>header 域表示为头部结点，由 4 部分构成：</p><ul><li><p>llink 和 rlink 为结点类型的指针域，分别用于指向直接前驱和直接后继结点。</p></li><li><p>tag 值：用于标记内存块的状态，是占用块（用 1 表示）还是空闲块（用 0 表示）</p></li><li><p>kval：记录该存储块的容量。由于系统中各存储块都是2的m幂次方，所以kval记录m的值。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> WORD_b<span class="token punctuation">{</span>  <span class="token keyword">struct</span> WORD_b <span class="token operator">*</span>llink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向直接前驱</span>  <span class="token keyword">int</span> tag<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录该块是占用块还是空闲块</span>  <span class="token keyword">int</span> kval<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录该存储块容量大小为2的多少次幂</span>  <span class="token keyword">struct</span> WORD_b <span class="token operator">*</span>rlink<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指向直接后继</span>  OtherType other<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录结点的其它信息</span><span class="token punctuation">}</span>WORD_b<span class="token punctuation">,</span>head<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在伙伴系统中，由于系统会不断地接受用户的内存申请的请求，所以会产生很多大小不同但是都是容量为$2^{m}$的内存块，所以为了在分配的时候查找方便，系统采用将大小相同的各自建立一个链表。对于初始容量为 $2^{m}$的一整块存储空间来说，形成的链表就有可能有m+1个，为了更好的对这些链表进行管理，系统将这m+1个链表的表头存储在数组中，就类似于邻接表的结构，如图7。</p><div align="center"><img src="/images/伙伴系统的初始状态.png" width="800"></div><center>图7 伙伴系统的初始状态</center><p>可利用空间表的代码表示为：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> m 16</span><span class="token comment" spellcheck="true">//设定m的初始值</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> HeadNode <span class="token punctuation">{</span>  <span class="token keyword">int</span> nodesize<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录该链表中存储的空闲块的大小</span>  WORD_b <span class="token operator">*</span> first<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//相当于链表中的next指针的作用</span><span class="token punctuation">}</span>FreeList<span class="token punctuation">[</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一维数组</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="分配算法-1"><a href="#分配算法-1" class="headerlink" title="分配算法"></a>分配算法</h1><p>伙伴系统的分配算法很简单。假设用户向系统申请大小为 n 的存储空间，若$2^{k-1} &lt; n &lt;= 2^{k}$，此时就需要查看可利用空间表中大小为$2^{k}$ 的链表中有没有可利用的空间结点：</p></li><li><p>如果该链表不为NULL，可以直接采用头插法从头部取出一个结点，提供给用户使用；</p></li><li><p>如果大小为$2^{k}$的链表为 NULL，就需要依次查看比$2^{k}$大的链表，找到后从链表中删除，截取相应大小的空间给用户使用，剩余的空间，根据大小插入到相应的链表中。</p></li></ul><p>用户向系统申请一块大小为7个字的空间，而系统总的内存为$2^{4}$个字,按照伙伴系统的分配算法得出：$2^{2} &lt; 7 &lt; 2^{3}$，所以此时应查看可利用空间表中大小为 23 的链表中是否有空闲结点：</p><ul><li><p>如果有，则从该链表中摘除一个结点，直接分配给用户使用；</p></li><li><p>如果没有，则需依次查看比$2^{3}$大的各个链表中是否有空闲结点。假设，在大小$2^{4}$的链表中有空闲块，则摘除该空闲块，分配给用户$2^{3}$个字的空间，剩余$2^{3}$个字，该剩余的空闲块添加到大小为$2^{3}$的链表中。</p><div align="center"><img src="/images/分配过程.png" width="800"></div><center>图8 伙伴系统分配过程</center><h1 id="回收算法-1"><a href="#回收算法-1" class="headerlink" title="回收算法"></a>回收算法</h1><p>无论使用什么内存管理机制，在内存回收的问题上都会面临一个共同的问题：如何把回收的内存进行有效地整合，伙伴系统也不例外。</p></li></ul><p>当用户申请的内存块不再使用时，系统需要将这部分存储块回收，回收时需要判断是否可以和其它的空闲块进行合并。</p><p>在寻找合并对象时，伙伴系统和边界标识法不同，在伙伴系统中每一个存储块都有各自的“伙伴”，当用户释放存储块时只需要判断该内存块的伙伴是否为空闲块，如果是则将其合并，然后合并的新的空闲块还需要同其伙伴进行判断整合。反之直接将存储块根据大小插入到可利用空间表中即可。</p><p>判断一个存储块的伙伴的位置时，采用的方法为：如果该存储块的起始地址为 p，大小为$2^{k}$，则其伙伴所在的起始地址为：</p><div align="center"><img src="/images/公式1.png" width="800"></div><p>例如，当大小为$2^{8}$ ，起始地址为512的伙伴块的起始地址的计算方式为：由于512 MOD $2^{9}$=0，所以，$512+2^{8}=768$，及如果该存储块回收时，只需要查看起始地址为 768 的存储块的状态，如果是空闲块则两者合并，反之直接将回收的释放块链接到大小为$2^{8}$的链表中。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用伙伴系统进行存储空间的管理过程中，在用户申请空间时，由于大小不同的空闲块处于不同的链表中，所以分配完成的速度会更快，算法相对简单。</p><p>回收存储空间时，对于空闲块的合并，不是取决于该空闲块的相邻位置的块的状态；而是完全取决于其伙伴块。所以即使其相邻位置的存储块时空闲块，但是由于两者不是伙伴的关系，所以也不会合并。这也就是该系统的缺点之一：由于在合并时只考虑伙伴，所以容易产生存储的碎片。</p><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>当用户发出申请空间的请求后，系统向用户分配内存；用户运行结束释放存储空间后，系统回收内存。这两部操作都是在用户给出明确的指令后，系统对存储空间进行有效地分配和回收。</p><p>但是在实际使用过程中，有时会因为用户申请了空间，但是在使用完成后没有向系统发出释放的指令，导致存储空间既没有被使用也没有被回收，变为了无用单元或者会产生悬挂访问的问题。</p><p>什么是无用单元？简单来讲，无用单元是一块用户不再使用，但是系统无法回收的存储空间。例如在C语言中，用户可以通过 malloc 和 free 两个功能函数来动态申请和释放存储空间。当用户使用 malloc 申请的空间使用完成后，没有使用 free 函数进行释放，那么该空间就会成为无用单元。</p><p>悬挂访问也很好理解：假设使用malloc申请了一块存储空间，有多个指针同时指向这块空间，当其中一个指针完成使命后，私自将该存储空间使用free释放掉，导致其他指针处于悬空状态，如果释放掉的空间被再分配后，再通过之前的指针访问，就会造成错误。数据结构中称这种访问为悬挂访问。</p><p>解决存储空间可能成为无用单元或者产生悬挂访问的方法有两个：</p><ul><li>每个申请的存储空间设置一个计数域，这个计数域记录的是指向该存储空间的指针数目，只有当计数域的值为 0 时，该存储空间才会被释放。</li><li>在程序运行时，所有的存储空间无论是处于使用还是空闲的状态，一律不回收，当系统中的可利用空间表为空时，将程序中断，对当前不在使用状态的存储空间一律回收，全部链接成一个新的可利用空间表后，程序继续执行。</li></ul><p><font color="red">第二种方法中，在程序运行过程中很难找出此时哪些存储空间是空闲的。解决这个问题的办法是：找当前正在被占用的存储空间，只需要从当前正在工作的指针变量出发依次遍历，就可以找到当前正在被占用的存储空间，剩余的自然就是此时处于空闲状态的存储空间。</font></p><p>使用第二种方式，可以分为两步进行：</p><ul><li>对所有当前正在使用的存储空间加上被占用的标记（对于广义表来说，可以在每个结点结构的基础上，添加一个 mark 的标志域。在初始状态下，所有的存储空间全部标志为 0，被占用时标记为 1）；</li><li>依次遍历所有的存储空间，将所有标记为 0 的存储空间链接成一个新的可利用空间表。</li></ul><p>对正在被占用的存储空间进行标记的方法有三种：</p><ul><li>从当前正在工作的指针变量开始，采用递归算法依次将所有表中的存储结点中的标志域全部设置为 1；</li><li>第一种方法中使用递归算法实现的遍历。而递归底层使用的栈的存储结构，所以也可以直接使用栈的方式进行遍历；</li><li>以上两种方法都是使用栈结构来记录遍历时指针所走的路径，便于在后期可以沿原路返回。所以第三种方式就是使用其他的方法代替栈的作用。</li></ul><h1 id="内存碎片化处理"><a href="#内存碎片化处理" class="headerlink" title="内存碎片化处理"></a>内存碎片化处理</h1><p>这些地址连续的未被占用的存储区在编译程序中称为堆。</p><h1 id="分配内存空间"><a href="#分配内存空间" class="headerlink" title="分配内存空间"></a>分配内存空间</h1><p>在分配内存空间时，每次都从可利用空间中选择最低（或者最高）的地址进行分配。具体的实现办法为：设置一个指针（称为堆指针），每次用户申请存储空间时，都是堆的最低（或者最高）地址进行分配。假设当用户申请 N 个单位的存储空间时，堆指针向高地址（或者低地址）移动 N 个存储单位，这 N 个存储单位即为分配给用户使用的空闲块，空闲块的起始地址为堆指针移动之前所在的地址。</p><p>例如，某一时间段有四个用户（A、B、C、D）分别申请 12 个单位、6 个单位、10 个单位和 8 个单位的存储空间，假设此时堆指针的初值为 0。则分配后存储空间的效果为：</p><div align="center"><img src="/images/内存空间分配.png" width="800"></div> <center>图9 内存空间分配</center><h1 id="回收算法-2"><a href="#回收算法-2" class="headerlink" title="回收算法"></a>回收算法</h1><p>由于系统中的可利用空间始终都是一个连续的存储空间，所以回收时必须将用户释放的存储块合并到这个堆上才能够重新使用。存储紧缩有两种做法：其一是一旦用户释放所占空间就立即进行回收紧缩；另外一种是在程序执行过程中不立即回收用户释放的存储块，而是等到可利用空间不够分配或者堆指针指向了可利用存储区的最高地址时才进行存储紧缩。</p><p>具体的实现过程是：</p><ul><li>计算占用块的新地址。设立两个指针随巡查向前移动，分别用于指示占用块在紧缩之前和之后的原地址和新地址。因此，在每个占用块的第一个存储单位中，除了存储该占用块的大小和标志域之外，还需要新增一个新地址域，用于存储占用块在紧缩后应有的新地址，即建立一张新、旧地址的对照表。</li><li>修改用户的出事变量表，保证在进行存储紧缩后，用户还能找到自己的占用块。</li><li>检查每个占用块中存储的数据。如果有指向其它存储块的指针，则需作相应修改。</li><li>将所有占用块迁移到新地址去，即进行数据的传递。</li></ul><p>最后，还要将堆指针赋以新的值。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战</title>
      <link href="/2022/11/29/ji-qi-xue-xi/suan-fa-shi-jian/ji-qi-xue-xi-shi-zhan/"/>
      <url>/2022/11/29/ji-qi-xue-xi/suan-fa-shi-jian/ji-qi-xue-xi-shi-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="机器学习实战笔记"><a href="#机器学习实战笔记" class="headerlink" title="机器学习实战笔记"></a>机器学习实战笔记</h1><h2 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h2><ul><li>聚焦监督学习，以结构化数据的预测问题为主<ul><li>监督学习：y=f(x)，gbdt，nn都是不同类型的f，深度学习就是其中的一类f，y叫label，x叫特征</li><li>分类问题：y是离散的，回归问题：y是连续的</li><li>结构化数据：每个数都有具体的物理意义</li><li>非结构化数据：图像、语音、nlp</li></ul></li><li>强调共性问题，工作中需要注意的基本原则</li><li>Reference<ul><li>《Rules of Machine Learning》  – Google</li></ul></li></ul><p>（1.Rule与创造性之间的关系，rule更多的是原则 2.迁移学习）</p><h2 id="工业界的机器学习"><a href="#工业界的机器学习" class="headerlink" title="工业界的机器学习"></a>工业界的机器学习</h2><div align="center"><img src="/images/machine_learning_systems.png" width="800"></div><center>图1 机器学习</center><h2 id="将机器学习落地的两个步骤"><a href="#将机器学习落地的两个步骤" class="headerlink" title="将机器学习落地的两个步骤"></a>将机器学习落地的两个步骤</h2><p>业务问题转化为机器学习问题，然后不断优化机器学习模型 （机器学习+运筹优化）</p><h2 id="正确分析判断项目的价值"><a href="#正确分析判断项目的价值" class="headerlink" title="正确分析判断项目的价值"></a>正确分析判断项目的价值</h2><ul><li>价值五角星（彼此可能会有影响）<ul><li>开源（效果/用户体验）：业务指标</li><li>节流（成本）：存储、计算资源</li><li>效率：人效</li><li>安全：合规、隐私保护等</li><li>质量：可靠性、性能</li></ul></li><li>预估/判断价值</li></ul><p>(短信司机召回为例从效果上看，短信全发就是召回量的上限；支付方式默选，全部默选美团支付就是份额的上限；供需不平衡的计算资源优化)</p><h2 id="对于新业务问题的处理方法"><a href="#对于新业务问题的处理方法" class="headerlink" title="对于新业务问题的处理方法"></a>对于新业务问题的处理方法</h2><ul><li>模型未动，规则先行。一方面积累线上数据，用于未来的模型训练，同时，也可以观测规则的收益，以此辅助判断模型的收益。</li><li>如果有通用的模型，也可以先用通用模型上线实验。</li></ul><h2 id="对于一个新业务问题第一个定制模型开发前的注意事项"><a href="#对于一个新业务问题第一个定制模型开发前的注意事项" class="headerlink" title="对于一个新业务问题第一个定制模型开发前的注意事项"></a>对于一个新业务问题第一个定制模型开发前的注意事项</h2><ul><li>明确业务目标，包括优化目标以及约束指标。</li><li>明确模型的评价标准，满足什么条件可以扩量，可以全量上线。</li><li>明确模型上线后，是否有方便的数据报表可以观测，通常重要的业务问题需要专门的报表支持。</li><li>明确模型的使用方式，是离线还是在线，如果是在线对于性能要求如何，控制模型的复杂度；是否需要阈值辅助解决，如果需要的话，阈值如何确定。</li><li><font color="red"> 确保第一个模型要简单易用，目的是走通整个流程，一旦出现问题也方便debug。 </font></li><li>通常一个新场景中第一个模型的收益是最大的。</li><li>要对该场景的数据做一些基础的EDA，帮助后面更好的进行样本和label的选择</li><li>要明确模型是一个分类问题、回归问题还是排序问题，并确定相应的线下评估指标。<ul><li>分类：logloss，auc，fscore，gauc，KS</li><li>回归：mape，mae，rmse</li><li>排序：ndcg，map@k</li></ul></li></ul><h2 id="训练样本的选择"><a href="#训练样本的选择" class="headerlink" title="训练样本的选择"></a>训练样本的选择</h2><ul><li>所有的样本选择问题的核心就是线下训练用到的数据分布尽可能与线上场景保持一致</li><li>样本的bias问题<ul><li>绝大多数场景中，线上数据都是有偏的，最典型的例子，信用风险的预测问题。</li><li>无偏样本是稀缺的，不同场景的无偏样本的成本不同，根据实际情况酌情采用。</li><li>有偏样本需要考虑如何debias。广告的位置偏差问题是这类问题的代表。</li><li><font color="red"> 判断bias的严重性，越严重，无偏样本的收益越大。 </font></li></ul></li><li>样本的采样问题<ul><li>时间与样本量的平衡。</li><li>正负样本的平衡，有的时候负样本未必是负样本，比如信息流推荐问题；对于催收预测问题，如果催一次就还了，在日志中只有一条记录，且是正样本，如果总催不还，一个人就存在多条负样本。</li><li>需要探查样本量的增加与模型预测能力的关系曲线</li><li>样本量与特征的关系，如果引入大量的离散特征，需要记着样本量也要跟上。如果是LR+L1正则进行特征选择，100w样本最终大概可以保留1w特征。</li></ul></li><li>样本的清洗<ul><li>由于埋点等工程问题，导致原始log出现问题。比如推荐了A权益，log中记录的是B权益</li></ul></li></ul><h2 id="label的选择"><a href="#label的选择" class="headerlink" title="label的选择"></a>label的选择</h2><ul><li>label的选择要尽可能与业务目标一致，往往越一致效果会越好。在有些场景下，label的选择会比特征、模型的优化收益更大，如：收银台默选促活场景。</li><li>选择label的时候，尽量找简单的、直接的、能够快速反馈的、可归因的<ul><li>正例：点击、电话接通、使用没团支付完成订单</li><li>负例：用户满意度、30天激活率、90天逾期率。</li></ul></li><li>对于确实存在反馈周期慢的业务指标，可以考虑使用代理指标提高反馈的效率，前提是要保证该指标与业务指标正相关。</li><li>对于比较不太直接的业务指标，也需要用代理指标替换。如：用户满意度 -&gt; 点击率 or 在线时长。</li><li>Label也要注意做数据清洗，避免工程问题导致的数据错误。</li><li>对于有些问题label需要人工标注的，需要严格把关标注质量</li><li>对于多个业务目标的问题，可以考虑使用多任务学习。</li></ul><h2 id="示例：美团支付默认-样本和label的选择"><a href="#示例：美团支付默认-样本和label的选择" class="headerlink" title="示例：美团支付默认-样本和label的选择"></a>示例：美团支付默认-样本和label的选择</h2><ul><li>目标：订单转化率 &amp; 美团支付份额</li><li>支付流程：用户提单 -&gt; 选择支付方式 -&gt; 支付成功（支付失败可能会重试并切换支付方式） -&gt; 订单成功（订单流失）</li><li>方案演进：<ul><li>P(订单成功|默认美团支付)  -&gt;  美团份额提升不显著（订单成功不代表会用美团支付）</li><li>P(订单成功|默认美团支付&amp;最终使用美团支付) -&gt; 总订单转化率+2bp、美团支付订单转化率-108bp、美团支付份额+61bp （漏了“使用美团支付失败后切换支付方式”这部分样本）</li><li>P(最终使用美团支付&amp;订单成功 |默认美团支付) -&gt; 总订单转化率+10bp、美团支付订单转化率+341bp、美团支付份额+82bp</li></ul></li></ul><h2 id="验证集与测试集的划分"><a href="#验证集与测试集的划分" class="headerlink" title="验证集与测试集的划分"></a>验证集与测试集的划分</h2><ul><li>大部分结构化数据的场景下，我们都要使用时序划分的方法。即：训练集、验证集、测试集在时间上是先后顺序。</li><li>可以使用k-fold的场景，如：声纹识别、意图识别等非结构化数据的场景。</li><li>通常验证集和测试集一旦确定，就尽量不动，方便新模型与过去模型做对比。如果要调整，最好也把老模型重新跑一遍，重新对齐。</li></ul><h2 id="特征挖掘的思路"><a href="#特征挖掘的思路" class="headerlink" title="特征挖掘的思路"></a>特征挖掘的思路</h2><ul><li><p>数据本身限定了一个问题的天花板，模型和特征都是逼近天花板的方法</p></li><li><p>特征广义上分两个阶段：信息获取与信息提取，通常我们说的特征挖掘都是指的信息提取。</p></li><li><p>信息获取的思路</p><ul><li>从业务出发，思考该场景下影响用户做出某种决策（label）的因素，通常决策越重，信息缺失就越厉害，这个时候信息获取的收益更大。如：电商广告的点击就比转化更容易，转化中可能需要参考竞对价格信息；催收工作中需要了解这个人在其他地方贷款情况。</li><li>从bad case中发现新的机会</li></ul></li><li><p>信息提取的思路：通过数学的方法能够充分提取数据中蕴含的信息。</p><ul><li>实时化与特征组合是两个关键方向</li><li>行为序列特征挖掘需要跟进</li><li>对于神经网模型，不用特别深入优化特征离散化的工作，往往分位数就还不错。</li><li>特征开发的时候可以按照主题设计，方便猴戏复用。</li><li>关键一问：xx特征当前模型是否已经学到了。</li></ul></li></ul><h2 id="特征选择的方法"><a href="#特征选择的方法" class="headerlink" title="特征选择的方法"></a>特征选择的方法</h2><ul><li><p>模型无关的特征选择</p><ul><li>特征选择的方法如信息增益、缺失度、相关性等都是单特征的选择，只能用作参考</li><li>对某个特征进行随机扰动，观察模型预测能力下降的程度，以此作为模型权重的依据，这种方法会考虑到特征之间的相互作用相对更使用（确定模型特征权重的核心思想）</li></ul></li><li><p>模型相关的特征选择</p><ul><li>LR+L1</li><li>GBDT的特征权重，要看“gain”，而不是“split”</li><li>NN的特征权重：看原始特征embedding层的L2范数 or 逐一shuffle特征，看预测结果的下降程度。</li></ul></li><li><p>复杂模型的可解释性主要还是基于特征权重</p></li></ul><h2 id="避免建模过程中引入leak"><a href="#避免建模过程中引入leak" class="headerlink" title="避免建模过程中引入leak"></a>避免建模过程中引入leak</h2><ul><li>如何判断模型中引入了leak<ul><li>线下评估结果异常好</li></ul></li><li>特征维度<ul><li>特征生产过程中不要使用未来的数据，尤其是统计类特征</li><li>与label相关的统计特征尤其要小心，标准的target encoding是需要oof的。</li></ul></li><li>样本维度<ul><li>划分验证集合的时候没有按照时序划分，而是k-fold。</li></ul></li></ul><h2 id="模型优化的思路"><a href="#模型优化的思路" class="headerlink" title="模型优化的思路"></a>模型优化的思路</h2><ul><li>需要考虑模型更新的频率对于线上效果的影响</li><li>可以用树模型作为baseline，并通过树模型去判断特征的方向</li><li>gbdt和nn应该能够解决监督学习的绝大部分问题，对于两种模型都应该有经验参数，在此基础上调整</li><li>深度学习模型的优势<ul><li>在非结构化的问题泛化能力要明显好于结构化数据</li><li>类似非结构化的结构化数据：eta预估、交通流量预估、化学分子表达</li><li>大量id类特征，且更新频率：信息流、广告等</li><li>随着样本增多，模型的预测天花板更高。（待迭代认知）</li></ul></li><li>对于结构化数据的问题，nn也主要通过引入更多信息拿到大部分收益。</li><li>同样的信息对于不同模型的输入会有区别，gbdt更适合连续特征，离散度高的需要进行特征提取。通过大量实验体会模型能学到哪些信息，学不到哪些信息，什么样的模式适合学哪些信息</li></ul><h2 id="模型上线前的注意事项"><a href="#模型上线前的注意事项" class="headerlink" title="模型上线前的注意事项"></a>模型上线前的注意事项</h2><ul><li>线下评测要比之前的模型好</li><li>线下和线上代码尽量保持一致，包括：特征提取、预处理、线上预测。</li><li>线下与线上的特征顺序保持一致</li><li>线上特征最好能够写到日志中，便于后续查错，如果不能全量写入，也可以考虑采样。</li><li>每两次实验中的diff尽量小，方便有效归因，确定后续方向。</li><li>做AA分析，了解当前场景下流量大小与线上稳定性的关系。</li></ul><h2 id="模型上线中要注意的问题"><a href="#模型上线中要注意的问题" class="headerlink" title="模型上线中要注意的问题"></a>模型上线中要注意的问题</h2><ul><li>观察线上指标的抖动情况，确定模型的有效性</li><li>观察线上的变化是否符合预期</li><li>捕捉线上指标变化与线下指标的关系。如：线下提高多少，线上一定能有提升。</li><li>如果线上表现稳定，且与业务侧对齐后扩量继续观察。</li><li><font color="red"> 正确（无论成败）的实验都是有价值的，错误（无论成败）的实验都是负价值的。 </font></li></ul><h2 id="质量保障"><a href="#质量保障" class="headerlink" title="质量保障"></a>质量保障</h2><ul><li>模型管理SOP：待完善</li><li>事前<ul><li>上线前，需要周知所有相关业务方</li><li>静默期不上线（静默期时间：周一至周四11:00-14:00和17:00-20:30；周五、周六和周日全天）</li><li>模型分为立刻运行模型（如默选模型）和窗口期运行模型（如催收模型），立刻运行模型在上线后保证半小时观测，窗口期运行模型在上线后的下一个运行期，需保证进行半小时观察（如运行不超过半小时，则观察全运行周期）</li></ul></li><li>事中（算法工作尤其需要关注）<ul><li>监控指标（业务指标、模型指标、特征相关指标）的配置和报警阈值</li><li>特征生成表要与上游强依赖，特征不更新的损失要比更新错的损失小</li><li>降级方案的制定</li></ul></li><li>事后<ul><li>COE</li></ul></li></ul><h2 id="线上线下不一致可能的原因"><a href="#线上线下不一致可能的原因" class="headerlink" title="线上线下不一致可能的原因"></a>线上线下不一致可能的原因</h2><ul><li>特征分布问题<ul><li>可以用gbdt，用验证集和线上数据训练一个二分类模型，验证集样本为0，线上数据样本为1，根据二分类的准确度以及高权重的特征可以给出大致的分析结果</li><li>线下与线上特征提取的方法不一致</li></ul></li><li>样本问题<ul><li>忽略了样本偏置问题</li></ul></li><li>指标问题  <ul><li>线下评估指标设置不合理。</li></ul></li></ul><h2 id="反事实问题线下评估示例"><a href="#反事实问题线下评估示例" class="headerlink" title="反事实问题线下评估示例"></a>反事实问题线下评估示例</h2><ul><li>权益分配问题：有三种权益，如何分配可以在成本约束情况下，收益最大</li><li>构建线下评估样本：对于集合$\gamma$随机发放权益，作为评估样本</li><li>基于训练好的策略A对评估样本进行预测，其中有1/3的样本是“事实”样本，可以准确计算收益。</li></ul><div align="center"><img src="/images/machine_learning_线下评估示例.png" width="600"></div><center></center><h2 id="简单场景的优化思路"><a href="#简单场景的优化思路" class="headerlink" title="简单场景的优化思路"></a>简单场景的优化思路</h2><ul><li>思考当前引入的信息是否还有缺失</li><li>对于已经引入的信息，是否充分表达。如：行为序列特征。</li><li>模型调参：nn的调参方差会更大一些</li><li>模型融合：尽量用最简单的方法，如线性加权，或者特征融合。比赛用的套路比如stacking，性价比低，且debug困难，随着单模型优化空间变小，该方法也逐步在工业界落地。</li></ul><h2 id="复杂系统的优化思路"><a href="#复杂系统的优化思路" class="headerlink" title="复杂系统的优化思路"></a>复杂系统的优化思路</h2><ul><li>将复杂系统拆解为多个子系统</li><li>分析每个子系统对于最终指标的影响（case分析）</li><li>针对子系统的ROI进行排序（技术难度x收益）</li></ul><h2 id="要建立自己的算法pipline"><a href="#要建立自己的算法pipline" class="headerlink" title="要建立自己的算法pipline"></a>要建立自己的算法pipline</h2><ul><li>作为一门实践科学，高效实验是核心竞争力<ul><li>合理把控实验节奏：上线计划、样本采集计划</li></ul></li><li>机器不会休息<ul><li>调参、特征提取、线下训练</li></ul></li></ul><h2 id="如何入门"><a href="#如何入门" class="headerlink" title="如何入门"></a>如何入门</h2><ul><li>算法基本功<ul><li>编程、数学、数据洞察</li></ul></li><li>如果非要一个学习资料的话<ul><li>李宏毅的机器学习视频（B站）</li></ul></li><li>能动手尽量动作（All models are wrong but some are useful）</li></ul><h2 id="如何精进"><a href="#如何精进" class="headerlink" title="如何精进"></a>如何精进</h2><ul><li>能从纷繁复杂的各种资料中汲取知识是一门学问<ul><li>养成paper reading的习惯，跟进学术圈的前沿进展（google系的paper泛化性更好）</li><li>跟进比赛圈的一些相关问题solution（kaggle）</li><li>跟进工业圈的一些分享（批判地看）</li><li>社交能力（重要）</li></ul></li><li>批判的眼光看待各种问题，不要过拟合自己的经验，吃一堑长一智，其实是一种能力<div align="center"><img src="/images/如何精进.png" width="800"></div><center>流程图</center></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工程实践 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
