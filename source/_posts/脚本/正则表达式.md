---
title: 正则表达式
date: 2020-05-06 10:08:43
categories: 
- 计算机基础
tags:
- 正则表达式
- 
toc: true
---
# 正则表达式支持字符
创建正则表达式就是创建一个特殊的字符串。正则表达式所支持的合法字符如下表所示：
| 字符   | 解释                                                                 |
| ------ | -------------------------------------------------------------------- |
| X      | 字符x（x 可代表任何合法的字符)                                       |
| \xhh   | 十六进制值 0xhh 所表示的字符                                         |
| \uhhhh | 十六进制值 0xhhhh 所表示的 Unicode 字符                              |
| \t     | 制表符（“\u0009”）                                                   |
| \n     | 新行（换行）符（‘\u000A’）                                           |
| \r     | 回车符（‘\u000D’)                                                    |
| \f     | 换页符（‘\u000C’）                                                   |
| \a     | 报警（bell）符（‘\u0007’）                                           |
| \e     | Escape 符（‘\u001B’）                                                |
| \cx    | x 对应的的控制符。例如，\cM匹配 Ctrl-M。x 值必须为 A~Z 或 a~z 之一。 |

需要匹配这些特殊字符，就必须首先将这些字符转义，也就是在前面添加一个反斜线\。正则表达式中的特殊字符如下表所示。
| 特殊字符                                                                     | 说明                                                                 |
| ---------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| $                                                                            | 匹配一行的结尾。要匹配 $ 字符本身，请使用\\$                         |
| ^                                                                            | 匹配一行的开头。要匹配 ^ 字符本身，请使用\\^                         |
| ()                                                                           | 标记子表达式的开始和结束位置。要匹配这些字符，请使用\\(和\\)         |
| []                                                                           | 用于确定中括号表达式的开始和结束位置。要匹配这些字符，请使用\\[和\\] |
| {}                                                                           | 用于标记前面子表达式的出现频度。要匹配这些字符，请使用\\{和\\}       |
| *                                                                            | 指定前面子表达式可以出现零次或多次。要匹配 * 字符本身，请使用\\*     |
| +                                                                            | 指定前面子表达式可以出现一次或多次。要匹配 + 字符本身，请使用\\+     |
| ?                                                                            | 指定前面子表达式可以出现零次或一次。要匹配 ？字符本身，请使用\\?     |
| .                                                                            | 匹配除换行符\n之外的任何单字符。要匹配.字符本身，请使用\\.           |
| \\|	用于转义下一个字符，或指定八进制、十六进制字符。如果需匹配\字符，请用\\\ |
| \|                                                                           | 指定两项之间任选一项。如果要匹配丨字符本身，请使用\|                 |

上述的正则表达式依然只能匹配单个字符，这是因为还未在正则表达式中使用“通配符”，“通配符”是可以匹配多个字符的特殊字符。正则表达式中的“通配符”远远超出了普通通配符的功能，它被称为预定义字符，正则表达式支持如下表所示的预定义字符。
| 预定义字符 | 说明                                                           |
| ---------- | -------------------------------------------------------------- |
| .          | 可以匹配任何字符                                               |
| \d         | 匹配 0~9 的所有数字                                            |
| \D         | 匹配非数字                                                     |
| \s         | 匹配所有的空白字符，包括空格、制表符、回车符、换页符、换行符等 |
| \S         | 匹配所有的非空白字符                                           |
| \w         | 匹配所有的单词字符，包括 0~9 所有数字、26 个英文字母和下画线_  |
| \W         | 匹配所有的非单词字符                                           |

方括号表达式，方括号表达式有如下表所示的几种形式：
| 方括号表达式     | 说明                                                                                                                                                                     |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| 表示枚举         | 例如[abc]表示 a、b、c 其中任意一个字符；[gz]表示 g、z 其中任意一个字符                                                                                                   |
| 表示范围：-      | 例如[a-f]表示 a~f 范围内的任意字符；[\\u0041-\\u0056]表示十六进制字符 \u0041 到 \u0056 范围的字符。范围可以和枚举结合使用，如[a-cx-z]，表示 a~c、x~z 范围内的任意字符    |
| 表示求否：^      | 例如[^abc]表示非 a、b、c 的任意字符；[^a-f]表示不是 a~f 范围内的任意字符                                                                                                 |
| 表示“与”运算：&& | 例如 [a-z&&[def]]是 a~z 和 [def] 的交集，表示 d、e f[a-z&&^bc]]是 a~z 范围内的所有字符，除 b 和 c 之外 [ad-z] [a-z&&[m-p]]是 a~z 范围内的所有字符，除 m~p 范围之外的字符 |
| 表示“并”运算     | 并运算与前面的枚举类似。例如[a-d[m-p]]表示 [a-dm-p]                                                                                                                      |

方括号表达式比前面的预定义字符灵活多了，几乎可以匹配任何字符。例如，若需要匹配所有的中文字符，就可以利用 [\\\u0041-\\\u0056] 形式——因为所有中文字符的 Unicode 值是连续的，只要找出所有中文字符中最小、最大的 Unicode 值，就可以利用上面形式来匹配所有的中文字符。正则表达式的其它边界匹配符：
| 边界匹配符 | 说明                           |
| ---------- | ------------------------------ |
| ^          | 行的开头                       |
| $          | 行的结尾                       |
| \b         | 单词的边界                     |
| \B         | 非单词的边界                   |
| \A         | 输入的开头                     |
| \G         | 前一个匹配的结尾               |
| \Z         | 输入的结尾，仅用于最后的结束符 |
| \z         | 输入的结尾                     |

正则表达式还提供了数量标识符，正则表达式支持的数量标识符有如下几种模式。
* Greedy（贪婪模式）：数量表示符默认采用贪婪模式，除非另有表示。贪婪模式的表达式会一直匹配下去，直到无法匹配为止。如果你发现表达式匹配的结果与预期的不符，很有可能是因为你以为表达式只会匹配前面几个字符，而实际上它是贪婪模式，所以会一直匹配下去。
* Reluctant（勉强模式）：用问号后缀（?）表示，它只会匹配最少的字符。也称为最小匹配模式。
* Possessive（占有模式）：用加号后缀（+）表示，目前只有 Java 支持占有模式，通常比较少用。    

三个模式的数量标识符如下表：
| 贪婪模式 | 勉强模式 | 占用模式 | 说明                                |
| -------- | -------- | -------- | ----------------------------------- |
| X?       | X??      | X?+      | X表达式出现零次或一次               |
| X*       | X*?      | X*+      | X表达式出现零次或多次               |
| X+       | X+?      | X++      | X表达式出现一次或多次               |
| X{n}     | X{n}?    | X{n}+    | X表达式出现 n 次                    |
| X{n,}    | X{n,}?   | X{n,}+   | X表达式最少出现 n 次                |
| X{n,m}   | X{n,m}?  | X{n,m}+  | X表达式最少出现 n 次，最多出现 m 次 |

实例如下：
```java
public class MatchesTest {
    public static void main(String[] args) {
        String[] mails = { "kongyeeku@163.com", "kongyeeku@gmail.com", "ligang@crazyit.org", "wawa@abc.xx" };
        String mailRegEx = "\\w{3,20}@\\w+\\.(com|org|cn|net|gov)";
        Pattern mailPattern = Pattern.compile(mailRegEx);
        Matcher matcher = null;
        for (String mail : mails) {
            if (matcher == null) {
                matcher = mailPattern.matcher(mail);
            } else {
                matcher.reset(mail);
            }
            String result = mail + (matcher.matches() ? "是" : "不是") + "一个有效的邮件地址！";
            System.out.println(result);
        }
    }
}
// 验证电话号码
String regex = "0\\d{2,3}[-]?\\d{7,8}|0\\d{2,3}\\s?\\d{7,8}|13[0-9]\\d{8}|15[1089]\\d{8}";
```
# String、StringBuffer、StringBuilder类的区别
StringBuilder类是JDK 1.5新增的类，它也代表可变字符串对象。实际上，StringBuilder和StringBuffer 功能基本相似，方法也差不多。不同的是，StringBuffer 是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能略高。因此在通常情况下，如果需要创建一个内容可变的字符串对象，则应该优先考虑使用StringBuilder类。

StringBuffer、StringBuilder、String中都实现了CharSequence接口。CharSequence是一个定义字符串操作的接口，它只包括length()、charAt(int index)、subSequence(int start, int end)这几个API。

String直接实现了CharSequence接口，StringBuilder和 StringBuffer都是可变的字符序列，它们都继承于 AbstractStringBuilder，实现了 CharSequence接口。

## 总结
String是Java中基础且重要的类，被声明为final class，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。

StringBuffer就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append和add方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。

在很多情况下我们的字符串拼接操作不需要线程安全，所以StringBuilder登场了。StringBuilder 是JDK1.5发布的，它和StringBuffer本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。

**线程安全：**

StringBuffer：线程安全
StringBuilder：线程不安全

**速度：**

一般情况下，速度从快到慢为 StringBuilder > StringBuffer > String，当然这是相对的，不是绝对的。

**使用环境：**

操作少量的数据使用 String。
单线程操作大量数据使用 StringBuilder。
多线程操作大量数据使用 StringBuffer。